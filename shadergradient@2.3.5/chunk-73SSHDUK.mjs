import {
  __export
} from "./chunk-5BEQP2BQ.mjs";

// src/shaders/glass/plane/index.ts
var plane_exports = {};
__export(plane_exports, {
  fragment: () => fragment_default,
  vertex: () => vertex_default
});

// src/shaders/glass/plane/fragment.glsl
var fragment_default = "// Glass Plane Fragment Shader - Transparency & Refraction\n\n#define STANDARD\n#ifdef PHYSICAL\n#define REFLECTIVITY\n#define CLEARCOAT\n#define TRANSMISSION\n#endif\n\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n\n// transmission is already defined by Three.js when TRANSMISSION is enabled\n#ifdef REFLECTIVITY\nuniform float reflectivity;\n#endif\n#ifdef CLEARCOAT\nuniform float clearcoat;\nuniform float clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\nuniform vec3 sheen;\n#endif\n\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n#ifdef USE_TANGENT\nvarying vec3 vTangent;\nvarying vec3 vBitangent;\n#endif\n#endif\n\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <color_pars_fragment>\n#include <common>\n#include <dithering_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <map_pars_fragment>\n#include <packing>\n#include <uv2_pars_fragment>\n#include <uv_pars_fragment>\n#include <bsdfs>\n#include <bumpmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <clipping_planes_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <lights_physical_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <transmission_pars_fragment>\n\n// Custom uniforms for glass effect\nuniform float uTime;\nuniform vec3 uColor1;\nuniform vec3 uColor2;\nuniform vec3 uColor3;\nuniform float uTransparency;\nuniform float uRefraction;\nuniform float uChromaticAberration;\nuniform float uFresnelPower;\nuniform float uReflectivity;\n// envMap and envMapIntensity are provided by Three.js\n\nvarying vec2 vUv;\nvarying vec3 vPosition;\nvarying vec3 vNormal;\nvarying vec3 vGlassWorldPos;\nvarying vec3 vReflect;\nvarying vec3 vRefract;\n\n// Fresnel calculation\nfloat fresnel(vec3 viewDirection, vec3 normal, float power) {\n  return pow(1.0 - dot(viewDirection, normal), power);\n}\n\n// Chromatic aberration for refraction\nvec3 chromaticRefraction(vec3 viewDirection, vec3 normal, float ior, float chromaticStrength) {\n  vec3 refractedR = refract(viewDirection, normal, 1.0 / (ior - chromaticStrength));\n  vec3 refractedG = refract(viewDirection, normal, 1.0 / ior);\n  vec3 refractedB = refract(viewDirection, normal, 1.0 / (ior + chromaticStrength));\n  \n  #ifdef ENVMAP_TYPE_CUBE\n  return vec3(\n    textureCube(envMap, refractedR).r,\n    textureCube(envMap, refractedG).g,\n    textureCube(envMap, refractedB).b\n  );\n  #else\n  return vec3(0.5);\n  #endif\n}\n\nvoid main() {\n  #include <clipping_planes_fragment>\n  \n  vec4 diffuseColor = vec4(diffuse, opacity);\n  ReflectedLight reflectedLight = ReflectedLight(vec3(0.0), vec3(0.0), vec3(0.0), vec3(0.0));\n  vec3 totalEmissiveRadiance = emissive;\n  \n  #include <logdepthbuf_fragment>\n  #include <map_fragment>\n  #include <color_fragment>\n  #include <alphamap_fragment>\n  #include <alphatest_fragment>\n  #include <specularmap_fragment>\n  #include <roughnessmap_fragment>\n  #include <metalnessmap_fragment>\n  #include <normal_fragment_begin>\n  #include <normal_fragment_maps>\n  #include <clearcoat_normal_fragment_begin>\n  #include <clearcoat_normal_fragment_maps>\n  #include <emissivemap_fragment>\n  \n  // Glass-specific calculations\n  vec3 viewDirection = normalize(vViewPosition);\n  vec3 worldNormal = normalize(vNormal);\n  \n  // Calculate Fresnel effect\n  float fresnelFactor = fresnel(viewDirection, worldNormal, uFresnelPower);\n  \n  // Base glass color gradient\n  vec3 gradientColor = mix(uColor1, uColor2, vUv.y);\n  gradientColor = mix(gradientColor, uColor3, fresnelFactor);\n  \n  // Reflection\n  #ifdef ENVMAP_TYPE_CUBE\n  vec3 reflectionColor = textureCube(envMap, vReflect).rgb * envMapIntensity;\n  #else\n  vec3 reflectionColor = vec3(0.5);\n  #endif\n  \n  // Refraction with chromatic aberration\n  vec3 refractionColor;\n  #ifdef ENVMAP_TYPE_CUBE\n  if (uChromaticAberration > 0.0) {\n    refractionColor = chromaticRefraction(-viewDirection, worldNormal, uRefraction, uChromaticAberration);\n  } else {\n    refractionColor = textureCube(envMap, vRefract).rgb;\n  }\n  refractionColor *= envMapIntensity;\n  #else\n  refractionColor = vec3(0.3);\n  #endif\n  \n  // Mix reflection and refraction based on Fresnel\n  vec3 envColor = mix(refractionColor, reflectionColor, fresnelFactor * uReflectivity);\n  \n  // Combine with gradient color\n  vec3 finalColor = mix(gradientColor, envColor, 0.7);\n  \n  // Apply transparency\n  float finalAlpha = mix(uTransparency, 1.0, fresnelFactor * 0.5);\n  \n  // Set diffuse color for standard lighting\n  diffuseColor.rgb = finalColor;\n  diffuseColor.a = finalAlpha;\n  \n  // Skip transmission_fragment to avoid conflicts\n  \n  vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + \n                       reflectedLight.directSpecular + reflectedLight.indirectSpecular + \n                       totalEmissiveRadiance;\n  \n  // Add our glass color contribution\n  outgoingLight += finalColor * 0.8;\n  \n  gl_FragColor = vec4(outgoingLight, diffuseColor.a);\n  \n  #include <tonemapping_fragment>\n  #include <colorspace_fragment>\n  #include <fog_fragment>\n  #include <premultiplied_alpha_fragment>\n  #include <dithering_fragment>\n}\n";

// src/shaders/glass/plane/vertex.glsl
var vertex_default = "// Glass Plane Vertex Shader - Refraction & Transparency Effects\n\n#define STANDARD\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n#ifdef USE_TANGENT\nvarying vec3 vTangent;\nvarying vec3 vBitangent;\n#endif\n#endif\n#include <clipping_planes_pars_vertex>\n#include <color_pars_vertex>\n#include <common>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <skinning_pars_vertex>\n#include <uv2_pars_vertex>\n#include <uv_pars_vertex>\n\nvarying vec2 vUv;\nvarying vec3 vPosition;\nvarying vec3 vNormal;\nvarying vec3 vGlassWorldPos;\nvarying vec3 vReflect;\nvarying vec3 vRefract;\n\nuniform float uTime;\nuniform float uSpeed;\nuniform float uWaveAmplitude;\nuniform float uWaveFrequency;\nuniform float uNoiseStrength;\nuniform float uDistortion;\n\n// Noise functions for glass distortion\nvec3 mod289(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289(vec4 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x) {\n  return mod289(((x * 34.0) + 1.0) * x);\n}\n\nvec4 taylorInvSqrt(vec4 r) {\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat snoise(vec3 v) {\n  const vec2 C = vec2(1.0 / 6.0, 1.0 / 3.0);\n  const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n  vec3 i = floor(v + dot(v, C.yyy));\n  vec3 x0 = v - i + dot(i, C.xxx);\n\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min(g.xyz, l.zxy);\n  vec3 i2 = max(g.xyz, l.zxy);\n\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy;\n  vec3 x3 = x0 - D.yyy;\n\n  i = mod289(i);\n  vec4 p = permute(permute(permute(\n    i.z + vec4(0.0, i1.z, i2.z, 1.0))\n    + i.y + vec4(0.0, i1.y, i2.y, 1.0))\n    + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n  float n_ = 0.142857142857;\n  vec3 ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_);\n\n  vec4 x = x_ * ns.x + ns.yyyy;\n  vec4 y = y_ * ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4(x.xy, y.xy);\n  vec4 b1 = vec4(x.zw, y.zw);\n\n  vec4 s0 = floor(b0) * 2.0 + 1.0;\n  vec4 s1 = floor(b1) * 2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw * sh.xxyy;\n  vec4 a1 = b1.xzyw + s1.xzyw * sh.zzww;\n\n  vec3 p0 = vec3(a0.xy, h.x);\n  vec3 p1 = vec3(a0.zw, h.y);\n  vec3 p2 = vec3(a1.xy, h.z);\n  vec3 p3 = vec3(a1.zw, h.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(p0, p0), dot(p1, p1), dot(p2, p2), dot(p3, p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n  vec4 m = max(0.6 - vec4(dot(x0, x0), dot(x1, x1), dot(x2, x2), dot(x3, x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot(m * m, vec4(dot(p0, x0), dot(p1, x1),\n    dot(p2, x2), dot(p3, x3)));\n}\n\nvoid main() {\n  #include <uv_pars_vertex>\n  #include <uv_vertex>\n  #include <uv2_pars_vertex>\n  #include <uv2_vertex>\n  #include <color_pars_vertex>\n  #include <color_vertex>\n  #include <morphcolor_vertex>\n  #include <beginnormal_vertex>\n  #include <morphnormal_vertex>\n  #include <skinbase_vertex>\n  #include <skinnormal_vertex>\n  #include <defaultnormal_vertex>\n  #include <normal_vertex>\n  \n  #ifndef FLAT_SHADED\n  vNormal = normalize(transformedNormal);\n  #ifdef USE_TANGENT\n  vTangent = normalize(transformedTangent);\n  vBitangent = normalize(cross(vNormal, vTangent) * tangent.w);\n  #endif\n  #endif\n  \n  #include <begin_vertex>\n  #include <morphtarget_vertex>\n  #include <skinning_vertex>\n  #include <displacementmap_vertex>\n  \n  // Pass UV coordinates\n  vUv = uv;\n\n  // Calculate time-based animation\n  float time = uTime * uSpeed;\n  \n  // Create subtle wave distortion for glass effect\n  float waveX = sin(position.x * uWaveFrequency + time) * uWaveAmplitude;\n  float waveY = cos(position.y * uWaveFrequency + time) * uWaveAmplitude;\n  float waveZ = sin(position.z * uWaveFrequency + time * 0.5) * uWaveAmplitude * 0.5;\n  \n  // Add noise for organic glass distortion\n  vec3 noisePos = position + vec3(time * 0.1);\n  float noise = snoise(noisePos * 0.5) * uNoiseStrength;\n  \n  // Apply distortion to transformed position\n  transformed += vec3(waveX, waveY, waveZ) * uDistortion + normal * noise;\n  \n  #include <project_vertex>\n  #include <logdepthbuf_vertex>\n  #include <clipping_planes_vertex>\n  \n  vViewPosition = -mvPosition.xyz;\n  vPosition = transformed;\n  \n  // Calculate world position for refraction\n  vec4 worldPosition = modelMatrix * vec4(transformed, 1.0);\n  vGlassWorldPos = worldPosition.xyz;\n  \n  // Calculate reflection and refraction vectors\n  vec3 worldNormal = normalize(mat3(modelMatrix) * normal);\n  vec3 viewVector = normalize(cameraPosition - worldPosition.xyz);\n  \n  // Reflection vector\n  vReflect = reflect(-viewVector, worldNormal);\n  \n  // Refraction vector with index of refraction for glass (1.5)\n  float ior = 1.5;\n  vRefract = refract(-viewVector, worldNormal, 1.0 / ior);\n  \n  #include <fog_vertex>\n  #include <shadowmap_vertex>\n}\n";

export {
  fragment_default,
  vertex_default,
  plane_exports
};
