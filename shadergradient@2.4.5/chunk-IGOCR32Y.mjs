import {
  __export
} from "./chunk-5BEQP2BQ.mjs";

// src/shaders/glass/sphere/index.ts
var sphere_exports = {};
__export(sphere_exports, {
  fragment: () => fragment_default,
  vertex: () => vertex_default
});

// src/shaders/glass/sphere/fragment.glsl
var fragment_default = "// Glass Sphere Fragment Shader - Transparency & Refraction\n\n#define STANDARD\n#ifdef PHYSICAL\n#define REFLECTIVITY\n#define CLEARCOAT\n#define TRANSMISSION\n#endif\n\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n\n// transmission is already defined by Three.js when TRANSMISSION is enabled\n#ifdef REFLECTIVITY\nuniform float reflectivity;\n#endif\n#ifdef CLEARCOAT\nuniform float clearcoat;\nuniform float clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\nuniform vec3 sheen;\n#endif\n\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n#ifdef USE_TANGENT\nvarying vec3 vTangent;\nvarying vec3 vBitangent;\n#endif\n#endif\n\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <color_pars_fragment>\n#include <common>\n#include <dithering_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <map_pars_fragment>\n#include <packing>\n#include <uv2_pars_fragment>\n#include <uv_pars_fragment>\n#include <bsdfs>\n#include <bumpmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <clipping_planes_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <lights_physical_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <transmission_pars_fragment>\n\n// Custom uniforms for glass effect\nuniform float uTime;\nuniform vec3 uColor1;\nuniform vec3 uColor2;\nuniform vec3 uColor3;\nuniform float uTransparency;\nuniform float uRefraction;\nuniform float uChromaticAberration;\nuniform float uFresnelPower;\nuniform float uReflectivity;\n// envMap and envMapIntensity are provided by Three.js\n\nvarying vec2 vUv;\nvarying vec3 vPosition;\nvarying vec3 vNormal;\nvarying vec3 vGlassWorldPos;\nvarying vec3 vReflect;\nvarying vec3 vRefract;\nvarying float vDistortion;\n\n// Fresnel calculation\nfloat fresnel(vec3 viewDirection, vec3 normal, float power) {\n  return pow(1.0 - abs(dot(viewDirection, normal)), power);\n}\n\n// Chromatic aberration for refraction\nvec3 chromaticRefraction(vec3 viewDirection, vec3 normal, float ior, float chromaticStrength) {\n  vec3 refractedR = refract(viewDirection, normal, 1.0 / (ior - chromaticStrength));\n  vec3 refractedG = refract(viewDirection, normal, 1.0 / ior);\n  vec3 refractedB = refract(viewDirection, normal, 1.0 / (ior + chromaticStrength));\n  \n  #ifdef ENVMAP_TYPE_CUBE\n  return vec3(\n    textureCube(envMap, refractedR).r,\n    textureCube(envMap, refractedG).g,\n    textureCube(envMap, refractedB).b\n  );\n  #else\n  return vec3(0.5);\n  #endif\n}\n\n// Caustics simulation for sphere\nfloat caustics(vec3 position, float time) {\n  float c1 = sin(position.x * 4.0 + time) * sin(position.y * 4.0 + time * 0.8);\n  float c2 = sin(position.z * 3.0 - time * 1.2) * sin(position.x * 3.0 + time);\n  return (c1 + c2) * 0.5 + 0.5;\n}\n\nvoid main() {\n  #include <clipping_planes_fragment>\n  \n  vec4 diffuseColor = vec4(diffuse, opacity);\n  ReflectedLight reflectedLight = ReflectedLight(vec3(0.0), vec3(0.0), vec3(0.0), vec3(0.0));\n  vec3 totalEmissiveRadiance = emissive;\n  \n  #include <logdepthbuf_fragment>\n  #include <map_fragment>\n  #include <color_fragment>\n  #include <alphamap_fragment>\n  #include <alphatest_fragment>\n  #include <specularmap_fragment>\n  #include <roughnessmap_fragment>\n  #include <metalnessmap_fragment>\n  #include <normal_fragment_begin>\n  #include <normal_fragment_maps>\n  #include <clearcoat_normal_fragment_begin>\n  #include <clearcoat_normal_fragment_maps>\n  #include <emissivemap_fragment>\n  \n  // Glass-specific calculations\n  vec3 viewDirection = normalize(vViewPosition);\n  vec3 worldNormal = normalize(vNormal);\n  \n  // Calculate Fresnel effect\n  float fresnelFactor = fresnel(viewDirection, worldNormal, uFresnelPower);\n  \n  // For sphere, use spherical UV mapping for gradient\n  float sphericalU = atan(vPosition.z, vPosition.x) / (2.0 * PI) + 0.5;\n  float sphericalV = acos(vPosition.y / length(vPosition)) / PI;\n  vec2 sphericalUV = vec2(sphericalU, sphericalV);\n  \n  // Create color gradient based on spherical coordinates\n  vec3 gradientColor = mix(uColor1, uColor2, sphericalUV.y);\n  gradientColor = mix(gradientColor, uColor3, pow(fresnelFactor, 1.5));\n  \n  // Add caustics effect for sphere\n  float causticsValue = caustics(vGlassWorldPos, uTime);\n  gradientColor += vec3(causticsValue * 0.1);\n  \n  // Reflection\n  #ifdef ENVMAP_TYPE_CUBE\n  vec3 reflectionColor = textureCube(envMap, vReflect).rgb * envMapIntensity;\n  #else\n  vec3 reflectionColor = vec3(0.5);\n  #endif\n  \n  // Refraction with chromatic aberration (enhanced for sphere)\n  vec3 refractionColor;\n  #ifdef ENVMAP_TYPE_CUBE\n  if (uChromaticAberration > 0.0) {\n    float chromaticIntensity = uChromaticAberration * (1.0 + vDistortion * 0.5);\n    refractionColor = chromaticRefraction(-viewDirection, worldNormal, uRefraction, chromaticIntensity);\n  } else {\n    refractionColor = textureCube(envMap, vRefract).rgb;\n  }\n  refractionColor *= envMapIntensity;\n  #else\n  refractionColor = vec3(0.3);\n  #endif\n  \n  // Mix reflection and refraction based on Fresnel (stronger effect for sphere)\n  vec3 envColor = mix(refractionColor, reflectionColor, fresnelFactor * uReflectivity);\n  \n  // Add inner glow effect for sphere\n  float innerGlow = pow(1.0 - abs(dot(viewDirection, worldNormal)), 3.0);\n  vec3 glowColor = mix(uColor2, uColor3, innerGlow) * innerGlow * 0.5;\n  \n  // Combine all effects\n  vec3 finalColor = mix(gradientColor, envColor, 0.8) + glowColor;\n  \n  // Apply transparency with sphere thickness consideration\n  float thickness = 1.0 - pow(abs(dot(viewDirection, worldNormal)), 0.5);\n  float finalAlpha = mix(uTransparency * thickness, 1.0, fresnelFactor * 0.7);\n  \n  // Set diffuse color for standard lighting\n  diffuseColor.rgb = finalColor;\n  diffuseColor.a = finalAlpha;\n  \n  // Skip transmission_fragment to avoid conflicts\n  \n  vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + \n                       reflectedLight.directSpecular + reflectedLight.indirectSpecular + \n                       totalEmissiveRadiance;\n  \n  // Add our glass color contribution\n  outgoingLight += finalColor * 0.9;\n  \n  gl_FragColor = vec4(outgoingLight, diffuseColor.a);\n  \n  #include <tonemapping_fragment>\n  #include <colorspace_fragment>\n  #include <fog_fragment>\n  #include <premultiplied_alpha_fragment>\n  #include <dithering_fragment>\n}\n";

// src/shaders/glass/sphere/vertex.glsl
var vertex_default = "// Glass Sphere Vertex Shader - Refraction & Transparency Effects\n\n#define STANDARD\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n#ifdef USE_TANGENT\nvarying vec3 vTangent;\nvarying vec3 vBitangent;\n#endif\n#endif\n#include <clipping_planes_pars_vertex>\n#include <color_pars_vertex>\n#include <common>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <skinning_pars_vertex>\n#include <uv2_pars_vertex>\n#include <uv_pars_vertex>\n\nvarying vec2 vUv;\nvarying vec3 vPosition;\nvarying vec3 vNormal;\nvarying vec3 vGlassWorldPos;\nvarying vec3 vReflect;\nvarying vec3 vRefract;\nvarying float vDistortion;\n\nuniform float uTime;\nuniform float uSpeed;\nuniform float uWaveAmplitude;\nuniform float uWaveFrequency;\nuniform float uNoiseStrength;\nuniform float uDistortion;\n\n// Noise functions for glass distortion\nvec3 mod289(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289(vec4 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x) {\n  return mod289(((x * 34.0) + 1.0) * x);\n}\n\nvec4 taylorInvSqrt(vec4 r) {\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat snoise(vec3 v) {\n  const vec2 C = vec2(1.0 / 6.0, 1.0 / 3.0);\n  const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n  vec3 i = floor(v + dot(v, C.yyy));\n  vec3 x0 = v - i + dot(i, C.xxx);\n\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min(g.xyz, l.zxy);\n  vec3 i2 = max(g.xyz, l.zxy);\n\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy;\n  vec3 x3 = x0 - D.yyy;\n\n  i = mod289(i);\n  vec4 p = permute(permute(permute(\n    i.z + vec4(0.0, i1.z, i2.z, 1.0))\n    + i.y + vec4(0.0, i1.y, i2.y, 1.0))\n    + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n  float n_ = 0.142857142857;\n  vec3 ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_);\n\n  vec4 x = x_ * ns.x + ns.yyyy;\n  vec4 y = y_ * ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4(x.xy, y.xy);\n  vec4 b1 = vec4(x.zw, y.zw);\n\n  vec4 s0 = floor(b0) * 2.0 + 1.0;\n  vec4 s1 = floor(b1) * 2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw * sh.xxyy;\n  vec4 a1 = b1.xzyw + s1.xzyw * sh.zzww;\n\n  vec3 p0 = vec3(a0.xy, h.x);\n  vec3 p1 = vec3(a0.zw, h.y);\n  vec3 p2 = vec3(a1.xy, h.z);\n  vec3 p3 = vec3(a1.zw, h.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(p0, p0), dot(p1, p1), dot(p2, p2), dot(p3, p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n  vec4 m = max(0.6 - vec4(dot(x0, x0), dot(x1, x1), dot(x2, x2), dot(x3, x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot(m * m, vec4(dot(p0, x0), dot(p1, x1),\n    dot(p2, x2), dot(p3, x3)));\n}\n\nvoid main() {\n  #include <uv_pars_vertex>\n  #include <uv_vertex>\n  #include <uv2_pars_vertex>\n  #include <uv2_vertex>\n  #include <color_pars_vertex>\n  #include <color_vertex>\n  #include <morphcolor_vertex>\n  #include <beginnormal_vertex>\n  #include <morphnormal_vertex>\n  #include <skinbase_vertex>\n  #include <skinnormal_vertex>\n  #include <defaultnormal_vertex>\n  #include <normal_vertex>\n  \n  #ifndef FLAT_SHADED\n  vNormal = normalize(transformedNormal);\n  #ifdef USE_TANGENT\n  vTangent = normalize(transformedTangent);\n  vBitangent = normalize(cross(vNormal, vTangent) * tangent.w);\n  #endif\n  #endif\n  \n  #include <begin_vertex>\n  #include <morphtarget_vertex>\n  #include <skinning_vertex>\n  #include <displacementmap_vertex>\n  \n  // Pass UV coordinates\n  vUv = uv;\n\n  // Calculate time-based animation\n  float time = uTime * uSpeed;\n  \n  // For sphere, use spherical coordinates for better distortion\n  float theta = atan(position.z, position.x);\n  float phi = acos(position.y / length(position));\n  \n  // Create waves based on spherical coordinates\n  float waveTheta = sin(theta * uWaveFrequency * 2.0 + time) * uWaveAmplitude;\n  float wavePhi = cos(phi * uWaveFrequency + time * 1.5) * uWaveAmplitude;\n  \n  // Add noise for organic glass distortion\n  vec3 noisePos = position + vec3(time * 0.1);\n  float noise = snoise(noisePos * 0.8) * uNoiseStrength;\n  \n  // Calculate distortion based on position on sphere\n  float distortionAmount = (waveTheta + wavePhi) * uDistortion + noise;\n  vDistortion = distortionAmount;\n  \n  // Apply distortion along normal for sphere\n  transformed += normal * distortionAmount;\n  \n  #include <project_vertex>\n  #include <logdepthbuf_vertex>\n  #include <clipping_planes_vertex>\n  \n  vViewPosition = -mvPosition.xyz;\n  vPosition = transformed;\n  \n  // Calculate world position for refraction\n  vec4 worldPosition = modelMatrix * vec4(transformed, 1.0);\n  vGlassWorldPos = worldPosition.xyz;\n  \n  // Calculate reflection and refraction vectors\n  vec3 worldNormal = normalize(mat3(modelMatrix) * normal);\n  vec3 viewVector = normalize(cameraPosition - worldPosition.xyz);\n  \n  // Reflection vector\n  vReflect = reflect(-viewVector, worldNormal);\n  \n  // Refraction vector with index of refraction for glass (1.5)\n  // For sphere, adjust IOR based on curvature\n  float ior = 1.5 + sin(theta * 2.0 + time) * 0.1;\n  vRefract = refract(-viewVector, worldNormal, 1.0 / ior);\n  \n  #include <fog_vertex>\n  #include <shadowmap_vertex>\n}\n";

export {
  fragment_default,
  vertex_default,
  sphere_exports
};
