import {
  __esm
} from "./chunk-HXGKXP63.mjs";

// ../shadergradient-v2/dist/chunk-WBM42ICI.mjs
import { Fragment, jsx, jsxs } from "react/jsx-runtime";
function Geometry({ type }) {
  return /* @__PURE__ */ jsxs(Fragment, { children: [
    type === "plane" && /* @__PURE__ */ jsx("planeGeometry", { args: [10, 10, 1, meshCount] }),
    type === "sphere" && /* @__PURE__ */ jsx("icosahedronGeometry", { args: [1, meshCount / 3] }),
    type === "waterPlane" && /* @__PURE__ */ jsx("planeGeometry", { args: [10, 10, meshCount, meshCount] })
  ] });
}
var meshCount;
var init_chunk_WBM42ICI = __esm({
  "../shadergradient-v2/dist/chunk-WBM42ICI.mjs"() {
    meshCount = 192;
  }
});

// ../shadergradient-v2/dist/chunk-BI5IV7LU.mjs
function hexToRgb(hex) {
  const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
  return result ? {
    r: parseInt(result[1], 16),
    g: parseInt(result[2], 16),
    b: parseInt(result[3], 16)
  } : null;
}
function rgbStringToRgb(rgbString) {
  const result = rgbString.match(/^rgb\((\d+),\s*(\d+),\s*(\d+)\)$/);
  return result ? {
    r: parseInt(result[1]),
    g: parseInt(result[2]),
    b: parseInt(result[3])
  } : null;
}
function colorToRgb(color) {
  if (color.startsWith("#")) {
    return hexToRgb(color);
  } else if (color.startsWith("rgb")) {
    return rgbStringToRgb(color);
  } else {
    throw new Error("Invalid color format");
  }
}
function formatColor(color = 0) {
  return color / 255;
}
var init_chunk_BI5IV7LU = __esm({
  "../shadergradient-v2/dist/chunk-BI5IV7LU.mjs"() {
  }
});

// ../shadergradient-v2/dist/chunk-5BEQP2BQ.mjs
var __defProp, __defProps, __getOwnPropDescs, __getOwnPropSymbols, __hasOwnProp, __propIsEnum, __pow, __defNormalProp, __spreadValues, __spreadProps, __objRest, __export, __async;
var init_chunk_5BEQP2BQ = __esm({
  "../shadergradient-v2/dist/chunk-5BEQP2BQ.mjs"() {
    __defProp = Object.defineProperty;
    __defProps = Object.defineProperties;
    __getOwnPropDescs = Object.getOwnPropertyDescriptors;
    __getOwnPropSymbols = Object.getOwnPropertySymbols;
    __hasOwnProp = Object.prototype.hasOwnProperty;
    __propIsEnum = Object.prototype.propertyIsEnumerable;
    __pow = Math.pow;
    __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
    __spreadValues = (a, b) => {
      for (var prop in b || (b = {}))
        if (__hasOwnProp.call(b, prop))
          __defNormalProp(a, prop, b[prop]);
      if (__getOwnPropSymbols)
        for (var prop of __getOwnPropSymbols(b)) {
          if (__propIsEnum.call(b, prop))
            __defNormalProp(a, prop, b[prop]);
        }
      return a;
    };
    __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
    __objRest = (source, exclude) => {
      var target2 = {};
      for (var prop in source)
        if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
          target2[prop] = source[prop];
      if (source != null && __getOwnPropSymbols)
        for (var prop of __getOwnPropSymbols(source)) {
          if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
            target2[prop] = source[prop];
        }
      return target2;
    };
    __export = (target2, all) => {
      for (var name in all)
        __defProp(target2, name, { get: all[name], enumerable: true });
    };
    __async = (__this, __arguments, generator) => {
      return new Promise((resolve2, reject) => {
        var fulfilled = (value) => {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        };
        var rejected = (value) => {
          try {
            step(generator.throw(value));
          } catch (e) {
            reject(e);
          }
        };
        var step = (x) => x.done ? resolve2(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
        step((generator = generator.apply(__this, __arguments)).next());
      });
    };
  }
});

// ../shadergradient-v2/dist/chunk-BT6X4JN2.mjs
function generateUUID() {
  const d0 = Math.random() * 4294967295 | 0;
  const d1 = Math.random() * 4294967295 | 0;
  const d2 = Math.random() * 4294967295 | 0;
  const d3 = Math.random() * 4294967295 | 0;
  const uuid = _lut[d0 & 255] + _lut[d0 >> 8 & 255] + _lut[d0 >> 16 & 255] + _lut[d0 >> 24 & 255] + "-" + _lut[d1 & 255] + _lut[d1 >> 8 & 255] + "-" + _lut[d1 >> 16 & 15 | 64] + _lut[d1 >> 24 & 255] + "-" + _lut[d2 & 63 | 128] + _lut[d2 >> 8 & 255] + "-" + _lut[d2 >> 16 & 255] + _lut[d2 >> 24 & 255] + _lut[d3 & 255] + _lut[d3 >> 8 & 255] + _lut[d3 >> 16 & 255] + _lut[d3 >> 24 & 255];
  return uuid.toLowerCase();
}
function clamp(value, min, max) {
  return Math.max(min, Math.min(max, value));
}
function euclideanModulo(n, m) {
  return (n % m + m) % m;
}
function mapLinear(x, a1, a2, b1, b2) {
  return b1 + (x - a1) * (b2 - b1) / (a2 - a1);
}
function inverseLerp(x, y2, value) {
  if (x !== y2) {
    return (value - x) / (y2 - x);
  } else {
    return 0;
  }
}
function lerp(x, y2, t2) {
  return (1 - t2) * x + t2 * y2;
}
function damp(x, y2, lambda, dt) {
  return lerp(x, y2, 1 - Math.exp(-lambda * dt));
}
function pingpong(x, length = 1) {
  return length - Math.abs(euclideanModulo(x, length * 2) - length);
}
function smoothstep(x, min, max) {
  if (x <= min) return 0;
  if (x >= max) return 1;
  x = (x - min) / (max - min);
  return x * x * (3 - 2 * x);
}
function smootherstep(x, min, max) {
  if (x <= min) return 0;
  if (x >= max) return 1;
  x = (x - min) / (max - min);
  return x * x * x * (x * (x * 6 - 15) + 10);
}
function randInt(low, high) {
  return low + Math.floor(Math.random() * (high - low + 1));
}
function randFloat(low, high) {
  return low + Math.random() * (high - low);
}
function randFloatSpread(range) {
  return range * (0.5 - Math.random());
}
function seededRandom(s) {
  if (s !== void 0) _seed = s;
  let t2 = _seed += 1831565813;
  t2 = Math.imul(t2 ^ t2 >>> 15, t2 | 1);
  t2 ^= t2 + Math.imul(t2 ^ t2 >>> 7, t2 | 61);
  return ((t2 ^ t2 >>> 14) >>> 0) / 4294967296;
}
function degToRad(degrees) {
  return degrees * DEG2RAD;
}
function radToDeg(radians) {
  return radians * RAD2DEG;
}
function isPowerOfTwo(value) {
  return (value & value - 1) === 0 && value !== 0;
}
function ceilPowerOfTwo(value) {
  return Math.pow(2, Math.ceil(Math.log(value) / Math.LN2));
}
function floorPowerOfTwo(value) {
  return Math.pow(2, Math.floor(Math.log(value) / Math.LN2));
}
function setQuaternionFromProperEuler(q3, a, b, c, order) {
  const cos = Math.cos;
  const sin = Math.sin;
  const c2 = cos(b / 2);
  const s2 = sin(b / 2);
  const c13 = cos((a + c) / 2);
  const s13 = sin((a + c) / 2);
  const c1_3 = cos((a - c) / 2);
  const s1_3 = sin((a - c) / 2);
  const c3_1 = cos((c - a) / 2);
  const s3_1 = sin((c - a) / 2);
  switch (order) {
    case "XYX":
      q3.set(c2 * s13, s2 * c1_3, s2 * s1_3, c2 * c13);
      break;
    case "YZY":
      q3.set(s2 * s1_3, c2 * s13, s2 * c1_3, c2 * c13);
      break;
    case "ZXZ":
      q3.set(s2 * c1_3, s2 * s1_3, c2 * s13, c2 * c13);
      break;
    case "XZX":
      q3.set(c2 * s13, s2 * s3_1, s2 * c3_1, c2 * c13);
      break;
    case "YXY":
      q3.set(s2 * c3_1, c2 * s13, s2 * s3_1, c2 * c13);
      break;
    case "ZYZ":
      q3.set(s2 * s3_1, s2 * c3_1, c2 * s13, c2 * c13);
      break;
    default:
      console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + order);
  }
}
function denormalize(value, array) {
  switch (array.constructor) {
    case Float32Array:
      return value;
    case Uint32Array:
      return value / 4294967295;
    case Uint16Array:
      return value / 65535;
    case Uint8Array:
      return value / 255;
    case Int32Array:
      return Math.max(value / 2147483647, -1);
    case Int16Array:
      return Math.max(value / 32767, -1);
    case Int8Array:
      return Math.max(value / 127, -1);
    default:
      throw new Error("Invalid component type.");
  }
}
function normalize(value, array) {
  switch (array.constructor) {
    case Float32Array:
      return value;
    case Uint32Array:
      return Math.round(value * 4294967295);
    case Uint16Array:
      return Math.round(value * 65535);
    case Uint8Array:
      return Math.round(value * 255);
    case Int32Array:
      return Math.round(value * 2147483647);
    case Int16Array:
      return Math.round(value * 32767);
    case Int8Array:
      return Math.round(value * 127);
    default:
      throw new Error("Invalid component type.");
  }
}
function arrayNeedsUint32(array) {
  for (let i2 = array.length - 1; i2 >= 0; --i2) {
    if (array[i2] >= 65535) return true;
  }
  return false;
}
function getTypedArray(type, buffer) {
  return new TYPED_ARRAYS[type](buffer);
}
function createElementNS(name) {
  return document.createElementNS("http://www.w3.org/1999/xhtml", name);
}
function createCanvasElement() {
  const canvas = createElementNS("canvas");
  canvas.style.display = "block";
  return canvas;
}
function warnOnce(message) {
  if (message in _cache) return;
  _cache[message] = true;
  console.warn(message);
}
function probeAsync(gl, sync, interval) {
  return new Promise(function(resolve2, reject) {
    function probe() {
      switch (gl.clientWaitSync(sync, gl.SYNC_FLUSH_COMMANDS_BIT, 0)) {
        case gl.WAIT_FAILED:
          reject();
          break;
        case gl.TIMEOUT_EXPIRED:
          setTimeout(probe, interval);
          break;
        default:
          resolve2();
      }
    }
    setTimeout(probe, interval);
  });
}
function toNormalizedProjectionMatrix(projectionMatrix) {
  const m = projectionMatrix.elements;
  m[2] = 0.5 * m[2] + 0.5 * m[3];
  m[6] = 0.5 * m[6] + 0.5 * m[7];
  m[10] = 0.5 * m[10] + 0.5 * m[11];
  m[14] = 0.5 * m[14] + 0.5 * m[15];
}
function toReversedProjectionMatrix(projectionMatrix) {
  const m = projectionMatrix.elements;
  const isPerspectiveMatrix = m[11] === -1;
  if (isPerspectiveMatrix) {
    m[10] = -m[10] - 1;
    m[14] = -m[14];
  } else {
    m[10] = -m[10];
    m[14] = -m[14] + 1;
  }
}
function SRGBToLinear(c) {
  return c < 0.04045 ? c * 0.0773993808 : Math.pow(c * 0.9478672986 + 0.0521327014, 2.4);
}
function LinearToSRGB(c) {
  return c < 31308e-7 ? c * 12.92 : 1.055 * Math.pow(c, 0.41666) - 0.055;
}
function serializeImage(image) {
  if (typeof HTMLImageElement !== "undefined" && image instanceof HTMLImageElement || typeof HTMLCanvasElement !== "undefined" && image instanceof HTMLCanvasElement || typeof ImageBitmap !== "undefined" && image instanceof ImageBitmap) {
    return ImageUtils.getDataURL(image);
  } else {
    if (image.data) {
      return {
        data: Array.from(image.data),
        width: image.width,
        height: image.height,
        type: image.data.constructor.name
      };
    } else {
      console.warn("THREE.Texture: Unable to serialize Texture.");
      return {};
    }
  }
}
function satForAxes(axes, v0, v1, v2, extents) {
  for (let i2 = 0, j2 = axes.length - 3; i2 <= j2; i2 += 3) {
    _testAxis.fromArray(axes, i2);
    const r2 = extents.x * Math.abs(_testAxis.x) + extents.y * Math.abs(_testAxis.y) + extents.z * Math.abs(_testAxis.z);
    const p0 = v0.dot(_testAxis);
    const p1 = v1.dot(_testAxis);
    const p22 = v2.dot(_testAxis);
    if (Math.max(-Math.max(p0, p1, p22), Math.min(p0, p1, p22)) > r2) {
      return false;
    }
  }
  return true;
}
function hue2rgb(p3, q3, t2) {
  if (t2 < 0) t2 += 1;
  if (t2 > 1) t2 -= 1;
  if (t2 < 1 / 6) return p3 + (q3 - p3) * 6 * t2;
  if (t2 < 1 / 2) return q3;
  if (t2 < 2 / 3) return p3 + (q3 - p3) * 6 * (2 / 3 - t2);
  return p3;
}
function _generateTables() {
  const buffer = new ArrayBuffer(4);
  const floatView = new Float32Array(buffer);
  const uint32View = new Uint32Array(buffer);
  const baseTable = new Uint32Array(512);
  const shiftTable = new Uint32Array(512);
  for (let i2 = 0; i2 < 256; ++i2) {
    const e = i2 - 127;
    if (e < -27) {
      baseTable[i2] = 0;
      baseTable[i2 | 256] = 32768;
      shiftTable[i2] = 24;
      shiftTable[i2 | 256] = 24;
    } else if (e < -14) {
      baseTable[i2] = 1024 >> -e - 14;
      baseTable[i2 | 256] = 1024 >> -e - 14 | 32768;
      shiftTable[i2] = -e - 1;
      shiftTable[i2 | 256] = -e - 1;
    } else if (e <= 15) {
      baseTable[i2] = e + 15 << 10;
      baseTable[i2 | 256] = e + 15 << 10 | 32768;
      shiftTable[i2] = 13;
      shiftTable[i2 | 256] = 13;
    } else if (e < 128) {
      baseTable[i2] = 31744;
      baseTable[i2 | 256] = 64512;
      shiftTable[i2] = 24;
      shiftTable[i2 | 256] = 24;
    } else {
      baseTable[i2] = 31744;
      baseTable[i2 | 256] = 64512;
      shiftTable[i2] = 13;
      shiftTable[i2 | 256] = 13;
    }
  }
  const mantissaTable = new Uint32Array(2048);
  const exponentTable = new Uint32Array(64);
  const offsetTable = new Uint32Array(64);
  for (let i2 = 1; i2 < 1024; ++i2) {
    let m = i2 << 13;
    let e = 0;
    while ((m & 8388608) === 0) {
      m <<= 1;
      e -= 8388608;
    }
    m &= ~8388608;
    e += 947912704;
    mantissaTable[i2] = m | e;
  }
  for (let i2 = 1024; i2 < 2048; ++i2) {
    mantissaTable[i2] = 939524096 + (i2 - 1024 << 13);
  }
  for (let i2 = 1; i2 < 31; ++i2) {
    exponentTable[i2] = i2 << 23;
  }
  exponentTable[31] = 1199570944;
  exponentTable[32] = 2147483648;
  for (let i2 = 33; i2 < 63; ++i2) {
    exponentTable[i2] = 2147483648 + (i2 - 32 << 23);
  }
  exponentTable[63] = 3347054592;
  for (let i2 = 1; i2 < 64; ++i2) {
    if (i2 !== 32) {
      offsetTable[i2] = 1024;
    }
  }
  return {
    floatView,
    uint32View,
    baseTable,
    shiftTable,
    mantissaTable,
    exponentTable,
    offsetTable
  };
}
function toHalfFloat(val) {
  if (Math.abs(val) > 65504) console.warn("THREE.DataUtils.toHalfFloat(): Value out of range.");
  val = clamp(val, -65504, 65504);
  _tables.floatView[0] = val;
  const f2 = _tables.uint32View[0];
  const e = f2 >> 23 & 511;
  return _tables.baseTable[e] + ((f2 & 8388607) >> _tables.shiftTable[e]);
}
function fromHalfFloat(val) {
  const m = val >> 10;
  _tables.uint32View[0] = _tables.mantissaTable[_tables.offsetTable[m] + (val & 1023)] + _tables.exponentTable[m];
  return _tables.floatView[0];
}
function checkIntersection$1(object, material, raycaster, ray, pA, pB, pC, point) {
  let intersect2;
  if (material.side === BackSide) {
    intersect2 = ray.intersectTriangle(pC, pB, pA, true, point);
  } else {
    intersect2 = ray.intersectTriangle(pA, pB, pC, material.side === FrontSide, point);
  }
  if (intersect2 === null) return null;
  _intersectionPointWorld.copy(point);
  _intersectionPointWorld.applyMatrix4(object.matrixWorld);
  const distance = raycaster.ray.origin.distanceTo(_intersectionPointWorld);
  if (distance < raycaster.near || distance > raycaster.far) return null;
  return {
    distance,
    point: _intersectionPointWorld.clone(),
    object
  };
}
function checkGeometryIntersection(object, material, raycaster, ray, uv, uv1, normal, a, b, c) {
  object.getVertexPosition(a, _vA$1);
  object.getVertexPosition(b, _vB$1);
  object.getVertexPosition(c, _vC$1);
  const intersection = checkIntersection$1(object, material, raycaster, ray, _vA$1, _vB$1, _vC$1, _intersectionPoint);
  if (intersection) {
    const barycoord = new Vector3();
    Triangle.getBarycoord(_intersectionPoint, _vA$1, _vB$1, _vC$1, barycoord);
    if (uv) {
      intersection.uv = Triangle.getInterpolatedAttribute(uv, a, b, c, barycoord, new Vector2());
    }
    if (uv1) {
      intersection.uv1 = Triangle.getInterpolatedAttribute(uv1, a, b, c, barycoord, new Vector2());
    }
    if (normal) {
      intersection.normal = Triangle.getInterpolatedAttribute(normal, a, b, c, barycoord, new Vector3());
      if (intersection.normal.dot(ray.direction) > 0) {
        intersection.normal.multiplyScalar(-1);
      }
    }
    const face = {
      a,
      b,
      c,
      normal: new Vector3(),
      materialIndex: 0
    };
    Triangle.getNormal(_vA$1, _vB$1, _vC$1, face.normal);
    intersection.face = face;
    intersection.barycoord = barycoord;
  }
  return intersection;
}
function cloneUniforms(src) {
  const dst = {};
  for (const u3 in src) {
    dst[u3] = {};
    for (const p3 in src[u3]) {
      const property = src[u3][p3];
      if (property && (property.isColor || property.isMatrix3 || property.isMatrix4 || property.isVector2 || property.isVector3 || property.isVector4 || property.isTexture || property.isQuaternion)) {
        if (property.isRenderTargetTexture) {
          console.warn("UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms().");
          dst[u3][p3] = null;
        } else {
          dst[u3][p3] = property.clone();
        }
      } else if (Array.isArray(property)) {
        dst[u3][p3] = property.slice();
      } else {
        dst[u3][p3] = property;
      }
    }
  }
  return dst;
}
function mergeUniforms(uniforms) {
  const merged = {};
  for (let u3 = 0; u3 < uniforms.length; u3++) {
    const tmp2 = cloneUniforms(uniforms[u3]);
    for (const p3 in tmp2) {
      merged[p3] = tmp2[p3];
    }
  }
  return merged;
}
function cloneUniformsGroups(src) {
  const dst = [];
  for (let u3 = 0; u3 < src.length; u3++) {
    dst.push(src[u3].clone());
  }
  return dst;
}
function getUnlitUniformColorSpace(renderer) {
  const currentRenderTarget = renderer.getRenderTarget();
  if (currentRenderTarget === null) {
    return renderer.outputColorSpace;
  }
  if (currentRenderTarget.isXRRenderTarget === true) {
    return currentRenderTarget.texture.colorSpace;
  }
  return ColorManagement.workingColorSpace;
}
function WebGLAnimation() {
  let context2 = null;
  let isAnimating = false;
  let animationLoop = null;
  let requestId = null;
  function onAnimationFrame(time, frame) {
    animationLoop(time, frame);
    requestId = context2.requestAnimationFrame(onAnimationFrame);
  }
  return {
    start: function() {
      if (isAnimating === true) return;
      if (animationLoop === null) return;
      requestId = context2.requestAnimationFrame(onAnimationFrame);
      isAnimating = true;
    },
    stop: function() {
      context2.cancelAnimationFrame(requestId);
      isAnimating = false;
    },
    setAnimationLoop: function(callback) {
      animationLoop = callback;
    },
    setContext: function(value) {
      context2 = value;
    }
  };
}
function WebGLAttributes(gl) {
  const buffers = /* @__PURE__ */ new WeakMap();
  function createBuffer(attribute, bufferType) {
    const array = attribute.array;
    const usage = attribute.usage;
    const size = array.byteLength;
    const buffer = gl.createBuffer();
    gl.bindBuffer(bufferType, buffer);
    gl.bufferData(bufferType, array, usage);
    attribute.onUploadCallback();
    let type;
    if (array instanceof Float32Array) {
      type = gl.FLOAT;
    } else if (array instanceof Uint16Array) {
      if (attribute.isFloat16BufferAttribute) {
        type = gl.HALF_FLOAT;
      } else {
        type = gl.UNSIGNED_SHORT;
      }
    } else if (array instanceof Int16Array) {
      type = gl.SHORT;
    } else if (array instanceof Uint32Array) {
      type = gl.UNSIGNED_INT;
    } else if (array instanceof Int32Array) {
      type = gl.INT;
    } else if (array instanceof Int8Array) {
      type = gl.BYTE;
    } else if (array instanceof Uint8Array) {
      type = gl.UNSIGNED_BYTE;
    } else if (array instanceof Uint8ClampedArray) {
      type = gl.UNSIGNED_BYTE;
    } else {
      throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: " + array);
    }
    return {
      buffer,
      type,
      bytesPerElement: array.BYTES_PER_ELEMENT,
      version: attribute.version,
      size
    };
  }
  function updateBuffer(buffer, attribute, bufferType) {
    const array = attribute.array;
    const updateRanges = attribute.updateRanges;
    gl.bindBuffer(bufferType, buffer);
    if (updateRanges.length === 0) {
      gl.bufferSubData(bufferType, 0, array);
    } else {
      updateRanges.sort((a, b) => a.start - b.start);
      let mergeIndex = 0;
      for (let i2 = 1; i2 < updateRanges.length; i2++) {
        const previousRange = updateRanges[mergeIndex];
        const range = updateRanges[i2];
        if (range.start <= previousRange.start + previousRange.count + 1) {
          previousRange.count = Math.max(
            previousRange.count,
            range.start + range.count - previousRange.start
          );
        } else {
          ++mergeIndex;
          updateRanges[mergeIndex] = range;
        }
      }
      updateRanges.length = mergeIndex + 1;
      for (let i2 = 0, l2 = updateRanges.length; i2 < l2; i2++) {
        const range = updateRanges[i2];
        gl.bufferSubData(
          bufferType,
          range.start * array.BYTES_PER_ELEMENT,
          array,
          range.start,
          range.count
        );
      }
      attribute.clearUpdateRanges();
    }
    attribute.onUploadCallback();
  }
  function get(attribute) {
    if (attribute.isInterleavedBufferAttribute) attribute = attribute.data;
    return buffers.get(attribute);
  }
  function remove(attribute) {
    if (attribute.isInterleavedBufferAttribute) attribute = attribute.data;
    const data = buffers.get(attribute);
    if (data) {
      gl.deleteBuffer(data.buffer);
      buffers.delete(attribute);
    }
  }
  function update(attribute, bufferType) {
    if (attribute.isInterleavedBufferAttribute) attribute = attribute.data;
    if (attribute.isGLBufferAttribute) {
      const cached = buffers.get(attribute);
      if (!cached || cached.version < attribute.version) {
        buffers.set(attribute, {
          buffer: attribute.buffer,
          type: attribute.type,
          bytesPerElement: attribute.elementSize,
          version: attribute.version
        });
      }
      return;
    }
    const data = buffers.get(attribute);
    if (data === void 0) {
      buffers.set(attribute, createBuffer(attribute, bufferType));
    } else if (data.version < attribute.version) {
      if (data.size !== attribute.array.byteLength) {
        throw new Error("THREE.WebGLAttributes: The size of the buffer attribute's array buffer does not match the original size. Resizing buffer attributes is not supported.");
      }
      updateBuffer(data.buffer, attribute, bufferType);
      data.version = attribute.version;
    }
  }
  return {
    get,
    remove,
    update
  };
}
function WebGLBackground(renderer, cubemaps, cubeuvmaps, state, objects, alpha, premultipliedAlpha) {
  const clearColor = new Color(0);
  let clearAlpha = alpha === true ? 0 : 1;
  let planeMesh;
  let boxMesh;
  let currentBackground = null;
  let currentBackgroundVersion = 0;
  let currentTonemapping = null;
  function getBackground(scene) {
    let background = scene.isScene === true ? scene.background : null;
    if (background && background.isTexture) {
      const usePMREM = scene.backgroundBlurriness > 0;
      background = (usePMREM ? cubeuvmaps : cubemaps).get(background);
    }
    return background;
  }
  function render(scene) {
    let forceClear = false;
    const background = getBackground(scene);
    if (background === null) {
      setClear(clearColor, clearAlpha);
    } else if (background && background.isColor) {
      setClear(background, 1);
      forceClear = true;
    }
    const environmentBlendMode = renderer.xr.getEnvironmentBlendMode();
    if (environmentBlendMode === "additive") {
      state.buffers.color.setClear(0, 0, 0, 1, premultipliedAlpha);
    } else if (environmentBlendMode === "alpha-blend") {
      state.buffers.color.setClear(0, 0, 0, 0, premultipliedAlpha);
    }
    if (renderer.autoClear || forceClear) {
      state.buffers.depth.setTest(true);
      state.buffers.depth.setMask(true);
      state.buffers.color.setMask(true);
      renderer.clear(renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil);
    }
  }
  function addToRenderList(renderList, scene) {
    const background = getBackground(scene);
    if (background && (background.isCubeTexture || background.mapping === CubeUVReflectionMapping)) {
      if (boxMesh === void 0) {
        boxMesh = new Mesh(
          new BoxGeometry(1, 1, 1),
          new ShaderMaterial({
            name: "BackgroundCubeMaterial",
            uniforms: cloneUniforms(ShaderLib.backgroundCube.uniforms),
            vertexShader: ShaderLib.backgroundCube.vertexShader,
            fragmentShader: ShaderLib.backgroundCube.fragmentShader,
            side: BackSide,
            depthTest: false,
            depthWrite: false,
            fog: false
          })
        );
        boxMesh.geometry.deleteAttribute("normal");
        boxMesh.geometry.deleteAttribute("uv");
        boxMesh.onBeforeRender = function(renderer2, scene2, camera) {
          this.matrixWorld.copyPosition(camera.matrixWorld);
        };
        Object.defineProperty(boxMesh.material, "envMap", {
          get: function() {
            return this.uniforms.envMap.value;
          }
        });
        objects.update(boxMesh);
      }
      _e1$1.copy(scene.backgroundRotation);
      _e1$1.x *= -1;
      _e1$1.y *= -1;
      _e1$1.z *= -1;
      if (background.isCubeTexture && background.isRenderTargetTexture === false) {
        _e1$1.y *= -1;
        _e1$1.z *= -1;
      }
      boxMesh.material.uniforms.envMap.value = background;
      boxMesh.material.uniforms.flipEnvMap.value = background.isCubeTexture && background.isRenderTargetTexture === false ? -1 : 1;
      boxMesh.material.uniforms.backgroundBlurriness.value = scene.backgroundBlurriness;
      boxMesh.material.uniforms.backgroundIntensity.value = scene.backgroundIntensity;
      boxMesh.material.uniforms.backgroundRotation.value.setFromMatrix4(_m1$1.makeRotationFromEuler(_e1$1));
      boxMesh.material.toneMapped = ColorManagement.getTransfer(background.colorSpace) !== SRGBTransfer;
      if (currentBackground !== background || currentBackgroundVersion !== background.version || currentTonemapping !== renderer.toneMapping) {
        boxMesh.material.needsUpdate = true;
        currentBackground = background;
        currentBackgroundVersion = background.version;
        currentTonemapping = renderer.toneMapping;
      }
      boxMesh.layers.enableAll();
      renderList.unshift(boxMesh, boxMesh.geometry, boxMesh.material, 0, 0, null);
    } else if (background && background.isTexture) {
      if (planeMesh === void 0) {
        planeMesh = new Mesh(
          new PlaneGeometry(2, 2),
          new ShaderMaterial({
            name: "BackgroundMaterial",
            uniforms: cloneUniforms(ShaderLib.background.uniforms),
            vertexShader: ShaderLib.background.vertexShader,
            fragmentShader: ShaderLib.background.fragmentShader,
            side: FrontSide,
            depthTest: false,
            depthWrite: false,
            fog: false
          })
        );
        planeMesh.geometry.deleteAttribute("normal");
        Object.defineProperty(planeMesh.material, "map", {
          get: function() {
            return this.uniforms.t2D.value;
          }
        });
        objects.update(planeMesh);
      }
      planeMesh.material.uniforms.t2D.value = background;
      planeMesh.material.uniforms.backgroundIntensity.value = scene.backgroundIntensity;
      planeMesh.material.toneMapped = ColorManagement.getTransfer(background.colorSpace) !== SRGBTransfer;
      if (background.matrixAutoUpdate === true) {
        background.updateMatrix();
      }
      planeMesh.material.uniforms.uvTransform.value.copy(background.matrix);
      if (currentBackground !== background || currentBackgroundVersion !== background.version || currentTonemapping !== renderer.toneMapping) {
        planeMesh.material.needsUpdate = true;
        currentBackground = background;
        currentBackgroundVersion = background.version;
        currentTonemapping = renderer.toneMapping;
      }
      planeMesh.layers.enableAll();
      renderList.unshift(planeMesh, planeMesh.geometry, planeMesh.material, 0, 0, null);
    }
  }
  function setClear(color, alpha2) {
    color.getRGB(_rgb, getUnlitUniformColorSpace(renderer));
    state.buffers.color.setClear(_rgb.r, _rgb.g, _rgb.b, alpha2, premultipliedAlpha);
  }
  return {
    getClearColor: function() {
      return clearColor;
    },
    setClearColor: function(color, alpha2 = 1) {
      clearColor.set(color);
      clearAlpha = alpha2;
      setClear(clearColor, clearAlpha);
    },
    getClearAlpha: function() {
      return clearAlpha;
    },
    setClearAlpha: function(alpha2) {
      clearAlpha = alpha2;
      setClear(clearColor, clearAlpha);
    },
    render,
    addToRenderList
  };
}
function WebGLBindingStates(gl, attributes) {
  const maxVertexAttributes = gl.getParameter(gl.MAX_VERTEX_ATTRIBS);
  const bindingStates = {};
  const defaultState = createBindingState(null);
  let currentState = defaultState;
  let forceUpdate = false;
  function setup(object, material, program, geometry, index) {
    let updateBuffers = false;
    const state = getBindingState(geometry, program, material);
    if (currentState !== state) {
      currentState = state;
      bindVertexArrayObject(currentState.object);
    }
    updateBuffers = needsUpdate(object, geometry, program, index);
    if (updateBuffers) saveCache(object, geometry, program, index);
    if (index !== null) {
      attributes.update(index, gl.ELEMENT_ARRAY_BUFFER);
    }
    if (updateBuffers || forceUpdate) {
      forceUpdate = false;
      setupVertexAttributes(object, material, program, geometry);
      if (index !== null) {
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, attributes.get(index).buffer);
      }
    }
  }
  function createVertexArrayObject() {
    return gl.createVertexArray();
  }
  function bindVertexArrayObject(vao) {
    return gl.bindVertexArray(vao);
  }
  function deleteVertexArrayObject(vao) {
    return gl.deleteVertexArray(vao);
  }
  function getBindingState(geometry, program, material) {
    const wireframe = material.wireframe === true;
    let programMap = bindingStates[geometry.id];
    if (programMap === void 0) {
      programMap = {};
      bindingStates[geometry.id] = programMap;
    }
    let stateMap = programMap[program.id];
    if (stateMap === void 0) {
      stateMap = {};
      programMap[program.id] = stateMap;
    }
    let state = stateMap[wireframe];
    if (state === void 0) {
      state = createBindingState(createVertexArrayObject());
      stateMap[wireframe] = state;
    }
    return state;
  }
  function createBindingState(vao) {
    const newAttributes = [];
    const enabledAttributes = [];
    const attributeDivisors = [];
    for (let i2 = 0; i2 < maxVertexAttributes; i2++) {
      newAttributes[i2] = 0;
      enabledAttributes[i2] = 0;
      attributeDivisors[i2] = 0;
    }
    return {
      // for backward compatibility on non-VAO support browser
      geometry: null,
      program: null,
      wireframe: false,
      newAttributes,
      enabledAttributes,
      attributeDivisors,
      object: vao,
      attributes: {},
      index: null
    };
  }
  function needsUpdate(object, geometry, program, index) {
    const cachedAttributes = currentState.attributes;
    const geometryAttributes = geometry.attributes;
    let attributesNum = 0;
    const programAttributes = program.getAttributes();
    for (const name in programAttributes) {
      const programAttribute = programAttributes[name];
      if (programAttribute.location >= 0) {
        const cachedAttribute = cachedAttributes[name];
        let geometryAttribute = geometryAttributes[name];
        if (geometryAttribute === void 0) {
          if (name === "instanceMatrix" && object.instanceMatrix) geometryAttribute = object.instanceMatrix;
          if (name === "instanceColor" && object.instanceColor) geometryAttribute = object.instanceColor;
        }
        if (cachedAttribute === void 0) return true;
        if (cachedAttribute.attribute !== geometryAttribute) return true;
        if (geometryAttribute && cachedAttribute.data !== geometryAttribute.data) return true;
        attributesNum++;
      }
    }
    if (currentState.attributesNum !== attributesNum) return true;
    if (currentState.index !== index) return true;
    return false;
  }
  function saveCache(object, geometry, program, index) {
    const cache = {};
    const attributes2 = geometry.attributes;
    let attributesNum = 0;
    const programAttributes = program.getAttributes();
    for (const name in programAttributes) {
      const programAttribute = programAttributes[name];
      if (programAttribute.location >= 0) {
        let attribute = attributes2[name];
        if (attribute === void 0) {
          if (name === "instanceMatrix" && object.instanceMatrix) attribute = object.instanceMatrix;
          if (name === "instanceColor" && object.instanceColor) attribute = object.instanceColor;
        }
        const data = {};
        data.attribute = attribute;
        if (attribute && attribute.data) {
          data.data = attribute.data;
        }
        cache[name] = data;
        attributesNum++;
      }
    }
    currentState.attributes = cache;
    currentState.attributesNum = attributesNum;
    currentState.index = index;
  }
  function initAttributes() {
    const newAttributes = currentState.newAttributes;
    for (let i2 = 0, il = newAttributes.length; i2 < il; i2++) {
      newAttributes[i2] = 0;
    }
  }
  function enableAttribute(attribute) {
    enableAttributeAndDivisor(attribute, 0);
  }
  function enableAttributeAndDivisor(attribute, meshPerAttribute) {
    const newAttributes = currentState.newAttributes;
    const enabledAttributes = currentState.enabledAttributes;
    const attributeDivisors = currentState.attributeDivisors;
    newAttributes[attribute] = 1;
    if (enabledAttributes[attribute] === 0) {
      gl.enableVertexAttribArray(attribute);
      enabledAttributes[attribute] = 1;
    }
    if (attributeDivisors[attribute] !== meshPerAttribute) {
      gl.vertexAttribDivisor(attribute, meshPerAttribute);
      attributeDivisors[attribute] = meshPerAttribute;
    }
  }
  function disableUnusedAttributes() {
    const newAttributes = currentState.newAttributes;
    const enabledAttributes = currentState.enabledAttributes;
    for (let i2 = 0, il = enabledAttributes.length; i2 < il; i2++) {
      if (enabledAttributes[i2] !== newAttributes[i2]) {
        gl.disableVertexAttribArray(i2);
        enabledAttributes[i2] = 0;
      }
    }
  }
  function vertexAttribPointer(index, size, type, normalized, stride, offset, integer) {
    if (integer === true) {
      gl.vertexAttribIPointer(index, size, type, stride, offset);
    } else {
      gl.vertexAttribPointer(index, size, type, normalized, stride, offset);
    }
  }
  function setupVertexAttributes(object, material, program, geometry) {
    initAttributes();
    const geometryAttributes = geometry.attributes;
    const programAttributes = program.getAttributes();
    const materialDefaultAttributeValues = material.defaultAttributeValues;
    for (const name in programAttributes) {
      const programAttribute = programAttributes[name];
      if (programAttribute.location >= 0) {
        let geometryAttribute = geometryAttributes[name];
        if (geometryAttribute === void 0) {
          if (name === "instanceMatrix" && object.instanceMatrix) geometryAttribute = object.instanceMatrix;
          if (name === "instanceColor" && object.instanceColor) geometryAttribute = object.instanceColor;
        }
        if (geometryAttribute !== void 0) {
          const normalized = geometryAttribute.normalized;
          const size = geometryAttribute.itemSize;
          const attribute = attributes.get(geometryAttribute);
          if (attribute === void 0) continue;
          const buffer = attribute.buffer;
          const type = attribute.type;
          const bytesPerElement = attribute.bytesPerElement;
          const integer = type === gl.INT || type === gl.UNSIGNED_INT || geometryAttribute.gpuType === IntType;
          if (geometryAttribute.isInterleavedBufferAttribute) {
            const data = geometryAttribute.data;
            const stride = data.stride;
            const offset = geometryAttribute.offset;
            if (data.isInstancedInterleavedBuffer) {
              for (let i2 = 0; i2 < programAttribute.locationSize; i2++) {
                enableAttributeAndDivisor(programAttribute.location + i2, data.meshPerAttribute);
              }
              if (object.isInstancedMesh !== true && geometry._maxInstanceCount === void 0) {
                geometry._maxInstanceCount = data.meshPerAttribute * data.count;
              }
            } else {
              for (let i2 = 0; i2 < programAttribute.locationSize; i2++) {
                enableAttribute(programAttribute.location + i2);
              }
            }
            gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
            for (let i2 = 0; i2 < programAttribute.locationSize; i2++) {
              vertexAttribPointer(
                programAttribute.location + i2,
                size / programAttribute.locationSize,
                type,
                normalized,
                stride * bytesPerElement,
                (offset + size / programAttribute.locationSize * i2) * bytesPerElement,
                integer
              );
            }
          } else {
            if (geometryAttribute.isInstancedBufferAttribute) {
              for (let i2 = 0; i2 < programAttribute.locationSize; i2++) {
                enableAttributeAndDivisor(programAttribute.location + i2, geometryAttribute.meshPerAttribute);
              }
              if (object.isInstancedMesh !== true && geometry._maxInstanceCount === void 0) {
                geometry._maxInstanceCount = geometryAttribute.meshPerAttribute * geometryAttribute.count;
              }
            } else {
              for (let i2 = 0; i2 < programAttribute.locationSize; i2++) {
                enableAttribute(programAttribute.location + i2);
              }
            }
            gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
            for (let i2 = 0; i2 < programAttribute.locationSize; i2++) {
              vertexAttribPointer(
                programAttribute.location + i2,
                size / programAttribute.locationSize,
                type,
                normalized,
                size * bytesPerElement,
                size / programAttribute.locationSize * i2 * bytesPerElement,
                integer
              );
            }
          }
        } else if (materialDefaultAttributeValues !== void 0) {
          const value = materialDefaultAttributeValues[name];
          if (value !== void 0) {
            switch (value.length) {
              case 2:
                gl.vertexAttrib2fv(programAttribute.location, value);
                break;
              case 3:
                gl.vertexAttrib3fv(programAttribute.location, value);
                break;
              case 4:
                gl.vertexAttrib4fv(programAttribute.location, value);
                break;
              default:
                gl.vertexAttrib1fv(programAttribute.location, value);
            }
          }
        }
      }
    }
    disableUnusedAttributes();
  }
  function dispose2() {
    reset();
    for (const geometryId in bindingStates) {
      const programMap = bindingStates[geometryId];
      for (const programId in programMap) {
        const stateMap = programMap[programId];
        for (const wireframe in stateMap) {
          deleteVertexArrayObject(stateMap[wireframe].object);
          delete stateMap[wireframe];
        }
        delete programMap[programId];
      }
      delete bindingStates[geometryId];
    }
  }
  function releaseStatesOfGeometry(geometry) {
    if (bindingStates[geometry.id] === void 0) return;
    const programMap = bindingStates[geometry.id];
    for (const programId in programMap) {
      const stateMap = programMap[programId];
      for (const wireframe in stateMap) {
        deleteVertexArrayObject(stateMap[wireframe].object);
        delete stateMap[wireframe];
      }
      delete programMap[programId];
    }
    delete bindingStates[geometry.id];
  }
  function releaseStatesOfProgram(program) {
    for (const geometryId in bindingStates) {
      const programMap = bindingStates[geometryId];
      if (programMap[program.id] === void 0) continue;
      const stateMap = programMap[program.id];
      for (const wireframe in stateMap) {
        deleteVertexArrayObject(stateMap[wireframe].object);
        delete stateMap[wireframe];
      }
      delete programMap[program.id];
    }
  }
  function reset() {
    resetDefaultState();
    forceUpdate = true;
    if (currentState === defaultState) return;
    currentState = defaultState;
    bindVertexArrayObject(currentState.object);
  }
  function resetDefaultState() {
    defaultState.geometry = null;
    defaultState.program = null;
    defaultState.wireframe = false;
  }
  return {
    setup,
    reset,
    resetDefaultState,
    dispose: dispose2,
    releaseStatesOfGeometry,
    releaseStatesOfProgram,
    initAttributes,
    enableAttribute,
    disableUnusedAttributes
  };
}
function WebGLBufferRenderer(gl, extensions, info) {
  let mode;
  function setMode(value) {
    mode = value;
  }
  function render(start, count) {
    gl.drawArrays(mode, start, count);
    info.update(count, mode, 1);
  }
  function renderInstances(start, count, primcount) {
    if (primcount === 0) return;
    gl.drawArraysInstanced(mode, start, count, primcount);
    info.update(count, mode, primcount);
  }
  function renderMultiDraw(starts, counts, drawCount) {
    if (drawCount === 0) return;
    const extension = extensions.get("WEBGL_multi_draw");
    extension.multiDrawArraysWEBGL(mode, starts, 0, counts, 0, drawCount);
    let elementCount = 0;
    for (let i2 = 0; i2 < drawCount; i2++) {
      elementCount += counts[i2];
    }
    info.update(elementCount, mode, 1);
  }
  function renderMultiDrawInstances(starts, counts, drawCount, primcount) {
    if (drawCount === 0) return;
    const extension = extensions.get("WEBGL_multi_draw");
    if (extension === null) {
      for (let i2 = 0; i2 < starts.length; i2++) {
        renderInstances(starts[i2], counts[i2], primcount[i2]);
      }
    } else {
      extension.multiDrawArraysInstancedWEBGL(mode, starts, 0, counts, 0, primcount, 0, drawCount);
      let elementCount = 0;
      for (let i2 = 0; i2 < drawCount; i2++) {
        elementCount += counts[i2];
      }
      for (let i2 = 0; i2 < primcount.length; i2++) {
        info.update(elementCount, mode, primcount[i2]);
      }
    }
  }
  this.setMode = setMode;
  this.render = render;
  this.renderInstances = renderInstances;
  this.renderMultiDraw = renderMultiDraw;
  this.renderMultiDrawInstances = renderMultiDrawInstances;
}
function WebGLCapabilities(gl, extensions, parameters, utils) {
  let maxAnisotropy;
  function getMaxAnisotropy() {
    if (maxAnisotropy !== void 0) return maxAnisotropy;
    if (extensions.has("EXT_texture_filter_anisotropic") === true) {
      const extension = extensions.get("EXT_texture_filter_anisotropic");
      maxAnisotropy = gl.getParameter(extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
    } else {
      maxAnisotropy = 0;
    }
    return maxAnisotropy;
  }
  function textureFormatReadable(textureFormat) {
    if (textureFormat !== RGBAFormat && utils.convert(textureFormat) !== gl.getParameter(gl.IMPLEMENTATION_COLOR_READ_FORMAT)) {
      return false;
    }
    return true;
  }
  function textureTypeReadable(textureType) {
    const halfFloatSupportedByExt = textureType === HalfFloatType && (extensions.has("EXT_color_buffer_half_float") || extensions.has("EXT_color_buffer_float"));
    if (textureType !== UnsignedByteType && utils.convert(textureType) !== gl.getParameter(gl.IMPLEMENTATION_COLOR_READ_TYPE) && // Edge and Chrome Mac < 52 (#9513)
    textureType !== FloatType && !halfFloatSupportedByExt) {
      return false;
    }
    return true;
  }
  function getMaxPrecision(precision2) {
    if (precision2 === "highp") {
      if (gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.HIGH_FLOAT).precision > 0 && gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT).precision > 0) {
        return "highp";
      }
      precision2 = "mediump";
    }
    if (precision2 === "mediump") {
      if (gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.MEDIUM_FLOAT).precision > 0 && gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT).precision > 0) {
        return "mediump";
      }
    }
    return "lowp";
  }
  let precision = parameters.precision !== void 0 ? parameters.precision : "highp";
  const maxPrecision = getMaxPrecision(precision);
  if (maxPrecision !== precision) {
    console.warn("THREE.WebGLRenderer:", precision, "not supported, using", maxPrecision, "instead.");
    precision = maxPrecision;
  }
  const logarithmicDepthBuffer = parameters.logarithmicDepthBuffer === true;
  const reverseDepthBuffer = parameters.reverseDepthBuffer === true && extensions.has("EXT_clip_control");
  if (reverseDepthBuffer === true) {
    const ext = extensions.get("EXT_clip_control");
    ext.clipControlEXT(ext.LOWER_LEFT_EXT, ext.ZERO_TO_ONE_EXT);
  }
  const maxTextures = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);
  const maxVertexTextures = gl.getParameter(gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS);
  const maxTextureSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);
  const maxCubemapSize = gl.getParameter(gl.MAX_CUBE_MAP_TEXTURE_SIZE);
  const maxAttributes = gl.getParameter(gl.MAX_VERTEX_ATTRIBS);
  const maxVertexUniforms = gl.getParameter(gl.MAX_VERTEX_UNIFORM_VECTORS);
  const maxVaryings = gl.getParameter(gl.MAX_VARYING_VECTORS);
  const maxFragmentUniforms = gl.getParameter(gl.MAX_FRAGMENT_UNIFORM_VECTORS);
  const vertexTextures = maxVertexTextures > 0;
  const maxSamples = gl.getParameter(gl.MAX_SAMPLES);
  return {
    isWebGL2: true,
    // keeping this for backwards compatibility
    getMaxAnisotropy,
    getMaxPrecision,
    textureFormatReadable,
    textureTypeReadable,
    precision,
    logarithmicDepthBuffer,
    reverseDepthBuffer,
    maxTextures,
    maxVertexTextures,
    maxTextureSize,
    maxCubemapSize,
    maxAttributes,
    maxVertexUniforms,
    maxVaryings,
    maxFragmentUniforms,
    vertexTextures,
    maxSamples
  };
}
function WebGLClipping(properties) {
  const scope = this;
  let globalState = null, numGlobalPlanes = 0, localClippingEnabled = false, renderingShadows = false;
  const plane = new Plane(), viewNormalMatrix = new Matrix3(), uniform = { value: null, needsUpdate: false };
  this.uniform = uniform;
  this.numPlanes = 0;
  this.numIntersection = 0;
  this.init = function(planes, enableLocalClipping) {
    const enabled = planes.length !== 0 || enableLocalClipping || // enable state of previous frame - the clipping code has to
    // run another frame in order to reset the state:
    numGlobalPlanes !== 0 || localClippingEnabled;
    localClippingEnabled = enableLocalClipping;
    numGlobalPlanes = planes.length;
    return enabled;
  };
  this.beginShadows = function() {
    renderingShadows = true;
    projectPlanes(null);
  };
  this.endShadows = function() {
    renderingShadows = false;
  };
  this.setGlobalState = function(planes, camera) {
    globalState = projectPlanes(planes, camera, 0);
  };
  this.setState = function(material, camera, useCache) {
    const planes = material.clippingPlanes, clipIntersection = material.clipIntersection, clipShadows = material.clipShadows;
    const materialProperties = properties.get(material);
    if (!localClippingEnabled || planes === null || planes.length === 0 || renderingShadows && !clipShadows) {
      if (renderingShadows) {
        projectPlanes(null);
      } else {
        resetGlobalState();
      }
    } else {
      const nGlobal = renderingShadows ? 0 : numGlobalPlanes, lGlobal = nGlobal * 4;
      let dstArray = materialProperties.clippingState || null;
      uniform.value = dstArray;
      dstArray = projectPlanes(planes, camera, lGlobal, useCache);
      for (let i2 = 0; i2 !== lGlobal; ++i2) {
        dstArray[i2] = globalState[i2];
      }
      materialProperties.clippingState = dstArray;
      this.numIntersection = clipIntersection ? this.numPlanes : 0;
      this.numPlanes += nGlobal;
    }
  };
  function resetGlobalState() {
    if (uniform.value !== globalState) {
      uniform.value = globalState;
      uniform.needsUpdate = numGlobalPlanes > 0;
    }
    scope.numPlanes = numGlobalPlanes;
    scope.numIntersection = 0;
  }
  function projectPlanes(planes, camera, dstOffset, skipTransform) {
    const nPlanes = planes !== null ? planes.length : 0;
    let dstArray = null;
    if (nPlanes !== 0) {
      dstArray = uniform.value;
      if (skipTransform !== true || dstArray === null) {
        const flatSize = dstOffset + nPlanes * 4, viewMatrix = camera.matrixWorldInverse;
        viewNormalMatrix.getNormalMatrix(viewMatrix);
        if (dstArray === null || dstArray.length < flatSize) {
          dstArray = new Float32Array(flatSize);
        }
        for (let i2 = 0, i4 = dstOffset; i2 !== nPlanes; ++i2, i4 += 4) {
          plane.copy(planes[i2]).applyMatrix4(viewMatrix, viewNormalMatrix);
          plane.normal.toArray(dstArray, i4);
          dstArray[i4 + 3] = plane.constant;
        }
      }
      uniform.value = dstArray;
      uniform.needsUpdate = true;
    }
    scope.numPlanes = nPlanes;
    scope.numIntersection = 0;
    return dstArray;
  }
}
function WebGLCubeMaps(renderer) {
  let cubemaps = /* @__PURE__ */ new WeakMap();
  function mapTextureMapping(texture, mapping) {
    if (mapping === EquirectangularReflectionMapping) {
      texture.mapping = CubeReflectionMapping;
    } else if (mapping === EquirectangularRefractionMapping) {
      texture.mapping = CubeRefractionMapping;
    }
    return texture;
  }
  function get(texture) {
    if (texture && texture.isTexture) {
      const mapping = texture.mapping;
      if (mapping === EquirectangularReflectionMapping || mapping === EquirectangularRefractionMapping) {
        if (cubemaps.has(texture)) {
          const cubemap = cubemaps.get(texture).texture;
          return mapTextureMapping(cubemap, texture.mapping);
        } else {
          const image = texture.image;
          if (image && image.height > 0) {
            const renderTarget = new WebGLCubeRenderTarget(image.height);
            renderTarget.fromEquirectangularTexture(renderer, texture);
            cubemaps.set(texture, renderTarget);
            texture.addEventListener("dispose", onTextureDispose);
            return mapTextureMapping(renderTarget.texture, texture.mapping);
          } else {
            return null;
          }
        }
      }
    }
    return texture;
  }
  function onTextureDispose(event) {
    const texture = event.target;
    texture.removeEventListener("dispose", onTextureDispose);
    const cubemap = cubemaps.get(texture);
    if (cubemap !== void 0) {
      cubemaps.delete(texture);
      cubemap.dispose();
    }
  }
  function dispose2() {
    cubemaps = /* @__PURE__ */ new WeakMap();
  }
  return {
    get,
    dispose: dispose2
  };
}
function _createPlanes(lodMax) {
  const lodPlanes = [];
  const sizeLods = [];
  const sigmas = [];
  let lod = lodMax;
  const totalLods = lodMax - LOD_MIN + 1 + EXTRA_LOD_SIGMA.length;
  for (let i2 = 0; i2 < totalLods; i2++) {
    const sizeLod = Math.pow(2, lod);
    sizeLods.push(sizeLod);
    let sigma = 1 / sizeLod;
    if (i2 > lodMax - LOD_MIN) {
      sigma = EXTRA_LOD_SIGMA[i2 - lodMax + LOD_MIN - 1];
    } else if (i2 === 0) {
      sigma = 0;
    }
    sigmas.push(sigma);
    const texelSize = 1 / (sizeLod - 2);
    const min = -texelSize;
    const max = 1 + texelSize;
    const uv1 = [min, min, max, min, max, max, min, min, max, max, min, max];
    const cubeFaces = 6;
    const vertices = 6;
    const positionSize = 3;
    const uvSize = 2;
    const faceIndexSize = 1;
    const position = new Float32Array(positionSize * vertices * cubeFaces);
    const uv = new Float32Array(uvSize * vertices * cubeFaces);
    const faceIndex = new Float32Array(faceIndexSize * vertices * cubeFaces);
    for (let face = 0; face < cubeFaces; face++) {
      const x = face % 3 * 2 / 3 - 1;
      const y2 = face > 2 ? 0 : -1;
      const coordinates = [
        x,
        y2,
        0,
        x + 2 / 3,
        y2,
        0,
        x + 2 / 3,
        y2 + 1,
        0,
        x,
        y2,
        0,
        x + 2 / 3,
        y2 + 1,
        0,
        x,
        y2 + 1,
        0
      ];
      position.set(coordinates, positionSize * vertices * face);
      uv.set(uv1, uvSize * vertices * face);
      const fill2 = [face, face, face, face, face, face];
      faceIndex.set(fill2, faceIndexSize * vertices * face);
    }
    const planes = new BufferGeometry();
    planes.setAttribute("position", new BufferAttribute(position, positionSize));
    planes.setAttribute("uv", new BufferAttribute(uv, uvSize));
    planes.setAttribute("faceIndex", new BufferAttribute(faceIndex, faceIndexSize));
    lodPlanes.push(planes);
    if (lod > LOD_MIN) {
      lod--;
    }
  }
  return { lodPlanes, sizeLods, sigmas };
}
function _createRenderTarget(width, height, params) {
  const cubeUVRenderTarget = new WebGLRenderTarget(width, height, params);
  cubeUVRenderTarget.texture.mapping = CubeUVReflectionMapping;
  cubeUVRenderTarget.texture.name = "PMREM.cubeUv";
  cubeUVRenderTarget.scissorTest = true;
  return cubeUVRenderTarget;
}
function _setViewport(target2, x, y2, width, height) {
  target2.viewport.set(x, y2, width, height);
  target2.scissor.set(x, y2, width, height);
}
function _getBlurShader(lodMax, width, height) {
  const weights = new Float32Array(MAX_SAMPLES);
  const poleAxis = new Vector3(0, 1, 0);
  const shaderMaterial = new ShaderMaterial({
    name: "SphericalGaussianBlur",
    defines: {
      "n": MAX_SAMPLES,
      "CUBEUV_TEXEL_WIDTH": 1 / width,
      "CUBEUV_TEXEL_HEIGHT": 1 / height,
      "CUBEUV_MAX_MIP": `${lodMax}.0`
    },
    uniforms: {
      "envMap": { value: null },
      "samples": { value: 1 },
      "weights": { value: weights },
      "latitudinal": { value: false },
      "dTheta": { value: 0 },
      "mipInt": { value: 0 },
      "poleAxis": { value: poleAxis }
    },
    vertexShader: _getCommonVertexShader(),
    fragmentShader: (
      /* glsl */
      `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`
    ),
    blending: NoBlending,
    depthTest: false,
    depthWrite: false
  });
  return shaderMaterial;
}
function _getEquirectMaterial() {
  return new ShaderMaterial({
    name: "EquirectangularToCubeUV",
    uniforms: {
      "envMap": { value: null }
    },
    vertexShader: _getCommonVertexShader(),
    fragmentShader: (
      /* glsl */
      `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`
    ),
    blending: NoBlending,
    depthTest: false,
    depthWrite: false
  });
}
function _getCubemapMaterial() {
  return new ShaderMaterial({
    name: "CubemapToCubeUV",
    uniforms: {
      "envMap": { value: null },
      "flipEnvMap": { value: -1 }
    },
    vertexShader: _getCommonVertexShader(),
    fragmentShader: (
      /* glsl */
      `

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`
    ),
    blending: NoBlending,
    depthTest: false,
    depthWrite: false
  });
}
function _getCommonVertexShader() {
  return (
    /* glsl */
    `

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`
  );
}
function WebGLCubeUVMaps(renderer) {
  let cubeUVmaps = /* @__PURE__ */ new WeakMap();
  let pmremGenerator = null;
  function get(texture) {
    if (texture && texture.isTexture) {
      const mapping = texture.mapping;
      const isEquirectMap = mapping === EquirectangularReflectionMapping || mapping === EquirectangularRefractionMapping;
      const isCubeMap = mapping === CubeReflectionMapping || mapping === CubeRefractionMapping;
      if (isEquirectMap || isCubeMap) {
        let renderTarget = cubeUVmaps.get(texture);
        const currentPMREMVersion = renderTarget !== void 0 ? renderTarget.texture.pmremVersion : 0;
        if (texture.isRenderTargetTexture && texture.pmremVersion !== currentPMREMVersion) {
          if (pmremGenerator === null) pmremGenerator = new PMREMGenerator(renderer);
          renderTarget = isEquirectMap ? pmremGenerator.fromEquirectangular(texture, renderTarget) : pmremGenerator.fromCubemap(texture, renderTarget);
          renderTarget.texture.pmremVersion = texture.pmremVersion;
          cubeUVmaps.set(texture, renderTarget);
          return renderTarget.texture;
        } else {
          if (renderTarget !== void 0) {
            return renderTarget.texture;
          } else {
            const image = texture.image;
            if (isEquirectMap && image && image.height > 0 || isCubeMap && image && isCubeTextureComplete(image)) {
              if (pmremGenerator === null) pmremGenerator = new PMREMGenerator(renderer);
              renderTarget = isEquirectMap ? pmremGenerator.fromEquirectangular(texture) : pmremGenerator.fromCubemap(texture);
              renderTarget.texture.pmremVersion = texture.pmremVersion;
              cubeUVmaps.set(texture, renderTarget);
              texture.addEventListener("dispose", onTextureDispose);
              return renderTarget.texture;
            } else {
              return null;
            }
          }
        }
      }
    }
    return texture;
  }
  function isCubeTextureComplete(image) {
    let count = 0;
    const length = 6;
    for (let i2 = 0; i2 < length; i2++) {
      if (image[i2] !== void 0) count++;
    }
    return count === length;
  }
  function onTextureDispose(event) {
    const texture = event.target;
    texture.removeEventListener("dispose", onTextureDispose);
    const cubemapUV = cubeUVmaps.get(texture);
    if (cubemapUV !== void 0) {
      cubeUVmaps.delete(texture);
      cubemapUV.dispose();
    }
  }
  function dispose2() {
    cubeUVmaps = /* @__PURE__ */ new WeakMap();
    if (pmremGenerator !== null) {
      pmremGenerator.dispose();
      pmremGenerator = null;
    }
  }
  return {
    get,
    dispose: dispose2
  };
}
function WebGLExtensions(gl) {
  const extensions = {};
  function getExtension(name) {
    if (extensions[name] !== void 0) {
      return extensions[name];
    }
    let extension;
    switch (name) {
      case "WEBGL_depth_texture":
        extension = gl.getExtension("WEBGL_depth_texture") || gl.getExtension("MOZ_WEBGL_depth_texture") || gl.getExtension("WEBKIT_WEBGL_depth_texture");
        break;
      case "EXT_texture_filter_anisotropic":
        extension = gl.getExtension("EXT_texture_filter_anisotropic") || gl.getExtension("MOZ_EXT_texture_filter_anisotropic") || gl.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
        break;
      case "WEBGL_compressed_texture_s3tc":
        extension = gl.getExtension("WEBGL_compressed_texture_s3tc") || gl.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || gl.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
        break;
      case "WEBGL_compressed_texture_pvrtc":
        extension = gl.getExtension("WEBGL_compressed_texture_pvrtc") || gl.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
        break;
      default:
        extension = gl.getExtension(name);
    }
    extensions[name] = extension;
    return extension;
  }
  return {
    has: function(name) {
      return getExtension(name) !== null;
    },
    init: function() {
      getExtension("EXT_color_buffer_float");
      getExtension("WEBGL_clip_cull_distance");
      getExtension("OES_texture_float_linear");
      getExtension("EXT_color_buffer_half_float");
      getExtension("WEBGL_multisampled_render_to_texture");
      getExtension("WEBGL_render_shared_exponent");
    },
    get: function(name) {
      const extension = getExtension(name);
      if (extension === null) {
        warnOnce("THREE.WebGLRenderer: " + name + " extension not supported.");
      }
      return extension;
    }
  };
}
function WebGLGeometries(gl, attributes, info, bindingStates) {
  const geometries = {};
  const wireframeAttributes = /* @__PURE__ */ new WeakMap();
  function onGeometryDispose(event) {
    const geometry = event.target;
    if (geometry.index !== null) {
      attributes.remove(geometry.index);
    }
    for (const name in geometry.attributes) {
      attributes.remove(geometry.attributes[name]);
    }
    for (const name in geometry.morphAttributes) {
      const array = geometry.morphAttributes[name];
      for (let i2 = 0, l2 = array.length; i2 < l2; i2++) {
        attributes.remove(array[i2]);
      }
    }
    geometry.removeEventListener("dispose", onGeometryDispose);
    delete geometries[geometry.id];
    const attribute = wireframeAttributes.get(geometry);
    if (attribute) {
      attributes.remove(attribute);
      wireframeAttributes.delete(geometry);
    }
    bindingStates.releaseStatesOfGeometry(geometry);
    if (geometry.isInstancedBufferGeometry === true) {
      delete geometry._maxInstanceCount;
    }
    info.memory.geometries--;
  }
  function get(object, geometry) {
    if (geometries[geometry.id] === true) return geometry;
    geometry.addEventListener("dispose", onGeometryDispose);
    geometries[geometry.id] = true;
    info.memory.geometries++;
    return geometry;
  }
  function update(geometry) {
    const geometryAttributes = geometry.attributes;
    for (const name in geometryAttributes) {
      attributes.update(geometryAttributes[name], gl.ARRAY_BUFFER);
    }
    const morphAttributes = geometry.morphAttributes;
    for (const name in morphAttributes) {
      const array = morphAttributes[name];
      for (let i2 = 0, l2 = array.length; i2 < l2; i2++) {
        attributes.update(array[i2], gl.ARRAY_BUFFER);
      }
    }
  }
  function updateWireframeAttribute(geometry) {
    const indices = [];
    const geometryIndex = geometry.index;
    const geometryPosition = geometry.attributes.position;
    let version3 = 0;
    if (geometryIndex !== null) {
      const array = geometryIndex.array;
      version3 = geometryIndex.version;
      for (let i2 = 0, l2 = array.length; i2 < l2; i2 += 3) {
        const a = array[i2 + 0];
        const b = array[i2 + 1];
        const c = array[i2 + 2];
        indices.push(a, b, b, c, c, a);
      }
    } else if (geometryPosition !== void 0) {
      const array = geometryPosition.array;
      version3 = geometryPosition.version;
      for (let i2 = 0, l2 = array.length / 3 - 1; i2 < l2; i2 += 3) {
        const a = i2 + 0;
        const b = i2 + 1;
        const c = i2 + 2;
        indices.push(a, b, b, c, c, a);
      }
    } else {
      return;
    }
    const attribute = new (arrayNeedsUint32(indices) ? Uint32BufferAttribute : Uint16BufferAttribute)(indices, 1);
    attribute.version = version3;
    const previousAttribute = wireframeAttributes.get(geometry);
    if (previousAttribute) attributes.remove(previousAttribute);
    wireframeAttributes.set(geometry, attribute);
  }
  function getWireframeAttribute(geometry) {
    const currentAttribute = wireframeAttributes.get(geometry);
    if (currentAttribute) {
      const geometryIndex = geometry.index;
      if (geometryIndex !== null) {
        if (currentAttribute.version < geometryIndex.version) {
          updateWireframeAttribute(geometry);
        }
      }
    } else {
      updateWireframeAttribute(geometry);
    }
    return wireframeAttributes.get(geometry);
  }
  return {
    get,
    update,
    getWireframeAttribute
  };
}
function WebGLIndexedBufferRenderer(gl, extensions, info) {
  let mode;
  function setMode(value) {
    mode = value;
  }
  let type, bytesPerElement;
  function setIndex(value) {
    type = value.type;
    bytesPerElement = value.bytesPerElement;
  }
  function render(start, count) {
    gl.drawElements(mode, count, type, start * bytesPerElement);
    info.update(count, mode, 1);
  }
  function renderInstances(start, count, primcount) {
    if (primcount === 0) return;
    gl.drawElementsInstanced(mode, count, type, start * bytesPerElement, primcount);
    info.update(count, mode, primcount);
  }
  function renderMultiDraw(starts, counts, drawCount) {
    if (drawCount === 0) return;
    const extension = extensions.get("WEBGL_multi_draw");
    extension.multiDrawElementsWEBGL(mode, counts, 0, type, starts, 0, drawCount);
    let elementCount = 0;
    for (let i2 = 0; i2 < drawCount; i2++) {
      elementCount += counts[i2];
    }
    info.update(elementCount, mode, 1);
  }
  function renderMultiDrawInstances(starts, counts, drawCount, primcount) {
    if (drawCount === 0) return;
    const extension = extensions.get("WEBGL_multi_draw");
    if (extension === null) {
      for (let i2 = 0; i2 < starts.length; i2++) {
        renderInstances(starts[i2] / bytesPerElement, counts[i2], primcount[i2]);
      }
    } else {
      extension.multiDrawElementsInstancedWEBGL(mode, counts, 0, type, starts, 0, primcount, 0, drawCount);
      let elementCount = 0;
      for (let i2 = 0; i2 < drawCount; i2++) {
        elementCount += counts[i2];
      }
      for (let i2 = 0; i2 < primcount.length; i2++) {
        info.update(elementCount, mode, primcount[i2]);
      }
    }
  }
  this.setMode = setMode;
  this.setIndex = setIndex;
  this.render = render;
  this.renderInstances = renderInstances;
  this.renderMultiDraw = renderMultiDraw;
  this.renderMultiDrawInstances = renderMultiDrawInstances;
}
function WebGLInfo(gl) {
  const memory = {
    geometries: 0,
    textures: 0
  };
  const render = {
    frame: 0,
    calls: 0,
    triangles: 0,
    points: 0,
    lines: 0
  };
  function update(count, mode, instanceCount) {
    render.calls++;
    switch (mode) {
      case gl.TRIANGLES:
        render.triangles += instanceCount * (count / 3);
        break;
      case gl.LINES:
        render.lines += instanceCount * (count / 2);
        break;
      case gl.LINE_STRIP:
        render.lines += instanceCount * (count - 1);
        break;
      case gl.LINE_LOOP:
        render.lines += instanceCount * count;
        break;
      case gl.POINTS:
        render.points += instanceCount * count;
        break;
      default:
        console.error("THREE.WebGLInfo: Unknown draw mode:", mode);
        break;
    }
  }
  function reset() {
    render.calls = 0;
    render.triangles = 0;
    render.points = 0;
    render.lines = 0;
  }
  return {
    memory,
    render,
    programs: null,
    autoReset: true,
    reset,
    update
  };
}
function WebGLMorphtargets(gl, capabilities, textures) {
  const morphTextures = /* @__PURE__ */ new WeakMap();
  const morph = new Vector4();
  function update(object, geometry, program) {
    const objectInfluences = object.morphTargetInfluences;
    const morphAttribute = geometry.morphAttributes.position || geometry.morphAttributes.normal || geometry.morphAttributes.color;
    const morphTargetsCount = morphAttribute !== void 0 ? morphAttribute.length : 0;
    let entry = morphTextures.get(geometry);
    if (entry === void 0 || entry.count !== morphTargetsCount) {
      let disposeTexture = function() {
        texture.dispose();
        morphTextures.delete(geometry);
        geometry.removeEventListener("dispose", disposeTexture);
      };
      if (entry !== void 0) entry.texture.dispose();
      const hasMorphPosition = geometry.morphAttributes.position !== void 0;
      const hasMorphNormals = geometry.morphAttributes.normal !== void 0;
      const hasMorphColors = geometry.morphAttributes.color !== void 0;
      const morphTargets = geometry.morphAttributes.position || [];
      const morphNormals = geometry.morphAttributes.normal || [];
      const morphColors = geometry.morphAttributes.color || [];
      let vertexDataCount = 0;
      if (hasMorphPosition === true) vertexDataCount = 1;
      if (hasMorphNormals === true) vertexDataCount = 2;
      if (hasMorphColors === true) vertexDataCount = 3;
      let width = geometry.attributes.position.count * vertexDataCount;
      let height = 1;
      if (width > capabilities.maxTextureSize) {
        height = Math.ceil(width / capabilities.maxTextureSize);
        width = capabilities.maxTextureSize;
      }
      const buffer = new Float32Array(width * height * 4 * morphTargetsCount);
      const texture = new DataArrayTexture(buffer, width, height, morphTargetsCount);
      texture.type = FloatType;
      texture.needsUpdate = true;
      const vertexDataStride = vertexDataCount * 4;
      for (let i2 = 0; i2 < morphTargetsCount; i2++) {
        const morphTarget = morphTargets[i2];
        const morphNormal = morphNormals[i2];
        const morphColor = morphColors[i2];
        const offset = width * height * 4 * i2;
        for (let j2 = 0; j2 < morphTarget.count; j2++) {
          const stride = j2 * vertexDataStride;
          if (hasMorphPosition === true) {
            morph.fromBufferAttribute(morphTarget, j2);
            buffer[offset + stride + 0] = morph.x;
            buffer[offset + stride + 1] = morph.y;
            buffer[offset + stride + 2] = morph.z;
            buffer[offset + stride + 3] = 0;
          }
          if (hasMorphNormals === true) {
            morph.fromBufferAttribute(morphNormal, j2);
            buffer[offset + stride + 4] = morph.x;
            buffer[offset + stride + 5] = morph.y;
            buffer[offset + stride + 6] = morph.z;
            buffer[offset + stride + 7] = 0;
          }
          if (hasMorphColors === true) {
            morph.fromBufferAttribute(morphColor, j2);
            buffer[offset + stride + 8] = morph.x;
            buffer[offset + stride + 9] = morph.y;
            buffer[offset + stride + 10] = morph.z;
            buffer[offset + stride + 11] = morphColor.itemSize === 4 ? morph.w : 1;
          }
        }
      }
      entry = {
        count: morphTargetsCount,
        texture,
        size: new Vector2(width, height)
      };
      morphTextures.set(geometry, entry);
      geometry.addEventListener("dispose", disposeTexture);
    }
    if (object.isInstancedMesh === true && object.morphTexture !== null) {
      program.getUniforms().setValue(gl, "morphTexture", object.morphTexture, textures);
    } else {
      let morphInfluencesSum = 0;
      for (let i2 = 0; i2 < objectInfluences.length; i2++) {
        morphInfluencesSum += objectInfluences[i2];
      }
      const morphBaseInfluence = geometry.morphTargetsRelative ? 1 : 1 - morphInfluencesSum;
      program.getUniforms().setValue(gl, "morphTargetBaseInfluence", morphBaseInfluence);
      program.getUniforms().setValue(gl, "morphTargetInfluences", objectInfluences);
    }
    program.getUniforms().setValue(gl, "morphTargetsTexture", entry.texture, textures);
    program.getUniforms().setValue(gl, "morphTargetsTextureSize", entry.size);
  }
  return {
    update
  };
}
function WebGLObjects(gl, geometries, attributes, info) {
  let updateMap = /* @__PURE__ */ new WeakMap();
  function update(object) {
    const frame = info.render.frame;
    const geometry = object.geometry;
    const buffergeometry = geometries.get(object, geometry);
    if (updateMap.get(buffergeometry) !== frame) {
      geometries.update(buffergeometry);
      updateMap.set(buffergeometry, frame);
    }
    if (object.isInstancedMesh) {
      if (object.hasEventListener("dispose", onInstancedMeshDispose) === false) {
        object.addEventListener("dispose", onInstancedMeshDispose);
      }
      if (updateMap.get(object) !== frame) {
        attributes.update(object.instanceMatrix, gl.ARRAY_BUFFER);
        if (object.instanceColor !== null) {
          attributes.update(object.instanceColor, gl.ARRAY_BUFFER);
        }
        updateMap.set(object, frame);
      }
    }
    if (object.isSkinnedMesh) {
      const skeleton = object.skeleton;
      if (updateMap.get(skeleton) !== frame) {
        skeleton.update();
        updateMap.set(skeleton, frame);
      }
    }
    return buffergeometry;
  }
  function dispose2() {
    updateMap = /* @__PURE__ */ new WeakMap();
  }
  function onInstancedMeshDispose(event) {
    const instancedMesh = event.target;
    instancedMesh.removeEventListener("dispose", onInstancedMeshDispose);
    attributes.remove(instancedMesh.instanceMatrix);
    if (instancedMesh.instanceColor !== null) attributes.remove(instancedMesh.instanceColor);
  }
  return {
    update,
    dispose: dispose2
  };
}
function flatten(array, nBlocks, blockSize) {
  const firstElem = array[0];
  if (firstElem <= 0 || firstElem > 0) return array;
  const n = nBlocks * blockSize;
  let r2 = arrayCacheF32[n];
  if (r2 === void 0) {
    r2 = new Float32Array(n);
    arrayCacheF32[n] = r2;
  }
  if (nBlocks !== 0) {
    firstElem.toArray(r2, 0);
    for (let i2 = 1, offset = 0; i2 !== nBlocks; ++i2) {
      offset += blockSize;
      array[i2].toArray(r2, offset);
    }
  }
  return r2;
}
function arraysEqual(a, b) {
  if (a.length !== b.length) return false;
  for (let i2 = 0, l2 = a.length; i2 < l2; i2++) {
    if (a[i2] !== b[i2]) return false;
  }
  return true;
}
function copyArray(a, b) {
  for (let i2 = 0, l2 = b.length; i2 < l2; i2++) {
    a[i2] = b[i2];
  }
}
function allocTexUnits(textures, n) {
  let r2 = arrayCacheI32[n];
  if (r2 === void 0) {
    r2 = new Int32Array(n);
    arrayCacheI32[n] = r2;
  }
  for (let i2 = 0; i2 !== n; ++i2) {
    r2[i2] = textures.allocateTextureUnit();
  }
  return r2;
}
function setValueV1f(gl, v2) {
  const cache = this.cache;
  if (cache[0] === v2) return;
  gl.uniform1f(this.addr, v2);
  cache[0] = v2;
}
function setValueV2f(gl, v2) {
  const cache = this.cache;
  if (v2.x !== void 0) {
    if (cache[0] !== v2.x || cache[1] !== v2.y) {
      gl.uniform2f(this.addr, v2.x, v2.y);
      cache[0] = v2.x;
      cache[1] = v2.y;
    }
  } else {
    if (arraysEqual(cache, v2)) return;
    gl.uniform2fv(this.addr, v2);
    copyArray(cache, v2);
  }
}
function setValueV3f(gl, v2) {
  const cache = this.cache;
  if (v2.x !== void 0) {
    if (cache[0] !== v2.x || cache[1] !== v2.y || cache[2] !== v2.z) {
      gl.uniform3f(this.addr, v2.x, v2.y, v2.z);
      cache[0] = v2.x;
      cache[1] = v2.y;
      cache[2] = v2.z;
    }
  } else if (v2.r !== void 0) {
    if (cache[0] !== v2.r || cache[1] !== v2.g || cache[2] !== v2.b) {
      gl.uniform3f(this.addr, v2.r, v2.g, v2.b);
      cache[0] = v2.r;
      cache[1] = v2.g;
      cache[2] = v2.b;
    }
  } else {
    if (arraysEqual(cache, v2)) return;
    gl.uniform3fv(this.addr, v2);
    copyArray(cache, v2);
  }
}
function setValueV4f(gl, v2) {
  const cache = this.cache;
  if (v2.x !== void 0) {
    if (cache[0] !== v2.x || cache[1] !== v2.y || cache[2] !== v2.z || cache[3] !== v2.w) {
      gl.uniform4f(this.addr, v2.x, v2.y, v2.z, v2.w);
      cache[0] = v2.x;
      cache[1] = v2.y;
      cache[2] = v2.z;
      cache[3] = v2.w;
    }
  } else {
    if (arraysEqual(cache, v2)) return;
    gl.uniform4fv(this.addr, v2);
    copyArray(cache, v2);
  }
}
function setValueM2(gl, v2) {
  const cache = this.cache;
  const elements = v2.elements;
  if (elements === void 0) {
    if (arraysEqual(cache, v2)) return;
    gl.uniformMatrix2fv(this.addr, false, v2);
    copyArray(cache, v2);
  } else {
    if (arraysEqual(cache, elements)) return;
    mat2array.set(elements);
    gl.uniformMatrix2fv(this.addr, false, mat2array);
    copyArray(cache, elements);
  }
}
function setValueM3(gl, v2) {
  const cache = this.cache;
  const elements = v2.elements;
  if (elements === void 0) {
    if (arraysEqual(cache, v2)) return;
    gl.uniformMatrix3fv(this.addr, false, v2);
    copyArray(cache, v2);
  } else {
    if (arraysEqual(cache, elements)) return;
    mat3array.set(elements);
    gl.uniformMatrix3fv(this.addr, false, mat3array);
    copyArray(cache, elements);
  }
}
function setValueM4(gl, v2) {
  const cache = this.cache;
  const elements = v2.elements;
  if (elements === void 0) {
    if (arraysEqual(cache, v2)) return;
    gl.uniformMatrix4fv(this.addr, false, v2);
    copyArray(cache, v2);
  } else {
    if (arraysEqual(cache, elements)) return;
    mat4array.set(elements);
    gl.uniformMatrix4fv(this.addr, false, mat4array);
    copyArray(cache, elements);
  }
}
function setValueV1i(gl, v2) {
  const cache = this.cache;
  if (cache[0] === v2) return;
  gl.uniform1i(this.addr, v2);
  cache[0] = v2;
}
function setValueV2i(gl, v2) {
  const cache = this.cache;
  if (v2.x !== void 0) {
    if (cache[0] !== v2.x || cache[1] !== v2.y) {
      gl.uniform2i(this.addr, v2.x, v2.y);
      cache[0] = v2.x;
      cache[1] = v2.y;
    }
  } else {
    if (arraysEqual(cache, v2)) return;
    gl.uniform2iv(this.addr, v2);
    copyArray(cache, v2);
  }
}
function setValueV3i(gl, v2) {
  const cache = this.cache;
  if (v2.x !== void 0) {
    if (cache[0] !== v2.x || cache[1] !== v2.y || cache[2] !== v2.z) {
      gl.uniform3i(this.addr, v2.x, v2.y, v2.z);
      cache[0] = v2.x;
      cache[1] = v2.y;
      cache[2] = v2.z;
    }
  } else {
    if (arraysEqual(cache, v2)) return;
    gl.uniform3iv(this.addr, v2);
    copyArray(cache, v2);
  }
}
function setValueV4i(gl, v2) {
  const cache = this.cache;
  if (v2.x !== void 0) {
    if (cache[0] !== v2.x || cache[1] !== v2.y || cache[2] !== v2.z || cache[3] !== v2.w) {
      gl.uniform4i(this.addr, v2.x, v2.y, v2.z, v2.w);
      cache[0] = v2.x;
      cache[1] = v2.y;
      cache[2] = v2.z;
      cache[3] = v2.w;
    }
  } else {
    if (arraysEqual(cache, v2)) return;
    gl.uniform4iv(this.addr, v2);
    copyArray(cache, v2);
  }
}
function setValueV1ui(gl, v2) {
  const cache = this.cache;
  if (cache[0] === v2) return;
  gl.uniform1ui(this.addr, v2);
  cache[0] = v2;
}
function setValueV2ui(gl, v2) {
  const cache = this.cache;
  if (v2.x !== void 0) {
    if (cache[0] !== v2.x || cache[1] !== v2.y) {
      gl.uniform2ui(this.addr, v2.x, v2.y);
      cache[0] = v2.x;
      cache[1] = v2.y;
    }
  } else {
    if (arraysEqual(cache, v2)) return;
    gl.uniform2uiv(this.addr, v2);
    copyArray(cache, v2);
  }
}
function setValueV3ui(gl, v2) {
  const cache = this.cache;
  if (v2.x !== void 0) {
    if (cache[0] !== v2.x || cache[1] !== v2.y || cache[2] !== v2.z) {
      gl.uniform3ui(this.addr, v2.x, v2.y, v2.z);
      cache[0] = v2.x;
      cache[1] = v2.y;
      cache[2] = v2.z;
    }
  } else {
    if (arraysEqual(cache, v2)) return;
    gl.uniform3uiv(this.addr, v2);
    copyArray(cache, v2);
  }
}
function setValueV4ui(gl, v2) {
  const cache = this.cache;
  if (v2.x !== void 0) {
    if (cache[0] !== v2.x || cache[1] !== v2.y || cache[2] !== v2.z || cache[3] !== v2.w) {
      gl.uniform4ui(this.addr, v2.x, v2.y, v2.z, v2.w);
      cache[0] = v2.x;
      cache[1] = v2.y;
      cache[2] = v2.z;
      cache[3] = v2.w;
    }
  } else {
    if (arraysEqual(cache, v2)) return;
    gl.uniform4uiv(this.addr, v2);
    copyArray(cache, v2);
  }
}
function setValueT1(gl, v2, textures) {
  const cache = this.cache;
  const unit = textures.allocateTextureUnit();
  if (cache[0] !== unit) {
    gl.uniform1i(this.addr, unit);
    cache[0] = unit;
  }
  let emptyTexture2D;
  if (this.type === gl.SAMPLER_2D_SHADOW) {
    emptyShadowTexture.compareFunction = LessEqualCompare;
    emptyTexture2D = emptyShadowTexture;
  } else {
    emptyTexture2D = emptyTexture;
  }
  textures.setTexture2D(v2 || emptyTexture2D, unit);
}
function setValueT3D1(gl, v2, textures) {
  const cache = this.cache;
  const unit = textures.allocateTextureUnit();
  if (cache[0] !== unit) {
    gl.uniform1i(this.addr, unit);
    cache[0] = unit;
  }
  textures.setTexture3D(v2 || empty3dTexture, unit);
}
function setValueT6(gl, v2, textures) {
  const cache = this.cache;
  const unit = textures.allocateTextureUnit();
  if (cache[0] !== unit) {
    gl.uniform1i(this.addr, unit);
    cache[0] = unit;
  }
  textures.setTextureCube(v2 || emptyCubeTexture, unit);
}
function setValueT2DArray1(gl, v2, textures) {
  const cache = this.cache;
  const unit = textures.allocateTextureUnit();
  if (cache[0] !== unit) {
    gl.uniform1i(this.addr, unit);
    cache[0] = unit;
  }
  textures.setTexture2DArray(v2 || emptyArrayTexture, unit);
}
function getSingularSetter(type) {
  switch (type) {
    case 5126:
      return setValueV1f;
    // FLOAT
    case 35664:
      return setValueV2f;
    // _VEC2
    case 35665:
      return setValueV3f;
    // _VEC3
    case 35666:
      return setValueV4f;
    // _VEC4
    case 35674:
      return setValueM2;
    // _MAT2
    case 35675:
      return setValueM3;
    // _MAT3
    case 35676:
      return setValueM4;
    // _MAT4
    case 5124:
    case 35670:
      return setValueV1i;
    // INT, BOOL
    case 35667:
    case 35671:
      return setValueV2i;
    // _VEC2
    case 35668:
    case 35672:
      return setValueV3i;
    // _VEC3
    case 35669:
    case 35673:
      return setValueV4i;
    // _VEC4
    case 5125:
      return setValueV1ui;
    // UINT
    case 36294:
      return setValueV2ui;
    // _VEC2
    case 36295:
      return setValueV3ui;
    // _VEC3
    case 36296:
      return setValueV4ui;
    // _VEC4
    case 35678:
    // SAMPLER_2D
    case 36198:
    // SAMPLER_EXTERNAL_OES
    case 36298:
    // INT_SAMPLER_2D
    case 36306:
    // UNSIGNED_INT_SAMPLER_2D
    case 35682:
      return setValueT1;
    case 35679:
    // SAMPLER_3D
    case 36299:
    // INT_SAMPLER_3D
    case 36307:
      return setValueT3D1;
    case 35680:
    // SAMPLER_CUBE
    case 36300:
    // INT_SAMPLER_CUBE
    case 36308:
    // UNSIGNED_INT_SAMPLER_CUBE
    case 36293:
      return setValueT6;
    case 36289:
    // SAMPLER_2D_ARRAY
    case 36303:
    // INT_SAMPLER_2D_ARRAY
    case 36311:
    // UNSIGNED_INT_SAMPLER_2D_ARRAY
    case 36292:
      return setValueT2DArray1;
  }
}
function setValueV1fArray(gl, v2) {
  gl.uniform1fv(this.addr, v2);
}
function setValueV2fArray(gl, v2) {
  const data = flatten(v2, this.size, 2);
  gl.uniform2fv(this.addr, data);
}
function setValueV3fArray(gl, v2) {
  const data = flatten(v2, this.size, 3);
  gl.uniform3fv(this.addr, data);
}
function setValueV4fArray(gl, v2) {
  const data = flatten(v2, this.size, 4);
  gl.uniform4fv(this.addr, data);
}
function setValueM2Array(gl, v2) {
  const data = flatten(v2, this.size, 4);
  gl.uniformMatrix2fv(this.addr, false, data);
}
function setValueM3Array(gl, v2) {
  const data = flatten(v2, this.size, 9);
  gl.uniformMatrix3fv(this.addr, false, data);
}
function setValueM4Array(gl, v2) {
  const data = flatten(v2, this.size, 16);
  gl.uniformMatrix4fv(this.addr, false, data);
}
function setValueV1iArray(gl, v2) {
  gl.uniform1iv(this.addr, v2);
}
function setValueV2iArray(gl, v2) {
  gl.uniform2iv(this.addr, v2);
}
function setValueV3iArray(gl, v2) {
  gl.uniform3iv(this.addr, v2);
}
function setValueV4iArray(gl, v2) {
  gl.uniform4iv(this.addr, v2);
}
function setValueV1uiArray(gl, v2) {
  gl.uniform1uiv(this.addr, v2);
}
function setValueV2uiArray(gl, v2) {
  gl.uniform2uiv(this.addr, v2);
}
function setValueV3uiArray(gl, v2) {
  gl.uniform3uiv(this.addr, v2);
}
function setValueV4uiArray(gl, v2) {
  gl.uniform4uiv(this.addr, v2);
}
function setValueT1Array(gl, v2, textures) {
  const cache = this.cache;
  const n = v2.length;
  const units = allocTexUnits(textures, n);
  if (!arraysEqual(cache, units)) {
    gl.uniform1iv(this.addr, units);
    copyArray(cache, units);
  }
  for (let i2 = 0; i2 !== n; ++i2) {
    textures.setTexture2D(v2[i2] || emptyTexture, units[i2]);
  }
}
function setValueT3DArray(gl, v2, textures) {
  const cache = this.cache;
  const n = v2.length;
  const units = allocTexUnits(textures, n);
  if (!arraysEqual(cache, units)) {
    gl.uniform1iv(this.addr, units);
    copyArray(cache, units);
  }
  for (let i2 = 0; i2 !== n; ++i2) {
    textures.setTexture3D(v2[i2] || empty3dTexture, units[i2]);
  }
}
function setValueT6Array(gl, v2, textures) {
  const cache = this.cache;
  const n = v2.length;
  const units = allocTexUnits(textures, n);
  if (!arraysEqual(cache, units)) {
    gl.uniform1iv(this.addr, units);
    copyArray(cache, units);
  }
  for (let i2 = 0; i2 !== n; ++i2) {
    textures.setTextureCube(v2[i2] || emptyCubeTexture, units[i2]);
  }
}
function setValueT2DArrayArray(gl, v2, textures) {
  const cache = this.cache;
  const n = v2.length;
  const units = allocTexUnits(textures, n);
  if (!arraysEqual(cache, units)) {
    gl.uniform1iv(this.addr, units);
    copyArray(cache, units);
  }
  for (let i2 = 0; i2 !== n; ++i2) {
    textures.setTexture2DArray(v2[i2] || emptyArrayTexture, units[i2]);
  }
}
function getPureArraySetter(type) {
  switch (type) {
    case 5126:
      return setValueV1fArray;
    // FLOAT
    case 35664:
      return setValueV2fArray;
    // _VEC2
    case 35665:
      return setValueV3fArray;
    // _VEC3
    case 35666:
      return setValueV4fArray;
    // _VEC4
    case 35674:
      return setValueM2Array;
    // _MAT2
    case 35675:
      return setValueM3Array;
    // _MAT3
    case 35676:
      return setValueM4Array;
    // _MAT4
    case 5124:
    case 35670:
      return setValueV1iArray;
    // INT, BOOL
    case 35667:
    case 35671:
      return setValueV2iArray;
    // _VEC2
    case 35668:
    case 35672:
      return setValueV3iArray;
    // _VEC3
    case 35669:
    case 35673:
      return setValueV4iArray;
    // _VEC4
    case 5125:
      return setValueV1uiArray;
    // UINT
    case 36294:
      return setValueV2uiArray;
    // _VEC2
    case 36295:
      return setValueV3uiArray;
    // _VEC3
    case 36296:
      return setValueV4uiArray;
    // _VEC4
    case 35678:
    // SAMPLER_2D
    case 36198:
    // SAMPLER_EXTERNAL_OES
    case 36298:
    // INT_SAMPLER_2D
    case 36306:
    // UNSIGNED_INT_SAMPLER_2D
    case 35682:
      return setValueT1Array;
    case 35679:
    // SAMPLER_3D
    case 36299:
    // INT_SAMPLER_3D
    case 36307:
      return setValueT3DArray;
    case 35680:
    // SAMPLER_CUBE
    case 36300:
    // INT_SAMPLER_CUBE
    case 36308:
    // UNSIGNED_INT_SAMPLER_CUBE
    case 36293:
      return setValueT6Array;
    case 36289:
    // SAMPLER_2D_ARRAY
    case 36303:
    // INT_SAMPLER_2D_ARRAY
    case 36311:
    // UNSIGNED_INT_SAMPLER_2D_ARRAY
    case 36292:
      return setValueT2DArrayArray;
  }
}
function addUniform(container, uniformObject) {
  container.seq.push(uniformObject);
  container.map[uniformObject.id] = uniformObject;
}
function parseUniform(activeInfo, addr, container) {
  const path = activeInfo.name, pathLength = path.length;
  RePathPart.lastIndex = 0;
  while (true) {
    const match = RePathPart.exec(path), matchEnd = RePathPart.lastIndex;
    let id = match[1];
    const idIsIndex = match[2] === "]", subscript = match[3];
    if (idIsIndex) id = id | 0;
    if (subscript === void 0 || subscript === "[" && matchEnd + 2 === pathLength) {
      addUniform(container, subscript === void 0 ? new SingleUniform(id, activeInfo, addr) : new PureArrayUniform(id, activeInfo, addr));
      break;
    } else {
      const map = container.map;
      let next = map[id];
      if (next === void 0) {
        next = new StructuredUniform(id);
        addUniform(container, next);
      }
      container = next;
    }
  }
}
function WebGLShader(gl, type, string) {
  const shader = gl.createShader(type);
  gl.shaderSource(shader, string);
  gl.compileShader(shader);
  return shader;
}
function handleSource(string, errorLine) {
  const lines = string.split("\n");
  const lines2 = [];
  const from = Math.max(errorLine - 6, 0);
  const to = Math.min(errorLine + 6, lines.length);
  for (let i2 = from; i2 < to; i2++) {
    const line = i2 + 1;
    lines2.push(`${line === errorLine ? ">" : " "} ${line}: ${lines[i2]}`);
  }
  return lines2.join("\n");
}
function getEncodingComponents(colorSpace) {
  const workingPrimaries = ColorManagement.getPrimaries(ColorManagement.workingColorSpace);
  const encodingPrimaries = ColorManagement.getPrimaries(colorSpace);
  let gamutMapping;
  if (workingPrimaries === encodingPrimaries) {
    gamutMapping = "";
  } else if (workingPrimaries === P3Primaries && encodingPrimaries === Rec709Primaries) {
    gamutMapping = "LinearDisplayP3ToLinearSRGB";
  } else if (workingPrimaries === Rec709Primaries && encodingPrimaries === P3Primaries) {
    gamutMapping = "LinearSRGBToLinearDisplayP3";
  }
  switch (colorSpace) {
    case LinearSRGBColorSpace:
    case LinearDisplayP3ColorSpace:
      return [gamutMapping, "LinearTransferOETF"];
    case SRGBColorSpace:
    case DisplayP3ColorSpace:
      return [gamutMapping, "sRGBTransferOETF"];
    default:
      console.warn("THREE.WebGLProgram: Unsupported color space:", colorSpace);
      return [gamutMapping, "LinearTransferOETF"];
  }
}
function getShaderErrors(gl, shader, type) {
  const status = gl.getShaderParameter(shader, gl.COMPILE_STATUS);
  const errors = gl.getShaderInfoLog(shader).trim();
  if (status && errors === "") return "";
  const errorMatches = /ERROR: 0:(\d+)/.exec(errors);
  if (errorMatches) {
    const errorLine = parseInt(errorMatches[1]);
    return type.toUpperCase() + "\n\n" + errors + "\n\n" + handleSource(gl.getShaderSource(shader), errorLine);
  } else {
    return errors;
  }
}
function getTexelEncodingFunction(functionName, colorSpace) {
  const components = getEncodingComponents(colorSpace);
  return `vec4 ${functionName}( vec4 value ) { return ${components[0]}( ${components[1]}( value ) ); }`;
}
function getToneMappingFunction(functionName, toneMapping) {
  let toneMappingName;
  switch (toneMapping) {
    case LinearToneMapping:
      toneMappingName = "Linear";
      break;
    case ReinhardToneMapping:
      toneMappingName = "Reinhard";
      break;
    case CineonToneMapping:
      toneMappingName = "Cineon";
      break;
    case ACESFilmicToneMapping:
      toneMappingName = "ACESFilmic";
      break;
    case AgXToneMapping:
      toneMappingName = "AgX";
      break;
    case NeutralToneMapping:
      toneMappingName = "Neutral";
      break;
    case CustomToneMapping:
      toneMappingName = "Custom";
      break;
    default:
      console.warn("THREE.WebGLProgram: Unsupported toneMapping:", toneMapping);
      toneMappingName = "Linear";
  }
  return "vec3 " + functionName + "( vec3 color ) { return " + toneMappingName + "ToneMapping( color ); }";
}
function getLuminanceFunction() {
  ColorManagement.getLuminanceCoefficients(_v0$1);
  const r2 = _v0$1.x.toFixed(4);
  const g3 = _v0$1.y.toFixed(4);
  const b = _v0$1.z.toFixed(4);
  return [
    "float luminance( const in vec3 rgb ) {",
    `	const vec3 weights = vec3( ${r2}, ${g3}, ${b} );`,
    "	return dot( weights, rgb );",
    "}"
  ].join("\n");
}
function generateVertexExtensions(parameters) {
  const chunks = [
    parameters.extensionClipCullDistance ? "#extension GL_ANGLE_clip_cull_distance : require" : "",
    parameters.extensionMultiDraw ? "#extension GL_ANGLE_multi_draw : require" : ""
  ];
  return chunks.filter(filterEmptyLine).join("\n");
}
function generateDefines(defines) {
  const chunks = [];
  for (const name in defines) {
    const value = defines[name];
    if (value === false) continue;
    chunks.push("#define " + name + " " + value);
  }
  return chunks.join("\n");
}
function fetchAttributeLocations(gl, program) {
  const attributes = {};
  const n = gl.getProgramParameter(program, gl.ACTIVE_ATTRIBUTES);
  for (let i2 = 0; i2 < n; i2++) {
    const info = gl.getActiveAttrib(program, i2);
    const name = info.name;
    let locationSize = 1;
    if (info.type === gl.FLOAT_MAT2) locationSize = 2;
    if (info.type === gl.FLOAT_MAT3) locationSize = 3;
    if (info.type === gl.FLOAT_MAT4) locationSize = 4;
    attributes[name] = {
      type: info.type,
      location: gl.getAttribLocation(program, name),
      locationSize
    };
  }
  return attributes;
}
function filterEmptyLine(string) {
  return string !== "";
}
function replaceLightNums(string, parameters) {
  const numSpotLightCoords = parameters.numSpotLightShadows + parameters.numSpotLightMaps - parameters.numSpotLightShadowsWithMaps;
  return string.replace(/NUM_DIR_LIGHTS/g, parameters.numDirLights).replace(/NUM_SPOT_LIGHTS/g, parameters.numSpotLights).replace(/NUM_SPOT_LIGHT_MAPS/g, parameters.numSpotLightMaps).replace(/NUM_SPOT_LIGHT_COORDS/g, numSpotLightCoords).replace(/NUM_RECT_AREA_LIGHTS/g, parameters.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, parameters.numPointLights).replace(/NUM_HEMI_LIGHTS/g, parameters.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, parameters.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g, parameters.numSpotLightShadowsWithMaps).replace(/NUM_SPOT_LIGHT_SHADOWS/g, parameters.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, parameters.numPointLightShadows);
}
function replaceClippingPlaneNums(string, parameters) {
  return string.replace(/NUM_CLIPPING_PLANES/g, parameters.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, parameters.numClippingPlanes - parameters.numClipIntersection);
}
function resolveIncludes(string) {
  return string.replace(includePattern, includeReplacer);
}
function includeReplacer(match, include) {
  let string = ShaderChunk[include];
  if (string === void 0) {
    const newInclude = shaderChunkMap.get(include);
    if (newInclude !== void 0) {
      string = ShaderChunk[newInclude];
      console.warn('THREE.WebGLRenderer: Shader chunk "%s" has been deprecated. Use "%s" instead.', include, newInclude);
    } else {
      throw new Error("Can not resolve #include <" + include + ">");
    }
  }
  return resolveIncludes(string);
}
function unrollLoops(string) {
  return string.replace(unrollLoopPattern, loopReplacer);
}
function loopReplacer(match, start, end, snippet) {
  let string = "";
  for (let i2 = parseInt(start); i2 < parseInt(end); i2++) {
    string += snippet.replace(/\[\s*i\s*\]/g, "[ " + i2 + " ]").replace(/UNROLLED_LOOP_INDEX/g, i2);
  }
  return string;
}
function generatePrecision(parameters) {
  let precisionstring = `precision ${parameters.precision} float;
	precision ${parameters.precision} int;
	precision ${parameters.precision} sampler2D;
	precision ${parameters.precision} samplerCube;
	precision ${parameters.precision} sampler3D;
	precision ${parameters.precision} sampler2DArray;
	precision ${parameters.precision} sampler2DShadow;
	precision ${parameters.precision} samplerCubeShadow;
	precision ${parameters.precision} sampler2DArrayShadow;
	precision ${parameters.precision} isampler2D;
	precision ${parameters.precision} isampler3D;
	precision ${parameters.precision} isamplerCube;
	precision ${parameters.precision} isampler2DArray;
	precision ${parameters.precision} usampler2D;
	precision ${parameters.precision} usampler3D;
	precision ${parameters.precision} usamplerCube;
	precision ${parameters.precision} usampler2DArray;
	`;
  if (parameters.precision === "highp") {
    precisionstring += "\n#define HIGH_PRECISION";
  } else if (parameters.precision === "mediump") {
    precisionstring += "\n#define MEDIUM_PRECISION";
  } else if (parameters.precision === "lowp") {
    precisionstring += "\n#define LOW_PRECISION";
  }
  return precisionstring;
}
function generateShadowMapTypeDefine(parameters) {
  let shadowMapTypeDefine = "SHADOWMAP_TYPE_BASIC";
  if (parameters.shadowMapType === PCFShadowMap) {
    shadowMapTypeDefine = "SHADOWMAP_TYPE_PCF";
  } else if (parameters.shadowMapType === PCFSoftShadowMap) {
    shadowMapTypeDefine = "SHADOWMAP_TYPE_PCF_SOFT";
  } else if (parameters.shadowMapType === VSMShadowMap) {
    shadowMapTypeDefine = "SHADOWMAP_TYPE_VSM";
  }
  return shadowMapTypeDefine;
}
function generateEnvMapTypeDefine(parameters) {
  let envMapTypeDefine = "ENVMAP_TYPE_CUBE";
  if (parameters.envMap) {
    switch (parameters.envMapMode) {
      case CubeReflectionMapping:
      case CubeRefractionMapping:
        envMapTypeDefine = "ENVMAP_TYPE_CUBE";
        break;
      case CubeUVReflectionMapping:
        envMapTypeDefine = "ENVMAP_TYPE_CUBE_UV";
        break;
    }
  }
  return envMapTypeDefine;
}
function generateEnvMapModeDefine(parameters) {
  let envMapModeDefine = "ENVMAP_MODE_REFLECTION";
  if (parameters.envMap) {
    switch (parameters.envMapMode) {
      case CubeRefractionMapping:
        envMapModeDefine = "ENVMAP_MODE_REFRACTION";
        break;
    }
  }
  return envMapModeDefine;
}
function generateEnvMapBlendingDefine(parameters) {
  let envMapBlendingDefine = "ENVMAP_BLENDING_NONE";
  if (parameters.envMap) {
    switch (parameters.combine) {
      case MultiplyOperation:
        envMapBlendingDefine = "ENVMAP_BLENDING_MULTIPLY";
        break;
      case MixOperation:
        envMapBlendingDefine = "ENVMAP_BLENDING_MIX";
        break;
      case AddOperation:
        envMapBlendingDefine = "ENVMAP_BLENDING_ADD";
        break;
    }
  }
  return envMapBlendingDefine;
}
function generateCubeUVSize(parameters) {
  const imageHeight = parameters.envMapCubeUVHeight;
  if (imageHeight === null) return null;
  const maxMip = Math.log2(imageHeight) - 2;
  const texelHeight = 1 / imageHeight;
  const texelWidth = 1 / (3 * Math.max(Math.pow(2, maxMip), 7 * 16));
  return { texelWidth, texelHeight, maxMip };
}
function WebGLProgram(renderer, cacheKey, parameters, bindingStates) {
  const gl = renderer.getContext();
  const defines = parameters.defines;
  let vertexShader = parameters.vertexShader;
  let fragmentShader = parameters.fragmentShader;
  const shadowMapTypeDefine = generateShadowMapTypeDefine(parameters);
  const envMapTypeDefine = generateEnvMapTypeDefine(parameters);
  const envMapModeDefine = generateEnvMapModeDefine(parameters);
  const envMapBlendingDefine = generateEnvMapBlendingDefine(parameters);
  const envMapCubeUVSize = generateCubeUVSize(parameters);
  const customVertexExtensions = generateVertexExtensions(parameters);
  const customDefines = generateDefines(defines);
  const program = gl.createProgram();
  let prefixVertex, prefixFragment;
  let versionString = parameters.glslVersion ? "#version " + parameters.glslVersion + "\n" : "";
  if (parameters.isRawShaderMaterial) {
    prefixVertex = [
      "#define SHADER_TYPE " + parameters.shaderType,
      "#define SHADER_NAME " + parameters.shaderName,
      customDefines
    ].filter(filterEmptyLine).join("\n");
    if (prefixVertex.length > 0) {
      prefixVertex += "\n";
    }
    prefixFragment = [
      "#define SHADER_TYPE " + parameters.shaderType,
      "#define SHADER_NAME " + parameters.shaderName,
      customDefines
    ].filter(filterEmptyLine).join("\n");
    if (prefixFragment.length > 0) {
      prefixFragment += "\n";
    }
  } else {
    prefixVertex = [
      generatePrecision(parameters),
      "#define SHADER_TYPE " + parameters.shaderType,
      "#define SHADER_NAME " + parameters.shaderName,
      customDefines,
      parameters.extensionClipCullDistance ? "#define USE_CLIP_DISTANCE" : "",
      parameters.batching ? "#define USE_BATCHING" : "",
      parameters.batchingColor ? "#define USE_BATCHING_COLOR" : "",
      parameters.instancing ? "#define USE_INSTANCING" : "",
      parameters.instancingColor ? "#define USE_INSTANCING_COLOR" : "",
      parameters.instancingMorph ? "#define USE_INSTANCING_MORPH" : "",
      parameters.useFog && parameters.fog ? "#define USE_FOG" : "",
      parameters.useFog && parameters.fogExp2 ? "#define FOG_EXP2" : "",
      parameters.map ? "#define USE_MAP" : "",
      parameters.envMap ? "#define USE_ENVMAP" : "",
      parameters.envMap ? "#define " + envMapModeDefine : "",
      parameters.lightMap ? "#define USE_LIGHTMAP" : "",
      parameters.aoMap ? "#define USE_AOMAP" : "",
      parameters.bumpMap ? "#define USE_BUMPMAP" : "",
      parameters.normalMap ? "#define USE_NORMALMAP" : "",
      parameters.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "",
      parameters.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "",
      parameters.displacementMap ? "#define USE_DISPLACEMENTMAP" : "",
      parameters.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
      parameters.anisotropy ? "#define USE_ANISOTROPY" : "",
      parameters.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "",
      parameters.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
      parameters.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
      parameters.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
      parameters.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
      parameters.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "",
      parameters.specularMap ? "#define USE_SPECULARMAP" : "",
      parameters.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "",
      parameters.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "",
      parameters.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
      parameters.metalnessMap ? "#define USE_METALNESSMAP" : "",
      parameters.alphaMap ? "#define USE_ALPHAMAP" : "",
      parameters.alphaHash ? "#define USE_ALPHAHASH" : "",
      parameters.transmission ? "#define USE_TRANSMISSION" : "",
      parameters.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
      parameters.thicknessMap ? "#define USE_THICKNESSMAP" : "",
      parameters.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "",
      parameters.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "",
      //
      parameters.mapUv ? "#define MAP_UV " + parameters.mapUv : "",
      parameters.alphaMapUv ? "#define ALPHAMAP_UV " + parameters.alphaMapUv : "",
      parameters.lightMapUv ? "#define LIGHTMAP_UV " + parameters.lightMapUv : "",
      parameters.aoMapUv ? "#define AOMAP_UV " + parameters.aoMapUv : "",
      parameters.emissiveMapUv ? "#define EMISSIVEMAP_UV " + parameters.emissiveMapUv : "",
      parameters.bumpMapUv ? "#define BUMPMAP_UV " + parameters.bumpMapUv : "",
      parameters.normalMapUv ? "#define NORMALMAP_UV " + parameters.normalMapUv : "",
      parameters.displacementMapUv ? "#define DISPLACEMENTMAP_UV " + parameters.displacementMapUv : "",
      parameters.metalnessMapUv ? "#define METALNESSMAP_UV " + parameters.metalnessMapUv : "",
      parameters.roughnessMapUv ? "#define ROUGHNESSMAP_UV " + parameters.roughnessMapUv : "",
      parameters.anisotropyMapUv ? "#define ANISOTROPYMAP_UV " + parameters.anisotropyMapUv : "",
      parameters.clearcoatMapUv ? "#define CLEARCOATMAP_UV " + parameters.clearcoatMapUv : "",
      parameters.clearcoatNormalMapUv ? "#define CLEARCOAT_NORMALMAP_UV " + parameters.clearcoatNormalMapUv : "",
      parameters.clearcoatRoughnessMapUv ? "#define CLEARCOAT_ROUGHNESSMAP_UV " + parameters.clearcoatRoughnessMapUv : "",
      parameters.iridescenceMapUv ? "#define IRIDESCENCEMAP_UV " + parameters.iridescenceMapUv : "",
      parameters.iridescenceThicknessMapUv ? "#define IRIDESCENCE_THICKNESSMAP_UV " + parameters.iridescenceThicknessMapUv : "",
      parameters.sheenColorMapUv ? "#define SHEEN_COLORMAP_UV " + parameters.sheenColorMapUv : "",
      parameters.sheenRoughnessMapUv ? "#define SHEEN_ROUGHNESSMAP_UV " + parameters.sheenRoughnessMapUv : "",
      parameters.specularMapUv ? "#define SPECULARMAP_UV " + parameters.specularMapUv : "",
      parameters.specularColorMapUv ? "#define SPECULAR_COLORMAP_UV " + parameters.specularColorMapUv : "",
      parameters.specularIntensityMapUv ? "#define SPECULAR_INTENSITYMAP_UV " + parameters.specularIntensityMapUv : "",
      parameters.transmissionMapUv ? "#define TRANSMISSIONMAP_UV " + parameters.transmissionMapUv : "",
      parameters.thicknessMapUv ? "#define THICKNESSMAP_UV " + parameters.thicknessMapUv : "",
      //
      parameters.vertexTangents && parameters.flatShading === false ? "#define USE_TANGENT" : "",
      parameters.vertexColors ? "#define USE_COLOR" : "",
      parameters.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
      parameters.vertexUv1s ? "#define USE_UV1" : "",
      parameters.vertexUv2s ? "#define USE_UV2" : "",
      parameters.vertexUv3s ? "#define USE_UV3" : "",
      parameters.pointsUvs ? "#define USE_POINTS_UV" : "",
      parameters.flatShading ? "#define FLAT_SHADED" : "",
      parameters.skinning ? "#define USE_SKINNING" : "",
      parameters.morphTargets ? "#define USE_MORPHTARGETS" : "",
      parameters.morphNormals && parameters.flatShading === false ? "#define USE_MORPHNORMALS" : "",
      parameters.morphColors ? "#define USE_MORPHCOLORS" : "",
      parameters.morphTargetsCount > 0 ? "#define MORPHTARGETS_TEXTURE_STRIDE " + parameters.morphTextureStride : "",
      parameters.morphTargetsCount > 0 ? "#define MORPHTARGETS_COUNT " + parameters.morphTargetsCount : "",
      parameters.doubleSided ? "#define DOUBLE_SIDED" : "",
      parameters.flipSided ? "#define FLIP_SIDED" : "",
      parameters.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
      parameters.shadowMapEnabled ? "#define " + shadowMapTypeDefine : "",
      parameters.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "",
      parameters.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "",
      parameters.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
      parameters.reverseDepthBuffer ? "#define USE_REVERSEDEPTHBUF" : "",
      "uniform mat4 modelMatrix;",
      "uniform mat4 modelViewMatrix;",
      "uniform mat4 projectionMatrix;",
      "uniform mat4 viewMatrix;",
      "uniform mat3 normalMatrix;",
      "uniform vec3 cameraPosition;",
      "uniform bool isOrthographic;",
      "#ifdef USE_INSTANCING",
      "	attribute mat4 instanceMatrix;",
      "#endif",
      "#ifdef USE_INSTANCING_COLOR",
      "	attribute vec3 instanceColor;",
      "#endif",
      "#ifdef USE_INSTANCING_MORPH",
      "	uniform sampler2D morphTexture;",
      "#endif",
      "attribute vec3 position;",
      "attribute vec3 normal;",
      "attribute vec2 uv;",
      "#ifdef USE_UV1",
      "	attribute vec2 uv1;",
      "#endif",
      "#ifdef USE_UV2",
      "	attribute vec2 uv2;",
      "#endif",
      "#ifdef USE_UV3",
      "	attribute vec2 uv3;",
      "#endif",
      "#ifdef USE_TANGENT",
      "	attribute vec4 tangent;",
      "#endif",
      "#if defined( USE_COLOR_ALPHA )",
      "	attribute vec4 color;",
      "#elif defined( USE_COLOR )",
      "	attribute vec3 color;",
      "#endif",
      "#ifdef USE_SKINNING",
      "	attribute vec4 skinIndex;",
      "	attribute vec4 skinWeight;",
      "#endif",
      "\n"
    ].filter(filterEmptyLine).join("\n");
    prefixFragment = [
      generatePrecision(parameters),
      "#define SHADER_TYPE " + parameters.shaderType,
      "#define SHADER_NAME " + parameters.shaderName,
      customDefines,
      parameters.useFog && parameters.fog ? "#define USE_FOG" : "",
      parameters.useFog && parameters.fogExp2 ? "#define FOG_EXP2" : "",
      parameters.alphaToCoverage ? "#define ALPHA_TO_COVERAGE" : "",
      parameters.map ? "#define USE_MAP" : "",
      parameters.matcap ? "#define USE_MATCAP" : "",
      parameters.envMap ? "#define USE_ENVMAP" : "",
      parameters.envMap ? "#define " + envMapTypeDefine : "",
      parameters.envMap ? "#define " + envMapModeDefine : "",
      parameters.envMap ? "#define " + envMapBlendingDefine : "",
      envMapCubeUVSize ? "#define CUBEUV_TEXEL_WIDTH " + envMapCubeUVSize.texelWidth : "",
      envMapCubeUVSize ? "#define CUBEUV_TEXEL_HEIGHT " + envMapCubeUVSize.texelHeight : "",
      envMapCubeUVSize ? "#define CUBEUV_MAX_MIP " + envMapCubeUVSize.maxMip + ".0" : "",
      parameters.lightMap ? "#define USE_LIGHTMAP" : "",
      parameters.aoMap ? "#define USE_AOMAP" : "",
      parameters.bumpMap ? "#define USE_BUMPMAP" : "",
      parameters.normalMap ? "#define USE_NORMALMAP" : "",
      parameters.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "",
      parameters.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "",
      parameters.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
      parameters.anisotropy ? "#define USE_ANISOTROPY" : "",
      parameters.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "",
      parameters.clearcoat ? "#define USE_CLEARCOAT" : "",
      parameters.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
      parameters.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
      parameters.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
      parameters.dispersion ? "#define USE_DISPERSION" : "",
      parameters.iridescence ? "#define USE_IRIDESCENCE" : "",
      parameters.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
      parameters.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "",
      parameters.specularMap ? "#define USE_SPECULARMAP" : "",
      parameters.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "",
      parameters.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "",
      parameters.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
      parameters.metalnessMap ? "#define USE_METALNESSMAP" : "",
      parameters.alphaMap ? "#define USE_ALPHAMAP" : "",
      parameters.alphaTest ? "#define USE_ALPHATEST" : "",
      parameters.alphaHash ? "#define USE_ALPHAHASH" : "",
      parameters.sheen ? "#define USE_SHEEN" : "",
      parameters.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "",
      parameters.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "",
      parameters.transmission ? "#define USE_TRANSMISSION" : "",
      parameters.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
      parameters.thicknessMap ? "#define USE_THICKNESSMAP" : "",
      parameters.vertexTangents && parameters.flatShading === false ? "#define USE_TANGENT" : "",
      parameters.vertexColors || parameters.instancingColor || parameters.batchingColor ? "#define USE_COLOR" : "",
      parameters.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
      parameters.vertexUv1s ? "#define USE_UV1" : "",
      parameters.vertexUv2s ? "#define USE_UV2" : "",
      parameters.vertexUv3s ? "#define USE_UV3" : "",
      parameters.pointsUvs ? "#define USE_POINTS_UV" : "",
      parameters.gradientMap ? "#define USE_GRADIENTMAP" : "",
      parameters.flatShading ? "#define FLAT_SHADED" : "",
      parameters.doubleSided ? "#define DOUBLE_SIDED" : "",
      parameters.flipSided ? "#define FLIP_SIDED" : "",
      parameters.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
      parameters.shadowMapEnabled ? "#define " + shadowMapTypeDefine : "",
      parameters.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "",
      parameters.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "",
      parameters.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "",
      parameters.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
      parameters.reverseDepthBuffer ? "#define USE_REVERSEDEPTHBUF" : "",
      "uniform mat4 viewMatrix;",
      "uniform vec3 cameraPosition;",
      "uniform bool isOrthographic;",
      parameters.toneMapping !== NoToneMapping ? "#define TONE_MAPPING" : "",
      parameters.toneMapping !== NoToneMapping ? ShaderChunk["tonemapping_pars_fragment"] : "",
      // this code is required here because it is used by the toneMapping() function defined below
      parameters.toneMapping !== NoToneMapping ? getToneMappingFunction("toneMapping", parameters.toneMapping) : "",
      parameters.dithering ? "#define DITHERING" : "",
      parameters.opaque ? "#define OPAQUE" : "",
      ShaderChunk["colorspace_pars_fragment"],
      // this code is required here because it is used by the various encoding/decoding function defined below
      getTexelEncodingFunction("linearToOutputTexel", parameters.outputColorSpace),
      getLuminanceFunction(),
      parameters.useDepthPacking ? "#define DEPTH_PACKING " + parameters.depthPacking : "",
      "\n"
    ].filter(filterEmptyLine).join("\n");
  }
  vertexShader = resolveIncludes(vertexShader);
  vertexShader = replaceLightNums(vertexShader, parameters);
  vertexShader = replaceClippingPlaneNums(vertexShader, parameters);
  fragmentShader = resolveIncludes(fragmentShader);
  fragmentShader = replaceLightNums(fragmentShader, parameters);
  fragmentShader = replaceClippingPlaneNums(fragmentShader, parameters);
  vertexShader = unrollLoops(vertexShader);
  fragmentShader = unrollLoops(fragmentShader);
  if (parameters.isRawShaderMaterial !== true) {
    versionString = "#version 300 es\n";
    prefixVertex = [
      customVertexExtensions,
      "#define attribute in",
      "#define varying out",
      "#define texture2D texture"
    ].join("\n") + "\n" + prefixVertex;
    prefixFragment = [
      "#define varying in",
      parameters.glslVersion === GLSL3 ? "" : "layout(location = 0) out highp vec4 pc_fragColor;",
      parameters.glslVersion === GLSL3 ? "" : "#define gl_FragColor pc_fragColor",
      "#define gl_FragDepthEXT gl_FragDepth",
      "#define texture2D texture",
      "#define textureCube texture",
      "#define texture2DProj textureProj",
      "#define texture2DLodEXT textureLod",
      "#define texture2DProjLodEXT textureProjLod",
      "#define textureCubeLodEXT textureLod",
      "#define texture2DGradEXT textureGrad",
      "#define texture2DProjGradEXT textureProjGrad",
      "#define textureCubeGradEXT textureGrad"
    ].join("\n") + "\n" + prefixFragment;
  }
  const vertexGlsl = versionString + prefixVertex + vertexShader;
  const fragmentGlsl = versionString + prefixFragment + fragmentShader;
  const glVertexShader = WebGLShader(gl, gl.VERTEX_SHADER, vertexGlsl);
  const glFragmentShader = WebGLShader(gl, gl.FRAGMENT_SHADER, fragmentGlsl);
  gl.attachShader(program, glVertexShader);
  gl.attachShader(program, glFragmentShader);
  if (parameters.index0AttributeName !== void 0) {
    gl.bindAttribLocation(program, 0, parameters.index0AttributeName);
  } else if (parameters.morphTargets === true) {
    gl.bindAttribLocation(program, 0, "position");
  }
  gl.linkProgram(program);
  function onFirstUse(self2) {
    if (renderer.debug.checkShaderErrors) {
      const programLog = gl.getProgramInfoLog(program).trim();
      const vertexLog = gl.getShaderInfoLog(glVertexShader).trim();
      const fragmentLog = gl.getShaderInfoLog(glFragmentShader).trim();
      let runnable = true;
      let haveDiagnostics = true;
      if (gl.getProgramParameter(program, gl.LINK_STATUS) === false) {
        runnable = false;
        if (typeof renderer.debug.onShaderError === "function") {
          renderer.debug.onShaderError(gl, program, glVertexShader, glFragmentShader);
        } else {
          const vertexErrors = getShaderErrors(gl, glVertexShader, "vertex");
          const fragmentErrors = getShaderErrors(gl, glFragmentShader, "fragment");
          console.error(
            "THREE.WebGLProgram: Shader Error " + gl.getError() + " - VALIDATE_STATUS " + gl.getProgramParameter(program, gl.VALIDATE_STATUS) + "\n\nMaterial Name: " + self2.name + "\nMaterial Type: " + self2.type + "\n\nProgram Info Log: " + programLog + "\n" + vertexErrors + "\n" + fragmentErrors
          );
        }
      } else if (programLog !== "") {
        console.warn("THREE.WebGLProgram: Program Info Log:", programLog);
      } else if (vertexLog === "" || fragmentLog === "") {
        haveDiagnostics = false;
      }
      if (haveDiagnostics) {
        self2.diagnostics = {
          runnable,
          programLog,
          vertexShader: {
            log: vertexLog,
            prefix: prefixVertex
          },
          fragmentShader: {
            log: fragmentLog,
            prefix: prefixFragment
          }
        };
      }
    }
    gl.deleteShader(glVertexShader);
    gl.deleteShader(glFragmentShader);
    cachedUniforms = new WebGLUniforms(gl, program);
    cachedAttributes = fetchAttributeLocations(gl, program);
  }
  let cachedUniforms;
  this.getUniforms = function() {
    if (cachedUniforms === void 0) {
      onFirstUse(this);
    }
    return cachedUniforms;
  };
  let cachedAttributes;
  this.getAttributes = function() {
    if (cachedAttributes === void 0) {
      onFirstUse(this);
    }
    return cachedAttributes;
  };
  let programReady = parameters.rendererExtensionParallelShaderCompile === false;
  this.isReady = function() {
    if (programReady === false) {
      programReady = gl.getProgramParameter(program, COMPLETION_STATUS_KHR);
    }
    return programReady;
  };
  this.destroy = function() {
    bindingStates.releaseStatesOfProgram(this);
    gl.deleteProgram(program);
    this.program = void 0;
  };
  this.type = parameters.shaderType;
  this.name = parameters.shaderName;
  this.id = programIdCount++;
  this.cacheKey = cacheKey;
  this.usedTimes = 1;
  this.program = program;
  this.vertexShader = glVertexShader;
  this.fragmentShader = glFragmentShader;
  return this;
}
function WebGLPrograms(renderer, cubemaps, cubeuvmaps, extensions, capabilities, bindingStates, clipping) {
  const _programLayers = new Layers();
  const _customShaders = new WebGLShaderCache();
  const _activeChannels = /* @__PURE__ */ new Set();
  const programs = [];
  const logarithmicDepthBuffer = capabilities.logarithmicDepthBuffer;
  const reverseDepthBuffer = capabilities.reverseDepthBuffer;
  const SUPPORTS_VERTEX_TEXTURES = capabilities.vertexTextures;
  let precision = capabilities.precision;
  const shaderIDs = {
    MeshDepthMaterial: "depth",
    MeshDistanceMaterial: "distanceRGBA",
    MeshNormalMaterial: "normal",
    MeshBasicMaterial: "basic",
    MeshLambertMaterial: "lambert",
    MeshPhongMaterial: "phong",
    MeshToonMaterial: "toon",
    MeshStandardMaterial: "physical",
    MeshPhysicalMaterial: "physical",
    MeshMatcapMaterial: "matcap",
    LineBasicMaterial: "basic",
    LineDashedMaterial: "dashed",
    PointsMaterial: "points",
    ShadowMaterial: "shadow",
    SpriteMaterial: "sprite"
  };
  function getChannel(value) {
    _activeChannels.add(value);
    if (value === 0) return "uv";
    return `uv${value}`;
  }
  function getParameters(material, lights, shadows, scene, object) {
    const fog = scene.fog;
    const geometry = object.geometry;
    const environment = material.isMeshStandardMaterial ? scene.environment : null;
    const envMap = (material.isMeshStandardMaterial ? cubeuvmaps : cubemaps).get(material.envMap || environment);
    const envMapCubeUVHeight = !!envMap && envMap.mapping === CubeUVReflectionMapping ? envMap.image.height : null;
    const shaderID = shaderIDs[material.type];
    if (material.precision !== null) {
      precision = capabilities.getMaxPrecision(material.precision);
      if (precision !== material.precision) {
        console.warn("THREE.WebGLProgram.getParameters:", material.precision, "not supported, using", precision, "instead.");
      }
    }
    const morphAttribute = geometry.morphAttributes.position || geometry.morphAttributes.normal || geometry.morphAttributes.color;
    const morphTargetsCount = morphAttribute !== void 0 ? morphAttribute.length : 0;
    let morphTextureStride = 0;
    if (geometry.morphAttributes.position !== void 0) morphTextureStride = 1;
    if (geometry.morphAttributes.normal !== void 0) morphTextureStride = 2;
    if (geometry.morphAttributes.color !== void 0) morphTextureStride = 3;
    let vertexShader, fragmentShader;
    let customVertexShaderID, customFragmentShaderID;
    if (shaderID) {
      const shader = ShaderLib[shaderID];
      vertexShader = shader.vertexShader;
      fragmentShader = shader.fragmentShader;
    } else {
      vertexShader = material.vertexShader;
      fragmentShader = material.fragmentShader;
      _customShaders.update(material);
      customVertexShaderID = _customShaders.getVertexShaderID(material);
      customFragmentShaderID = _customShaders.getFragmentShaderID(material);
    }
    const currentRenderTarget = renderer.getRenderTarget();
    const IS_INSTANCEDMESH = object.isInstancedMesh === true;
    const IS_BATCHEDMESH = object.isBatchedMesh === true;
    const HAS_MAP = !!material.map;
    const HAS_MATCAP = !!material.matcap;
    const HAS_ENVMAP = !!envMap;
    const HAS_AOMAP = !!material.aoMap;
    const HAS_LIGHTMAP = !!material.lightMap;
    const HAS_BUMPMAP = !!material.bumpMap;
    const HAS_NORMALMAP = !!material.normalMap;
    const HAS_DISPLACEMENTMAP = !!material.displacementMap;
    const HAS_EMISSIVEMAP = !!material.emissiveMap;
    const HAS_METALNESSMAP = !!material.metalnessMap;
    const HAS_ROUGHNESSMAP = !!material.roughnessMap;
    const HAS_ANISOTROPY = material.anisotropy > 0;
    const HAS_CLEARCOAT = material.clearcoat > 0;
    const HAS_DISPERSION = material.dispersion > 0;
    const HAS_IRIDESCENCE = material.iridescence > 0;
    const HAS_SHEEN = material.sheen > 0;
    const HAS_TRANSMISSION = material.transmission > 0;
    const HAS_ANISOTROPYMAP = HAS_ANISOTROPY && !!material.anisotropyMap;
    const HAS_CLEARCOATMAP = HAS_CLEARCOAT && !!material.clearcoatMap;
    const HAS_CLEARCOAT_NORMALMAP = HAS_CLEARCOAT && !!material.clearcoatNormalMap;
    const HAS_CLEARCOAT_ROUGHNESSMAP = HAS_CLEARCOAT && !!material.clearcoatRoughnessMap;
    const HAS_IRIDESCENCEMAP = HAS_IRIDESCENCE && !!material.iridescenceMap;
    const HAS_IRIDESCENCE_THICKNESSMAP = HAS_IRIDESCENCE && !!material.iridescenceThicknessMap;
    const HAS_SHEEN_COLORMAP = HAS_SHEEN && !!material.sheenColorMap;
    const HAS_SHEEN_ROUGHNESSMAP = HAS_SHEEN && !!material.sheenRoughnessMap;
    const HAS_SPECULARMAP = !!material.specularMap;
    const HAS_SPECULAR_COLORMAP = !!material.specularColorMap;
    const HAS_SPECULAR_INTENSITYMAP = !!material.specularIntensityMap;
    const HAS_TRANSMISSIONMAP = HAS_TRANSMISSION && !!material.transmissionMap;
    const HAS_THICKNESSMAP = HAS_TRANSMISSION && !!material.thicknessMap;
    const HAS_GRADIENTMAP = !!material.gradientMap;
    const HAS_ALPHAMAP = !!material.alphaMap;
    const HAS_ALPHATEST = material.alphaTest > 0;
    const HAS_ALPHAHASH = !!material.alphaHash;
    const HAS_EXTENSIONS = !!material.extensions;
    let toneMapping = NoToneMapping;
    if (material.toneMapped) {
      if (currentRenderTarget === null || currentRenderTarget.isXRRenderTarget === true) {
        toneMapping = renderer.toneMapping;
      }
    }
    const parameters = {
      shaderID,
      shaderType: material.type,
      shaderName: material.name,
      vertexShader,
      fragmentShader,
      defines: material.defines,
      customVertexShaderID,
      customFragmentShaderID,
      isRawShaderMaterial: material.isRawShaderMaterial === true,
      glslVersion: material.glslVersion,
      precision,
      batching: IS_BATCHEDMESH,
      batchingColor: IS_BATCHEDMESH && object._colorsTexture !== null,
      instancing: IS_INSTANCEDMESH,
      instancingColor: IS_INSTANCEDMESH && object.instanceColor !== null,
      instancingMorph: IS_INSTANCEDMESH && object.morphTexture !== null,
      supportsVertexTextures: SUPPORTS_VERTEX_TEXTURES,
      outputColorSpace: currentRenderTarget === null ? renderer.outputColorSpace : currentRenderTarget.isXRRenderTarget === true ? currentRenderTarget.texture.colorSpace : LinearSRGBColorSpace,
      alphaToCoverage: !!material.alphaToCoverage,
      map: HAS_MAP,
      matcap: HAS_MATCAP,
      envMap: HAS_ENVMAP,
      envMapMode: HAS_ENVMAP && envMap.mapping,
      envMapCubeUVHeight,
      aoMap: HAS_AOMAP,
      lightMap: HAS_LIGHTMAP,
      bumpMap: HAS_BUMPMAP,
      normalMap: HAS_NORMALMAP,
      displacementMap: SUPPORTS_VERTEX_TEXTURES && HAS_DISPLACEMENTMAP,
      emissiveMap: HAS_EMISSIVEMAP,
      normalMapObjectSpace: HAS_NORMALMAP && material.normalMapType === ObjectSpaceNormalMap,
      normalMapTangentSpace: HAS_NORMALMAP && material.normalMapType === TangentSpaceNormalMap,
      metalnessMap: HAS_METALNESSMAP,
      roughnessMap: HAS_ROUGHNESSMAP,
      anisotropy: HAS_ANISOTROPY,
      anisotropyMap: HAS_ANISOTROPYMAP,
      clearcoat: HAS_CLEARCOAT,
      clearcoatMap: HAS_CLEARCOATMAP,
      clearcoatNormalMap: HAS_CLEARCOAT_NORMALMAP,
      clearcoatRoughnessMap: HAS_CLEARCOAT_ROUGHNESSMAP,
      dispersion: HAS_DISPERSION,
      iridescence: HAS_IRIDESCENCE,
      iridescenceMap: HAS_IRIDESCENCEMAP,
      iridescenceThicknessMap: HAS_IRIDESCENCE_THICKNESSMAP,
      sheen: HAS_SHEEN,
      sheenColorMap: HAS_SHEEN_COLORMAP,
      sheenRoughnessMap: HAS_SHEEN_ROUGHNESSMAP,
      specularMap: HAS_SPECULARMAP,
      specularColorMap: HAS_SPECULAR_COLORMAP,
      specularIntensityMap: HAS_SPECULAR_INTENSITYMAP,
      transmission: HAS_TRANSMISSION,
      transmissionMap: HAS_TRANSMISSIONMAP,
      thicknessMap: HAS_THICKNESSMAP,
      gradientMap: HAS_GRADIENTMAP,
      opaque: material.transparent === false && material.blending === NormalBlending && material.alphaToCoverage === false,
      alphaMap: HAS_ALPHAMAP,
      alphaTest: HAS_ALPHATEST,
      alphaHash: HAS_ALPHAHASH,
      combine: material.combine,
      //
      mapUv: HAS_MAP && getChannel(material.map.channel),
      aoMapUv: HAS_AOMAP && getChannel(material.aoMap.channel),
      lightMapUv: HAS_LIGHTMAP && getChannel(material.lightMap.channel),
      bumpMapUv: HAS_BUMPMAP && getChannel(material.bumpMap.channel),
      normalMapUv: HAS_NORMALMAP && getChannel(material.normalMap.channel),
      displacementMapUv: HAS_DISPLACEMENTMAP && getChannel(material.displacementMap.channel),
      emissiveMapUv: HAS_EMISSIVEMAP && getChannel(material.emissiveMap.channel),
      metalnessMapUv: HAS_METALNESSMAP && getChannel(material.metalnessMap.channel),
      roughnessMapUv: HAS_ROUGHNESSMAP && getChannel(material.roughnessMap.channel),
      anisotropyMapUv: HAS_ANISOTROPYMAP && getChannel(material.anisotropyMap.channel),
      clearcoatMapUv: HAS_CLEARCOATMAP && getChannel(material.clearcoatMap.channel),
      clearcoatNormalMapUv: HAS_CLEARCOAT_NORMALMAP && getChannel(material.clearcoatNormalMap.channel),
      clearcoatRoughnessMapUv: HAS_CLEARCOAT_ROUGHNESSMAP && getChannel(material.clearcoatRoughnessMap.channel),
      iridescenceMapUv: HAS_IRIDESCENCEMAP && getChannel(material.iridescenceMap.channel),
      iridescenceThicknessMapUv: HAS_IRIDESCENCE_THICKNESSMAP && getChannel(material.iridescenceThicknessMap.channel),
      sheenColorMapUv: HAS_SHEEN_COLORMAP && getChannel(material.sheenColorMap.channel),
      sheenRoughnessMapUv: HAS_SHEEN_ROUGHNESSMAP && getChannel(material.sheenRoughnessMap.channel),
      specularMapUv: HAS_SPECULARMAP && getChannel(material.specularMap.channel),
      specularColorMapUv: HAS_SPECULAR_COLORMAP && getChannel(material.specularColorMap.channel),
      specularIntensityMapUv: HAS_SPECULAR_INTENSITYMAP && getChannel(material.specularIntensityMap.channel),
      transmissionMapUv: HAS_TRANSMISSIONMAP && getChannel(material.transmissionMap.channel),
      thicknessMapUv: HAS_THICKNESSMAP && getChannel(material.thicknessMap.channel),
      alphaMapUv: HAS_ALPHAMAP && getChannel(material.alphaMap.channel),
      //
      vertexTangents: !!geometry.attributes.tangent && (HAS_NORMALMAP || HAS_ANISOTROPY),
      vertexColors: material.vertexColors,
      vertexAlphas: material.vertexColors === true && !!geometry.attributes.color && geometry.attributes.color.itemSize === 4,
      pointsUvs: object.isPoints === true && !!geometry.attributes.uv && (HAS_MAP || HAS_ALPHAMAP),
      fog: !!fog,
      useFog: material.fog === true,
      fogExp2: !!fog && fog.isFogExp2,
      flatShading: material.flatShading === true,
      sizeAttenuation: material.sizeAttenuation === true,
      logarithmicDepthBuffer,
      reverseDepthBuffer,
      skinning: object.isSkinnedMesh === true,
      morphTargets: geometry.morphAttributes.position !== void 0,
      morphNormals: geometry.morphAttributes.normal !== void 0,
      morphColors: geometry.morphAttributes.color !== void 0,
      morphTargetsCount,
      morphTextureStride,
      numDirLights: lights.directional.length,
      numPointLights: lights.point.length,
      numSpotLights: lights.spot.length,
      numSpotLightMaps: lights.spotLightMap.length,
      numRectAreaLights: lights.rectArea.length,
      numHemiLights: lights.hemi.length,
      numDirLightShadows: lights.directionalShadowMap.length,
      numPointLightShadows: lights.pointShadowMap.length,
      numSpotLightShadows: lights.spotShadowMap.length,
      numSpotLightShadowsWithMaps: lights.numSpotLightShadowsWithMaps,
      numLightProbes: lights.numLightProbes,
      numClippingPlanes: clipping.numPlanes,
      numClipIntersection: clipping.numIntersection,
      dithering: material.dithering,
      shadowMapEnabled: renderer.shadowMap.enabled && shadows.length > 0,
      shadowMapType: renderer.shadowMap.type,
      toneMapping,
      decodeVideoTexture: HAS_MAP && material.map.isVideoTexture === true && ColorManagement.getTransfer(material.map.colorSpace) === SRGBTransfer,
      premultipliedAlpha: material.premultipliedAlpha,
      doubleSided: material.side === DoubleSide,
      flipSided: material.side === BackSide,
      useDepthPacking: material.depthPacking >= 0,
      depthPacking: material.depthPacking || 0,
      index0AttributeName: material.index0AttributeName,
      extensionClipCullDistance: HAS_EXTENSIONS && material.extensions.clipCullDistance === true && extensions.has("WEBGL_clip_cull_distance"),
      extensionMultiDraw: (HAS_EXTENSIONS && material.extensions.multiDraw === true || IS_BATCHEDMESH) && extensions.has("WEBGL_multi_draw"),
      rendererExtensionParallelShaderCompile: extensions.has("KHR_parallel_shader_compile"),
      customProgramCacheKey: material.customProgramCacheKey()
    };
    parameters.vertexUv1s = _activeChannels.has(1);
    parameters.vertexUv2s = _activeChannels.has(2);
    parameters.vertexUv3s = _activeChannels.has(3);
    _activeChannels.clear();
    return parameters;
  }
  function getProgramCacheKey(parameters) {
    const array = [];
    if (parameters.shaderID) {
      array.push(parameters.shaderID);
    } else {
      array.push(parameters.customVertexShaderID);
      array.push(parameters.customFragmentShaderID);
    }
    if (parameters.defines !== void 0) {
      for (const name in parameters.defines) {
        array.push(name);
        array.push(parameters.defines[name]);
      }
    }
    if (parameters.isRawShaderMaterial === false) {
      getProgramCacheKeyParameters(array, parameters);
      getProgramCacheKeyBooleans(array, parameters);
      array.push(renderer.outputColorSpace);
    }
    array.push(parameters.customProgramCacheKey);
    return array.join();
  }
  function getProgramCacheKeyParameters(array, parameters) {
    array.push(parameters.precision);
    array.push(parameters.outputColorSpace);
    array.push(parameters.envMapMode);
    array.push(parameters.envMapCubeUVHeight);
    array.push(parameters.mapUv);
    array.push(parameters.alphaMapUv);
    array.push(parameters.lightMapUv);
    array.push(parameters.aoMapUv);
    array.push(parameters.bumpMapUv);
    array.push(parameters.normalMapUv);
    array.push(parameters.displacementMapUv);
    array.push(parameters.emissiveMapUv);
    array.push(parameters.metalnessMapUv);
    array.push(parameters.roughnessMapUv);
    array.push(parameters.anisotropyMapUv);
    array.push(parameters.clearcoatMapUv);
    array.push(parameters.clearcoatNormalMapUv);
    array.push(parameters.clearcoatRoughnessMapUv);
    array.push(parameters.iridescenceMapUv);
    array.push(parameters.iridescenceThicknessMapUv);
    array.push(parameters.sheenColorMapUv);
    array.push(parameters.sheenRoughnessMapUv);
    array.push(parameters.specularMapUv);
    array.push(parameters.specularColorMapUv);
    array.push(parameters.specularIntensityMapUv);
    array.push(parameters.transmissionMapUv);
    array.push(parameters.thicknessMapUv);
    array.push(parameters.combine);
    array.push(parameters.fogExp2);
    array.push(parameters.sizeAttenuation);
    array.push(parameters.morphTargetsCount);
    array.push(parameters.morphAttributeCount);
    array.push(parameters.numDirLights);
    array.push(parameters.numPointLights);
    array.push(parameters.numSpotLights);
    array.push(parameters.numSpotLightMaps);
    array.push(parameters.numHemiLights);
    array.push(parameters.numRectAreaLights);
    array.push(parameters.numDirLightShadows);
    array.push(parameters.numPointLightShadows);
    array.push(parameters.numSpotLightShadows);
    array.push(parameters.numSpotLightShadowsWithMaps);
    array.push(parameters.numLightProbes);
    array.push(parameters.shadowMapType);
    array.push(parameters.toneMapping);
    array.push(parameters.numClippingPlanes);
    array.push(parameters.numClipIntersection);
    array.push(parameters.depthPacking);
  }
  function getProgramCacheKeyBooleans(array, parameters) {
    _programLayers.disableAll();
    if (parameters.supportsVertexTextures)
      _programLayers.enable(0);
    if (parameters.instancing)
      _programLayers.enable(1);
    if (parameters.instancingColor)
      _programLayers.enable(2);
    if (parameters.instancingMorph)
      _programLayers.enable(3);
    if (parameters.matcap)
      _programLayers.enable(4);
    if (parameters.envMap)
      _programLayers.enable(5);
    if (parameters.normalMapObjectSpace)
      _programLayers.enable(6);
    if (parameters.normalMapTangentSpace)
      _programLayers.enable(7);
    if (parameters.clearcoat)
      _programLayers.enable(8);
    if (parameters.iridescence)
      _programLayers.enable(9);
    if (parameters.alphaTest)
      _programLayers.enable(10);
    if (parameters.vertexColors)
      _programLayers.enable(11);
    if (parameters.vertexAlphas)
      _programLayers.enable(12);
    if (parameters.vertexUv1s)
      _programLayers.enable(13);
    if (parameters.vertexUv2s)
      _programLayers.enable(14);
    if (parameters.vertexUv3s)
      _programLayers.enable(15);
    if (parameters.vertexTangents)
      _programLayers.enable(16);
    if (parameters.anisotropy)
      _programLayers.enable(17);
    if (parameters.alphaHash)
      _programLayers.enable(18);
    if (parameters.batching)
      _programLayers.enable(19);
    if (parameters.dispersion)
      _programLayers.enable(20);
    if (parameters.batchingColor)
      _programLayers.enable(21);
    array.push(_programLayers.mask);
    _programLayers.disableAll();
    if (parameters.fog)
      _programLayers.enable(0);
    if (parameters.useFog)
      _programLayers.enable(1);
    if (parameters.flatShading)
      _programLayers.enable(2);
    if (parameters.logarithmicDepthBuffer)
      _programLayers.enable(3);
    if (parameters.reverseDepthBuffer)
      _programLayers.enable(4);
    if (parameters.skinning)
      _programLayers.enable(5);
    if (parameters.morphTargets)
      _programLayers.enable(6);
    if (parameters.morphNormals)
      _programLayers.enable(7);
    if (parameters.morphColors)
      _programLayers.enable(8);
    if (parameters.premultipliedAlpha)
      _programLayers.enable(9);
    if (parameters.shadowMapEnabled)
      _programLayers.enable(10);
    if (parameters.doubleSided)
      _programLayers.enable(11);
    if (parameters.flipSided)
      _programLayers.enable(12);
    if (parameters.useDepthPacking)
      _programLayers.enable(13);
    if (parameters.dithering)
      _programLayers.enable(14);
    if (parameters.transmission)
      _programLayers.enable(15);
    if (parameters.sheen)
      _programLayers.enable(16);
    if (parameters.opaque)
      _programLayers.enable(17);
    if (parameters.pointsUvs)
      _programLayers.enable(18);
    if (parameters.decodeVideoTexture)
      _programLayers.enable(19);
    if (parameters.alphaToCoverage)
      _programLayers.enable(20);
    array.push(_programLayers.mask);
  }
  function getUniforms(material) {
    const shaderID = shaderIDs[material.type];
    let uniforms;
    if (shaderID) {
      const shader = ShaderLib[shaderID];
      uniforms = UniformsUtils.clone(shader.uniforms);
    } else {
      uniforms = material.uniforms;
    }
    return uniforms;
  }
  function acquireProgram(parameters, cacheKey) {
    let program;
    for (let p3 = 0, pl = programs.length; p3 < pl; p3++) {
      const preexistingProgram = programs[p3];
      if (preexistingProgram.cacheKey === cacheKey) {
        program = preexistingProgram;
        ++program.usedTimes;
        break;
      }
    }
    if (program === void 0) {
      program = new WebGLProgram(renderer, cacheKey, parameters, bindingStates);
      programs.push(program);
    }
    return program;
  }
  function releaseProgram(program) {
    if (--program.usedTimes === 0) {
      const i2 = programs.indexOf(program);
      programs[i2] = programs[programs.length - 1];
      programs.pop();
      program.destroy();
    }
  }
  function releaseShaderCache(material) {
    _customShaders.remove(material);
  }
  function dispose2() {
    _customShaders.dispose();
  }
  return {
    getParameters,
    getProgramCacheKey,
    getUniforms,
    acquireProgram,
    releaseProgram,
    releaseShaderCache,
    // Exposed for resource monitoring & error feedback via renderer.info:
    programs,
    dispose: dispose2
  };
}
function WebGLProperties() {
  let properties = /* @__PURE__ */ new WeakMap();
  function has(object) {
    return properties.has(object);
  }
  function get(object) {
    let map = properties.get(object);
    if (map === void 0) {
      map = {};
      properties.set(object, map);
    }
    return map;
  }
  function remove(object) {
    properties.delete(object);
  }
  function update(object, key, value) {
    properties.get(object)[key] = value;
  }
  function dispose2() {
    properties = /* @__PURE__ */ new WeakMap();
  }
  return {
    has,
    get,
    remove,
    update,
    dispose: dispose2
  };
}
function painterSortStable(a, b) {
  if (a.groupOrder !== b.groupOrder) {
    return a.groupOrder - b.groupOrder;
  } else if (a.renderOrder !== b.renderOrder) {
    return a.renderOrder - b.renderOrder;
  } else if (a.material.id !== b.material.id) {
    return a.material.id - b.material.id;
  } else if (a.z !== b.z) {
    return a.z - b.z;
  } else {
    return a.id - b.id;
  }
}
function reversePainterSortStable(a, b) {
  if (a.groupOrder !== b.groupOrder) {
    return a.groupOrder - b.groupOrder;
  } else if (a.renderOrder !== b.renderOrder) {
    return a.renderOrder - b.renderOrder;
  } else if (a.z !== b.z) {
    return b.z - a.z;
  } else {
    return a.id - b.id;
  }
}
function WebGLRenderList() {
  const renderItems = [];
  let renderItemsIndex = 0;
  const opaque = [];
  const transmissive = [];
  const transparent = [];
  function init() {
    renderItemsIndex = 0;
    opaque.length = 0;
    transmissive.length = 0;
    transparent.length = 0;
  }
  function getNextRenderItem(object, geometry, material, groupOrder, z2, group) {
    let renderItem = renderItems[renderItemsIndex];
    if (renderItem === void 0) {
      renderItem = {
        id: object.id,
        object,
        geometry,
        material,
        groupOrder,
        renderOrder: object.renderOrder,
        z: z2,
        group
      };
      renderItems[renderItemsIndex] = renderItem;
    } else {
      renderItem.id = object.id;
      renderItem.object = object;
      renderItem.geometry = geometry;
      renderItem.material = material;
      renderItem.groupOrder = groupOrder;
      renderItem.renderOrder = object.renderOrder;
      renderItem.z = z2;
      renderItem.group = group;
    }
    renderItemsIndex++;
    return renderItem;
  }
  function push(object, geometry, material, groupOrder, z2, group) {
    const renderItem = getNextRenderItem(object, geometry, material, groupOrder, z2, group);
    if (material.transmission > 0) {
      transmissive.push(renderItem);
    } else if (material.transparent === true) {
      transparent.push(renderItem);
    } else {
      opaque.push(renderItem);
    }
  }
  function unshift(object, geometry, material, groupOrder, z2, group) {
    const renderItem = getNextRenderItem(object, geometry, material, groupOrder, z2, group);
    if (material.transmission > 0) {
      transmissive.unshift(renderItem);
    } else if (material.transparent === true) {
      transparent.unshift(renderItem);
    } else {
      opaque.unshift(renderItem);
    }
  }
  function sort(customOpaqueSort, customTransparentSort) {
    if (opaque.length > 1) opaque.sort(customOpaqueSort || painterSortStable);
    if (transmissive.length > 1) transmissive.sort(customTransparentSort || reversePainterSortStable);
    if (transparent.length > 1) transparent.sort(customTransparentSort || reversePainterSortStable);
  }
  function finish() {
    for (let i2 = renderItemsIndex, il = renderItems.length; i2 < il; i2++) {
      const renderItem = renderItems[i2];
      if (renderItem.id === null) break;
      renderItem.id = null;
      renderItem.object = null;
      renderItem.geometry = null;
      renderItem.material = null;
      renderItem.group = null;
    }
  }
  return {
    opaque,
    transmissive,
    transparent,
    init,
    push,
    unshift,
    finish,
    sort
  };
}
function WebGLRenderLists() {
  let lists = /* @__PURE__ */ new WeakMap();
  function get(scene, renderCallDepth) {
    const listArray = lists.get(scene);
    let list;
    if (listArray === void 0) {
      list = new WebGLRenderList();
      lists.set(scene, [list]);
    } else {
      if (renderCallDepth >= listArray.length) {
        list = new WebGLRenderList();
        listArray.push(list);
      } else {
        list = listArray[renderCallDepth];
      }
    }
    return list;
  }
  function dispose2() {
    lists = /* @__PURE__ */ new WeakMap();
  }
  return {
    get,
    dispose: dispose2
  };
}
function UniformsCache() {
  const lights = {};
  return {
    get: function(light) {
      if (lights[light.id] !== void 0) {
        return lights[light.id];
      }
      let uniforms;
      switch (light.type) {
        case "DirectionalLight":
          uniforms = {
            direction: new Vector3(),
            color: new Color()
          };
          break;
        case "SpotLight":
          uniforms = {
            position: new Vector3(),
            direction: new Vector3(),
            color: new Color(),
            distance: 0,
            coneCos: 0,
            penumbraCos: 0,
            decay: 0
          };
          break;
        case "PointLight":
          uniforms = {
            position: new Vector3(),
            color: new Color(),
            distance: 0,
            decay: 0
          };
          break;
        case "HemisphereLight":
          uniforms = {
            direction: new Vector3(),
            skyColor: new Color(),
            groundColor: new Color()
          };
          break;
        case "RectAreaLight":
          uniforms = {
            color: new Color(),
            position: new Vector3(),
            halfWidth: new Vector3(),
            halfHeight: new Vector3()
          };
          break;
      }
      lights[light.id] = uniforms;
      return uniforms;
    }
  };
}
function ShadowUniformsCache() {
  const lights = {};
  return {
    get: function(light) {
      if (lights[light.id] !== void 0) {
        return lights[light.id];
      }
      let uniforms;
      switch (light.type) {
        case "DirectionalLight":
          uniforms = {
            shadowIntensity: 1,
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new Vector2()
          };
          break;
        case "SpotLight":
          uniforms = {
            shadowIntensity: 1,
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new Vector2()
          };
          break;
        case "PointLight":
          uniforms = {
            shadowIntensity: 1,
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new Vector2(),
            shadowCameraNear: 1,
            shadowCameraFar: 1e3
          };
          break;
      }
      lights[light.id] = uniforms;
      return uniforms;
    }
  };
}
function shadowCastingAndTexturingLightsFirst(lightA, lightB) {
  return (lightB.castShadow ? 2 : 0) - (lightA.castShadow ? 2 : 0) + (lightB.map ? 1 : 0) - (lightA.map ? 1 : 0);
}
function WebGLLights(extensions) {
  const cache = new UniformsCache();
  const shadowCache = ShadowUniformsCache();
  const state = {
    version: 0,
    hash: {
      directionalLength: -1,
      pointLength: -1,
      spotLength: -1,
      rectAreaLength: -1,
      hemiLength: -1,
      numDirectionalShadows: -1,
      numPointShadows: -1,
      numSpotShadows: -1,
      numSpotMaps: -1,
      numLightProbes: -1
    },
    ambient: [0, 0, 0],
    probe: [],
    directional: [],
    directionalShadow: [],
    directionalShadowMap: [],
    directionalShadowMatrix: [],
    spot: [],
    spotLightMap: [],
    spotShadow: [],
    spotShadowMap: [],
    spotLightMatrix: [],
    rectArea: [],
    rectAreaLTC1: null,
    rectAreaLTC2: null,
    point: [],
    pointShadow: [],
    pointShadowMap: [],
    pointShadowMatrix: [],
    hemi: [],
    numSpotLightShadowsWithMaps: 0,
    numLightProbes: 0
  };
  for (let i2 = 0; i2 < 9; i2++) state.probe.push(new Vector3());
  const vector3 = new Vector3();
  const matrix4 = new Matrix4();
  const matrix42 = new Matrix4();
  function setup(lights) {
    let r2 = 0, g3 = 0, b = 0;
    for (let i2 = 0; i2 < 9; i2++) state.probe[i2].set(0, 0, 0);
    let directionalLength = 0;
    let pointLength = 0;
    let spotLength = 0;
    let rectAreaLength = 0;
    let hemiLength = 0;
    let numDirectionalShadows = 0;
    let numPointShadows = 0;
    let numSpotShadows = 0;
    let numSpotMaps = 0;
    let numSpotShadowsWithMaps = 0;
    let numLightProbes = 0;
    lights.sort(shadowCastingAndTexturingLightsFirst);
    for (let i2 = 0, l2 = lights.length; i2 < l2; i2++) {
      const light = lights[i2];
      const color = light.color;
      const intensity = light.intensity;
      const distance = light.distance;
      const shadowMap = light.shadow && light.shadow.map ? light.shadow.map.texture : null;
      if (light.isAmbientLight) {
        r2 += color.r * intensity;
        g3 += color.g * intensity;
        b += color.b * intensity;
      } else if (light.isLightProbe) {
        for (let j2 = 0; j2 < 9; j2++) {
          state.probe[j2].addScaledVector(light.sh.coefficients[j2], intensity);
        }
        numLightProbes++;
      } else if (light.isDirectionalLight) {
        const uniforms = cache.get(light);
        uniforms.color.copy(light.color).multiplyScalar(light.intensity);
        if (light.castShadow) {
          const shadow = light.shadow;
          const shadowUniforms = shadowCache.get(light);
          shadowUniforms.shadowIntensity = shadow.intensity;
          shadowUniforms.shadowBias = shadow.bias;
          shadowUniforms.shadowNormalBias = shadow.normalBias;
          shadowUniforms.shadowRadius = shadow.radius;
          shadowUniforms.shadowMapSize = shadow.mapSize;
          state.directionalShadow[directionalLength] = shadowUniforms;
          state.directionalShadowMap[directionalLength] = shadowMap;
          state.directionalShadowMatrix[directionalLength] = light.shadow.matrix;
          numDirectionalShadows++;
        }
        state.directional[directionalLength] = uniforms;
        directionalLength++;
      } else if (light.isSpotLight) {
        const uniforms = cache.get(light);
        uniforms.position.setFromMatrixPosition(light.matrixWorld);
        uniforms.color.copy(color).multiplyScalar(intensity);
        uniforms.distance = distance;
        uniforms.coneCos = Math.cos(light.angle);
        uniforms.penumbraCos = Math.cos(light.angle * (1 - light.penumbra));
        uniforms.decay = light.decay;
        state.spot[spotLength] = uniforms;
        const shadow = light.shadow;
        if (light.map) {
          state.spotLightMap[numSpotMaps] = light.map;
          numSpotMaps++;
          shadow.updateMatrices(light);
          if (light.castShadow) numSpotShadowsWithMaps++;
        }
        state.spotLightMatrix[spotLength] = shadow.matrix;
        if (light.castShadow) {
          const shadowUniforms = shadowCache.get(light);
          shadowUniforms.shadowIntensity = shadow.intensity;
          shadowUniforms.shadowBias = shadow.bias;
          shadowUniforms.shadowNormalBias = shadow.normalBias;
          shadowUniforms.shadowRadius = shadow.radius;
          shadowUniforms.shadowMapSize = shadow.mapSize;
          state.spotShadow[spotLength] = shadowUniforms;
          state.spotShadowMap[spotLength] = shadowMap;
          numSpotShadows++;
        }
        spotLength++;
      } else if (light.isRectAreaLight) {
        const uniforms = cache.get(light);
        uniforms.color.copy(color).multiplyScalar(intensity);
        uniforms.halfWidth.set(light.width * 0.5, 0, 0);
        uniforms.halfHeight.set(0, light.height * 0.5, 0);
        state.rectArea[rectAreaLength] = uniforms;
        rectAreaLength++;
      } else if (light.isPointLight) {
        const uniforms = cache.get(light);
        uniforms.color.copy(light.color).multiplyScalar(light.intensity);
        uniforms.distance = light.distance;
        uniforms.decay = light.decay;
        if (light.castShadow) {
          const shadow = light.shadow;
          const shadowUniforms = shadowCache.get(light);
          shadowUniforms.shadowIntensity = shadow.intensity;
          shadowUniforms.shadowBias = shadow.bias;
          shadowUniforms.shadowNormalBias = shadow.normalBias;
          shadowUniforms.shadowRadius = shadow.radius;
          shadowUniforms.shadowMapSize = shadow.mapSize;
          shadowUniforms.shadowCameraNear = shadow.camera.near;
          shadowUniforms.shadowCameraFar = shadow.camera.far;
          state.pointShadow[pointLength] = shadowUniforms;
          state.pointShadowMap[pointLength] = shadowMap;
          state.pointShadowMatrix[pointLength] = light.shadow.matrix;
          numPointShadows++;
        }
        state.point[pointLength] = uniforms;
        pointLength++;
      } else if (light.isHemisphereLight) {
        const uniforms = cache.get(light);
        uniforms.skyColor.copy(light.color).multiplyScalar(intensity);
        uniforms.groundColor.copy(light.groundColor).multiplyScalar(intensity);
        state.hemi[hemiLength] = uniforms;
        hemiLength++;
      }
    }
    if (rectAreaLength > 0) {
      if (extensions.has("OES_texture_float_linear") === true) {
        state.rectAreaLTC1 = UniformsLib.LTC_FLOAT_1;
        state.rectAreaLTC2 = UniformsLib.LTC_FLOAT_2;
      } else {
        state.rectAreaLTC1 = UniformsLib.LTC_HALF_1;
        state.rectAreaLTC2 = UniformsLib.LTC_HALF_2;
      }
    }
    state.ambient[0] = r2;
    state.ambient[1] = g3;
    state.ambient[2] = b;
    const hash = state.hash;
    if (hash.directionalLength !== directionalLength || hash.pointLength !== pointLength || hash.spotLength !== spotLength || hash.rectAreaLength !== rectAreaLength || hash.hemiLength !== hemiLength || hash.numDirectionalShadows !== numDirectionalShadows || hash.numPointShadows !== numPointShadows || hash.numSpotShadows !== numSpotShadows || hash.numSpotMaps !== numSpotMaps || hash.numLightProbes !== numLightProbes) {
      state.directional.length = directionalLength;
      state.spot.length = spotLength;
      state.rectArea.length = rectAreaLength;
      state.point.length = pointLength;
      state.hemi.length = hemiLength;
      state.directionalShadow.length = numDirectionalShadows;
      state.directionalShadowMap.length = numDirectionalShadows;
      state.pointShadow.length = numPointShadows;
      state.pointShadowMap.length = numPointShadows;
      state.spotShadow.length = numSpotShadows;
      state.spotShadowMap.length = numSpotShadows;
      state.directionalShadowMatrix.length = numDirectionalShadows;
      state.pointShadowMatrix.length = numPointShadows;
      state.spotLightMatrix.length = numSpotShadows + numSpotMaps - numSpotShadowsWithMaps;
      state.spotLightMap.length = numSpotMaps;
      state.numSpotLightShadowsWithMaps = numSpotShadowsWithMaps;
      state.numLightProbes = numLightProbes;
      hash.directionalLength = directionalLength;
      hash.pointLength = pointLength;
      hash.spotLength = spotLength;
      hash.rectAreaLength = rectAreaLength;
      hash.hemiLength = hemiLength;
      hash.numDirectionalShadows = numDirectionalShadows;
      hash.numPointShadows = numPointShadows;
      hash.numSpotShadows = numSpotShadows;
      hash.numSpotMaps = numSpotMaps;
      hash.numLightProbes = numLightProbes;
      state.version = nextVersion++;
    }
  }
  function setupView(lights, camera) {
    let directionalLength = 0;
    let pointLength = 0;
    let spotLength = 0;
    let rectAreaLength = 0;
    let hemiLength = 0;
    const viewMatrix = camera.matrixWorldInverse;
    for (let i2 = 0, l2 = lights.length; i2 < l2; i2++) {
      const light = lights[i2];
      if (light.isDirectionalLight) {
        const uniforms = state.directional[directionalLength];
        uniforms.direction.setFromMatrixPosition(light.matrixWorld);
        vector3.setFromMatrixPosition(light.target.matrixWorld);
        uniforms.direction.sub(vector3);
        uniforms.direction.transformDirection(viewMatrix);
        directionalLength++;
      } else if (light.isSpotLight) {
        const uniforms = state.spot[spotLength];
        uniforms.position.setFromMatrixPosition(light.matrixWorld);
        uniforms.position.applyMatrix4(viewMatrix);
        uniforms.direction.setFromMatrixPosition(light.matrixWorld);
        vector3.setFromMatrixPosition(light.target.matrixWorld);
        uniforms.direction.sub(vector3);
        uniforms.direction.transformDirection(viewMatrix);
        spotLength++;
      } else if (light.isRectAreaLight) {
        const uniforms = state.rectArea[rectAreaLength];
        uniforms.position.setFromMatrixPosition(light.matrixWorld);
        uniforms.position.applyMatrix4(viewMatrix);
        matrix42.identity();
        matrix4.copy(light.matrixWorld);
        matrix4.premultiply(viewMatrix);
        matrix42.extractRotation(matrix4);
        uniforms.halfWidth.set(light.width * 0.5, 0, 0);
        uniforms.halfHeight.set(0, light.height * 0.5, 0);
        uniforms.halfWidth.applyMatrix4(matrix42);
        uniforms.halfHeight.applyMatrix4(matrix42);
        rectAreaLength++;
      } else if (light.isPointLight) {
        const uniforms = state.point[pointLength];
        uniforms.position.setFromMatrixPosition(light.matrixWorld);
        uniforms.position.applyMatrix4(viewMatrix);
        pointLength++;
      } else if (light.isHemisphereLight) {
        const uniforms = state.hemi[hemiLength];
        uniforms.direction.setFromMatrixPosition(light.matrixWorld);
        uniforms.direction.transformDirection(viewMatrix);
        hemiLength++;
      }
    }
  }
  return {
    setup,
    setupView,
    state
  };
}
function WebGLRenderState(extensions) {
  const lights = new WebGLLights(extensions);
  const lightsArray = [];
  const shadowsArray = [];
  function init(camera) {
    state.camera = camera;
    lightsArray.length = 0;
    shadowsArray.length = 0;
  }
  function pushLight(light) {
    lightsArray.push(light);
  }
  function pushShadow(shadowLight) {
    shadowsArray.push(shadowLight);
  }
  function setupLights() {
    lights.setup(lightsArray);
  }
  function setupLightsView(camera) {
    lights.setupView(lightsArray, camera);
  }
  const state = {
    lightsArray,
    shadowsArray,
    camera: null,
    lights,
    transmissionRenderTarget: {}
  };
  return {
    init,
    state,
    setupLights,
    setupLightsView,
    pushLight,
    pushShadow
  };
}
function WebGLRenderStates(extensions) {
  let renderStates = /* @__PURE__ */ new WeakMap();
  function get(scene, renderCallDepth = 0) {
    const renderStateArray = renderStates.get(scene);
    let renderState;
    if (renderStateArray === void 0) {
      renderState = new WebGLRenderState(extensions);
      renderStates.set(scene, [renderState]);
    } else {
      if (renderCallDepth >= renderStateArray.length) {
        renderState = new WebGLRenderState(extensions);
        renderStateArray.push(renderState);
      } else {
        renderState = renderStateArray[renderCallDepth];
      }
    }
    return renderState;
  }
  function dispose2() {
    renderStates = /* @__PURE__ */ new WeakMap();
  }
  return {
    get,
    dispose: dispose2
  };
}
function WebGLShadowMap(renderer, objects, capabilities) {
  let _frustum2 = new Frustum();
  const _shadowMapSize = new Vector2(), _viewportSize = new Vector2(), _viewport = new Vector4(), _depthMaterial = new MeshDepthMaterial({ depthPacking: RGBADepthPacking }), _distanceMaterial = new MeshDistanceMaterial(), _materialCache = {}, _maxTextureSize = capabilities.maxTextureSize;
  const shadowSide = { [FrontSide]: BackSide, [BackSide]: FrontSide, [DoubleSide]: DoubleSide };
  const shadowMaterialVertical = new ShaderMaterial({
    defines: {
      VSM_SAMPLES: 8
    },
    uniforms: {
      shadow_pass: { value: null },
      resolution: { value: new Vector2() },
      radius: { value: 4 }
    },
    vertexShader: vertex,
    fragmentShader: fragment
  });
  const shadowMaterialHorizontal = shadowMaterialVertical.clone();
  shadowMaterialHorizontal.defines.HORIZONTAL_PASS = 1;
  const fullScreenTri = new BufferGeometry();
  fullScreenTri.setAttribute(
    "position",
    new BufferAttribute(
      new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]),
      3
    )
  );
  const fullScreenMesh = new Mesh(fullScreenTri, shadowMaterialVertical);
  const scope = this;
  this.enabled = false;
  this.autoUpdate = true;
  this.needsUpdate = false;
  this.type = PCFShadowMap;
  let _previousType = this.type;
  this.render = function(lights, scene, camera) {
    if (scope.enabled === false) return;
    if (scope.autoUpdate === false && scope.needsUpdate === false) return;
    if (lights.length === 0) return;
    const currentRenderTarget = renderer.getRenderTarget();
    const activeCubeFace = renderer.getActiveCubeFace();
    const activeMipmapLevel = renderer.getActiveMipmapLevel();
    const _state = renderer.state;
    _state.setBlending(NoBlending);
    _state.buffers.color.setClear(1, 1, 1, 1);
    _state.buffers.depth.setTest(true);
    _state.setScissorTest(false);
    const toVSM = _previousType !== VSMShadowMap && this.type === VSMShadowMap;
    const fromVSM = _previousType === VSMShadowMap && this.type !== VSMShadowMap;
    for (let i2 = 0, il = lights.length; i2 < il; i2++) {
      const light = lights[i2];
      const shadow = light.shadow;
      if (shadow === void 0) {
        console.warn("THREE.WebGLShadowMap:", light, "has no shadow.");
        continue;
      }
      if (shadow.autoUpdate === false && shadow.needsUpdate === false) continue;
      _shadowMapSize.copy(shadow.mapSize);
      const shadowFrameExtents = shadow.getFrameExtents();
      _shadowMapSize.multiply(shadowFrameExtents);
      _viewportSize.copy(shadow.mapSize);
      if (_shadowMapSize.x > _maxTextureSize || _shadowMapSize.y > _maxTextureSize) {
        if (_shadowMapSize.x > _maxTextureSize) {
          _viewportSize.x = Math.floor(_maxTextureSize / shadowFrameExtents.x);
          _shadowMapSize.x = _viewportSize.x * shadowFrameExtents.x;
          shadow.mapSize.x = _viewportSize.x;
        }
        if (_shadowMapSize.y > _maxTextureSize) {
          _viewportSize.y = Math.floor(_maxTextureSize / shadowFrameExtents.y);
          _shadowMapSize.y = _viewportSize.y * shadowFrameExtents.y;
          shadow.mapSize.y = _viewportSize.y;
        }
      }
      if (shadow.map === null || toVSM === true || fromVSM === true) {
        const pars = this.type !== VSMShadowMap ? { minFilter: NearestFilter, magFilter: NearestFilter } : {};
        if (shadow.map !== null) {
          shadow.map.dispose();
        }
        shadow.map = new WebGLRenderTarget(_shadowMapSize.x, _shadowMapSize.y, pars);
        shadow.map.texture.name = light.name + ".shadowMap";
        shadow.camera.updateProjectionMatrix();
      }
      renderer.setRenderTarget(shadow.map);
      renderer.clear();
      const viewportCount = shadow.getViewportCount();
      for (let vp = 0; vp < viewportCount; vp++) {
        const viewport = shadow.getViewport(vp);
        _viewport.set(
          _viewportSize.x * viewport.x,
          _viewportSize.y * viewport.y,
          _viewportSize.x * viewport.z,
          _viewportSize.y * viewport.w
        );
        _state.viewport(_viewport);
        shadow.updateMatrices(light, vp);
        _frustum2 = shadow.getFrustum();
        renderObject(scene, camera, shadow.camera, light, this.type);
      }
      if (shadow.isPointLightShadow !== true && this.type === VSMShadowMap) {
        VSMPass(shadow, camera);
      }
      shadow.needsUpdate = false;
    }
    _previousType = this.type;
    scope.needsUpdate = false;
    renderer.setRenderTarget(currentRenderTarget, activeCubeFace, activeMipmapLevel);
  };
  function VSMPass(shadow, camera) {
    const geometry = objects.update(fullScreenMesh);
    if (shadowMaterialVertical.defines.VSM_SAMPLES !== shadow.blurSamples) {
      shadowMaterialVertical.defines.VSM_SAMPLES = shadow.blurSamples;
      shadowMaterialHorizontal.defines.VSM_SAMPLES = shadow.blurSamples;
      shadowMaterialVertical.needsUpdate = true;
      shadowMaterialHorizontal.needsUpdate = true;
    }
    if (shadow.mapPass === null) {
      shadow.mapPass = new WebGLRenderTarget(_shadowMapSize.x, _shadowMapSize.y);
    }
    shadowMaterialVertical.uniforms.shadow_pass.value = shadow.map.texture;
    shadowMaterialVertical.uniforms.resolution.value = shadow.mapSize;
    shadowMaterialVertical.uniforms.radius.value = shadow.radius;
    renderer.setRenderTarget(shadow.mapPass);
    renderer.clear();
    renderer.renderBufferDirect(camera, null, geometry, shadowMaterialVertical, fullScreenMesh, null);
    shadowMaterialHorizontal.uniforms.shadow_pass.value = shadow.mapPass.texture;
    shadowMaterialHorizontal.uniforms.resolution.value = shadow.mapSize;
    shadowMaterialHorizontal.uniforms.radius.value = shadow.radius;
    renderer.setRenderTarget(shadow.map);
    renderer.clear();
    renderer.renderBufferDirect(camera, null, geometry, shadowMaterialHorizontal, fullScreenMesh, null);
  }
  function getDepthMaterial(object, material, light, type) {
    let result = null;
    const customMaterial = light.isPointLight === true ? object.customDistanceMaterial : object.customDepthMaterial;
    if (customMaterial !== void 0) {
      result = customMaterial;
    } else {
      result = light.isPointLight === true ? _distanceMaterial : _depthMaterial;
      if (renderer.localClippingEnabled && material.clipShadows === true && Array.isArray(material.clippingPlanes) && material.clippingPlanes.length !== 0 || material.displacementMap && material.displacementScale !== 0 || material.alphaMap && material.alphaTest > 0 || material.map && material.alphaTest > 0) {
        const keyA = result.uuid, keyB = material.uuid;
        let materialsForVariant = _materialCache[keyA];
        if (materialsForVariant === void 0) {
          materialsForVariant = {};
          _materialCache[keyA] = materialsForVariant;
        }
        let cachedMaterial = materialsForVariant[keyB];
        if (cachedMaterial === void 0) {
          cachedMaterial = result.clone();
          materialsForVariant[keyB] = cachedMaterial;
          material.addEventListener("dispose", onMaterialDispose);
        }
        result = cachedMaterial;
      }
    }
    result.visible = material.visible;
    result.wireframe = material.wireframe;
    if (type === VSMShadowMap) {
      result.side = material.shadowSide !== null ? material.shadowSide : material.side;
    } else {
      result.side = material.shadowSide !== null ? material.shadowSide : shadowSide[material.side];
    }
    result.alphaMap = material.alphaMap;
    result.alphaTest = material.alphaTest;
    result.map = material.map;
    result.clipShadows = material.clipShadows;
    result.clippingPlanes = material.clippingPlanes;
    result.clipIntersection = material.clipIntersection;
    result.displacementMap = material.displacementMap;
    result.displacementScale = material.displacementScale;
    result.displacementBias = material.displacementBias;
    result.wireframeLinewidth = material.wireframeLinewidth;
    result.linewidth = material.linewidth;
    if (light.isPointLight === true && result.isMeshDistanceMaterial === true) {
      const materialProperties = renderer.properties.get(result);
      materialProperties.light = light;
    }
    return result;
  }
  function renderObject(object, camera, shadowCamera, light, type) {
    if (object.visible === false) return;
    const visible = object.layers.test(camera.layers);
    if (visible && (object.isMesh || object.isLine || object.isPoints)) {
      if ((object.castShadow || object.receiveShadow && type === VSMShadowMap) && (!object.frustumCulled || _frustum2.intersectsObject(object))) {
        object.modelViewMatrix.multiplyMatrices(shadowCamera.matrixWorldInverse, object.matrixWorld);
        const geometry = objects.update(object);
        const material = object.material;
        if (Array.isArray(material)) {
          const groups = geometry.groups;
          for (let k3 = 0, kl = groups.length; k3 < kl; k3++) {
            const group = groups[k3];
            const groupMaterial = material[group.materialIndex];
            if (groupMaterial && groupMaterial.visible) {
              const depthMaterial = getDepthMaterial(object, groupMaterial, light, type);
              object.onBeforeShadow(renderer, object, camera, shadowCamera, geometry, depthMaterial, group);
              renderer.renderBufferDirect(shadowCamera, null, geometry, depthMaterial, object, group);
              object.onAfterShadow(renderer, object, camera, shadowCamera, geometry, depthMaterial, group);
            }
          }
        } else if (material.visible) {
          const depthMaterial = getDepthMaterial(object, material, light, type);
          object.onBeforeShadow(renderer, object, camera, shadowCamera, geometry, depthMaterial, null);
          renderer.renderBufferDirect(shadowCamera, null, geometry, depthMaterial, object, null);
          object.onAfterShadow(renderer, object, camera, shadowCamera, geometry, depthMaterial, null);
        }
      }
    }
    const children = object.children;
    for (let i2 = 0, l2 = children.length; i2 < l2; i2++) {
      renderObject(children[i2], camera, shadowCamera, light, type);
    }
  }
  function onMaterialDispose(event) {
    const material = event.target;
    material.removeEventListener("dispose", onMaterialDispose);
    for (const id in _materialCache) {
      const cache = _materialCache[id];
      const uuid = event.target.uuid;
      if (uuid in cache) {
        const shadowMaterial = cache[uuid];
        shadowMaterial.dispose();
        delete cache[uuid];
      }
    }
  }
}
function WebGLState(gl) {
  function ColorBuffer() {
    let locked = false;
    const color = new Vector4();
    let currentColorMask = null;
    const currentColorClear = new Vector4(0, 0, 0, 0);
    return {
      setMask: function(colorMask) {
        if (currentColorMask !== colorMask && !locked) {
          gl.colorMask(colorMask, colorMask, colorMask, colorMask);
          currentColorMask = colorMask;
        }
      },
      setLocked: function(lock) {
        locked = lock;
      },
      setClear: function(r2, g3, b, a, premultipliedAlpha) {
        if (premultipliedAlpha === true) {
          r2 *= a;
          g3 *= a;
          b *= a;
        }
        color.set(r2, g3, b, a);
        if (currentColorClear.equals(color) === false) {
          gl.clearColor(r2, g3, b, a);
          currentColorClear.copy(color);
        }
      },
      reset: function() {
        locked = false;
        currentColorMask = null;
        currentColorClear.set(-1, 0, 0, 0);
      }
    };
  }
  function DepthBuffer() {
    let locked = false;
    let reversed = false;
    let currentDepthMask = null;
    let currentDepthFunc = null;
    let currentDepthClear = null;
    return {
      setReversed: function(value) {
        reversed = value;
      },
      setTest: function(depthTest) {
        if (depthTest) {
          enable(gl.DEPTH_TEST);
        } else {
          disable(gl.DEPTH_TEST);
        }
      },
      setMask: function(depthMask) {
        if (currentDepthMask !== depthMask && !locked) {
          gl.depthMask(depthMask);
          currentDepthMask = depthMask;
        }
      },
      setFunc: function(depthFunc) {
        if (reversed) depthFunc = reversedFuncs[depthFunc];
        if (currentDepthFunc !== depthFunc) {
          switch (depthFunc) {
            case NeverDepth:
              gl.depthFunc(gl.NEVER);
              break;
            case AlwaysDepth:
              gl.depthFunc(gl.ALWAYS);
              break;
            case LessDepth:
              gl.depthFunc(gl.LESS);
              break;
            case LessEqualDepth:
              gl.depthFunc(gl.LEQUAL);
              break;
            case EqualDepth:
              gl.depthFunc(gl.EQUAL);
              break;
            case GreaterEqualDepth:
              gl.depthFunc(gl.GEQUAL);
              break;
            case GreaterDepth:
              gl.depthFunc(gl.GREATER);
              break;
            case NotEqualDepth:
              gl.depthFunc(gl.NOTEQUAL);
              break;
            default:
              gl.depthFunc(gl.LEQUAL);
          }
          currentDepthFunc = depthFunc;
        }
      },
      setLocked: function(lock) {
        locked = lock;
      },
      setClear: function(depth) {
        if (currentDepthClear !== depth) {
          gl.clearDepth(depth);
          currentDepthClear = depth;
        }
      },
      reset: function() {
        locked = false;
        currentDepthMask = null;
        currentDepthFunc = null;
        currentDepthClear = null;
      }
    };
  }
  function StencilBuffer() {
    let locked = false;
    let currentStencilMask = null;
    let currentStencilFunc = null;
    let currentStencilRef = null;
    let currentStencilFuncMask = null;
    let currentStencilFail = null;
    let currentStencilZFail = null;
    let currentStencilZPass = null;
    let currentStencilClear = null;
    return {
      setTest: function(stencilTest) {
        if (!locked) {
          if (stencilTest) {
            enable(gl.STENCIL_TEST);
          } else {
            disable(gl.STENCIL_TEST);
          }
        }
      },
      setMask: function(stencilMask) {
        if (currentStencilMask !== stencilMask && !locked) {
          gl.stencilMask(stencilMask);
          currentStencilMask = stencilMask;
        }
      },
      setFunc: function(stencilFunc, stencilRef, stencilMask) {
        if (currentStencilFunc !== stencilFunc || currentStencilRef !== stencilRef || currentStencilFuncMask !== stencilMask) {
          gl.stencilFunc(stencilFunc, stencilRef, stencilMask);
          currentStencilFunc = stencilFunc;
          currentStencilRef = stencilRef;
          currentStencilFuncMask = stencilMask;
        }
      },
      setOp: function(stencilFail, stencilZFail, stencilZPass) {
        if (currentStencilFail !== stencilFail || currentStencilZFail !== stencilZFail || currentStencilZPass !== stencilZPass) {
          gl.stencilOp(stencilFail, stencilZFail, stencilZPass);
          currentStencilFail = stencilFail;
          currentStencilZFail = stencilZFail;
          currentStencilZPass = stencilZPass;
        }
      },
      setLocked: function(lock) {
        locked = lock;
      },
      setClear: function(stencil) {
        if (currentStencilClear !== stencil) {
          gl.clearStencil(stencil);
          currentStencilClear = stencil;
        }
      },
      reset: function() {
        locked = false;
        currentStencilMask = null;
        currentStencilFunc = null;
        currentStencilRef = null;
        currentStencilFuncMask = null;
        currentStencilFail = null;
        currentStencilZFail = null;
        currentStencilZPass = null;
        currentStencilClear = null;
      }
    };
  }
  const colorBuffer = new ColorBuffer();
  const depthBuffer = new DepthBuffer();
  const stencilBuffer = new StencilBuffer();
  const uboBindings = /* @__PURE__ */ new WeakMap();
  const uboProgramMap = /* @__PURE__ */ new WeakMap();
  let enabledCapabilities = {};
  let currentBoundFramebuffers = {};
  let currentDrawbuffers = /* @__PURE__ */ new WeakMap();
  let defaultDrawbuffers = [];
  let currentProgram = null;
  let currentBlendingEnabled = false;
  let currentBlending = null;
  let currentBlendEquation = null;
  let currentBlendSrc = null;
  let currentBlendDst = null;
  let currentBlendEquationAlpha = null;
  let currentBlendSrcAlpha = null;
  let currentBlendDstAlpha = null;
  let currentBlendColor = new Color(0, 0, 0);
  let currentBlendAlpha = 0;
  let currentPremultipledAlpha = false;
  let currentFlipSided = null;
  let currentCullFace = null;
  let currentLineWidth = null;
  let currentPolygonOffsetFactor = null;
  let currentPolygonOffsetUnits = null;
  const maxTextures = gl.getParameter(gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
  let lineWidthAvailable = false;
  let version3 = 0;
  const glVersion = gl.getParameter(gl.VERSION);
  if (glVersion.indexOf("WebGL") !== -1) {
    version3 = parseFloat(/^WebGL (\d)/.exec(glVersion)[1]);
    lineWidthAvailable = version3 >= 1;
  } else if (glVersion.indexOf("OpenGL ES") !== -1) {
    version3 = parseFloat(/^OpenGL ES (\d)/.exec(glVersion)[1]);
    lineWidthAvailable = version3 >= 2;
  }
  let currentTextureSlot = null;
  let currentBoundTextures = {};
  const scissorParam = gl.getParameter(gl.SCISSOR_BOX);
  const viewportParam = gl.getParameter(gl.VIEWPORT);
  const currentScissor = new Vector4().fromArray(scissorParam);
  const currentViewport = new Vector4().fromArray(viewportParam);
  function createTexture(type, target2, count, dimensions) {
    const data = new Uint8Array(4);
    const texture = gl.createTexture();
    gl.bindTexture(type, texture);
    gl.texParameteri(type, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
    gl.texParameteri(type, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
    for (let i2 = 0; i2 < count; i2++) {
      if (type === gl.TEXTURE_3D || type === gl.TEXTURE_2D_ARRAY) {
        gl.texImage3D(target2, 0, gl.RGBA, 1, 1, dimensions, 0, gl.RGBA, gl.UNSIGNED_BYTE, data);
      } else {
        gl.texImage2D(target2 + i2, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, data);
      }
    }
    return texture;
  }
  const emptyTextures = {};
  emptyTextures[gl.TEXTURE_2D] = createTexture(gl.TEXTURE_2D, gl.TEXTURE_2D, 1);
  emptyTextures[gl.TEXTURE_CUBE_MAP] = createTexture(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_CUBE_MAP_POSITIVE_X, 6);
  emptyTextures[gl.TEXTURE_2D_ARRAY] = createTexture(gl.TEXTURE_2D_ARRAY, gl.TEXTURE_2D_ARRAY, 1, 1);
  emptyTextures[gl.TEXTURE_3D] = createTexture(gl.TEXTURE_3D, gl.TEXTURE_3D, 1, 1);
  colorBuffer.setClear(0, 0, 0, 1);
  depthBuffer.setClear(1);
  stencilBuffer.setClear(0);
  enable(gl.DEPTH_TEST);
  depthBuffer.setFunc(LessEqualDepth);
  setFlipSided(false);
  setCullFace(CullFaceBack);
  enable(gl.CULL_FACE);
  setBlending(NoBlending);
  function enable(id) {
    if (enabledCapabilities[id] !== true) {
      gl.enable(id);
      enabledCapabilities[id] = true;
    }
  }
  function disable(id) {
    if (enabledCapabilities[id] !== false) {
      gl.disable(id);
      enabledCapabilities[id] = false;
    }
  }
  function bindFramebuffer(target2, framebuffer) {
    if (currentBoundFramebuffers[target2] !== framebuffer) {
      gl.bindFramebuffer(target2, framebuffer);
      currentBoundFramebuffers[target2] = framebuffer;
      if (target2 === gl.DRAW_FRAMEBUFFER) {
        currentBoundFramebuffers[gl.FRAMEBUFFER] = framebuffer;
      }
      if (target2 === gl.FRAMEBUFFER) {
        currentBoundFramebuffers[gl.DRAW_FRAMEBUFFER] = framebuffer;
      }
      return true;
    }
    return false;
  }
  function drawBuffers(renderTarget, framebuffer) {
    let drawBuffers2 = defaultDrawbuffers;
    let needsUpdate = false;
    if (renderTarget) {
      drawBuffers2 = currentDrawbuffers.get(framebuffer);
      if (drawBuffers2 === void 0) {
        drawBuffers2 = [];
        currentDrawbuffers.set(framebuffer, drawBuffers2);
      }
      const textures = renderTarget.textures;
      if (drawBuffers2.length !== textures.length || drawBuffers2[0] !== gl.COLOR_ATTACHMENT0) {
        for (let i2 = 0, il = textures.length; i2 < il; i2++) {
          drawBuffers2[i2] = gl.COLOR_ATTACHMENT0 + i2;
        }
        drawBuffers2.length = textures.length;
        needsUpdate = true;
      }
    } else {
      if (drawBuffers2[0] !== gl.BACK) {
        drawBuffers2[0] = gl.BACK;
        needsUpdate = true;
      }
    }
    if (needsUpdate) {
      gl.drawBuffers(drawBuffers2);
    }
  }
  function useProgram(program) {
    if (currentProgram !== program) {
      gl.useProgram(program);
      currentProgram = program;
      return true;
    }
    return false;
  }
  const equationToGL = {
    [AddEquation]: gl.FUNC_ADD,
    [SubtractEquation]: gl.FUNC_SUBTRACT,
    [ReverseSubtractEquation]: gl.FUNC_REVERSE_SUBTRACT
  };
  equationToGL[MinEquation] = gl.MIN;
  equationToGL[MaxEquation] = gl.MAX;
  const factorToGL = {
    [ZeroFactor]: gl.ZERO,
    [OneFactor]: gl.ONE,
    [SrcColorFactor]: gl.SRC_COLOR,
    [SrcAlphaFactor]: gl.SRC_ALPHA,
    [SrcAlphaSaturateFactor]: gl.SRC_ALPHA_SATURATE,
    [DstColorFactor]: gl.DST_COLOR,
    [DstAlphaFactor]: gl.DST_ALPHA,
    [OneMinusSrcColorFactor]: gl.ONE_MINUS_SRC_COLOR,
    [OneMinusSrcAlphaFactor]: gl.ONE_MINUS_SRC_ALPHA,
    [OneMinusDstColorFactor]: gl.ONE_MINUS_DST_COLOR,
    [OneMinusDstAlphaFactor]: gl.ONE_MINUS_DST_ALPHA,
    [ConstantColorFactor]: gl.CONSTANT_COLOR,
    [OneMinusConstantColorFactor]: gl.ONE_MINUS_CONSTANT_COLOR,
    [ConstantAlphaFactor]: gl.CONSTANT_ALPHA,
    [OneMinusConstantAlphaFactor]: gl.ONE_MINUS_CONSTANT_ALPHA
  };
  function setBlending(blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha, blendColor, blendAlpha, premultipliedAlpha) {
    if (blending === NoBlending) {
      if (currentBlendingEnabled === true) {
        disable(gl.BLEND);
        currentBlendingEnabled = false;
      }
      return;
    }
    if (currentBlendingEnabled === false) {
      enable(gl.BLEND);
      currentBlendingEnabled = true;
    }
    if (blending !== CustomBlending) {
      if (blending !== currentBlending || premultipliedAlpha !== currentPremultipledAlpha) {
        if (currentBlendEquation !== AddEquation || currentBlendEquationAlpha !== AddEquation) {
          gl.blendEquation(gl.FUNC_ADD);
          currentBlendEquation = AddEquation;
          currentBlendEquationAlpha = AddEquation;
        }
        if (premultipliedAlpha) {
          switch (blending) {
            case NormalBlending:
              gl.blendFuncSeparate(gl.ONE, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
              break;
            case AdditiveBlending:
              gl.blendFunc(gl.ONE, gl.ONE);
              break;
            case SubtractiveBlending:
              gl.blendFuncSeparate(gl.ZERO, gl.ONE_MINUS_SRC_COLOR, gl.ZERO, gl.ONE);
              break;
            case MultiplyBlending:
              gl.blendFuncSeparate(gl.ZERO, gl.SRC_COLOR, gl.ZERO, gl.SRC_ALPHA);
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", blending);
              break;
          }
        } else {
          switch (blending) {
            case NormalBlending:
              gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
              break;
            case AdditiveBlending:
              gl.blendFunc(gl.SRC_ALPHA, gl.ONE);
              break;
            case SubtractiveBlending:
              gl.blendFuncSeparate(gl.ZERO, gl.ONE_MINUS_SRC_COLOR, gl.ZERO, gl.ONE);
              break;
            case MultiplyBlending:
              gl.blendFunc(gl.ZERO, gl.SRC_COLOR);
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", blending);
              break;
          }
        }
        currentBlendSrc = null;
        currentBlendDst = null;
        currentBlendSrcAlpha = null;
        currentBlendDstAlpha = null;
        currentBlendColor.set(0, 0, 0);
        currentBlendAlpha = 0;
        currentBlending = blending;
        currentPremultipledAlpha = premultipliedAlpha;
      }
      return;
    }
    blendEquationAlpha = blendEquationAlpha || blendEquation;
    blendSrcAlpha = blendSrcAlpha || blendSrc;
    blendDstAlpha = blendDstAlpha || blendDst;
    if (blendEquation !== currentBlendEquation || blendEquationAlpha !== currentBlendEquationAlpha) {
      gl.blendEquationSeparate(equationToGL[blendEquation], equationToGL[blendEquationAlpha]);
      currentBlendEquation = blendEquation;
      currentBlendEquationAlpha = blendEquationAlpha;
    }
    if (blendSrc !== currentBlendSrc || blendDst !== currentBlendDst || blendSrcAlpha !== currentBlendSrcAlpha || blendDstAlpha !== currentBlendDstAlpha) {
      gl.blendFuncSeparate(factorToGL[blendSrc], factorToGL[blendDst], factorToGL[blendSrcAlpha], factorToGL[blendDstAlpha]);
      currentBlendSrc = blendSrc;
      currentBlendDst = blendDst;
      currentBlendSrcAlpha = blendSrcAlpha;
      currentBlendDstAlpha = blendDstAlpha;
    }
    if (blendColor.equals(currentBlendColor) === false || blendAlpha !== currentBlendAlpha) {
      gl.blendColor(blendColor.r, blendColor.g, blendColor.b, blendAlpha);
      currentBlendColor.copy(blendColor);
      currentBlendAlpha = blendAlpha;
    }
    currentBlending = blending;
    currentPremultipledAlpha = false;
  }
  function setMaterial(material, frontFaceCW) {
    material.side === DoubleSide ? disable(gl.CULL_FACE) : enable(gl.CULL_FACE);
    let flipSided = material.side === BackSide;
    if (frontFaceCW) flipSided = !flipSided;
    setFlipSided(flipSided);
    material.blending === NormalBlending && material.transparent === false ? setBlending(NoBlending) : setBlending(material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha, material.blendColor, material.blendAlpha, material.premultipliedAlpha);
    depthBuffer.setFunc(material.depthFunc);
    depthBuffer.setTest(material.depthTest);
    depthBuffer.setMask(material.depthWrite);
    colorBuffer.setMask(material.colorWrite);
    const stencilWrite = material.stencilWrite;
    stencilBuffer.setTest(stencilWrite);
    if (stencilWrite) {
      stencilBuffer.setMask(material.stencilWriteMask);
      stencilBuffer.setFunc(material.stencilFunc, material.stencilRef, material.stencilFuncMask);
      stencilBuffer.setOp(material.stencilFail, material.stencilZFail, material.stencilZPass);
    }
    setPolygonOffset(material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits);
    material.alphaToCoverage === true ? enable(gl.SAMPLE_ALPHA_TO_COVERAGE) : disable(gl.SAMPLE_ALPHA_TO_COVERAGE);
  }
  function setFlipSided(flipSided) {
    if (currentFlipSided !== flipSided) {
      if (flipSided) {
        gl.frontFace(gl.CW);
      } else {
        gl.frontFace(gl.CCW);
      }
      currentFlipSided = flipSided;
    }
  }
  function setCullFace(cullFace) {
    if (cullFace !== CullFaceNone) {
      enable(gl.CULL_FACE);
      if (cullFace !== currentCullFace) {
        if (cullFace === CullFaceBack) {
          gl.cullFace(gl.BACK);
        } else if (cullFace === CullFaceFront) {
          gl.cullFace(gl.FRONT);
        } else {
          gl.cullFace(gl.FRONT_AND_BACK);
        }
      }
    } else {
      disable(gl.CULL_FACE);
    }
    currentCullFace = cullFace;
  }
  function setLineWidth(width) {
    if (width !== currentLineWidth) {
      if (lineWidthAvailable) gl.lineWidth(width);
      currentLineWidth = width;
    }
  }
  function setPolygonOffset(polygonOffset, factor, units) {
    if (polygonOffset) {
      enable(gl.POLYGON_OFFSET_FILL);
      if (currentPolygonOffsetFactor !== factor || currentPolygonOffsetUnits !== units) {
        gl.polygonOffset(factor, units);
        currentPolygonOffsetFactor = factor;
        currentPolygonOffsetUnits = units;
      }
    } else {
      disable(gl.POLYGON_OFFSET_FILL);
    }
  }
  function setScissorTest(scissorTest) {
    if (scissorTest) {
      enable(gl.SCISSOR_TEST);
    } else {
      disable(gl.SCISSOR_TEST);
    }
  }
  function activeTexture(webglSlot) {
    if (webglSlot === void 0) webglSlot = gl.TEXTURE0 + maxTextures - 1;
    if (currentTextureSlot !== webglSlot) {
      gl.activeTexture(webglSlot);
      currentTextureSlot = webglSlot;
    }
  }
  function bindTexture(webglType, webglTexture, webglSlot) {
    if (webglSlot === void 0) {
      if (currentTextureSlot === null) {
        webglSlot = gl.TEXTURE0 + maxTextures - 1;
      } else {
        webglSlot = currentTextureSlot;
      }
    }
    let boundTexture = currentBoundTextures[webglSlot];
    if (boundTexture === void 0) {
      boundTexture = { type: void 0, texture: void 0 };
      currentBoundTextures[webglSlot] = boundTexture;
    }
    if (boundTexture.type !== webglType || boundTexture.texture !== webglTexture) {
      if (currentTextureSlot !== webglSlot) {
        gl.activeTexture(webglSlot);
        currentTextureSlot = webglSlot;
      }
      gl.bindTexture(webglType, webglTexture || emptyTextures[webglType]);
      boundTexture.type = webglType;
      boundTexture.texture = webglTexture;
    }
  }
  function unbindTexture() {
    const boundTexture = currentBoundTextures[currentTextureSlot];
    if (boundTexture !== void 0 && boundTexture.type !== void 0) {
      gl.bindTexture(boundTexture.type, null);
      boundTexture.type = void 0;
      boundTexture.texture = void 0;
    }
  }
  function compressedTexImage2D() {
    try {
      gl.compressedTexImage2D.apply(gl, arguments);
    } catch (error2) {
      console.error("THREE.WebGLState:", error2);
    }
  }
  function compressedTexImage3D() {
    try {
      gl.compressedTexImage3D.apply(gl, arguments);
    } catch (error2) {
      console.error("THREE.WebGLState:", error2);
    }
  }
  function texSubImage2D() {
    try {
      gl.texSubImage2D.apply(gl, arguments);
    } catch (error2) {
      console.error("THREE.WebGLState:", error2);
    }
  }
  function texSubImage3D() {
    try {
      gl.texSubImage3D.apply(gl, arguments);
    } catch (error2) {
      console.error("THREE.WebGLState:", error2);
    }
  }
  function compressedTexSubImage2D() {
    try {
      gl.compressedTexSubImage2D.apply(gl, arguments);
    } catch (error2) {
      console.error("THREE.WebGLState:", error2);
    }
  }
  function compressedTexSubImage3D() {
    try {
      gl.compressedTexSubImage3D.apply(gl, arguments);
    } catch (error2) {
      console.error("THREE.WebGLState:", error2);
    }
  }
  function texStorage2D() {
    try {
      gl.texStorage2D.apply(gl, arguments);
    } catch (error2) {
      console.error("THREE.WebGLState:", error2);
    }
  }
  function texStorage3D() {
    try {
      gl.texStorage3D.apply(gl, arguments);
    } catch (error2) {
      console.error("THREE.WebGLState:", error2);
    }
  }
  function texImage2D() {
    try {
      gl.texImage2D.apply(gl, arguments);
    } catch (error2) {
      console.error("THREE.WebGLState:", error2);
    }
  }
  function texImage3D() {
    try {
      gl.texImage3D.apply(gl, arguments);
    } catch (error2) {
      console.error("THREE.WebGLState:", error2);
    }
  }
  function scissor(scissor2) {
    if (currentScissor.equals(scissor2) === false) {
      gl.scissor(scissor2.x, scissor2.y, scissor2.z, scissor2.w);
      currentScissor.copy(scissor2);
    }
  }
  function viewport(viewport2) {
    if (currentViewport.equals(viewport2) === false) {
      gl.viewport(viewport2.x, viewport2.y, viewport2.z, viewport2.w);
      currentViewport.copy(viewport2);
    }
  }
  function updateUBOMapping(uniformsGroup, program) {
    let mapping = uboProgramMap.get(program);
    if (mapping === void 0) {
      mapping = /* @__PURE__ */ new WeakMap();
      uboProgramMap.set(program, mapping);
    }
    let blockIndex = mapping.get(uniformsGroup);
    if (blockIndex === void 0) {
      blockIndex = gl.getUniformBlockIndex(program, uniformsGroup.name);
      mapping.set(uniformsGroup, blockIndex);
    }
  }
  function uniformBlockBinding(uniformsGroup, program) {
    const mapping = uboProgramMap.get(program);
    const blockIndex = mapping.get(uniformsGroup);
    if (uboBindings.get(program) !== blockIndex) {
      gl.uniformBlockBinding(program, blockIndex, uniformsGroup.__bindingPointIndex);
      uboBindings.set(program, blockIndex);
    }
  }
  function reset() {
    gl.disable(gl.BLEND);
    gl.disable(gl.CULL_FACE);
    gl.disable(gl.DEPTH_TEST);
    gl.disable(gl.POLYGON_OFFSET_FILL);
    gl.disable(gl.SCISSOR_TEST);
    gl.disable(gl.STENCIL_TEST);
    gl.disable(gl.SAMPLE_ALPHA_TO_COVERAGE);
    gl.blendEquation(gl.FUNC_ADD);
    gl.blendFunc(gl.ONE, gl.ZERO);
    gl.blendFuncSeparate(gl.ONE, gl.ZERO, gl.ONE, gl.ZERO);
    gl.blendColor(0, 0, 0, 0);
    gl.colorMask(true, true, true, true);
    gl.clearColor(0, 0, 0, 0);
    gl.depthMask(true);
    gl.depthFunc(gl.LESS);
    gl.clearDepth(1);
    gl.stencilMask(4294967295);
    gl.stencilFunc(gl.ALWAYS, 0, 4294967295);
    gl.stencilOp(gl.KEEP, gl.KEEP, gl.KEEP);
    gl.clearStencil(0);
    gl.cullFace(gl.BACK);
    gl.frontFace(gl.CCW);
    gl.polygonOffset(0, 0);
    gl.activeTexture(gl.TEXTURE0);
    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, null);
    gl.bindFramebuffer(gl.READ_FRAMEBUFFER, null);
    gl.useProgram(null);
    gl.lineWidth(1);
    gl.scissor(0, 0, gl.canvas.width, gl.canvas.height);
    gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
    enabledCapabilities = {};
    currentTextureSlot = null;
    currentBoundTextures = {};
    currentBoundFramebuffers = {};
    currentDrawbuffers = /* @__PURE__ */ new WeakMap();
    defaultDrawbuffers = [];
    currentProgram = null;
    currentBlendingEnabled = false;
    currentBlending = null;
    currentBlendEquation = null;
    currentBlendSrc = null;
    currentBlendDst = null;
    currentBlendEquationAlpha = null;
    currentBlendSrcAlpha = null;
    currentBlendDstAlpha = null;
    currentBlendColor = new Color(0, 0, 0);
    currentBlendAlpha = 0;
    currentPremultipledAlpha = false;
    currentFlipSided = null;
    currentCullFace = null;
    currentLineWidth = null;
    currentPolygonOffsetFactor = null;
    currentPolygonOffsetUnits = null;
    currentScissor.set(0, 0, gl.canvas.width, gl.canvas.height);
    currentViewport.set(0, 0, gl.canvas.width, gl.canvas.height);
    colorBuffer.reset();
    depthBuffer.reset();
    stencilBuffer.reset();
  }
  return {
    buffers: {
      color: colorBuffer,
      depth: depthBuffer,
      stencil: stencilBuffer
    },
    enable,
    disable,
    bindFramebuffer,
    drawBuffers,
    useProgram,
    setBlending,
    setMaterial,
    setFlipSided,
    setCullFace,
    setLineWidth,
    setPolygonOffset,
    setScissorTest,
    activeTexture,
    bindTexture,
    unbindTexture,
    compressedTexImage2D,
    compressedTexImage3D,
    texImage2D,
    texImage3D,
    updateUBOMapping,
    uniformBlockBinding,
    texStorage2D,
    texStorage3D,
    texSubImage2D,
    texSubImage3D,
    compressedTexSubImage2D,
    compressedTexSubImage3D,
    scissor,
    viewport,
    reset
  };
}
function contain(texture, aspect2) {
  const imageAspect = texture.image && texture.image.width ? texture.image.width / texture.image.height : 1;
  if (imageAspect > aspect2) {
    texture.repeat.x = 1;
    texture.repeat.y = imageAspect / aspect2;
    texture.offset.x = 0;
    texture.offset.y = (1 - texture.repeat.y) / 2;
  } else {
    texture.repeat.x = aspect2 / imageAspect;
    texture.repeat.y = 1;
    texture.offset.x = (1 - texture.repeat.x) / 2;
    texture.offset.y = 0;
  }
  return texture;
}
function cover(texture, aspect2) {
  const imageAspect = texture.image && texture.image.width ? texture.image.width / texture.image.height : 1;
  if (imageAspect > aspect2) {
    texture.repeat.x = aspect2 / imageAspect;
    texture.repeat.y = 1;
    texture.offset.x = (1 - texture.repeat.x) / 2;
    texture.offset.y = 0;
  } else {
    texture.repeat.x = 1;
    texture.repeat.y = imageAspect / aspect2;
    texture.offset.x = 0;
    texture.offset.y = (1 - texture.repeat.y) / 2;
  }
  return texture;
}
function fill(texture) {
  texture.repeat.x = 1;
  texture.repeat.y = 1;
  texture.offset.x = 0;
  texture.offset.y = 0;
  return texture;
}
function getByteLength(width, height, format, type) {
  const typeByteLength = getTextureTypeByteLength(type);
  switch (format) {
    // https://registry.khronos.org/OpenGL-Refpages/es3.0/html/glTexImage2D.xhtml
    case AlphaFormat:
      return width * height;
    case LuminanceFormat:
      return width * height;
    case LuminanceAlphaFormat:
      return width * height * 2;
    case RedFormat:
      return width * height / typeByteLength.components * typeByteLength.byteLength;
    case RedIntegerFormat:
      return width * height / typeByteLength.components * typeByteLength.byteLength;
    case RGFormat:
      return width * height * 2 / typeByteLength.components * typeByteLength.byteLength;
    case RGIntegerFormat:
      return width * height * 2 / typeByteLength.components * typeByteLength.byteLength;
    case RGBFormat:
      return width * height * 3 / typeByteLength.components * typeByteLength.byteLength;
    case RGBAFormat:
      return width * height * 4 / typeByteLength.components * typeByteLength.byteLength;
    case RGBAIntegerFormat:
      return width * height * 4 / typeByteLength.components * typeByteLength.byteLength;
    // https://registry.khronos.org/webgl/extensions/WEBGL_compressed_texture_s3tc_srgb/
    case RGB_S3TC_DXT1_Format:
    case RGBA_S3TC_DXT1_Format:
      return Math.floor((width + 3) / 4) * Math.floor((height + 3) / 4) * 8;
    case RGBA_S3TC_DXT3_Format:
    case RGBA_S3TC_DXT5_Format:
      return Math.floor((width + 3) / 4) * Math.floor((height + 3) / 4) * 16;
    // https://registry.khronos.org/webgl/extensions/WEBGL_compressed_texture_pvrtc/
    case RGB_PVRTC_2BPPV1_Format:
    case RGBA_PVRTC_2BPPV1_Format:
      return Math.max(width, 16) * Math.max(height, 8) / 4;
    case RGB_PVRTC_4BPPV1_Format:
    case RGBA_PVRTC_4BPPV1_Format:
      return Math.max(width, 8) * Math.max(height, 8) / 2;
    // https://registry.khronos.org/webgl/extensions/WEBGL_compressed_texture_etc/
    case RGB_ETC1_Format:
    case RGB_ETC2_Format:
      return Math.floor((width + 3) / 4) * Math.floor((height + 3) / 4) * 8;
    case RGBA_ETC2_EAC_Format:
      return Math.floor((width + 3) / 4) * Math.floor((height + 3) / 4) * 16;
    // https://registry.khronos.org/webgl/extensions/WEBGL_compressed_texture_astc/
    case RGBA_ASTC_4x4_Format:
      return Math.floor((width + 3) / 4) * Math.floor((height + 3) / 4) * 16;
    case RGBA_ASTC_5x4_Format:
      return Math.floor((width + 4) / 5) * Math.floor((height + 3) / 4) * 16;
    case RGBA_ASTC_5x5_Format:
      return Math.floor((width + 4) / 5) * Math.floor((height + 4) / 5) * 16;
    case RGBA_ASTC_6x5_Format:
      return Math.floor((width + 5) / 6) * Math.floor((height + 4) / 5) * 16;
    case RGBA_ASTC_6x6_Format:
      return Math.floor((width + 5) / 6) * Math.floor((height + 5) / 6) * 16;
    case RGBA_ASTC_8x5_Format:
      return Math.floor((width + 7) / 8) * Math.floor((height + 4) / 5) * 16;
    case RGBA_ASTC_8x6_Format:
      return Math.floor((width + 7) / 8) * Math.floor((height + 5) / 6) * 16;
    case RGBA_ASTC_8x8_Format:
      return Math.floor((width + 7) / 8) * Math.floor((height + 7) / 8) * 16;
    case RGBA_ASTC_10x5_Format:
      return Math.floor((width + 9) / 10) * Math.floor((height + 4) / 5) * 16;
    case RGBA_ASTC_10x6_Format:
      return Math.floor((width + 9) / 10) * Math.floor((height + 5) / 6) * 16;
    case RGBA_ASTC_10x8_Format:
      return Math.floor((width + 9) / 10) * Math.floor((height + 7) / 8) * 16;
    case RGBA_ASTC_10x10_Format:
      return Math.floor((width + 9) / 10) * Math.floor((height + 9) / 10) * 16;
    case RGBA_ASTC_12x10_Format:
      return Math.floor((width + 11) / 12) * Math.floor((height + 9) / 10) * 16;
    case RGBA_ASTC_12x12_Format:
      return Math.floor((width + 11) / 12) * Math.floor((height + 11) / 12) * 16;
    // https://registry.khronos.org/webgl/extensions/EXT_texture_compression_bptc/
    case RGBA_BPTC_Format:
    case RGB_BPTC_SIGNED_Format:
    case RGB_BPTC_UNSIGNED_Format:
      return Math.ceil(width / 4) * Math.ceil(height / 4) * 16;
    // https://registry.khronos.org/webgl/extensions/EXT_texture_compression_rgtc/
    case RED_RGTC1_Format:
    case SIGNED_RED_RGTC1_Format:
      return Math.ceil(width / 4) * Math.ceil(height / 4) * 8;
    case RED_GREEN_RGTC2_Format:
    case SIGNED_RED_GREEN_RGTC2_Format:
      return Math.ceil(width / 4) * Math.ceil(height / 4) * 16;
  }
  throw new Error(
    `Unable to determine texture byte length for ${format} format.`
  );
}
function getTextureTypeByteLength(type) {
  switch (type) {
    case UnsignedByteType:
    case ByteType:
      return { byteLength: 1, components: 1 };
    case UnsignedShortType:
    case ShortType:
    case HalfFloatType:
      return { byteLength: 2, components: 1 };
    case UnsignedShort4444Type:
    case UnsignedShort5551Type:
      return { byteLength: 2, components: 4 };
    case UnsignedIntType:
    case IntType:
    case FloatType:
      return { byteLength: 4, components: 1 };
    case UnsignedInt5999Type:
      return { byteLength: 4, components: 3 };
  }
  throw new Error(`Unknown texture type ${type}.`);
}
function WebGLTextures(_gl, extensions, state, properties, capabilities, utils, info) {
  const multisampledRTTExt = extensions.has("WEBGL_multisampled_render_to_texture") ? extensions.get("WEBGL_multisampled_render_to_texture") : null;
  const supportsInvalidateFramebuffer = typeof navigator === "undefined" ? false : /OculusBrowser/g.test(navigator.userAgent);
  const _imageDimensions = new Vector2();
  const _videoTextures = /* @__PURE__ */ new WeakMap();
  let _canvas2;
  const _sources = /* @__PURE__ */ new WeakMap();
  let useOffscreenCanvas = false;
  try {
    useOffscreenCanvas = typeof OffscreenCanvas !== "undefined" && new OffscreenCanvas(1, 1).getContext("2d") !== null;
  } catch (err) {
  }
  function createCanvas(width, height) {
    return useOffscreenCanvas ? (
      // eslint-disable-next-line compat/compat
      new OffscreenCanvas(width, height)
    ) : createElementNS("canvas");
  }
  function resizeImage(image, needsNewCanvas, maxSize) {
    let scale = 1;
    const dimensions = getDimensions(image);
    if (dimensions.width > maxSize || dimensions.height > maxSize) {
      scale = maxSize / Math.max(dimensions.width, dimensions.height);
    }
    if (scale < 1) {
      if (typeof HTMLImageElement !== "undefined" && image instanceof HTMLImageElement || typeof HTMLCanvasElement !== "undefined" && image instanceof HTMLCanvasElement || typeof ImageBitmap !== "undefined" && image instanceof ImageBitmap || typeof VideoFrame !== "undefined" && image instanceof VideoFrame) {
        const width = Math.floor(scale * dimensions.width);
        const height = Math.floor(scale * dimensions.height);
        if (_canvas2 === void 0) _canvas2 = createCanvas(width, height);
        const canvas = needsNewCanvas ? createCanvas(width, height) : _canvas2;
        canvas.width = width;
        canvas.height = height;
        const context2 = canvas.getContext("2d");
        context2.drawImage(image, 0, 0, width, height);
        console.warn("THREE.WebGLRenderer: Texture has been resized from (" + dimensions.width + "x" + dimensions.height + ") to (" + width + "x" + height + ").");
        return canvas;
      } else {
        if ("data" in image) {
          console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + dimensions.width + "x" + dimensions.height + ").");
        }
        return image;
      }
    }
    return image;
  }
  function textureNeedsGenerateMipmaps(texture) {
    return texture.generateMipmaps && texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter;
  }
  function generateMipmap(target2) {
    _gl.generateMipmap(target2);
  }
  function getInternalFormat(internalFormatName, glFormat, glType, colorSpace, forceLinearTransfer = false) {
    if (internalFormatName !== null) {
      if (_gl[internalFormatName] !== void 0) return _gl[internalFormatName];
      console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + internalFormatName + "'");
    }
    let internalFormat = glFormat;
    if (glFormat === _gl.RED) {
      if (glType === _gl.FLOAT) internalFormat = _gl.R32F;
      if (glType === _gl.HALF_FLOAT) internalFormat = _gl.R16F;
      if (glType === _gl.UNSIGNED_BYTE) internalFormat = _gl.R8;
    }
    if (glFormat === _gl.RED_INTEGER) {
      if (glType === _gl.UNSIGNED_BYTE) internalFormat = _gl.R8UI;
      if (glType === _gl.UNSIGNED_SHORT) internalFormat = _gl.R16UI;
      if (glType === _gl.UNSIGNED_INT) internalFormat = _gl.R32UI;
      if (glType === _gl.BYTE) internalFormat = _gl.R8I;
      if (glType === _gl.SHORT) internalFormat = _gl.R16I;
      if (glType === _gl.INT) internalFormat = _gl.R32I;
    }
    if (glFormat === _gl.RG) {
      if (glType === _gl.FLOAT) internalFormat = _gl.RG32F;
      if (glType === _gl.HALF_FLOAT) internalFormat = _gl.RG16F;
      if (glType === _gl.UNSIGNED_BYTE) internalFormat = _gl.RG8;
    }
    if (glFormat === _gl.RG_INTEGER) {
      if (glType === _gl.UNSIGNED_BYTE) internalFormat = _gl.RG8UI;
      if (glType === _gl.UNSIGNED_SHORT) internalFormat = _gl.RG16UI;
      if (glType === _gl.UNSIGNED_INT) internalFormat = _gl.RG32UI;
      if (glType === _gl.BYTE) internalFormat = _gl.RG8I;
      if (glType === _gl.SHORT) internalFormat = _gl.RG16I;
      if (glType === _gl.INT) internalFormat = _gl.RG32I;
    }
    if (glFormat === _gl.RGB_INTEGER) {
      if (glType === _gl.UNSIGNED_BYTE) internalFormat = _gl.RGB8UI;
      if (glType === _gl.UNSIGNED_SHORT) internalFormat = _gl.RGB16UI;
      if (glType === _gl.UNSIGNED_INT) internalFormat = _gl.RGB32UI;
      if (glType === _gl.BYTE) internalFormat = _gl.RGB8I;
      if (glType === _gl.SHORT) internalFormat = _gl.RGB16I;
      if (glType === _gl.INT) internalFormat = _gl.RGB32I;
    }
    if (glFormat === _gl.RGBA_INTEGER) {
      if (glType === _gl.UNSIGNED_BYTE) internalFormat = _gl.RGBA8UI;
      if (glType === _gl.UNSIGNED_SHORT) internalFormat = _gl.RGBA16UI;
      if (glType === _gl.UNSIGNED_INT) internalFormat = _gl.RGBA32UI;
      if (glType === _gl.BYTE) internalFormat = _gl.RGBA8I;
      if (glType === _gl.SHORT) internalFormat = _gl.RGBA16I;
      if (glType === _gl.INT) internalFormat = _gl.RGBA32I;
    }
    if (glFormat === _gl.RGB) {
      if (glType === _gl.UNSIGNED_INT_5_9_9_9_REV) internalFormat = _gl.RGB9_E5;
    }
    if (glFormat === _gl.RGBA) {
      const transfer = forceLinearTransfer ? LinearTransfer : ColorManagement.getTransfer(colorSpace);
      if (glType === _gl.FLOAT) internalFormat = _gl.RGBA32F;
      if (glType === _gl.HALF_FLOAT) internalFormat = _gl.RGBA16F;
      if (glType === _gl.UNSIGNED_BYTE) internalFormat = transfer === SRGBTransfer ? _gl.SRGB8_ALPHA8 : _gl.RGBA8;
      if (glType === _gl.UNSIGNED_SHORT_4_4_4_4) internalFormat = _gl.RGBA4;
      if (glType === _gl.UNSIGNED_SHORT_5_5_5_1) internalFormat = _gl.RGB5_A1;
    }
    if (internalFormat === _gl.R16F || internalFormat === _gl.R32F || internalFormat === _gl.RG16F || internalFormat === _gl.RG32F || internalFormat === _gl.RGBA16F || internalFormat === _gl.RGBA32F) {
      extensions.get("EXT_color_buffer_float");
    }
    return internalFormat;
  }
  function getInternalDepthFormat(useStencil, depthType) {
    let glInternalFormat;
    if (useStencil) {
      if (depthType === null || depthType === UnsignedIntType || depthType === UnsignedInt248Type) {
        glInternalFormat = _gl.DEPTH24_STENCIL8;
      } else if (depthType === FloatType) {
        glInternalFormat = _gl.DEPTH32F_STENCIL8;
      } else if (depthType === UnsignedShortType) {
        glInternalFormat = _gl.DEPTH24_STENCIL8;
        console.warn("DepthTexture: 16 bit depth attachment is not supported with stencil. Using 24-bit attachment.");
      }
    } else {
      if (depthType === null || depthType === UnsignedIntType || depthType === UnsignedInt248Type) {
        glInternalFormat = _gl.DEPTH_COMPONENT24;
      } else if (depthType === FloatType) {
        glInternalFormat = _gl.DEPTH_COMPONENT32F;
      } else if (depthType === UnsignedShortType) {
        glInternalFormat = _gl.DEPTH_COMPONENT16;
      }
    }
    return glInternalFormat;
  }
  function getMipLevels(texture, image) {
    if (textureNeedsGenerateMipmaps(texture) === true || texture.isFramebufferTexture && texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter) {
      return Math.log2(Math.max(image.width, image.height)) + 1;
    } else if (texture.mipmaps !== void 0 && texture.mipmaps.length > 0) {
      return texture.mipmaps.length;
    } else if (texture.isCompressedTexture && Array.isArray(texture.image)) {
      return image.mipmaps.length;
    } else {
      return 1;
    }
  }
  function onTextureDispose(event) {
    const texture = event.target;
    texture.removeEventListener("dispose", onTextureDispose);
    deallocateTexture(texture);
    if (texture.isVideoTexture) {
      _videoTextures.delete(texture);
    }
  }
  function onRenderTargetDispose(event) {
    const renderTarget = event.target;
    renderTarget.removeEventListener("dispose", onRenderTargetDispose);
    deallocateRenderTarget(renderTarget);
  }
  function deallocateTexture(texture) {
    const textureProperties = properties.get(texture);
    if (textureProperties.__webglInit === void 0) return;
    const source = texture.source;
    const webglTextures = _sources.get(source);
    if (webglTextures) {
      const webglTexture = webglTextures[textureProperties.__cacheKey];
      webglTexture.usedTimes--;
      if (webglTexture.usedTimes === 0) {
        deleteTexture(texture);
      }
      if (Object.keys(webglTextures).length === 0) {
        _sources.delete(source);
      }
    }
    properties.remove(texture);
  }
  function deleteTexture(texture) {
    const textureProperties = properties.get(texture);
    _gl.deleteTexture(textureProperties.__webglTexture);
    const source = texture.source;
    const webglTextures = _sources.get(source);
    delete webglTextures[textureProperties.__cacheKey];
    info.memory.textures--;
  }
  function deallocateRenderTarget(renderTarget) {
    const renderTargetProperties = properties.get(renderTarget);
    if (renderTarget.depthTexture) {
      renderTarget.depthTexture.dispose();
    }
    if (renderTarget.isWebGLCubeRenderTarget) {
      for (let i2 = 0; i2 < 6; i2++) {
        if (Array.isArray(renderTargetProperties.__webglFramebuffer[i2])) {
          for (let level = 0; level < renderTargetProperties.__webglFramebuffer[i2].length; level++) _gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer[i2][level]);
        } else {
          _gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer[i2]);
        }
        if (renderTargetProperties.__webglDepthbuffer) _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer[i2]);
      }
    } else {
      if (Array.isArray(renderTargetProperties.__webglFramebuffer)) {
        for (let level = 0; level < renderTargetProperties.__webglFramebuffer.length; level++) _gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer[level]);
      } else {
        _gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer);
      }
      if (renderTargetProperties.__webglDepthbuffer) _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer);
      if (renderTargetProperties.__webglMultisampledFramebuffer) _gl.deleteFramebuffer(renderTargetProperties.__webglMultisampledFramebuffer);
      if (renderTargetProperties.__webglColorRenderbuffer) {
        for (let i2 = 0; i2 < renderTargetProperties.__webglColorRenderbuffer.length; i2++) {
          if (renderTargetProperties.__webglColorRenderbuffer[i2]) _gl.deleteRenderbuffer(renderTargetProperties.__webglColorRenderbuffer[i2]);
        }
      }
      if (renderTargetProperties.__webglDepthRenderbuffer) _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthRenderbuffer);
    }
    const textures = renderTarget.textures;
    for (let i2 = 0, il = textures.length; i2 < il; i2++) {
      const attachmentProperties = properties.get(textures[i2]);
      if (attachmentProperties.__webglTexture) {
        _gl.deleteTexture(attachmentProperties.__webglTexture);
        info.memory.textures--;
      }
      properties.remove(textures[i2]);
    }
    properties.remove(renderTarget);
  }
  let textureUnits = 0;
  function resetTextureUnits() {
    textureUnits = 0;
  }
  function allocateTextureUnit() {
    const textureUnit = textureUnits;
    if (textureUnit >= capabilities.maxTextures) {
      console.warn("THREE.WebGLTextures: Trying to use " + textureUnit + " texture units while this GPU supports only " + capabilities.maxTextures);
    }
    textureUnits += 1;
    return textureUnit;
  }
  function getTextureCacheKey(texture) {
    const array = [];
    array.push(texture.wrapS);
    array.push(texture.wrapT);
    array.push(texture.wrapR || 0);
    array.push(texture.magFilter);
    array.push(texture.minFilter);
    array.push(texture.anisotropy);
    array.push(texture.internalFormat);
    array.push(texture.format);
    array.push(texture.type);
    array.push(texture.generateMipmaps);
    array.push(texture.premultiplyAlpha);
    array.push(texture.flipY);
    array.push(texture.unpackAlignment);
    array.push(texture.colorSpace);
    return array.join();
  }
  function setTexture2D(texture, slot) {
    const textureProperties = properties.get(texture);
    if (texture.isVideoTexture) updateVideoTexture(texture);
    if (texture.isRenderTargetTexture === false && texture.version > 0 && textureProperties.__version !== texture.version) {
      const image = texture.image;
      if (image === null) {
        console.warn("THREE.WebGLRenderer: Texture marked for update but no image data found.");
      } else if (image.complete === false) {
        console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");
      } else {
        uploadTexture(textureProperties, texture, slot);
        return;
      }
    }
    state.bindTexture(_gl.TEXTURE_2D, textureProperties.__webglTexture, _gl.TEXTURE0 + slot);
  }
  function setTexture2DArray(texture, slot) {
    const textureProperties = properties.get(texture);
    if (texture.version > 0 && textureProperties.__version !== texture.version) {
      uploadTexture(textureProperties, texture, slot);
      return;
    }
    state.bindTexture(_gl.TEXTURE_2D_ARRAY, textureProperties.__webglTexture, _gl.TEXTURE0 + slot);
  }
  function setTexture3D(texture, slot) {
    const textureProperties = properties.get(texture);
    if (texture.version > 0 && textureProperties.__version !== texture.version) {
      uploadTexture(textureProperties, texture, slot);
      return;
    }
    state.bindTexture(_gl.TEXTURE_3D, textureProperties.__webglTexture, _gl.TEXTURE0 + slot);
  }
  function setTextureCube(texture, slot) {
    const textureProperties = properties.get(texture);
    if (texture.version > 0 && textureProperties.__version !== texture.version) {
      uploadCubeTexture(textureProperties, texture, slot);
      return;
    }
    state.bindTexture(_gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture, _gl.TEXTURE0 + slot);
  }
  const wrappingToGL = {
    [RepeatWrapping]: _gl.REPEAT,
    [ClampToEdgeWrapping]: _gl.CLAMP_TO_EDGE,
    [MirroredRepeatWrapping]: _gl.MIRRORED_REPEAT
  };
  const filterToGL = {
    [NearestFilter]: _gl.NEAREST,
    [NearestMipmapNearestFilter]: _gl.NEAREST_MIPMAP_NEAREST,
    [NearestMipmapLinearFilter]: _gl.NEAREST_MIPMAP_LINEAR,
    [LinearFilter]: _gl.LINEAR,
    [LinearMipmapNearestFilter]: _gl.LINEAR_MIPMAP_NEAREST,
    [LinearMipmapLinearFilter]: _gl.LINEAR_MIPMAP_LINEAR
  };
  const compareToGL = {
    [NeverCompare]: _gl.NEVER,
    [AlwaysCompare]: _gl.ALWAYS,
    [LessCompare]: _gl.LESS,
    [LessEqualCompare]: _gl.LEQUAL,
    [EqualCompare]: _gl.EQUAL,
    [GreaterEqualCompare]: _gl.GEQUAL,
    [GreaterCompare]: _gl.GREATER,
    [NotEqualCompare]: _gl.NOTEQUAL
  };
  function setTextureParameters(textureType, texture) {
    if (texture.type === FloatType && extensions.has("OES_texture_float_linear") === false && (texture.magFilter === LinearFilter || texture.magFilter === LinearMipmapNearestFilter || texture.magFilter === NearestMipmapLinearFilter || texture.magFilter === LinearMipmapLinearFilter || texture.minFilter === LinearFilter || texture.minFilter === LinearMipmapNearestFilter || texture.minFilter === NearestMipmapLinearFilter || texture.minFilter === LinearMipmapLinearFilter)) {
      console.warn("THREE.WebGLRenderer: Unable to use linear filtering with floating point textures. OES_texture_float_linear not supported on this device.");
    }
    _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_S, wrappingToGL[texture.wrapS]);
    _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_T, wrappingToGL[texture.wrapT]);
    if (textureType === _gl.TEXTURE_3D || textureType === _gl.TEXTURE_2D_ARRAY) {
      _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_R, wrappingToGL[texture.wrapR]);
    }
    _gl.texParameteri(textureType, _gl.TEXTURE_MAG_FILTER, filterToGL[texture.magFilter]);
    _gl.texParameteri(textureType, _gl.TEXTURE_MIN_FILTER, filterToGL[texture.minFilter]);
    if (texture.compareFunction) {
      _gl.texParameteri(textureType, _gl.TEXTURE_COMPARE_MODE, _gl.COMPARE_REF_TO_TEXTURE);
      _gl.texParameteri(textureType, _gl.TEXTURE_COMPARE_FUNC, compareToGL[texture.compareFunction]);
    }
    if (extensions.has("EXT_texture_filter_anisotropic") === true) {
      if (texture.magFilter === NearestFilter) return;
      if (texture.minFilter !== NearestMipmapLinearFilter && texture.minFilter !== LinearMipmapLinearFilter) return;
      if (texture.type === FloatType && extensions.has("OES_texture_float_linear") === false) return;
      if (texture.anisotropy > 1 || properties.get(texture).__currentAnisotropy) {
        const extension = extensions.get("EXT_texture_filter_anisotropic");
        _gl.texParameterf(textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(texture.anisotropy, capabilities.getMaxAnisotropy()));
        properties.get(texture).__currentAnisotropy = texture.anisotropy;
      }
    }
  }
  function initTexture(textureProperties, texture) {
    let forceUpload = false;
    if (textureProperties.__webglInit === void 0) {
      textureProperties.__webglInit = true;
      texture.addEventListener("dispose", onTextureDispose);
    }
    const source = texture.source;
    let webglTextures = _sources.get(source);
    if (webglTextures === void 0) {
      webglTextures = {};
      _sources.set(source, webglTextures);
    }
    const textureCacheKey = getTextureCacheKey(texture);
    if (textureCacheKey !== textureProperties.__cacheKey) {
      if (webglTextures[textureCacheKey] === void 0) {
        webglTextures[textureCacheKey] = {
          texture: _gl.createTexture(),
          usedTimes: 0
        };
        info.memory.textures++;
        forceUpload = true;
      }
      webglTextures[textureCacheKey].usedTimes++;
      const webglTexture = webglTextures[textureProperties.__cacheKey];
      if (webglTexture !== void 0) {
        webglTextures[textureProperties.__cacheKey].usedTimes--;
        if (webglTexture.usedTimes === 0) {
          deleteTexture(texture);
        }
      }
      textureProperties.__cacheKey = textureCacheKey;
      textureProperties.__webglTexture = webglTextures[textureCacheKey].texture;
    }
    return forceUpload;
  }
  function uploadTexture(textureProperties, texture, slot) {
    let textureType = _gl.TEXTURE_2D;
    if (texture.isDataArrayTexture || texture.isCompressedArrayTexture) textureType = _gl.TEXTURE_2D_ARRAY;
    if (texture.isData3DTexture) textureType = _gl.TEXTURE_3D;
    const forceUpload = initTexture(textureProperties, texture);
    const source = texture.source;
    state.bindTexture(textureType, textureProperties.__webglTexture, _gl.TEXTURE0 + slot);
    const sourceProperties = properties.get(source);
    if (source.version !== sourceProperties.__version || forceUpload === true) {
      state.activeTexture(_gl.TEXTURE0 + slot);
      const workingPrimaries = ColorManagement.getPrimaries(ColorManagement.workingColorSpace);
      const texturePrimaries = texture.colorSpace === NoColorSpace ? null : ColorManagement.getPrimaries(texture.colorSpace);
      const unpackConversion = texture.colorSpace === NoColorSpace || workingPrimaries === texturePrimaries ? _gl.NONE : _gl.BROWSER_DEFAULT_WEBGL;
      _gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, texture.flipY);
      _gl.pixelStorei(_gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha);
      _gl.pixelStorei(_gl.UNPACK_ALIGNMENT, texture.unpackAlignment);
      _gl.pixelStorei(_gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, unpackConversion);
      let image = resizeImage(texture.image, false, capabilities.maxTextureSize);
      image = verifyColorSpace(texture, image);
      const glFormat = utils.convert(texture.format, texture.colorSpace);
      const glType = utils.convert(texture.type);
      let glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType, texture.colorSpace, texture.isVideoTexture);
      setTextureParameters(textureType, texture);
      let mipmap;
      const mipmaps = texture.mipmaps;
      const useTexStorage = texture.isVideoTexture !== true;
      const allocateMemory = sourceProperties.__version === void 0 || forceUpload === true;
      const dataReady = source.dataReady;
      const levels = getMipLevels(texture, image);
      if (texture.isDepthTexture) {
        glInternalFormat = getInternalDepthFormat(texture.format === DepthStencilFormat, texture.type);
        if (allocateMemory) {
          if (useTexStorage) {
            state.texStorage2D(_gl.TEXTURE_2D, 1, glInternalFormat, image.width, image.height);
          } else {
            state.texImage2D(_gl.TEXTURE_2D, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, null);
          }
        }
      } else if (texture.isDataTexture) {
        if (mipmaps.length > 0) {
          if (useTexStorage && allocateMemory) {
            state.texStorage2D(_gl.TEXTURE_2D, levels, glInternalFormat, mipmaps[0].width, mipmaps[0].height);
          }
          for (let i2 = 0, il = mipmaps.length; i2 < il; i2++) {
            mipmap = mipmaps[i2];
            if (useTexStorage) {
              if (dataReady) {
                state.texSubImage2D(_gl.TEXTURE_2D, i2, 0, 0, mipmap.width, mipmap.height, glFormat, glType, mipmap.data);
              }
            } else {
              state.texImage2D(_gl.TEXTURE_2D, i2, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
            }
          }
          texture.generateMipmaps = false;
        } else {
          if (useTexStorage) {
            if (allocateMemory) {
              state.texStorage2D(_gl.TEXTURE_2D, levels, glInternalFormat, image.width, image.height);
            }
            if (dataReady) {
              state.texSubImage2D(_gl.TEXTURE_2D, 0, 0, 0, image.width, image.height, glFormat, glType, image.data);
            }
          } else {
            state.texImage2D(_gl.TEXTURE_2D, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, image.data);
          }
        }
      } else if (texture.isCompressedTexture) {
        if (texture.isCompressedArrayTexture) {
          if (useTexStorage && allocateMemory) {
            state.texStorage3D(_gl.TEXTURE_2D_ARRAY, levels, glInternalFormat, mipmaps[0].width, mipmaps[0].height, image.depth);
          }
          for (let i2 = 0, il = mipmaps.length; i2 < il; i2++) {
            mipmap = mipmaps[i2];
            if (texture.format !== RGBAFormat) {
              if (glFormat !== null) {
                if (useTexStorage) {
                  if (dataReady) {
                    if (texture.layerUpdates.size > 0) {
                      const layerByteLength = getByteLength(mipmap.width, mipmap.height, texture.format, texture.type);
                      for (const layerIndex of texture.layerUpdates) {
                        const layerData = mipmap.data.subarray(
                          layerIndex * layerByteLength / mipmap.data.BYTES_PER_ELEMENT,
                          (layerIndex + 1) * layerByteLength / mipmap.data.BYTES_PER_ELEMENT
                        );
                        state.compressedTexSubImage3D(_gl.TEXTURE_2D_ARRAY, i2, 0, 0, layerIndex, mipmap.width, mipmap.height, 1, glFormat, layerData, 0, 0);
                      }
                      texture.clearLayerUpdates();
                    } else {
                      state.compressedTexSubImage3D(_gl.TEXTURE_2D_ARRAY, i2, 0, 0, 0, mipmap.width, mipmap.height, image.depth, glFormat, mipmap.data, 0, 0);
                    }
                  }
                } else {
                  state.compressedTexImage3D(_gl.TEXTURE_2D_ARRAY, i2, glInternalFormat, mipmap.width, mipmap.height, image.depth, 0, mipmap.data, 0, 0);
                }
              } else {
                console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()");
              }
            } else {
              if (useTexStorage) {
                if (dataReady) {
                  state.texSubImage3D(_gl.TEXTURE_2D_ARRAY, i2, 0, 0, 0, mipmap.width, mipmap.height, image.depth, glFormat, glType, mipmap.data);
                }
              } else {
                state.texImage3D(_gl.TEXTURE_2D_ARRAY, i2, glInternalFormat, mipmap.width, mipmap.height, image.depth, 0, glFormat, glType, mipmap.data);
              }
            }
          }
        } else {
          if (useTexStorage && allocateMemory) {
            state.texStorage2D(_gl.TEXTURE_2D, levels, glInternalFormat, mipmaps[0].width, mipmaps[0].height);
          }
          for (let i2 = 0, il = mipmaps.length; i2 < il; i2++) {
            mipmap = mipmaps[i2];
            if (texture.format !== RGBAFormat) {
              if (glFormat !== null) {
                if (useTexStorage) {
                  if (dataReady) {
                    state.compressedTexSubImage2D(_gl.TEXTURE_2D, i2, 0, 0, mipmap.width, mipmap.height, glFormat, mipmap.data);
                  }
                } else {
                  state.compressedTexImage2D(_gl.TEXTURE_2D, i2, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data);
                }
              } else {
                console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()");
              }
            } else {
              if (useTexStorage) {
                if (dataReady) {
                  state.texSubImage2D(_gl.TEXTURE_2D, i2, 0, 0, mipmap.width, mipmap.height, glFormat, glType, mipmap.data);
                }
              } else {
                state.texImage2D(_gl.TEXTURE_2D, i2, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
              }
            }
          }
        }
      } else if (texture.isDataArrayTexture) {
        if (useTexStorage) {
          if (allocateMemory) {
            state.texStorage3D(_gl.TEXTURE_2D_ARRAY, levels, glInternalFormat, image.width, image.height, image.depth);
          }
          if (dataReady) {
            if (texture.layerUpdates.size > 0) {
              const layerByteLength = getByteLength(image.width, image.height, texture.format, texture.type);
              for (const layerIndex of texture.layerUpdates) {
                const layerData = image.data.subarray(
                  layerIndex * layerByteLength / image.data.BYTES_PER_ELEMENT,
                  (layerIndex + 1) * layerByteLength / image.data.BYTES_PER_ELEMENT
                );
                state.texSubImage3D(_gl.TEXTURE_2D_ARRAY, 0, 0, 0, layerIndex, image.width, image.height, 1, glFormat, glType, layerData);
              }
              texture.clearLayerUpdates();
            } else {
              state.texSubImage3D(_gl.TEXTURE_2D_ARRAY, 0, 0, 0, 0, image.width, image.height, image.depth, glFormat, glType, image.data);
            }
          }
        } else {
          state.texImage3D(_gl.TEXTURE_2D_ARRAY, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data);
        }
      } else if (texture.isData3DTexture) {
        if (useTexStorage) {
          if (allocateMemory) {
            state.texStorage3D(_gl.TEXTURE_3D, levels, glInternalFormat, image.width, image.height, image.depth);
          }
          if (dataReady) {
            state.texSubImage3D(_gl.TEXTURE_3D, 0, 0, 0, 0, image.width, image.height, image.depth, glFormat, glType, image.data);
          }
        } else {
          state.texImage3D(_gl.TEXTURE_3D, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data);
        }
      } else if (texture.isFramebufferTexture) {
        if (allocateMemory) {
          if (useTexStorage) {
            state.texStorage2D(_gl.TEXTURE_2D, levels, glInternalFormat, image.width, image.height);
          } else {
            let width = image.width, height = image.height;
            for (let i2 = 0; i2 < levels; i2++) {
              state.texImage2D(_gl.TEXTURE_2D, i2, glInternalFormat, width, height, 0, glFormat, glType, null);
              width >>= 1;
              height >>= 1;
            }
          }
        }
      } else {
        if (mipmaps.length > 0) {
          if (useTexStorage && allocateMemory) {
            const dimensions = getDimensions(mipmaps[0]);
            state.texStorage2D(_gl.TEXTURE_2D, levels, glInternalFormat, dimensions.width, dimensions.height);
          }
          for (let i2 = 0, il = mipmaps.length; i2 < il; i2++) {
            mipmap = mipmaps[i2];
            if (useTexStorage) {
              if (dataReady) {
                state.texSubImage2D(_gl.TEXTURE_2D, i2, 0, 0, glFormat, glType, mipmap);
              }
            } else {
              state.texImage2D(_gl.TEXTURE_2D, i2, glInternalFormat, glFormat, glType, mipmap);
            }
          }
          texture.generateMipmaps = false;
        } else {
          if (useTexStorage) {
            if (allocateMemory) {
              const dimensions = getDimensions(image);
              state.texStorage2D(_gl.TEXTURE_2D, levels, glInternalFormat, dimensions.width, dimensions.height);
            }
            if (dataReady) {
              state.texSubImage2D(_gl.TEXTURE_2D, 0, 0, 0, glFormat, glType, image);
            }
          } else {
            state.texImage2D(_gl.TEXTURE_2D, 0, glInternalFormat, glFormat, glType, image);
          }
        }
      }
      if (textureNeedsGenerateMipmaps(texture)) {
        generateMipmap(textureType);
      }
      sourceProperties.__version = source.version;
      if (texture.onUpdate) texture.onUpdate(texture);
    }
    textureProperties.__version = texture.version;
  }
  function uploadCubeTexture(textureProperties, texture, slot) {
    if (texture.image.length !== 6) return;
    const forceUpload = initTexture(textureProperties, texture);
    const source = texture.source;
    state.bindTexture(_gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture, _gl.TEXTURE0 + slot);
    const sourceProperties = properties.get(source);
    if (source.version !== sourceProperties.__version || forceUpload === true) {
      state.activeTexture(_gl.TEXTURE0 + slot);
      const workingPrimaries = ColorManagement.getPrimaries(ColorManagement.workingColorSpace);
      const texturePrimaries = texture.colorSpace === NoColorSpace ? null : ColorManagement.getPrimaries(texture.colorSpace);
      const unpackConversion = texture.colorSpace === NoColorSpace || workingPrimaries === texturePrimaries ? _gl.NONE : _gl.BROWSER_DEFAULT_WEBGL;
      _gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, texture.flipY);
      _gl.pixelStorei(_gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha);
      _gl.pixelStorei(_gl.UNPACK_ALIGNMENT, texture.unpackAlignment);
      _gl.pixelStorei(_gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, unpackConversion);
      const isCompressed = texture.isCompressedTexture || texture.image[0].isCompressedTexture;
      const isDataTexture = texture.image[0] && texture.image[0].isDataTexture;
      const cubeImage = [];
      for (let i2 = 0; i2 < 6; i2++) {
        if (!isCompressed && !isDataTexture) {
          cubeImage[i2] = resizeImage(texture.image[i2], true, capabilities.maxCubemapSize);
        } else {
          cubeImage[i2] = isDataTexture ? texture.image[i2].image : texture.image[i2];
        }
        cubeImage[i2] = verifyColorSpace(texture, cubeImage[i2]);
      }
      const image = cubeImage[0], glFormat = utils.convert(texture.format, texture.colorSpace), glType = utils.convert(texture.type), glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType, texture.colorSpace);
      const useTexStorage = texture.isVideoTexture !== true;
      const allocateMemory = sourceProperties.__version === void 0 || forceUpload === true;
      const dataReady = source.dataReady;
      let levels = getMipLevels(texture, image);
      setTextureParameters(_gl.TEXTURE_CUBE_MAP, texture);
      let mipmaps;
      if (isCompressed) {
        if (useTexStorage && allocateMemory) {
          state.texStorage2D(_gl.TEXTURE_CUBE_MAP, levels, glInternalFormat, image.width, image.height);
        }
        for (let i2 = 0; i2 < 6; i2++) {
          mipmaps = cubeImage[i2].mipmaps;
          for (let j2 = 0; j2 < mipmaps.length; j2++) {
            const mipmap = mipmaps[j2];
            if (texture.format !== RGBAFormat) {
              if (glFormat !== null) {
                if (useTexStorage) {
                  if (dataReady) {
                    state.compressedTexSubImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i2, j2, 0, 0, mipmap.width, mipmap.height, glFormat, mipmap.data);
                  }
                } else {
                  state.compressedTexImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i2, j2, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data);
                }
              } else {
                console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()");
              }
            } else {
              if (useTexStorage) {
                if (dataReady) {
                  state.texSubImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i2, j2, 0, 0, mipmap.width, mipmap.height, glFormat, glType, mipmap.data);
                }
              } else {
                state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i2, j2, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
              }
            }
          }
        }
      } else {
        mipmaps = texture.mipmaps;
        if (useTexStorage && allocateMemory) {
          if (mipmaps.length > 0) levels++;
          const dimensions = getDimensions(cubeImage[0]);
          state.texStorage2D(_gl.TEXTURE_CUBE_MAP, levels, glInternalFormat, dimensions.width, dimensions.height);
        }
        for (let i2 = 0; i2 < 6; i2++) {
          if (isDataTexture) {
            if (useTexStorage) {
              if (dataReady) {
                state.texSubImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i2, 0, 0, 0, cubeImage[i2].width, cubeImage[i2].height, glFormat, glType, cubeImage[i2].data);
              }
            } else {
              state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i2, 0, glInternalFormat, cubeImage[i2].width, cubeImage[i2].height, 0, glFormat, glType, cubeImage[i2].data);
            }
            for (let j2 = 0; j2 < mipmaps.length; j2++) {
              const mipmap = mipmaps[j2];
              const mipmapImage = mipmap.image[i2].image;
              if (useTexStorage) {
                if (dataReady) {
                  state.texSubImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i2, j2 + 1, 0, 0, mipmapImage.width, mipmapImage.height, glFormat, glType, mipmapImage.data);
                }
              } else {
                state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i2, j2 + 1, glInternalFormat, mipmapImage.width, mipmapImage.height, 0, glFormat, glType, mipmapImage.data);
              }
            }
          } else {
            if (useTexStorage) {
              if (dataReady) {
                state.texSubImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i2, 0, 0, 0, glFormat, glType, cubeImage[i2]);
              }
            } else {
              state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i2, 0, glInternalFormat, glFormat, glType, cubeImage[i2]);
            }
            for (let j2 = 0; j2 < mipmaps.length; j2++) {
              const mipmap = mipmaps[j2];
              if (useTexStorage) {
                if (dataReady) {
                  state.texSubImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i2, j2 + 1, 0, 0, glFormat, glType, mipmap.image[i2]);
                }
              } else {
                state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i2, j2 + 1, glInternalFormat, glFormat, glType, mipmap.image[i2]);
              }
            }
          }
        }
      }
      if (textureNeedsGenerateMipmaps(texture)) {
        generateMipmap(_gl.TEXTURE_CUBE_MAP);
      }
      sourceProperties.__version = source.version;
      if (texture.onUpdate) texture.onUpdate(texture);
    }
    textureProperties.__version = texture.version;
  }
  function setupFrameBufferTexture(framebuffer, renderTarget, texture, attachment, textureTarget, level) {
    const glFormat = utils.convert(texture.format, texture.colorSpace);
    const glType = utils.convert(texture.type);
    const glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType, texture.colorSpace);
    const renderTargetProperties = properties.get(renderTarget);
    if (!renderTargetProperties.__hasExternalTextures) {
      const width = Math.max(1, renderTarget.width >> level);
      const height = Math.max(1, renderTarget.height >> level);
      if (textureTarget === _gl.TEXTURE_3D || textureTarget === _gl.TEXTURE_2D_ARRAY) {
        state.texImage3D(textureTarget, level, glInternalFormat, width, height, renderTarget.depth, 0, glFormat, glType, null);
      } else {
        state.texImage2D(textureTarget, level, glInternalFormat, width, height, 0, glFormat, glType, null);
      }
    }
    state.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);
    if (useMultisampledRTT(renderTarget)) {
      multisampledRTTExt.framebufferTexture2DMultisampleEXT(_gl.FRAMEBUFFER, attachment, textureTarget, properties.get(texture).__webglTexture, 0, getRenderTargetSamples(renderTarget));
    } else if (textureTarget === _gl.TEXTURE_2D || textureTarget >= _gl.TEXTURE_CUBE_MAP_POSITIVE_X && textureTarget <= _gl.TEXTURE_CUBE_MAP_NEGATIVE_Z) {
      _gl.framebufferTexture2D(_gl.FRAMEBUFFER, attachment, textureTarget, properties.get(texture).__webglTexture, level);
    }
    state.bindFramebuffer(_gl.FRAMEBUFFER, null);
  }
  function setupRenderBufferStorage(renderbuffer, renderTarget, isMultisample) {
    _gl.bindRenderbuffer(_gl.RENDERBUFFER, renderbuffer);
    if (renderTarget.depthBuffer) {
      const depthTexture = renderTarget.depthTexture;
      const depthType = depthTexture && depthTexture.isDepthTexture ? depthTexture.type : null;
      const glInternalFormat = getInternalDepthFormat(renderTarget.stencilBuffer, depthType);
      const glAttachmentType = renderTarget.stencilBuffer ? _gl.DEPTH_STENCIL_ATTACHMENT : _gl.DEPTH_ATTACHMENT;
      const samples = getRenderTargetSamples(renderTarget);
      const isUseMultisampledRTT = useMultisampledRTT(renderTarget);
      if (isUseMultisampledRTT) {
        multisampledRTTExt.renderbufferStorageMultisampleEXT(_gl.RENDERBUFFER, samples, glInternalFormat, renderTarget.width, renderTarget.height);
      } else if (isMultisample) {
        _gl.renderbufferStorageMultisample(_gl.RENDERBUFFER, samples, glInternalFormat, renderTarget.width, renderTarget.height);
      } else {
        _gl.renderbufferStorage(_gl.RENDERBUFFER, glInternalFormat, renderTarget.width, renderTarget.height);
      }
      _gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, glAttachmentType, _gl.RENDERBUFFER, renderbuffer);
    } else {
      const textures = renderTarget.textures;
      for (let i2 = 0; i2 < textures.length; i2++) {
        const texture = textures[i2];
        const glFormat = utils.convert(texture.format, texture.colorSpace);
        const glType = utils.convert(texture.type);
        const glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType, texture.colorSpace);
        const samples = getRenderTargetSamples(renderTarget);
        if (isMultisample && useMultisampledRTT(renderTarget) === false) {
          _gl.renderbufferStorageMultisample(_gl.RENDERBUFFER, samples, glInternalFormat, renderTarget.width, renderTarget.height);
        } else if (useMultisampledRTT(renderTarget)) {
          multisampledRTTExt.renderbufferStorageMultisampleEXT(_gl.RENDERBUFFER, samples, glInternalFormat, renderTarget.width, renderTarget.height);
        } else {
          _gl.renderbufferStorage(_gl.RENDERBUFFER, glInternalFormat, renderTarget.width, renderTarget.height);
        }
      }
    }
    _gl.bindRenderbuffer(_gl.RENDERBUFFER, null);
  }
  function setupDepthTexture(framebuffer, renderTarget) {
    const isCube = renderTarget && renderTarget.isWebGLCubeRenderTarget;
    if (isCube) throw new Error("Depth Texture with cube render targets is not supported");
    state.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);
    if (!(renderTarget.depthTexture && renderTarget.depthTexture.isDepthTexture)) {
      throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
    }
    if (!properties.get(renderTarget.depthTexture).__webglTexture || renderTarget.depthTexture.image.width !== renderTarget.width || renderTarget.depthTexture.image.height !== renderTarget.height) {
      renderTarget.depthTexture.image.width = renderTarget.width;
      renderTarget.depthTexture.image.height = renderTarget.height;
      renderTarget.depthTexture.needsUpdate = true;
    }
    setTexture2D(renderTarget.depthTexture, 0);
    const webglDepthTexture = properties.get(renderTarget.depthTexture).__webglTexture;
    const samples = getRenderTargetSamples(renderTarget);
    if (renderTarget.depthTexture.format === DepthFormat) {
      if (useMultisampledRTT(renderTarget)) {
        multisampledRTTExt.framebufferTexture2DMultisampleEXT(_gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0, samples);
      } else {
        _gl.framebufferTexture2D(_gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0);
      }
    } else if (renderTarget.depthTexture.format === DepthStencilFormat) {
      if (useMultisampledRTT(renderTarget)) {
        multisampledRTTExt.framebufferTexture2DMultisampleEXT(_gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0, samples);
      } else {
        _gl.framebufferTexture2D(_gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0);
      }
    } else {
      throw new Error("Unknown depthTexture format");
    }
  }
  function setupDepthRenderbuffer(renderTarget) {
    const renderTargetProperties = properties.get(renderTarget);
    const isCube = renderTarget.isWebGLCubeRenderTarget === true;
    if (renderTargetProperties.__boundDepthTexture !== renderTarget.depthTexture) {
      const depthTexture = renderTarget.depthTexture;
      if (renderTargetProperties.__depthDisposeCallback) {
        renderTargetProperties.__depthDisposeCallback();
      }
      if (depthTexture) {
        const disposeEvent = () => {
          delete renderTargetProperties.__boundDepthTexture;
          delete renderTargetProperties.__depthDisposeCallback;
          depthTexture.removeEventListener("dispose", disposeEvent);
        };
        depthTexture.addEventListener("dispose", disposeEvent);
        renderTargetProperties.__depthDisposeCallback = disposeEvent;
      }
      renderTargetProperties.__boundDepthTexture = depthTexture;
    }
    if (renderTarget.depthTexture && !renderTargetProperties.__autoAllocateDepthBuffer) {
      if (isCube) throw new Error("target.depthTexture not supported in Cube render targets");
      setupDepthTexture(renderTargetProperties.__webglFramebuffer, renderTarget);
    } else {
      if (isCube) {
        renderTargetProperties.__webglDepthbuffer = [];
        for (let i2 = 0; i2 < 6; i2++) {
          state.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer[i2]);
          if (renderTargetProperties.__webglDepthbuffer[i2] === void 0) {
            renderTargetProperties.__webglDepthbuffer[i2] = _gl.createRenderbuffer();
            setupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer[i2], renderTarget, false);
          } else {
            const glAttachmentType = renderTarget.stencilBuffer ? _gl.DEPTH_STENCIL_ATTACHMENT : _gl.DEPTH_ATTACHMENT;
            const renderbuffer = renderTargetProperties.__webglDepthbuffer[i2];
            _gl.bindRenderbuffer(_gl.RENDERBUFFER, renderbuffer);
            _gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, glAttachmentType, _gl.RENDERBUFFER, renderbuffer);
          }
        }
      } else {
        state.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer);
        if (renderTargetProperties.__webglDepthbuffer === void 0) {
          renderTargetProperties.__webglDepthbuffer = _gl.createRenderbuffer();
          setupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer, renderTarget, false);
        } else {
          const glAttachmentType = renderTarget.stencilBuffer ? _gl.DEPTH_STENCIL_ATTACHMENT : _gl.DEPTH_ATTACHMENT;
          const renderbuffer = renderTargetProperties.__webglDepthbuffer;
          _gl.bindRenderbuffer(_gl.RENDERBUFFER, renderbuffer);
          _gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, glAttachmentType, _gl.RENDERBUFFER, renderbuffer);
        }
      }
    }
    state.bindFramebuffer(_gl.FRAMEBUFFER, null);
  }
  function rebindTextures(renderTarget, colorTexture, depthTexture) {
    const renderTargetProperties = properties.get(renderTarget);
    if (colorTexture !== void 0) {
      setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer, renderTarget, renderTarget.texture, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_2D, 0);
    }
    if (depthTexture !== void 0) {
      setupDepthRenderbuffer(renderTarget);
    }
  }
  function setupRenderTarget(renderTarget) {
    const texture = renderTarget.texture;
    const renderTargetProperties = properties.get(renderTarget);
    const textureProperties = properties.get(texture);
    renderTarget.addEventListener("dispose", onRenderTargetDispose);
    const textures = renderTarget.textures;
    const isCube = renderTarget.isWebGLCubeRenderTarget === true;
    const isMultipleRenderTargets = textures.length > 1;
    if (!isMultipleRenderTargets) {
      if (textureProperties.__webglTexture === void 0) {
        textureProperties.__webglTexture = _gl.createTexture();
      }
      textureProperties.__version = texture.version;
      info.memory.textures++;
    }
    if (isCube) {
      renderTargetProperties.__webglFramebuffer = [];
      for (let i2 = 0; i2 < 6; i2++) {
        if (texture.mipmaps && texture.mipmaps.length > 0) {
          renderTargetProperties.__webglFramebuffer[i2] = [];
          for (let level = 0; level < texture.mipmaps.length; level++) {
            renderTargetProperties.__webglFramebuffer[i2][level] = _gl.createFramebuffer();
          }
        } else {
          renderTargetProperties.__webglFramebuffer[i2] = _gl.createFramebuffer();
        }
      }
    } else {
      if (texture.mipmaps && texture.mipmaps.length > 0) {
        renderTargetProperties.__webglFramebuffer = [];
        for (let level = 0; level < texture.mipmaps.length; level++) {
          renderTargetProperties.__webglFramebuffer[level] = _gl.createFramebuffer();
        }
      } else {
        renderTargetProperties.__webglFramebuffer = _gl.createFramebuffer();
      }
      if (isMultipleRenderTargets) {
        for (let i2 = 0, il = textures.length; i2 < il; i2++) {
          const attachmentProperties = properties.get(textures[i2]);
          if (attachmentProperties.__webglTexture === void 0) {
            attachmentProperties.__webglTexture = _gl.createTexture();
            info.memory.textures++;
          }
        }
      }
      if (renderTarget.samples > 0 && useMultisampledRTT(renderTarget) === false) {
        renderTargetProperties.__webglMultisampledFramebuffer = _gl.createFramebuffer();
        renderTargetProperties.__webglColorRenderbuffer = [];
        state.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglMultisampledFramebuffer);
        for (let i2 = 0; i2 < textures.length; i2++) {
          const texture2 = textures[i2];
          renderTargetProperties.__webglColorRenderbuffer[i2] = _gl.createRenderbuffer();
          _gl.bindRenderbuffer(_gl.RENDERBUFFER, renderTargetProperties.__webglColorRenderbuffer[i2]);
          const glFormat = utils.convert(texture2.format, texture2.colorSpace);
          const glType = utils.convert(texture2.type);
          const glInternalFormat = getInternalFormat(texture2.internalFormat, glFormat, glType, texture2.colorSpace, renderTarget.isXRRenderTarget === true);
          const samples = getRenderTargetSamples(renderTarget);
          _gl.renderbufferStorageMultisample(_gl.RENDERBUFFER, samples, glInternalFormat, renderTarget.width, renderTarget.height);
          _gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0 + i2, _gl.RENDERBUFFER, renderTargetProperties.__webglColorRenderbuffer[i2]);
        }
        _gl.bindRenderbuffer(_gl.RENDERBUFFER, null);
        if (renderTarget.depthBuffer) {
          renderTargetProperties.__webglDepthRenderbuffer = _gl.createRenderbuffer();
          setupRenderBufferStorage(renderTargetProperties.__webglDepthRenderbuffer, renderTarget, true);
        }
        state.bindFramebuffer(_gl.FRAMEBUFFER, null);
      }
    }
    if (isCube) {
      state.bindTexture(_gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture);
      setTextureParameters(_gl.TEXTURE_CUBE_MAP, texture);
      for (let i2 = 0; i2 < 6; i2++) {
        if (texture.mipmaps && texture.mipmaps.length > 0) {
          for (let level = 0; level < texture.mipmaps.length; level++) {
            setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer[i2][level], renderTarget, texture, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i2, level);
          }
        } else {
          setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer[i2], renderTarget, texture, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i2, 0);
        }
      }
      if (textureNeedsGenerateMipmaps(texture)) {
        generateMipmap(_gl.TEXTURE_CUBE_MAP);
      }
      state.unbindTexture();
    } else if (isMultipleRenderTargets) {
      for (let i2 = 0, il = textures.length; i2 < il; i2++) {
        const attachment = textures[i2];
        const attachmentProperties = properties.get(attachment);
        state.bindTexture(_gl.TEXTURE_2D, attachmentProperties.__webglTexture);
        setTextureParameters(_gl.TEXTURE_2D, attachment);
        setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer, renderTarget, attachment, _gl.COLOR_ATTACHMENT0 + i2, _gl.TEXTURE_2D, 0);
        if (textureNeedsGenerateMipmaps(attachment)) {
          generateMipmap(_gl.TEXTURE_2D);
        }
      }
      state.unbindTexture();
    } else {
      let glTextureType = _gl.TEXTURE_2D;
      if (renderTarget.isWebGL3DRenderTarget || renderTarget.isWebGLArrayRenderTarget) {
        glTextureType = renderTarget.isWebGL3DRenderTarget ? _gl.TEXTURE_3D : _gl.TEXTURE_2D_ARRAY;
      }
      state.bindTexture(glTextureType, textureProperties.__webglTexture);
      setTextureParameters(glTextureType, texture);
      if (texture.mipmaps && texture.mipmaps.length > 0) {
        for (let level = 0; level < texture.mipmaps.length; level++) {
          setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer[level], renderTarget, texture, _gl.COLOR_ATTACHMENT0, glTextureType, level);
        }
      } else {
        setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer, renderTarget, texture, _gl.COLOR_ATTACHMENT0, glTextureType, 0);
      }
      if (textureNeedsGenerateMipmaps(texture)) {
        generateMipmap(glTextureType);
      }
      state.unbindTexture();
    }
    if (renderTarget.depthBuffer) {
      setupDepthRenderbuffer(renderTarget);
    }
  }
  function updateRenderTargetMipmap(renderTarget) {
    const textures = renderTarget.textures;
    for (let i2 = 0, il = textures.length; i2 < il; i2++) {
      const texture = textures[i2];
      if (textureNeedsGenerateMipmaps(texture)) {
        const target2 = renderTarget.isWebGLCubeRenderTarget ? _gl.TEXTURE_CUBE_MAP : _gl.TEXTURE_2D;
        const webglTexture = properties.get(texture).__webglTexture;
        state.bindTexture(target2, webglTexture);
        generateMipmap(target2);
        state.unbindTexture();
      }
    }
  }
  const invalidationArrayRead = [];
  const invalidationArrayDraw = [];
  function updateMultisampleRenderTarget(renderTarget) {
    if (renderTarget.samples > 0) {
      if (useMultisampledRTT(renderTarget) === false) {
        const textures = renderTarget.textures;
        const width = renderTarget.width;
        const height = renderTarget.height;
        let mask = _gl.COLOR_BUFFER_BIT;
        const depthStyle = renderTarget.stencilBuffer ? _gl.DEPTH_STENCIL_ATTACHMENT : _gl.DEPTH_ATTACHMENT;
        const renderTargetProperties = properties.get(renderTarget);
        const isMultipleRenderTargets = textures.length > 1;
        if (isMultipleRenderTargets) {
          for (let i2 = 0; i2 < textures.length; i2++) {
            state.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglMultisampledFramebuffer);
            _gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0 + i2, _gl.RENDERBUFFER, null);
            state.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer);
            _gl.framebufferTexture2D(_gl.DRAW_FRAMEBUFFER, _gl.COLOR_ATTACHMENT0 + i2, _gl.TEXTURE_2D, null, 0);
          }
        }
        state.bindFramebuffer(_gl.READ_FRAMEBUFFER, renderTargetProperties.__webglMultisampledFramebuffer);
        state.bindFramebuffer(_gl.DRAW_FRAMEBUFFER, renderTargetProperties.__webglFramebuffer);
        for (let i2 = 0; i2 < textures.length; i2++) {
          if (renderTarget.resolveDepthBuffer) {
            if (renderTarget.depthBuffer) mask |= _gl.DEPTH_BUFFER_BIT;
            if (renderTarget.stencilBuffer && renderTarget.resolveStencilBuffer) mask |= _gl.STENCIL_BUFFER_BIT;
          }
          if (isMultipleRenderTargets) {
            _gl.framebufferRenderbuffer(_gl.READ_FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.RENDERBUFFER, renderTargetProperties.__webglColorRenderbuffer[i2]);
            const webglTexture = properties.get(textures[i2]).__webglTexture;
            _gl.framebufferTexture2D(_gl.DRAW_FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_2D, webglTexture, 0);
          }
          _gl.blitFramebuffer(0, 0, width, height, 0, 0, width, height, mask, _gl.NEAREST);
          if (supportsInvalidateFramebuffer === true) {
            invalidationArrayRead.length = 0;
            invalidationArrayDraw.length = 0;
            invalidationArrayRead.push(_gl.COLOR_ATTACHMENT0 + i2);
            if (renderTarget.depthBuffer && renderTarget.resolveDepthBuffer === false) {
              invalidationArrayRead.push(depthStyle);
              invalidationArrayDraw.push(depthStyle);
              _gl.invalidateFramebuffer(_gl.DRAW_FRAMEBUFFER, invalidationArrayDraw);
            }
            _gl.invalidateFramebuffer(_gl.READ_FRAMEBUFFER, invalidationArrayRead);
          }
        }
        state.bindFramebuffer(_gl.READ_FRAMEBUFFER, null);
        state.bindFramebuffer(_gl.DRAW_FRAMEBUFFER, null);
        if (isMultipleRenderTargets) {
          for (let i2 = 0; i2 < textures.length; i2++) {
            state.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglMultisampledFramebuffer);
            _gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0 + i2, _gl.RENDERBUFFER, renderTargetProperties.__webglColorRenderbuffer[i2]);
            const webglTexture = properties.get(textures[i2]).__webglTexture;
            state.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer);
            _gl.framebufferTexture2D(_gl.DRAW_FRAMEBUFFER, _gl.COLOR_ATTACHMENT0 + i2, _gl.TEXTURE_2D, webglTexture, 0);
          }
        }
        state.bindFramebuffer(_gl.DRAW_FRAMEBUFFER, renderTargetProperties.__webglMultisampledFramebuffer);
      } else {
        if (renderTarget.depthBuffer && renderTarget.resolveDepthBuffer === false && supportsInvalidateFramebuffer) {
          const depthStyle = renderTarget.stencilBuffer ? _gl.DEPTH_STENCIL_ATTACHMENT : _gl.DEPTH_ATTACHMENT;
          _gl.invalidateFramebuffer(_gl.DRAW_FRAMEBUFFER, [depthStyle]);
        }
      }
    }
  }
  function getRenderTargetSamples(renderTarget) {
    return Math.min(capabilities.maxSamples, renderTarget.samples);
  }
  function useMultisampledRTT(renderTarget) {
    const renderTargetProperties = properties.get(renderTarget);
    return renderTarget.samples > 0 && extensions.has("WEBGL_multisampled_render_to_texture") === true && renderTargetProperties.__useRenderToTexture !== false;
  }
  function updateVideoTexture(texture) {
    const frame = info.render.frame;
    if (_videoTextures.get(texture) !== frame) {
      _videoTextures.set(texture, frame);
      texture.update();
    }
  }
  function verifyColorSpace(texture, image) {
    const colorSpace = texture.colorSpace;
    const format = texture.format;
    const type = texture.type;
    if (texture.isCompressedTexture === true || texture.isVideoTexture === true) return image;
    if (colorSpace !== LinearSRGBColorSpace && colorSpace !== NoColorSpace) {
      if (ColorManagement.getTransfer(colorSpace) === SRGBTransfer) {
        if (format !== RGBAFormat || type !== UnsignedByteType) {
          console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.");
        }
      } else {
        console.error("THREE.WebGLTextures: Unsupported texture color space:", colorSpace);
      }
    }
    return image;
  }
  function getDimensions(image) {
    if (typeof HTMLImageElement !== "undefined" && image instanceof HTMLImageElement) {
      _imageDimensions.width = image.naturalWidth || image.width;
      _imageDimensions.height = image.naturalHeight || image.height;
    } else if (typeof VideoFrame !== "undefined" && image instanceof VideoFrame) {
      _imageDimensions.width = image.displayWidth;
      _imageDimensions.height = image.displayHeight;
    } else {
      _imageDimensions.width = image.width;
      _imageDimensions.height = image.height;
    }
    return _imageDimensions;
  }
  this.allocateTextureUnit = allocateTextureUnit;
  this.resetTextureUnits = resetTextureUnits;
  this.setTexture2D = setTexture2D;
  this.setTexture2DArray = setTexture2DArray;
  this.setTexture3D = setTexture3D;
  this.setTextureCube = setTextureCube;
  this.rebindTextures = rebindTextures;
  this.setupRenderTarget = setupRenderTarget;
  this.updateRenderTargetMipmap = updateRenderTargetMipmap;
  this.updateMultisampleRenderTarget = updateMultisampleRenderTarget;
  this.setupDepthRenderbuffer = setupDepthRenderbuffer;
  this.setupFrameBufferTexture = setupFrameBufferTexture;
  this.useMultisampledRTT = useMultisampledRTT;
}
function WebGLUtils(gl, extensions) {
  function convert(p3, colorSpace = NoColorSpace) {
    let extension;
    const transfer = ColorManagement.getTransfer(colorSpace);
    if (p3 === UnsignedByteType) return gl.UNSIGNED_BYTE;
    if (p3 === UnsignedShort4444Type) return gl.UNSIGNED_SHORT_4_4_4_4;
    if (p3 === UnsignedShort5551Type) return gl.UNSIGNED_SHORT_5_5_5_1;
    if (p3 === UnsignedInt5999Type) return gl.UNSIGNED_INT_5_9_9_9_REV;
    if (p3 === ByteType) return gl.BYTE;
    if (p3 === ShortType) return gl.SHORT;
    if (p3 === UnsignedShortType) return gl.UNSIGNED_SHORT;
    if (p3 === IntType) return gl.INT;
    if (p3 === UnsignedIntType) return gl.UNSIGNED_INT;
    if (p3 === FloatType) return gl.FLOAT;
    if (p3 === HalfFloatType) return gl.HALF_FLOAT;
    if (p3 === AlphaFormat) return gl.ALPHA;
    if (p3 === RGBFormat) return gl.RGB;
    if (p3 === RGBAFormat) return gl.RGBA;
    if (p3 === LuminanceFormat) return gl.LUMINANCE;
    if (p3 === LuminanceAlphaFormat) return gl.LUMINANCE_ALPHA;
    if (p3 === DepthFormat) return gl.DEPTH_COMPONENT;
    if (p3 === DepthStencilFormat) return gl.DEPTH_STENCIL;
    if (p3 === RedFormat) return gl.RED;
    if (p3 === RedIntegerFormat) return gl.RED_INTEGER;
    if (p3 === RGFormat) return gl.RG;
    if (p3 === RGIntegerFormat) return gl.RG_INTEGER;
    if (p3 === RGBAIntegerFormat) return gl.RGBA_INTEGER;
    if (p3 === RGB_S3TC_DXT1_Format || p3 === RGBA_S3TC_DXT1_Format || p3 === RGBA_S3TC_DXT3_Format || p3 === RGBA_S3TC_DXT5_Format) {
      if (transfer === SRGBTransfer) {
        extension = extensions.get("WEBGL_compressed_texture_s3tc_srgb");
        if (extension !== null) {
          if (p3 === RGB_S3TC_DXT1_Format) return extension.COMPRESSED_SRGB_S3TC_DXT1_EXT;
          if (p3 === RGBA_S3TC_DXT1_Format) return extension.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
          if (p3 === RGBA_S3TC_DXT3_Format) return extension.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
          if (p3 === RGBA_S3TC_DXT5_Format) return extension.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;
        } else {
          return null;
        }
      } else {
        extension = extensions.get("WEBGL_compressed_texture_s3tc");
        if (extension !== null) {
          if (p3 === RGB_S3TC_DXT1_Format) return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;
          if (p3 === RGBA_S3TC_DXT1_Format) return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;
          if (p3 === RGBA_S3TC_DXT3_Format) return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;
          if (p3 === RGBA_S3TC_DXT5_Format) return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;
        } else {
          return null;
        }
      }
    }
    if (p3 === RGB_PVRTC_4BPPV1_Format || p3 === RGB_PVRTC_2BPPV1_Format || p3 === RGBA_PVRTC_4BPPV1_Format || p3 === RGBA_PVRTC_2BPPV1_Format) {
      extension = extensions.get("WEBGL_compressed_texture_pvrtc");
      if (extension !== null) {
        if (p3 === RGB_PVRTC_4BPPV1_Format) return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
        if (p3 === RGB_PVRTC_2BPPV1_Format) return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
        if (p3 === RGBA_PVRTC_4BPPV1_Format) return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
        if (p3 === RGBA_PVRTC_2BPPV1_Format) return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
      } else {
        return null;
      }
    }
    if (p3 === RGB_ETC1_Format || p3 === RGB_ETC2_Format || p3 === RGBA_ETC2_EAC_Format) {
      extension = extensions.get("WEBGL_compressed_texture_etc");
      if (extension !== null) {
        if (p3 === RGB_ETC1_Format || p3 === RGB_ETC2_Format) return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ETC2 : extension.COMPRESSED_RGB8_ETC2;
        if (p3 === RGBA_ETC2_EAC_Format) return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : extension.COMPRESSED_RGBA8_ETC2_EAC;
      } else {
        return null;
      }
    }
    if (p3 === RGBA_ASTC_4x4_Format || p3 === RGBA_ASTC_5x4_Format || p3 === RGBA_ASTC_5x5_Format || p3 === RGBA_ASTC_6x5_Format || p3 === RGBA_ASTC_6x6_Format || p3 === RGBA_ASTC_8x5_Format || p3 === RGBA_ASTC_8x6_Format || p3 === RGBA_ASTC_8x8_Format || p3 === RGBA_ASTC_10x5_Format || p3 === RGBA_ASTC_10x6_Format || p3 === RGBA_ASTC_10x8_Format || p3 === RGBA_ASTC_10x10_Format || p3 === RGBA_ASTC_12x10_Format || p3 === RGBA_ASTC_12x12_Format) {
      extension = extensions.get("WEBGL_compressed_texture_astc");
      if (extension !== null) {
        if (p3 === RGBA_ASTC_4x4_Format) return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : extension.COMPRESSED_RGBA_ASTC_4x4_KHR;
        if (p3 === RGBA_ASTC_5x4_Format) return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : extension.COMPRESSED_RGBA_ASTC_5x4_KHR;
        if (p3 === RGBA_ASTC_5x5_Format) return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : extension.COMPRESSED_RGBA_ASTC_5x5_KHR;
        if (p3 === RGBA_ASTC_6x5_Format) return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : extension.COMPRESSED_RGBA_ASTC_6x5_KHR;
        if (p3 === RGBA_ASTC_6x6_Format) return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : extension.COMPRESSED_RGBA_ASTC_6x6_KHR;
        if (p3 === RGBA_ASTC_8x5_Format) return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : extension.COMPRESSED_RGBA_ASTC_8x5_KHR;
        if (p3 === RGBA_ASTC_8x6_Format) return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : extension.COMPRESSED_RGBA_ASTC_8x6_KHR;
        if (p3 === RGBA_ASTC_8x8_Format) return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : extension.COMPRESSED_RGBA_ASTC_8x8_KHR;
        if (p3 === RGBA_ASTC_10x5_Format) return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : extension.COMPRESSED_RGBA_ASTC_10x5_KHR;
        if (p3 === RGBA_ASTC_10x6_Format) return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : extension.COMPRESSED_RGBA_ASTC_10x6_KHR;
        if (p3 === RGBA_ASTC_10x8_Format) return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : extension.COMPRESSED_RGBA_ASTC_10x8_KHR;
        if (p3 === RGBA_ASTC_10x10_Format) return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : extension.COMPRESSED_RGBA_ASTC_10x10_KHR;
        if (p3 === RGBA_ASTC_12x10_Format) return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : extension.COMPRESSED_RGBA_ASTC_12x10_KHR;
        if (p3 === RGBA_ASTC_12x12_Format) return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : extension.COMPRESSED_RGBA_ASTC_12x12_KHR;
      } else {
        return null;
      }
    }
    if (p3 === RGBA_BPTC_Format || p3 === RGB_BPTC_SIGNED_Format || p3 === RGB_BPTC_UNSIGNED_Format) {
      extension = extensions.get("EXT_texture_compression_bptc");
      if (extension !== null) {
        if (p3 === RGBA_BPTC_Format) return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : extension.COMPRESSED_RGBA_BPTC_UNORM_EXT;
        if (p3 === RGB_BPTC_SIGNED_Format) return extension.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT;
        if (p3 === RGB_BPTC_UNSIGNED_Format) return extension.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT;
      } else {
        return null;
      }
    }
    if (p3 === RED_RGTC1_Format || p3 === SIGNED_RED_RGTC1_Format || p3 === RED_GREEN_RGTC2_Format || p3 === SIGNED_RED_GREEN_RGTC2_Format) {
      extension = extensions.get("EXT_texture_compression_rgtc");
      if (extension !== null) {
        if (p3 === RGBA_BPTC_Format) return extension.COMPRESSED_RED_RGTC1_EXT;
        if (p3 === SIGNED_RED_RGTC1_Format) return extension.COMPRESSED_SIGNED_RED_RGTC1_EXT;
        if (p3 === RED_GREEN_RGTC2_Format) return extension.COMPRESSED_RED_GREEN_RGTC2_EXT;
        if (p3 === SIGNED_RED_GREEN_RGTC2_Format) return extension.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT;
      } else {
        return null;
      }
    }
    if (p3 === UnsignedInt248Type) return gl.UNSIGNED_INT_24_8;
    return gl[p3] !== void 0 ? gl[p3] : null;
  }
  return { convert };
}
function WebGLMaterials(renderer, properties) {
  function refreshTransformUniform(map, uniform) {
    if (map.matrixAutoUpdate === true) {
      map.updateMatrix();
    }
    uniform.value.copy(map.matrix);
  }
  function refreshFogUniforms(uniforms, fog) {
    fog.color.getRGB(uniforms.fogColor.value, getUnlitUniformColorSpace(renderer));
    if (fog.isFog) {
      uniforms.fogNear.value = fog.near;
      uniforms.fogFar.value = fog.far;
    } else if (fog.isFogExp2) {
      uniforms.fogDensity.value = fog.density;
    }
  }
  function refreshMaterialUniforms(uniforms, material, pixelRatio, height, transmissionRenderTarget) {
    if (material.isMeshBasicMaterial) {
      refreshUniformsCommon(uniforms, material);
    } else if (material.isMeshLambertMaterial) {
      refreshUniformsCommon(uniforms, material);
    } else if (material.isMeshToonMaterial) {
      refreshUniformsCommon(uniforms, material);
      refreshUniformsToon(uniforms, material);
    } else if (material.isMeshPhongMaterial) {
      refreshUniformsCommon(uniforms, material);
      refreshUniformsPhong(uniforms, material);
    } else if (material.isMeshStandardMaterial) {
      refreshUniformsCommon(uniforms, material);
      refreshUniformsStandard(uniforms, material);
      if (material.isMeshPhysicalMaterial) {
        refreshUniformsPhysical(uniforms, material, transmissionRenderTarget);
      }
    } else if (material.isMeshMatcapMaterial) {
      refreshUniformsCommon(uniforms, material);
      refreshUniformsMatcap(uniforms, material);
    } else if (material.isMeshDepthMaterial) {
      refreshUniformsCommon(uniforms, material);
    } else if (material.isMeshDistanceMaterial) {
      refreshUniformsCommon(uniforms, material);
      refreshUniformsDistance(uniforms, material);
    } else if (material.isMeshNormalMaterial) {
      refreshUniformsCommon(uniforms, material);
    } else if (material.isLineBasicMaterial) {
      refreshUniformsLine(uniforms, material);
      if (material.isLineDashedMaterial) {
        refreshUniformsDash(uniforms, material);
      }
    } else if (material.isPointsMaterial) {
      refreshUniformsPoints(uniforms, material, pixelRatio, height);
    } else if (material.isSpriteMaterial) {
      refreshUniformsSprites(uniforms, material);
    } else if (material.isShadowMaterial) {
      uniforms.color.value.copy(material.color);
      uniforms.opacity.value = material.opacity;
    } else if (material.isShaderMaterial) {
      material.uniformsNeedUpdate = false;
    }
  }
  function refreshUniformsCommon(uniforms, material) {
    uniforms.opacity.value = material.opacity;
    if (material.color) {
      uniforms.diffuse.value.copy(material.color);
    }
    if (material.emissive) {
      uniforms.emissive.value.copy(material.emissive).multiplyScalar(material.emissiveIntensity);
    }
    if (material.map) {
      uniforms.map.value = material.map;
      refreshTransformUniform(material.map, uniforms.mapTransform);
    }
    if (material.alphaMap) {
      uniforms.alphaMap.value = material.alphaMap;
      refreshTransformUniform(material.alphaMap, uniforms.alphaMapTransform);
    }
    if (material.bumpMap) {
      uniforms.bumpMap.value = material.bumpMap;
      refreshTransformUniform(material.bumpMap, uniforms.bumpMapTransform);
      uniforms.bumpScale.value = material.bumpScale;
      if (material.side === BackSide) {
        uniforms.bumpScale.value *= -1;
      }
    }
    if (material.normalMap) {
      uniforms.normalMap.value = material.normalMap;
      refreshTransformUniform(material.normalMap, uniforms.normalMapTransform);
      uniforms.normalScale.value.copy(material.normalScale);
      if (material.side === BackSide) {
        uniforms.normalScale.value.negate();
      }
    }
    if (material.displacementMap) {
      uniforms.displacementMap.value = material.displacementMap;
      refreshTransformUniform(material.displacementMap, uniforms.displacementMapTransform);
      uniforms.displacementScale.value = material.displacementScale;
      uniforms.displacementBias.value = material.displacementBias;
    }
    if (material.emissiveMap) {
      uniforms.emissiveMap.value = material.emissiveMap;
      refreshTransformUniform(material.emissiveMap, uniforms.emissiveMapTransform);
    }
    if (material.specularMap) {
      uniforms.specularMap.value = material.specularMap;
      refreshTransformUniform(material.specularMap, uniforms.specularMapTransform);
    }
    if (material.alphaTest > 0) {
      uniforms.alphaTest.value = material.alphaTest;
    }
    const materialProperties = properties.get(material);
    const envMap = materialProperties.envMap;
    const envMapRotation = materialProperties.envMapRotation;
    if (envMap) {
      uniforms.envMap.value = envMap;
      _e1.copy(envMapRotation);
      _e1.x *= -1;
      _e1.y *= -1;
      _e1.z *= -1;
      if (envMap.isCubeTexture && envMap.isRenderTargetTexture === false) {
        _e1.y *= -1;
        _e1.z *= -1;
      }
      uniforms.envMapRotation.value.setFromMatrix4(_m1.makeRotationFromEuler(_e1));
      uniforms.flipEnvMap.value = envMap.isCubeTexture && envMap.isRenderTargetTexture === false ? -1 : 1;
      uniforms.reflectivity.value = material.reflectivity;
      uniforms.ior.value = material.ior;
      uniforms.refractionRatio.value = material.refractionRatio;
    }
    if (material.lightMap) {
      uniforms.lightMap.value = material.lightMap;
      uniforms.lightMapIntensity.value = material.lightMapIntensity;
      refreshTransformUniform(material.lightMap, uniforms.lightMapTransform);
    }
    if (material.aoMap) {
      uniforms.aoMap.value = material.aoMap;
      uniforms.aoMapIntensity.value = material.aoMapIntensity;
      refreshTransformUniform(material.aoMap, uniforms.aoMapTransform);
    }
  }
  function refreshUniformsLine(uniforms, material) {
    uniforms.diffuse.value.copy(material.color);
    uniforms.opacity.value = material.opacity;
    if (material.map) {
      uniforms.map.value = material.map;
      refreshTransformUniform(material.map, uniforms.mapTransform);
    }
  }
  function refreshUniformsDash(uniforms, material) {
    uniforms.dashSize.value = material.dashSize;
    uniforms.totalSize.value = material.dashSize + material.gapSize;
    uniforms.scale.value = material.scale;
  }
  function refreshUniformsPoints(uniforms, material, pixelRatio, height) {
    uniforms.diffuse.value.copy(material.color);
    uniforms.opacity.value = material.opacity;
    uniforms.size.value = material.size * pixelRatio;
    uniforms.scale.value = height * 0.5;
    if (material.map) {
      uniforms.map.value = material.map;
      refreshTransformUniform(material.map, uniforms.uvTransform);
    }
    if (material.alphaMap) {
      uniforms.alphaMap.value = material.alphaMap;
      refreshTransformUniform(material.alphaMap, uniforms.alphaMapTransform);
    }
    if (material.alphaTest > 0) {
      uniforms.alphaTest.value = material.alphaTest;
    }
  }
  function refreshUniformsSprites(uniforms, material) {
    uniforms.diffuse.value.copy(material.color);
    uniforms.opacity.value = material.opacity;
    uniforms.rotation.value = material.rotation;
    if (material.map) {
      uniforms.map.value = material.map;
      refreshTransformUniform(material.map, uniforms.mapTransform);
    }
    if (material.alphaMap) {
      uniforms.alphaMap.value = material.alphaMap;
      refreshTransformUniform(material.alphaMap, uniforms.alphaMapTransform);
    }
    if (material.alphaTest > 0) {
      uniforms.alphaTest.value = material.alphaTest;
    }
  }
  function refreshUniformsPhong(uniforms, material) {
    uniforms.specular.value.copy(material.specular);
    uniforms.shininess.value = Math.max(material.shininess, 1e-4);
  }
  function refreshUniformsToon(uniforms, material) {
    if (material.gradientMap) {
      uniforms.gradientMap.value = material.gradientMap;
    }
  }
  function refreshUniformsStandard(uniforms, material) {
    uniforms.metalness.value = material.metalness;
    if (material.metalnessMap) {
      uniforms.metalnessMap.value = material.metalnessMap;
      refreshTransformUniform(material.metalnessMap, uniforms.metalnessMapTransform);
    }
    uniforms.roughness.value = material.roughness;
    if (material.roughnessMap) {
      uniforms.roughnessMap.value = material.roughnessMap;
      refreshTransformUniform(material.roughnessMap, uniforms.roughnessMapTransform);
    }
    if (material.envMap) {
      uniforms.envMapIntensity.value = material.envMapIntensity;
    }
  }
  function refreshUniformsPhysical(uniforms, material, transmissionRenderTarget) {
    uniforms.ior.value = material.ior;
    if (material.sheen > 0) {
      uniforms.sheenColor.value.copy(material.sheenColor).multiplyScalar(material.sheen);
      uniforms.sheenRoughness.value = material.sheenRoughness;
      if (material.sheenColorMap) {
        uniforms.sheenColorMap.value = material.sheenColorMap;
        refreshTransformUniform(material.sheenColorMap, uniforms.sheenColorMapTransform);
      }
      if (material.sheenRoughnessMap) {
        uniforms.sheenRoughnessMap.value = material.sheenRoughnessMap;
        refreshTransformUniform(material.sheenRoughnessMap, uniforms.sheenRoughnessMapTransform);
      }
    }
    if (material.clearcoat > 0) {
      uniforms.clearcoat.value = material.clearcoat;
      uniforms.clearcoatRoughness.value = material.clearcoatRoughness;
      if (material.clearcoatMap) {
        uniforms.clearcoatMap.value = material.clearcoatMap;
        refreshTransformUniform(material.clearcoatMap, uniforms.clearcoatMapTransform);
      }
      if (material.clearcoatRoughnessMap) {
        uniforms.clearcoatRoughnessMap.value = material.clearcoatRoughnessMap;
        refreshTransformUniform(material.clearcoatRoughnessMap, uniforms.clearcoatRoughnessMapTransform);
      }
      if (material.clearcoatNormalMap) {
        uniforms.clearcoatNormalMap.value = material.clearcoatNormalMap;
        refreshTransformUniform(material.clearcoatNormalMap, uniforms.clearcoatNormalMapTransform);
        uniforms.clearcoatNormalScale.value.copy(material.clearcoatNormalScale);
        if (material.side === BackSide) {
          uniforms.clearcoatNormalScale.value.negate();
        }
      }
    }
    if (material.dispersion > 0) {
      uniforms.dispersion.value = material.dispersion;
    }
    if (material.iridescence > 0) {
      uniforms.iridescence.value = material.iridescence;
      uniforms.iridescenceIOR.value = material.iridescenceIOR;
      uniforms.iridescenceThicknessMinimum.value = material.iridescenceThicknessRange[0];
      uniforms.iridescenceThicknessMaximum.value = material.iridescenceThicknessRange[1];
      if (material.iridescenceMap) {
        uniforms.iridescenceMap.value = material.iridescenceMap;
        refreshTransformUniform(material.iridescenceMap, uniforms.iridescenceMapTransform);
      }
      if (material.iridescenceThicknessMap) {
        uniforms.iridescenceThicknessMap.value = material.iridescenceThicknessMap;
        refreshTransformUniform(material.iridescenceThicknessMap, uniforms.iridescenceThicknessMapTransform);
      }
    }
    if (material.transmission > 0) {
      uniforms.transmission.value = material.transmission;
      uniforms.transmissionSamplerMap.value = transmissionRenderTarget.texture;
      uniforms.transmissionSamplerSize.value.set(transmissionRenderTarget.width, transmissionRenderTarget.height);
      if (material.transmissionMap) {
        uniforms.transmissionMap.value = material.transmissionMap;
        refreshTransformUniform(material.transmissionMap, uniforms.transmissionMapTransform);
      }
      uniforms.thickness.value = material.thickness;
      if (material.thicknessMap) {
        uniforms.thicknessMap.value = material.thicknessMap;
        refreshTransformUniform(material.thicknessMap, uniforms.thicknessMapTransform);
      }
      uniforms.attenuationDistance.value = material.attenuationDistance;
      uniforms.attenuationColor.value.copy(material.attenuationColor);
    }
    if (material.anisotropy > 0) {
      uniforms.anisotropyVector.value.set(material.anisotropy * Math.cos(material.anisotropyRotation), material.anisotropy * Math.sin(material.anisotropyRotation));
      if (material.anisotropyMap) {
        uniforms.anisotropyMap.value = material.anisotropyMap;
        refreshTransformUniform(material.anisotropyMap, uniforms.anisotropyMapTransform);
      }
    }
    uniforms.specularIntensity.value = material.specularIntensity;
    uniforms.specularColor.value.copy(material.specularColor);
    if (material.specularColorMap) {
      uniforms.specularColorMap.value = material.specularColorMap;
      refreshTransformUniform(material.specularColorMap, uniforms.specularColorMapTransform);
    }
    if (material.specularIntensityMap) {
      uniforms.specularIntensityMap.value = material.specularIntensityMap;
      refreshTransformUniform(material.specularIntensityMap, uniforms.specularIntensityMapTransform);
    }
  }
  function refreshUniformsMatcap(uniforms, material) {
    if (material.matcap) {
      uniforms.matcap.value = material.matcap;
    }
  }
  function refreshUniformsDistance(uniforms, material) {
    const light = properties.get(material).light;
    uniforms.referencePosition.value.setFromMatrixPosition(light.matrixWorld);
    uniforms.nearDistance.value = light.shadow.camera.near;
    uniforms.farDistance.value = light.shadow.camera.far;
  }
  return {
    refreshFogUniforms,
    refreshMaterialUniforms
  };
}
function WebGLUniformsGroups(gl, info, capabilities, state) {
  let buffers = {};
  let updateList = {};
  let allocatedBindingPoints = [];
  const maxBindingPoints = gl.getParameter(gl.MAX_UNIFORM_BUFFER_BINDINGS);
  function bind(uniformsGroup, program) {
    const webglProgram = program.program;
    state.uniformBlockBinding(uniformsGroup, webglProgram);
  }
  function update(uniformsGroup, program) {
    let buffer = buffers[uniformsGroup.id];
    if (buffer === void 0) {
      prepareUniformsGroup(uniformsGroup);
      buffer = createBuffer(uniformsGroup);
      buffers[uniformsGroup.id] = buffer;
      uniformsGroup.addEventListener("dispose", onUniformsGroupsDispose);
    }
    const webglProgram = program.program;
    state.updateUBOMapping(uniformsGroup, webglProgram);
    const frame = info.render.frame;
    if (updateList[uniformsGroup.id] !== frame) {
      updateBufferData(uniformsGroup);
      updateList[uniformsGroup.id] = frame;
    }
  }
  function createBuffer(uniformsGroup) {
    const bindingPointIndex = allocateBindingPointIndex();
    uniformsGroup.__bindingPointIndex = bindingPointIndex;
    const buffer = gl.createBuffer();
    const size = uniformsGroup.__size;
    const usage = uniformsGroup.usage;
    gl.bindBuffer(gl.UNIFORM_BUFFER, buffer);
    gl.bufferData(gl.UNIFORM_BUFFER, size, usage);
    gl.bindBuffer(gl.UNIFORM_BUFFER, null);
    gl.bindBufferBase(gl.UNIFORM_BUFFER, bindingPointIndex, buffer);
    return buffer;
  }
  function allocateBindingPointIndex() {
    for (let i2 = 0; i2 < maxBindingPoints; i2++) {
      if (allocatedBindingPoints.indexOf(i2) === -1) {
        allocatedBindingPoints.push(i2);
        return i2;
      }
    }
    console.error("THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached.");
    return 0;
  }
  function updateBufferData(uniformsGroup) {
    const buffer = buffers[uniformsGroup.id];
    const uniforms = uniformsGroup.uniforms;
    const cache = uniformsGroup.__cache;
    gl.bindBuffer(gl.UNIFORM_BUFFER, buffer);
    for (let i2 = 0, il = uniforms.length; i2 < il; i2++) {
      const uniformArray = Array.isArray(uniforms[i2]) ? uniforms[i2] : [uniforms[i2]];
      for (let j2 = 0, jl = uniformArray.length; j2 < jl; j2++) {
        const uniform = uniformArray[j2];
        if (hasUniformChanged(uniform, i2, j2, cache) === true) {
          const offset = uniform.__offset;
          const values = Array.isArray(uniform.value) ? uniform.value : [uniform.value];
          let arrayOffset = 0;
          for (let k3 = 0; k3 < values.length; k3++) {
            const value = values[k3];
            const info2 = getUniformSize(value);
            if (typeof value === "number" || typeof value === "boolean") {
              uniform.__data[0] = value;
              gl.bufferSubData(gl.UNIFORM_BUFFER, offset + arrayOffset, uniform.__data);
            } else if (value.isMatrix3) {
              uniform.__data[0] = value.elements[0];
              uniform.__data[1] = value.elements[1];
              uniform.__data[2] = value.elements[2];
              uniform.__data[3] = 0;
              uniform.__data[4] = value.elements[3];
              uniform.__data[5] = value.elements[4];
              uniform.__data[6] = value.elements[5];
              uniform.__data[7] = 0;
              uniform.__data[8] = value.elements[6];
              uniform.__data[9] = value.elements[7];
              uniform.__data[10] = value.elements[8];
              uniform.__data[11] = 0;
            } else {
              value.toArray(uniform.__data, arrayOffset);
              arrayOffset += info2.storage / Float32Array.BYTES_PER_ELEMENT;
            }
          }
          gl.bufferSubData(gl.UNIFORM_BUFFER, offset, uniform.__data);
        }
      }
    }
    gl.bindBuffer(gl.UNIFORM_BUFFER, null);
  }
  function hasUniformChanged(uniform, index, indexArray, cache) {
    const value = uniform.value;
    const indexString = index + "_" + indexArray;
    if (cache[indexString] === void 0) {
      if (typeof value === "number" || typeof value === "boolean") {
        cache[indexString] = value;
      } else {
        cache[indexString] = value.clone();
      }
      return true;
    } else {
      const cachedObject = cache[indexString];
      if (typeof value === "number" || typeof value === "boolean") {
        if (cachedObject !== value) {
          cache[indexString] = value;
          return true;
        }
      } else {
        if (cachedObject.equals(value) === false) {
          cachedObject.copy(value);
          return true;
        }
      }
    }
    return false;
  }
  function prepareUniformsGroup(uniformsGroup) {
    const uniforms = uniformsGroup.uniforms;
    let offset = 0;
    const chunkSize = 16;
    for (let i2 = 0, l2 = uniforms.length; i2 < l2; i2++) {
      const uniformArray = Array.isArray(uniforms[i2]) ? uniforms[i2] : [uniforms[i2]];
      for (let j2 = 0, jl = uniformArray.length; j2 < jl; j2++) {
        const uniform = uniformArray[j2];
        const values = Array.isArray(uniform.value) ? uniform.value : [uniform.value];
        for (let k3 = 0, kl = values.length; k3 < kl; k3++) {
          const value = values[k3];
          const info2 = getUniformSize(value);
          const chunkOffset2 = offset % chunkSize;
          const chunkPadding = chunkOffset2 % info2.boundary;
          const chunkStart = chunkOffset2 + chunkPadding;
          offset += chunkPadding;
          if (chunkStart !== 0 && chunkSize - chunkStart < info2.storage) {
            offset += chunkSize - chunkStart;
          }
          uniform.__data = new Float32Array(info2.storage / Float32Array.BYTES_PER_ELEMENT);
          uniform.__offset = offset;
          offset += info2.storage;
        }
      }
    }
    const chunkOffset = offset % chunkSize;
    if (chunkOffset > 0) offset += chunkSize - chunkOffset;
    uniformsGroup.__size = offset;
    uniformsGroup.__cache = {};
    return this;
  }
  function getUniformSize(value) {
    const info2 = {
      boundary: 0,
      // bytes
      storage: 0
      // bytes
    };
    if (typeof value === "number" || typeof value === "boolean") {
      info2.boundary = 4;
      info2.storage = 4;
    } else if (value.isVector2) {
      info2.boundary = 8;
      info2.storage = 8;
    } else if (value.isVector3 || value.isColor) {
      info2.boundary = 16;
      info2.storage = 12;
    } else if (value.isVector4) {
      info2.boundary = 16;
      info2.storage = 16;
    } else if (value.isMatrix3) {
      info2.boundary = 48;
      info2.storage = 48;
    } else if (value.isMatrix4) {
      info2.boundary = 64;
      info2.storage = 64;
    } else if (value.isTexture) {
      console.warn("THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group.");
    } else {
      console.warn("THREE.WebGLRenderer: Unsupported uniform value type.", value);
    }
    return info2;
  }
  function onUniformsGroupsDispose(event) {
    const uniformsGroup = event.target;
    uniformsGroup.removeEventListener("dispose", onUniformsGroupsDispose);
    const index = allocatedBindingPoints.indexOf(uniformsGroup.__bindingPointIndex);
    allocatedBindingPoints.splice(index, 1);
    gl.deleteBuffer(buffers[uniformsGroup.id]);
    delete buffers[uniformsGroup.id];
    delete updateList[uniformsGroup.id];
  }
  function dispose2() {
    for (const id in buffers) {
      gl.deleteBuffer(buffers[id]);
    }
    allocatedBindingPoints = [];
    buffers = {};
    updateList = {};
  }
  return {
    bind,
    update,
    dispose: dispose2
  };
}
function transformVertex(vertexPosition, mvPosition, center, scale, sin, cos) {
  _alignedPosition.subVectors(vertexPosition, center).addScalar(0.5).multiply(scale);
  if (sin !== void 0) {
    _rotatedPosition.x = cos * _alignedPosition.x - sin * _alignedPosition.y;
    _rotatedPosition.y = sin * _alignedPosition.x + cos * _alignedPosition.y;
  } else {
    _rotatedPosition.copy(_alignedPosition);
  }
  vertexPosition.copy(mvPosition);
  vertexPosition.x += _rotatedPosition.x;
  vertexPosition.y += _rotatedPosition.y;
  vertexPosition.applyMatrix4(_viewWorldMatrix);
}
function sortOpaque(a, b) {
  return a.z - b.z;
}
function sortTransparent(a, b) {
  return b.z - a.z;
}
function copyAttributeData(src, target2, targetOffset = 0) {
  const itemSize = target2.itemSize;
  if (src.isInterleavedBufferAttribute || src.array.constructor !== target2.array.constructor) {
    const vertexCount = src.count;
    for (let i2 = 0; i2 < vertexCount; i2++) {
      for (let c = 0; c < itemSize; c++) {
        target2.setComponent(i2 + targetOffset, c, src.getComponent(i2, c));
      }
    }
  } else {
    target2.array.set(src.array, targetOffset * itemSize);
  }
  target2.needsUpdate = true;
}
function checkIntersection(object, raycaster, ray, thresholdSq, a, b) {
  const positionAttribute = object.geometry.attributes.position;
  _vStart.fromBufferAttribute(positionAttribute, a);
  _vEnd.fromBufferAttribute(positionAttribute, b);
  const distSq = ray.distanceSqToSegment(_vStart, _vEnd, _intersectPointOnRay, _intersectPointOnSegment);
  if (distSq > thresholdSq) return;
  _intersectPointOnRay.applyMatrix4(object.matrixWorld);
  const distance = raycaster.ray.origin.distanceTo(_intersectPointOnRay);
  if (distance < raycaster.near || distance > raycaster.far) return;
  return {
    distance,
    // What do we want? intersection point on the ray or on the segment??
    // point: raycaster.ray.at( distance ),
    point: _intersectPointOnSegment.clone().applyMatrix4(object.matrixWorld),
    index: a,
    face: null,
    faceIndex: null,
    barycoord: null,
    object
  };
}
function testPoint(point, index, localThresholdSq, matrixWorld, raycaster, intersects2, object) {
  const rayPointDistanceSq = _ray.distanceSqToPoint(point);
  if (rayPointDistanceSq < localThresholdSq) {
    const intersectPoint = new Vector3();
    _ray.closestPointToPoint(point, intersectPoint);
    intersectPoint.applyMatrix4(matrixWorld);
    const distance = raycaster.ray.origin.distanceTo(intersectPoint);
    if (distance < raycaster.near || distance > raycaster.far) return;
    intersects2.push({
      distance,
      distanceToRay: Math.sqrt(rayPointDistanceSq),
      point: intersectPoint,
      index,
      face: null,
      faceIndex: null,
      barycoord: null,
      object
    });
  }
}
function CubicPoly() {
  let c0 = 0, c1 = 0, c2 = 0, c3 = 0;
  function init(x0, x1, t0, t1) {
    c0 = x0;
    c1 = t0;
    c2 = -3 * x0 + 3 * x1 - 2 * t0 - t1;
    c3 = 2 * x0 - 2 * x1 + t0 + t1;
  }
  return {
    initCatmullRom: function(x0, x1, x2, x3, tension) {
      init(x1, x2, tension * (x2 - x0), tension * (x3 - x1));
    },
    initNonuniformCatmullRom: function(x0, x1, x2, x3, dt0, dt1, dt2) {
      let t1 = (x1 - x0) / dt0 - (x2 - x0) / (dt0 + dt1) + (x2 - x1) / dt1;
      let t2 = (x2 - x1) / dt1 - (x3 - x1) / (dt1 + dt2) + (x3 - x2) / dt2;
      t1 *= dt1;
      t2 *= dt1;
      init(x1, x2, t1, t2);
    },
    calc: function(t2) {
      const t22 = t2 * t2;
      const t3 = t22 * t2;
      return c0 + c1 * t2 + c2 * t22 + c3 * t3;
    }
  };
}
function CatmullRom(t2, p0, p1, p22, p3) {
  const v0 = (p22 - p0) * 0.5;
  const v1 = (p3 - p1) * 0.5;
  const t22 = t2 * t2;
  const t3 = t2 * t22;
  return (2 * p1 - 2 * p22 + v0 + v1) * t3 + (-3 * p1 + 3 * p22 - 2 * v0 - v1) * t22 + v0 * t2 + p1;
}
function QuadraticBezierP0(t2, p3) {
  const k3 = 1 - t2;
  return k3 * k3 * p3;
}
function QuadraticBezierP1(t2, p3) {
  return 2 * (1 - t2) * t2 * p3;
}
function QuadraticBezierP2(t2, p3) {
  return t2 * t2 * p3;
}
function QuadraticBezier(t2, p0, p1, p22) {
  return QuadraticBezierP0(t2, p0) + QuadraticBezierP1(t2, p1) + QuadraticBezierP2(t2, p22);
}
function CubicBezierP0(t2, p3) {
  const k3 = 1 - t2;
  return k3 * k3 * k3 * p3;
}
function CubicBezierP1(t2, p3) {
  const k3 = 1 - t2;
  return 3 * k3 * k3 * t2 * p3;
}
function CubicBezierP2(t2, p3) {
  return 3 * (1 - t2) * t2 * t2 * p3;
}
function CubicBezierP3(t2, p3) {
  return t2 * t2 * t2 * p3;
}
function CubicBezier(t2, p0, p1, p22, p3) {
  return CubicBezierP0(t2, p0) + CubicBezierP1(t2, p1) + CubicBezierP2(t2, p22) + CubicBezierP3(t2, p3);
}
function linkedList(data, start, end, dim, clockwise) {
  let i2, last;
  if (clockwise === signedArea(data, start, end, dim) > 0) {
    for (i2 = start; i2 < end; i2 += dim) last = insertNode(i2, data[i2], data[i2 + 1], last);
  } else {
    for (i2 = end - dim; i2 >= start; i2 -= dim) last = insertNode(i2, data[i2], data[i2 + 1], last);
  }
  if (last && equals(last, last.next)) {
    removeNode(last);
    last = last.next;
  }
  return last;
}
function filterPoints(start, end) {
  if (!start) return start;
  if (!end) end = start;
  let p3 = start, again;
  do {
    again = false;
    if (!p3.steiner && (equals(p3, p3.next) || area(p3.prev, p3, p3.next) === 0)) {
      removeNode(p3);
      p3 = end = p3.prev;
      if (p3 === p3.next) break;
      again = true;
    } else {
      p3 = p3.next;
    }
  } while (again || p3 !== end);
  return end;
}
function earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {
  if (!ear) return;
  if (!pass && invSize) indexCurve(ear, minX, minY, invSize);
  let stop = ear, prev, next;
  while (ear.prev !== ear.next) {
    prev = ear.prev;
    next = ear.next;
    if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {
      triangles.push(prev.i / dim | 0);
      triangles.push(ear.i / dim | 0);
      triangles.push(next.i / dim | 0);
      removeNode(ear);
      ear = next.next;
      stop = next.next;
      continue;
    }
    ear = next;
    if (ear === stop) {
      if (!pass) {
        earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);
      } else if (pass === 1) {
        ear = cureLocalIntersections(filterPoints(ear), triangles, dim);
        earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);
      } else if (pass === 2) {
        splitEarcut(ear, triangles, dim, minX, minY, invSize);
      }
      break;
    }
  }
}
function isEar(ear) {
  const a = ear.prev, b = ear, c = ear.next;
  if (area(a, b, c) >= 0) return false;
  const ax = a.x, bx = b.x, cx = c.x, ay = a.y, by = b.y, cy = c.y;
  const x0 = ax < bx ? ax < cx ? ax : cx : bx < cx ? bx : cx, y0 = ay < by ? ay < cy ? ay : cy : by < cy ? by : cy, x1 = ax > bx ? ax > cx ? ax : cx : bx > cx ? bx : cx, y1 = ay > by ? ay > cy ? ay : cy : by > cy ? by : cy;
  let p3 = c.next;
  while (p3 !== a) {
    if (p3.x >= x0 && p3.x <= x1 && p3.y >= y0 && p3.y <= y1 && pointInTriangle(ax, ay, bx, by, cx, cy, p3.x, p3.y) && area(p3.prev, p3, p3.next) >= 0) return false;
    p3 = p3.next;
  }
  return true;
}
function isEarHashed(ear, minX, minY, invSize) {
  const a = ear.prev, b = ear, c = ear.next;
  if (area(a, b, c) >= 0) return false;
  const ax = a.x, bx = b.x, cx = c.x, ay = a.y, by = b.y, cy = c.y;
  const x0 = ax < bx ? ax < cx ? ax : cx : bx < cx ? bx : cx, y0 = ay < by ? ay < cy ? ay : cy : by < cy ? by : cy, x1 = ax > bx ? ax > cx ? ax : cx : bx > cx ? bx : cx, y1 = ay > by ? ay > cy ? ay : cy : by > cy ? by : cy;
  const minZ = zOrder(x0, y0, minX, minY, invSize), maxZ = zOrder(x1, y1, minX, minY, invSize);
  let p3 = ear.prevZ, n = ear.nextZ;
  while (p3 && p3.z >= minZ && n && n.z <= maxZ) {
    if (p3.x >= x0 && p3.x <= x1 && p3.y >= y0 && p3.y <= y1 && p3 !== a && p3 !== c && pointInTriangle(ax, ay, bx, by, cx, cy, p3.x, p3.y) && area(p3.prev, p3, p3.next) >= 0) return false;
    p3 = p3.prevZ;
    if (n.x >= x0 && n.x <= x1 && n.y >= y0 && n.y <= y1 && n !== a && n !== c && pointInTriangle(ax, ay, bx, by, cx, cy, n.x, n.y) && area(n.prev, n, n.next) >= 0) return false;
    n = n.nextZ;
  }
  while (p3 && p3.z >= minZ) {
    if (p3.x >= x0 && p3.x <= x1 && p3.y >= y0 && p3.y <= y1 && p3 !== a && p3 !== c && pointInTriangle(ax, ay, bx, by, cx, cy, p3.x, p3.y) && area(p3.prev, p3, p3.next) >= 0) return false;
    p3 = p3.prevZ;
  }
  while (n && n.z <= maxZ) {
    if (n.x >= x0 && n.x <= x1 && n.y >= y0 && n.y <= y1 && n !== a && n !== c && pointInTriangle(ax, ay, bx, by, cx, cy, n.x, n.y) && area(n.prev, n, n.next) >= 0) return false;
    n = n.nextZ;
  }
  return true;
}
function cureLocalIntersections(start, triangles, dim) {
  let p3 = start;
  do {
    const a = p3.prev, b = p3.next.next;
    if (!equals(a, b) && intersects(a, p3, p3.next, b) && locallyInside(a, b) && locallyInside(b, a)) {
      triangles.push(a.i / dim | 0);
      triangles.push(p3.i / dim | 0);
      triangles.push(b.i / dim | 0);
      removeNode(p3);
      removeNode(p3.next);
      p3 = start = b;
    }
    p3 = p3.next;
  } while (p3 !== start);
  return filterPoints(p3);
}
function splitEarcut(start, triangles, dim, minX, minY, invSize) {
  let a = start;
  do {
    let b = a.next.next;
    while (b !== a.prev) {
      if (a.i !== b.i && isValidDiagonal(a, b)) {
        let c = splitPolygon(a, b);
        a = filterPoints(a, a.next);
        c = filterPoints(c, c.next);
        earcutLinked(a, triangles, dim, minX, minY, invSize, 0);
        earcutLinked(c, triangles, dim, minX, minY, invSize, 0);
        return;
      }
      b = b.next;
    }
    a = a.next;
  } while (a !== start);
}
function eliminateHoles(data, holeIndices, outerNode, dim) {
  const queue = [];
  let i2, len, start, end, list;
  for (i2 = 0, len = holeIndices.length; i2 < len; i2++) {
    start = holeIndices[i2] * dim;
    end = i2 < len - 1 ? holeIndices[i2 + 1] * dim : data.length;
    list = linkedList(data, start, end, dim, false);
    if (list === list.next) list.steiner = true;
    queue.push(getLeftmost(list));
  }
  queue.sort(compareX);
  for (i2 = 0; i2 < queue.length; i2++) {
    outerNode = eliminateHole(queue[i2], outerNode);
  }
  return outerNode;
}
function compareX(a, b) {
  return a.x - b.x;
}
function eliminateHole(hole, outerNode) {
  const bridge = findHoleBridge(hole, outerNode);
  if (!bridge) {
    return outerNode;
  }
  const bridgeReverse = splitPolygon(bridge, hole);
  filterPoints(bridgeReverse, bridgeReverse.next);
  return filterPoints(bridge, bridge.next);
}
function findHoleBridge(hole, outerNode) {
  let p3 = outerNode, qx = -Infinity, m;
  const hx = hole.x, hy = hole.y;
  do {
    if (hy <= p3.y && hy >= p3.next.y && p3.next.y !== p3.y) {
      const x = p3.x + (hy - p3.y) * (p3.next.x - p3.x) / (p3.next.y - p3.y);
      if (x <= hx && x > qx) {
        qx = x;
        m = p3.x < p3.next.x ? p3 : p3.next;
        if (x === hx) return m;
      }
    }
    p3 = p3.next;
  } while (p3 !== outerNode);
  if (!m) return null;
  const stop = m, mx = m.x, my = m.y;
  let tanMin = Infinity, tan;
  p3 = m;
  do {
    if (hx >= p3.x && p3.x >= mx && hx !== p3.x && pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p3.x, p3.y)) {
      tan = Math.abs(hy - p3.y) / (hx - p3.x);
      if (locallyInside(p3, hole) && (tan < tanMin || tan === tanMin && (p3.x > m.x || p3.x === m.x && sectorContainsSector(m, p3)))) {
        m = p3;
        tanMin = tan;
      }
    }
    p3 = p3.next;
  } while (p3 !== stop);
  return m;
}
function sectorContainsSector(m, p3) {
  return area(m.prev, m, p3.prev) < 0 && area(p3.next, m, m.next) < 0;
}
function indexCurve(start, minX, minY, invSize) {
  let p3 = start;
  do {
    if (p3.z === 0) p3.z = zOrder(p3.x, p3.y, minX, minY, invSize);
    p3.prevZ = p3.prev;
    p3.nextZ = p3.next;
    p3 = p3.next;
  } while (p3 !== start);
  p3.prevZ.nextZ = null;
  p3.prevZ = null;
  sortLinked(p3);
}
function sortLinked(list) {
  let i2, p3, q3, e, tail, numMerges, pSize, qSize, inSize = 1;
  do {
    p3 = list;
    list = null;
    tail = null;
    numMerges = 0;
    while (p3) {
      numMerges++;
      q3 = p3;
      pSize = 0;
      for (i2 = 0; i2 < inSize; i2++) {
        pSize++;
        q3 = q3.nextZ;
        if (!q3) break;
      }
      qSize = inSize;
      while (pSize > 0 || qSize > 0 && q3) {
        if (pSize !== 0 && (qSize === 0 || !q3 || p3.z <= q3.z)) {
          e = p3;
          p3 = p3.nextZ;
          pSize--;
        } else {
          e = q3;
          q3 = q3.nextZ;
          qSize--;
        }
        if (tail) tail.nextZ = e;
        else list = e;
        e.prevZ = tail;
        tail = e;
      }
      p3 = q3;
    }
    tail.nextZ = null;
    inSize *= 2;
  } while (numMerges > 1);
  return list;
}
function zOrder(x, y2, minX, minY, invSize) {
  x = (x - minX) * invSize | 0;
  y2 = (y2 - minY) * invSize | 0;
  x = (x | x << 8) & 16711935;
  x = (x | x << 4) & 252645135;
  x = (x | x << 2) & 858993459;
  x = (x | x << 1) & 1431655765;
  y2 = (y2 | y2 << 8) & 16711935;
  y2 = (y2 | y2 << 4) & 252645135;
  y2 = (y2 | y2 << 2) & 858993459;
  y2 = (y2 | y2 << 1) & 1431655765;
  return x | y2 << 1;
}
function getLeftmost(start) {
  let p3 = start, leftmost = start;
  do {
    if (p3.x < leftmost.x || p3.x === leftmost.x && p3.y < leftmost.y) leftmost = p3;
    p3 = p3.next;
  } while (p3 !== start);
  return leftmost;
}
function pointInTriangle(ax, ay, bx, by, cx, cy, px2, py2) {
  return (cx - px2) * (ay - py2) >= (ax - px2) * (cy - py2) && (ax - px2) * (by - py2) >= (bx - px2) * (ay - py2) && (bx - px2) * (cy - py2) >= (cx - px2) * (by - py2);
}
function isValidDiagonal(a, b) {
  return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) && // dones't intersect other edges
  (locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b) && // locally visible
  (area(a.prev, a, b.prev) || area(a, b.prev, b)) || // does not create opposite-facing sectors
  equals(a, b) && area(a.prev, a, a.next) > 0 && area(b.prev, b, b.next) > 0);
}
function area(p3, q3, r2) {
  return (q3.y - p3.y) * (r2.x - q3.x) - (q3.x - p3.x) * (r2.y - q3.y);
}
function equals(p1, p22) {
  return p1.x === p22.x && p1.y === p22.y;
}
function intersects(p1, q12, p22, q22) {
  const o1 = sign(area(p1, q12, p22));
  const o2 = sign(area(p1, q12, q22));
  const o3 = sign(area(p22, q22, p1));
  const o4 = sign(area(p22, q22, q12));
  if (o1 !== o2 && o3 !== o4) return true;
  if (o1 === 0 && onSegment(p1, p22, q12)) return true;
  if (o2 === 0 && onSegment(p1, q22, q12)) return true;
  if (o3 === 0 && onSegment(p22, p1, q22)) return true;
  if (o4 === 0 && onSegment(p22, q12, q22)) return true;
  return false;
}
function onSegment(p3, q3, r2) {
  return q3.x <= Math.max(p3.x, r2.x) && q3.x >= Math.min(p3.x, r2.x) && q3.y <= Math.max(p3.y, r2.y) && q3.y >= Math.min(p3.y, r2.y);
}
function sign(num) {
  return num > 0 ? 1 : num < 0 ? -1 : 0;
}
function intersectsPolygon(a, b) {
  let p3 = a;
  do {
    if (p3.i !== a.i && p3.next.i !== a.i && p3.i !== b.i && p3.next.i !== b.i && intersects(p3, p3.next, a, b)) return true;
    p3 = p3.next;
  } while (p3 !== a);
  return false;
}
function locallyInside(a, b) {
  return area(a.prev, a, a.next) < 0 ? area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 : area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;
}
function middleInside(a, b) {
  let p3 = a, inside = false;
  const px2 = (a.x + b.x) / 2, py2 = (a.y + b.y) / 2;
  do {
    if (p3.y > py2 !== p3.next.y > py2 && p3.next.y !== p3.y && px2 < (p3.next.x - p3.x) * (py2 - p3.y) / (p3.next.y - p3.y) + p3.x)
      inside = !inside;
    p3 = p3.next;
  } while (p3 !== a);
  return inside;
}
function splitPolygon(a, b) {
  const a2 = new Node(a.i, a.x, a.y), b2 = new Node(b.i, b.x, b.y), an = a.next, bp = b.prev;
  a.next = b;
  b.prev = a;
  a2.next = an;
  an.prev = a2;
  b2.next = a2;
  a2.prev = b2;
  bp.next = b2;
  b2.prev = bp;
  return b2;
}
function insertNode(i2, x, y2, last) {
  const p3 = new Node(i2, x, y2);
  if (!last) {
    p3.prev = p3;
    p3.next = p3;
  } else {
    p3.next = last.next;
    p3.prev = last;
    last.next.prev = p3;
    last.next = p3;
  }
  return p3;
}
function removeNode(p3) {
  p3.next.prev = p3.prev;
  p3.prev.next = p3.next;
  if (p3.prevZ) p3.prevZ.nextZ = p3.nextZ;
  if (p3.nextZ) p3.nextZ.prevZ = p3.prevZ;
}
function Node(i2, x, y2) {
  this.i = i2;
  this.x = x;
  this.y = y2;
  this.prev = null;
  this.next = null;
  this.z = 0;
  this.prevZ = null;
  this.nextZ = null;
  this.steiner = false;
}
function signedArea(data, start, end, dim) {
  let sum = 0;
  for (let i2 = start, j2 = end - dim; i2 < end; i2 += dim) {
    sum += (data[j2] - data[i2]) * (data[i2 + 1] + data[j2 + 1]);
    j2 = i2;
  }
  return sum;
}
function removeDupEndPts(points) {
  const l2 = points.length;
  if (l2 > 2 && points[l2 - 1].equals(points[0])) {
    points.pop();
  }
}
function addContour(vertices, contour) {
  for (let i2 = 0; i2 < contour.length; i2++) {
    vertices.push(contour[i2].x);
    vertices.push(contour[i2].y);
  }
}
function toJSON$1(shapes, options, data) {
  data.shapes = [];
  if (Array.isArray(shapes)) {
    for (let i2 = 0, l2 = shapes.length; i2 < l2; i2++) {
      const shape = shapes[i2];
      data.shapes.push(shape.uuid);
    }
  } else {
    data.shapes.push(shapes.uuid);
  }
  data.options = Object.assign({}, options);
  if (options.extrudePath !== void 0) data.options.extrudePath = options.extrudePath.toJSON();
  return data;
}
function toJSON(shapes, data) {
  data.shapes = [];
  if (Array.isArray(shapes)) {
    for (let i2 = 0, l2 = shapes.length; i2 < l2; i2++) {
      const shape = shapes[i2];
      data.shapes.push(shape.uuid);
    }
  } else {
    data.shapes.push(shapes.uuid);
  }
  return data;
}
function isUniqueEdge(start, end, edges) {
  const hash1 = `${start.x},${start.y},${start.z}-${end.x},${end.y},${end.z}`;
  const hash2 = `${end.x},${end.y},${end.z}-${start.x},${start.y},${start.z}`;
  if (edges.has(hash1) === true || edges.has(hash2) === true) {
    return false;
  } else {
    edges.add(hash1);
    edges.add(hash2);
    return true;
  }
}
function convertArray(array, type, forceClone) {
  if (!array || // let 'undefined' and 'null' pass
  !forceClone && array.constructor === type) return array;
  if (typeof type.BYTES_PER_ELEMENT === "number") {
    return new type(array);
  }
  return Array.prototype.slice.call(array);
}
function isTypedArray(object) {
  return ArrayBuffer.isView(object) && !(object instanceof DataView);
}
function getKeyframeOrder(times) {
  function compareTime(i2, j2) {
    return times[i2] - times[j2];
  }
  const n = times.length;
  const result = new Array(n);
  for (let i2 = 0; i2 !== n; ++i2) result[i2] = i2;
  result.sort(compareTime);
  return result;
}
function sortedArray(values, stride, order) {
  const nValues = values.length;
  const result = new values.constructor(nValues);
  for (let i2 = 0, dstOffset = 0; dstOffset !== nValues; ++i2) {
    const srcOffset = order[i2] * stride;
    for (let j2 = 0; j2 !== stride; ++j2) {
      result[dstOffset++] = values[srcOffset + j2];
    }
  }
  return result;
}
function flattenJSON(jsonKeys, times, values, valuePropertyName) {
  let i2 = 1, key = jsonKeys[0];
  while (key !== void 0 && key[valuePropertyName] === void 0) {
    key = jsonKeys[i2++];
  }
  if (key === void 0) return;
  let value = key[valuePropertyName];
  if (value === void 0) return;
  if (Array.isArray(value)) {
    do {
      value = key[valuePropertyName];
      if (value !== void 0) {
        times.push(key.time);
        values.push.apply(values, value);
      }
      key = jsonKeys[i2++];
    } while (key !== void 0);
  } else if (value.toArray !== void 0) {
    do {
      value = key[valuePropertyName];
      if (value !== void 0) {
        times.push(key.time);
        value.toArray(values, values.length);
      }
      key = jsonKeys[i2++];
    } while (key !== void 0);
  } else {
    do {
      value = key[valuePropertyName];
      if (value !== void 0) {
        times.push(key.time);
        values.push(value);
      }
      key = jsonKeys[i2++];
    } while (key !== void 0);
  }
}
function subclip(sourceClip, name, startFrame, endFrame, fps = 30) {
  const clip = sourceClip.clone();
  clip.name = name;
  const tracks = [];
  for (let i2 = 0; i2 < clip.tracks.length; ++i2) {
    const track = clip.tracks[i2];
    const valueSize = track.getValueSize();
    const times = [];
    const values = [];
    for (let j2 = 0; j2 < track.times.length; ++j2) {
      const frame = track.times[j2] * fps;
      if (frame < startFrame || frame >= endFrame) continue;
      times.push(track.times[j2]);
      for (let k3 = 0; k3 < valueSize; ++k3) {
        values.push(track.values[j2 * valueSize + k3]);
      }
    }
    if (times.length === 0) continue;
    track.times = convertArray(times, track.times.constructor);
    track.values = convertArray(values, track.values.constructor);
    tracks.push(track);
  }
  clip.tracks = tracks;
  let minStartTime = Infinity;
  for (let i2 = 0; i2 < clip.tracks.length; ++i2) {
    if (minStartTime > clip.tracks[i2].times[0]) {
      minStartTime = clip.tracks[i2].times[0];
    }
  }
  for (let i2 = 0; i2 < clip.tracks.length; ++i2) {
    clip.tracks[i2].shift(-1 * minStartTime);
  }
  clip.resetDuration();
  return clip;
}
function makeClipAdditive(targetClip, referenceFrame = 0, referenceClip = targetClip, fps = 30) {
  if (fps <= 0) fps = 30;
  const numTracks = referenceClip.tracks.length;
  const referenceTime = referenceFrame / fps;
  for (let i2 = 0; i2 < numTracks; ++i2) {
    const referenceTrack = referenceClip.tracks[i2];
    const referenceTrackType = referenceTrack.ValueTypeName;
    if (referenceTrackType === "bool" || referenceTrackType === "string") continue;
    const targetTrack = targetClip.tracks.find(function(track) {
      return track.name === referenceTrack.name && track.ValueTypeName === referenceTrackType;
    });
    if (targetTrack === void 0) continue;
    let referenceOffset = 0;
    const referenceValueSize = referenceTrack.getValueSize();
    if (referenceTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline) {
      referenceOffset = referenceValueSize / 3;
    }
    let targetOffset = 0;
    const targetValueSize = targetTrack.getValueSize();
    if (targetTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline) {
      targetOffset = targetValueSize / 3;
    }
    const lastIndex = referenceTrack.times.length - 1;
    let referenceValue;
    if (referenceTime <= referenceTrack.times[0]) {
      const startIndex = referenceOffset;
      const endIndex = referenceValueSize - referenceOffset;
      referenceValue = referenceTrack.values.slice(startIndex, endIndex);
    } else if (referenceTime >= referenceTrack.times[lastIndex]) {
      const startIndex = lastIndex * referenceValueSize + referenceOffset;
      const endIndex = startIndex + referenceValueSize - referenceOffset;
      referenceValue = referenceTrack.values.slice(startIndex, endIndex);
    } else {
      const interpolant = referenceTrack.createInterpolant();
      const startIndex = referenceOffset;
      const endIndex = referenceValueSize - referenceOffset;
      interpolant.evaluate(referenceTime);
      referenceValue = interpolant.resultBuffer.slice(startIndex, endIndex);
    }
    if (referenceTrackType === "quaternion") {
      const referenceQuat = new Quaternion().fromArray(referenceValue).normalize().conjugate();
      referenceQuat.toArray(referenceValue);
    }
    const numTimes = targetTrack.times.length;
    for (let j2 = 0; j2 < numTimes; ++j2) {
      const valueStart = j2 * targetValueSize + targetOffset;
      if (referenceTrackType === "quaternion") {
        Quaternion.multiplyQuaternionsFlat(
          targetTrack.values,
          valueStart,
          referenceValue,
          0,
          targetTrack.values,
          valueStart
        );
      } else {
        const valueEnd = targetValueSize - targetOffset * 2;
        for (let k3 = 0; k3 < valueEnd; ++k3) {
          targetTrack.values[valueStart + k3] -= referenceValue[k3];
        }
      }
    }
  }
  targetClip.blendMode = AdditiveAnimationBlendMode;
  return targetClip;
}
function getTrackTypeForValueTypeName(typeName) {
  switch (typeName.toLowerCase()) {
    case "scalar":
    case "double":
    case "float":
    case "number":
    case "integer":
      return NumberKeyframeTrack;
    case "vector":
    case "vector2":
    case "vector3":
    case "vector4":
      return VectorKeyframeTrack;
    case "color":
      return ColorKeyframeTrack;
    case "quaternion":
      return QuaternionKeyframeTrack;
    case "bool":
    case "boolean":
      return BooleanKeyframeTrack;
    case "string":
      return StringKeyframeTrack;
  }
  throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + typeName);
}
function parseKeyframeTrack(json) {
  if (json.type === void 0) {
    throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
  }
  const trackType = getTrackTypeForValueTypeName(json.type);
  if (json.times === void 0) {
    const times = [], values = [];
    flattenJSON(json.keys, times, values, "value");
    json.times = times;
    json.values = values;
  }
  if (trackType.parse !== void 0) {
    return trackType.parse(json);
  } else {
    return new trackType(json.name, json.times, json.values, json.interpolation);
  }
}
function now() {
  return performance.now();
}
function ascSort(a, b) {
  return a.distance - b.distance;
}
function intersect(object, raycaster, intersects2, recursive) {
  let propagate = true;
  if (object.layers.test(raycaster.layers)) {
    const result = object.raycast(raycaster, intersects2);
    if (result === false) propagate = false;
  }
  if (propagate === true && recursive === true) {
    const children = object.children;
    for (let i2 = 0, l2 = children.length; i2 < l2; i2++) {
      intersect(children[i2], raycaster, intersects2, true);
    }
  }
}
function getBoneList(object) {
  const boneList = [];
  if (object.isBone === true) {
    boneList.push(object);
  }
  for (let i2 = 0; i2 < object.children.length; i2++) {
    boneList.push.apply(boneList, getBoneList(object.children[i2]));
  }
  return boneList;
}
function setPoint(point, pointMap, geometry, camera, x, y2, z2) {
  _vector.set(x, y2, z2).unproject(camera);
  const points = pointMap[point];
  if (points !== void 0) {
    const position = geometry.getAttribute("position");
    for (let i2 = 0, l2 = points.length; i2 < l2; i2++) {
      position.setXYZ(points[i2], _vector.x, _vector.y, _vector.z);
    }
  }
}
var three_module_exports, REVISION, MOUSE, TOUCH, CullFaceNone, CullFaceBack, CullFaceFront, CullFaceFrontBack, BasicShadowMap, PCFShadowMap, PCFSoftShadowMap, VSMShadowMap, FrontSide, BackSide, DoubleSide, NoBlending, NormalBlending, AdditiveBlending, SubtractiveBlending, MultiplyBlending, CustomBlending, AddEquation, SubtractEquation, ReverseSubtractEquation, MinEquation, MaxEquation, ZeroFactor, OneFactor, SrcColorFactor, OneMinusSrcColorFactor, SrcAlphaFactor, OneMinusSrcAlphaFactor, DstAlphaFactor, OneMinusDstAlphaFactor, DstColorFactor, OneMinusDstColorFactor, SrcAlphaSaturateFactor, ConstantColorFactor, OneMinusConstantColorFactor, ConstantAlphaFactor, OneMinusConstantAlphaFactor, NeverDepth, AlwaysDepth, LessDepth, LessEqualDepth, EqualDepth, GreaterEqualDepth, GreaterDepth, NotEqualDepth, MultiplyOperation, MixOperation, AddOperation, NoToneMapping, LinearToneMapping, ReinhardToneMapping, CineonToneMapping, ACESFilmicToneMapping, CustomToneMapping, AgXToneMapping, NeutralToneMapping, AttachedBindMode, DetachedBindMode, UVMapping, CubeReflectionMapping, CubeRefractionMapping, EquirectangularReflectionMapping, EquirectangularRefractionMapping, CubeUVReflectionMapping, RepeatWrapping, ClampToEdgeWrapping, MirroredRepeatWrapping, NearestFilter, NearestMipmapNearestFilter, NearestMipMapNearestFilter, NearestMipmapLinearFilter, NearestMipMapLinearFilter, LinearFilter, LinearMipmapNearestFilter, LinearMipMapNearestFilter, LinearMipmapLinearFilter, LinearMipMapLinearFilter, UnsignedByteType, ByteType, ShortType, UnsignedShortType, IntType, UnsignedIntType, FloatType, HalfFloatType, UnsignedShort4444Type, UnsignedShort5551Type, UnsignedInt248Type, UnsignedInt5999Type, AlphaFormat, RGBFormat, RGBAFormat, LuminanceFormat, LuminanceAlphaFormat, DepthFormat, DepthStencilFormat, RedFormat, RedIntegerFormat, RGFormat, RGIntegerFormat, RGBIntegerFormat, RGBAIntegerFormat, RGB_S3TC_DXT1_Format, RGBA_S3TC_DXT1_Format, RGBA_S3TC_DXT3_Format, RGBA_S3TC_DXT5_Format, RGB_PVRTC_4BPPV1_Format, RGB_PVRTC_2BPPV1_Format, RGBA_PVRTC_4BPPV1_Format, RGBA_PVRTC_2BPPV1_Format, RGB_ETC1_Format, RGB_ETC2_Format, RGBA_ETC2_EAC_Format, RGBA_ASTC_4x4_Format, RGBA_ASTC_5x4_Format, RGBA_ASTC_5x5_Format, RGBA_ASTC_6x5_Format, RGBA_ASTC_6x6_Format, RGBA_ASTC_8x5_Format, RGBA_ASTC_8x6_Format, RGBA_ASTC_8x8_Format, RGBA_ASTC_10x5_Format, RGBA_ASTC_10x6_Format, RGBA_ASTC_10x8_Format, RGBA_ASTC_10x10_Format, RGBA_ASTC_12x10_Format, RGBA_ASTC_12x12_Format, RGBA_BPTC_Format, RGB_BPTC_SIGNED_Format, RGB_BPTC_UNSIGNED_Format, RED_RGTC1_Format, SIGNED_RED_RGTC1_Format, RED_GREEN_RGTC2_Format, SIGNED_RED_GREEN_RGTC2_Format, LoopOnce, LoopRepeat, LoopPingPong, InterpolateDiscrete, InterpolateLinear, InterpolateSmooth, ZeroCurvatureEnding, ZeroSlopeEnding, WrapAroundEnding, NormalAnimationBlendMode, AdditiveAnimationBlendMode, TrianglesDrawMode, TriangleStripDrawMode, TriangleFanDrawMode, BasicDepthPacking, RGBADepthPacking, RGBDepthPacking, RGDepthPacking, TangentSpaceNormalMap, ObjectSpaceNormalMap, NoColorSpace, SRGBColorSpace, LinearSRGBColorSpace, DisplayP3ColorSpace, LinearDisplayP3ColorSpace, LinearTransfer, SRGBTransfer, Rec709Primaries, P3Primaries, ZeroStencilOp, KeepStencilOp, ReplaceStencilOp, IncrementStencilOp, DecrementStencilOp, IncrementWrapStencilOp, DecrementWrapStencilOp, InvertStencilOp, NeverStencilFunc, LessStencilFunc, EqualStencilFunc, LessEqualStencilFunc, GreaterStencilFunc, NotEqualStencilFunc, GreaterEqualStencilFunc, AlwaysStencilFunc, NeverCompare, LessCompare, EqualCompare, LessEqualCompare, GreaterCompare, NotEqualCompare, GreaterEqualCompare, AlwaysCompare, StaticDrawUsage, DynamicDrawUsage, StreamDrawUsage, StaticReadUsage, DynamicReadUsage, StreamReadUsage, StaticCopyUsage, DynamicCopyUsage, StreamCopyUsage, GLSL1, GLSL3, WebGLCoordinateSystem, WebGPUCoordinateSystem, EventDispatcher, _lut, _seed, DEG2RAD, RAD2DEG, MathUtils, Vector2, Matrix3, _m3, TYPED_ARRAYS, _cache, LINEAR_SRGB_TO_LINEAR_DISPLAY_P3, LINEAR_DISPLAY_P3_TO_LINEAR_SRGB, COLOR_SPACES, SUPPORTED_WORKING_COLOR_SPACES, ColorManagement, _canvas, ImageUtils, _sourceId, Source, _textureId, Texture, Vector4, RenderTarget, WebGLRenderTarget, DataArrayTexture, WebGLArrayRenderTarget, Data3DTexture, WebGL3DRenderTarget, Quaternion, Vector3, _vector$c, _quaternion$4, Box3, _points, _vector$b, _box$4, _v0$3, _v1$7, _v2$4, _f0, _f1, _f2, _center, _extents, _triangleNormal, _testAxis, _box$3, _v1$6, _v2$3, Sphere, _vector$a, _segCenter, _segDir, _diff, _edge1, _edge2, _normal$1, Ray, Matrix4, _v1$5, _m1$4, _zero, _one, _x, _y, _z, _matrix$2, _quaternion$3, Euler, Layers, _object3DId, _v1$4, _q1, _m1$3, _target, _position$3, _scale$2, _quaternion$2, _xAxis, _yAxis, _zAxis, _addedEvent, _removedEvent, _childaddedEvent, _childremovedEvent, Object3D, _v0$2, _v1$3, _v2$2, _v3$2, _vab, _vac, _vbc, _vap, _vbp, _vcp, _v40, _v41, _v42, Triangle, _colorKeywords, _hslA, _hslB, Color, _color, _materialId, Material, MeshBasicMaterial, _tables, DataUtils, _vector$9, _vector2$1, BufferAttribute, Int8BufferAttribute, Uint8BufferAttribute, Uint8ClampedBufferAttribute, Int16BufferAttribute, Uint16BufferAttribute, Int32BufferAttribute, Uint32BufferAttribute, Float16BufferAttribute, Float32BufferAttribute, _id$2, _m1$2, _obj, _offset, _box$2, _boxMorphTargets, _vector$8, BufferGeometry, _inverseMatrix$3, _ray$3, _sphere$6, _sphereHitAt, _vA$1, _vB$1, _vC$1, _tempA, _morphA, _intersectionPoint, _intersectionPointWorld, Mesh, BoxGeometry, UniformsUtils, default_vertex, default_fragment, ShaderMaterial, Camera, _v3$1, _minTarget, _maxTarget, PerspectiveCamera, fov, aspect, CubeCamera, CubeTexture, WebGLCubeRenderTarget, _vector1, _vector2, _normalMatrix, Plane, _sphere$5, _vector$7, Frustum, PlaneGeometry, alphahash_fragment, alphahash_pars_fragment, alphamap_fragment, alphamap_pars_fragment, alphatest_fragment, alphatest_pars_fragment, aomap_fragment, aomap_pars_fragment, batching_pars_vertex, batching_vertex, begin_vertex, beginnormal_vertex, bsdfs, iridescence_fragment, bumpmap_pars_fragment, clipping_planes_fragment, clipping_planes_pars_fragment, clipping_planes_pars_vertex, clipping_planes_vertex, color_fragment, color_pars_fragment, color_pars_vertex, color_vertex, common, cube_uv_reflection_fragment, defaultnormal_vertex, displacementmap_pars_vertex, displacementmap_vertex, emissivemap_fragment, emissivemap_pars_fragment, colorspace_fragment, colorspace_pars_fragment, envmap_fragment, envmap_common_pars_fragment, envmap_pars_fragment, envmap_pars_vertex, envmap_vertex, fog_vertex, fog_pars_vertex, fog_fragment, fog_pars_fragment, gradientmap_pars_fragment, lightmap_pars_fragment, lights_lambert_fragment, lights_lambert_pars_fragment, lights_pars_begin, envmap_physical_pars_fragment, lights_toon_fragment, lights_toon_pars_fragment, lights_phong_fragment, lights_phong_pars_fragment, lights_physical_fragment, lights_physical_pars_fragment, lights_fragment_begin, lights_fragment_maps, lights_fragment_end, logdepthbuf_fragment, logdepthbuf_pars_fragment, logdepthbuf_pars_vertex, logdepthbuf_vertex, map_fragment, map_pars_fragment, map_particle_fragment, map_particle_pars_fragment, metalnessmap_fragment, metalnessmap_pars_fragment, morphinstance_vertex, morphcolor_vertex, morphnormal_vertex, morphtarget_pars_vertex, morphtarget_vertex, normal_fragment_begin, normal_fragment_maps, normal_pars_fragment, normal_pars_vertex, normal_vertex, normalmap_pars_fragment, clearcoat_normal_fragment_begin, clearcoat_normal_fragment_maps, clearcoat_pars_fragment, iridescence_pars_fragment, opaque_fragment, packing, premultiplied_alpha_fragment, project_vertex, dithering_fragment, dithering_pars_fragment, roughnessmap_fragment, roughnessmap_pars_fragment, shadowmap_pars_fragment, shadowmap_pars_vertex, shadowmap_vertex, shadowmask_pars_fragment, skinbase_vertex, skinning_pars_vertex, skinning_vertex, skinnormal_vertex, specularmap_fragment, specularmap_pars_fragment, tonemapping_fragment, tonemapping_pars_fragment, transmission_fragment, transmission_pars_fragment, uv_pars_fragment, uv_pars_vertex, uv_vertex, worldpos_vertex, vertex$h, fragment$h, vertex$g, fragment$g, vertex$f, fragment$f, vertex$e, fragment$e, vertex$d, fragment$d, vertex$c, fragment$c, vertex$b, fragment$b, vertex$a, fragment$a, vertex$9, fragment$9, vertex$8, fragment$8, vertex$7, fragment$7, vertex$6, fragment$6, vertex$5, fragment$5, vertex$4, fragment$4, vertex$3, fragment$3, vertex$2, fragment$2, vertex$1, fragment$1, ShaderChunk, UniformsLib, ShaderLib, _rgb, _e1$1, _m1$1, OrthographicCamera, LOD_MIN, EXTRA_LOD_SIGMA, MAX_SAMPLES, _flatCamera, _clearColor, _oldTarget, _oldActiveCubeFace, _oldActiveMipmapLevel, _oldXrEnabled, PHI, INV_PHI, _axisDirections, PMREMGenerator, DepthTexture, emptyTexture, emptyShadowTexture, emptyArrayTexture, empty3dTexture, emptyCubeTexture, arrayCacheF32, arrayCacheI32, mat4array, mat3array, mat2array, SingleUniform, PureArrayUniform, StructuredUniform, RePathPart, WebGLUniforms, COMPLETION_STATUS_KHR, programIdCount, _v0$1, includePattern, shaderChunkMap, unrollLoopPattern, _id$1, WebGLShaderCache, WebGLShaderStage, nextVersion, MeshDepthMaterial, MeshDistanceMaterial, vertex, fragment, reversedFuncs, TextureUtils, ArrayCamera, Group, _moveEvent, WebXRController, _occlusion_vertex, _occlusion_fragment, WebXRDepthSensing, WebXRManager, _e1, _m1, WebGLRenderer, FogExp2, Fog, Scene, InterleavedBuffer, _vector$6, InterleavedBufferAttribute, SpriteMaterial, _geometry, _intersectPoint, _worldScale, _mvPosition, _alignedPosition, _rotatedPosition, _viewWorldMatrix, _vA, _vB, _vC, _uvA, _uvB, _uvC, Sprite, _v1$2, _v2$1, LOD, _basePosition, _skinIndex, _skinWeight, _vector3, _matrix4, _vertex, _sphere$4, _inverseMatrix$2, _ray$2, SkinnedMesh, Bone, DataTexture, _offsetMatrix, _identityMatrix$1, Skeleton, InstancedBufferAttribute, _instanceLocalMatrix, _instanceWorldMatrix, _instanceIntersects, _box3, _identity, _mesh$1, _sphere$3, InstancedMesh, MultiDrawRenderList, _matrix$1, _invMatrixWorld, _identityMatrix, _whiteColor, _projScreenMatrix$2, _frustum, _box$1, _sphere$2, _vector$5, _forward, _temp, _renderList, _mesh, _batchIntersects, BatchedMesh, LineBasicMaterial, _vStart, _vEnd, _inverseMatrix$1, _ray$1, _sphere$1, _intersectPointOnRay, _intersectPointOnSegment, Line, _start, _end, LineSegments, LineLoop, PointsMaterial, _inverseMatrix, _ray, _sphere, _position$2, Points, VideoTexture, FramebufferTexture, CompressedTexture, CompressedArrayTexture, CompressedCubeTexture, CanvasTexture, Curve, EllipseCurve, ArcCurve, tmp, px, py, pz, CatmullRomCurve3, CubicBezierCurve, CubicBezierCurve3, LineCurve, LineCurve3, QuadraticBezierCurve, QuadraticBezierCurve3, SplineCurve, Curves, CurvePath, Path, LatheGeometry, CapsuleGeometry, CircleGeometry, CylinderGeometry, ConeGeometry, PolyhedronGeometry, DodecahedronGeometry, _v0, _v1$1, _normal, _triangle, EdgesGeometry, Shape, Earcut, ShapeUtils, ExtrudeGeometry, WorldUVGenerator, IcosahedronGeometry, OctahedronGeometry, RingGeometry, ShapeGeometry, SphereGeometry, TetrahedronGeometry, TorusGeometry, TorusKnotGeometry, TubeGeometry, WireframeGeometry, Geometries, ShadowMaterial, RawShaderMaterial, MeshStandardMaterial, MeshPhysicalMaterial, MeshPhongMaterial, MeshToonMaterial, MeshNormalMaterial, MeshLambertMaterial, MeshMatcapMaterial, LineDashedMaterial, AnimationUtils, Interpolant, CubicInterpolant, LinearInterpolant, DiscreteInterpolant, KeyframeTrack, BooleanKeyframeTrack, ColorKeyframeTrack, NumberKeyframeTrack, QuaternionLinearInterpolant, QuaternionKeyframeTrack, StringKeyframeTrack, VectorKeyframeTrack, AnimationClip, Cache, LoadingManager, DefaultLoadingManager, Loader, loading, HttpError, FileLoader, AnimationLoader, CompressedTextureLoader, ImageLoader, CubeTextureLoader, DataTextureLoader, TextureLoader, Light, HemisphereLight, _projScreenMatrix$1, _lightPositionWorld$1, _lookTarget$1, LightShadow, SpotLightShadow, SpotLight, _projScreenMatrix, _lightPositionWorld, _lookTarget, PointLightShadow, PointLight, DirectionalLightShadow, DirectionalLight, AmbientLight, RectAreaLight, SphericalHarmonics3, LightProbe, MaterialLoader, LoaderUtils, InstancedBufferGeometry, BufferGeometryLoader, ObjectLoader, TEXTURE_MAPPING, TEXTURE_WRAPPING, TEXTURE_FILTER, ImageBitmapLoader, _context, AudioContext, AudioLoader, _eyeRight, _eyeLeft, _projectionMatrix, StereoCamera, Clock, _position$1, _quaternion$1, _scale$1, _orientation$1, AudioListener, Audio, _position, _quaternion, _scale, _orientation, PositionalAudio, AudioAnalyser, PropertyMixer, _RESERVED_CHARS_RE, _reservedRe, _wordChar, _wordCharOrDot, _directoryRe, _nodeRe, _objectRe, _propertyRe, _trackRe, _supportedObjectNames, Composite, PropertyBinding, AnimationObjectGroup, AnimationAction, _controlInterpolantsResultBuffer, AnimationMixer, Uniform, _id, UniformsGroup, InstancedInterleavedBuffer, GLBufferAttribute, _matrix, Raycaster, Spherical, Cylindrical, Matrix2, _vector$4, Box2, _startP, _startEnd, Line3, _vector$3, SpotLightHelper, _vector$2, _boneMatrix, _matrixWorldInv, SkeletonHelper, PointLightHelper, _vector$1, _color1, _color2, HemisphereLightHelper, GridHelper, PolarGridHelper, _v1, _v2, _v3, DirectionalLightHelper, _vector, _camera, CameraHelper, _box, BoxHelper, Box3Helper, PlaneHelper, _axis, _lineGeometry, _coneGeometry, ArrowHelper, AxesHelper, ShapePath, Controls, WebGLMultipleRenderTargets;
var init_chunk_BT6X4JN2 = __esm({
  "../shadergradient-v2/dist/chunk-BT6X4JN2.mjs"() {
    init_chunk_5BEQP2BQ();
    three_module_exports = {};
    __export(three_module_exports, {
      ACESFilmicToneMapping: () => ACESFilmicToneMapping,
      AddEquation: () => AddEquation,
      AddOperation: () => AddOperation,
      AdditiveAnimationBlendMode: () => AdditiveAnimationBlendMode,
      AdditiveBlending: () => AdditiveBlending,
      AgXToneMapping: () => AgXToneMapping,
      AlphaFormat: () => AlphaFormat,
      AlwaysCompare: () => AlwaysCompare,
      AlwaysDepth: () => AlwaysDepth,
      AlwaysStencilFunc: () => AlwaysStencilFunc,
      AmbientLight: () => AmbientLight,
      AnimationAction: () => AnimationAction,
      AnimationClip: () => AnimationClip,
      AnimationLoader: () => AnimationLoader,
      AnimationMixer: () => AnimationMixer,
      AnimationObjectGroup: () => AnimationObjectGroup,
      AnimationUtils: () => AnimationUtils,
      ArcCurve: () => ArcCurve,
      ArrayCamera: () => ArrayCamera,
      ArrowHelper: () => ArrowHelper,
      AttachedBindMode: () => AttachedBindMode,
      Audio: () => Audio,
      AudioAnalyser: () => AudioAnalyser,
      AudioContext: () => AudioContext,
      AudioListener: () => AudioListener,
      AudioLoader: () => AudioLoader,
      AxesHelper: () => AxesHelper,
      BackSide: () => BackSide,
      BasicDepthPacking: () => BasicDepthPacking,
      BasicShadowMap: () => BasicShadowMap,
      BatchedMesh: () => BatchedMesh,
      Bone: () => Bone,
      BooleanKeyframeTrack: () => BooleanKeyframeTrack,
      Box2: () => Box2,
      Box3: () => Box3,
      Box3Helper: () => Box3Helper,
      BoxGeometry: () => BoxGeometry,
      BoxHelper: () => BoxHelper,
      BufferAttribute: () => BufferAttribute,
      BufferGeometry: () => BufferGeometry,
      BufferGeometryLoader: () => BufferGeometryLoader,
      ByteType: () => ByteType,
      Cache: () => Cache,
      Camera: () => Camera,
      CameraHelper: () => CameraHelper,
      CanvasTexture: () => CanvasTexture,
      CapsuleGeometry: () => CapsuleGeometry,
      CatmullRomCurve3: () => CatmullRomCurve3,
      CineonToneMapping: () => CineonToneMapping,
      CircleGeometry: () => CircleGeometry,
      ClampToEdgeWrapping: () => ClampToEdgeWrapping,
      Clock: () => Clock,
      Color: () => Color,
      ColorKeyframeTrack: () => ColorKeyframeTrack,
      ColorManagement: () => ColorManagement,
      CompressedArrayTexture: () => CompressedArrayTexture,
      CompressedCubeTexture: () => CompressedCubeTexture,
      CompressedTexture: () => CompressedTexture,
      CompressedTextureLoader: () => CompressedTextureLoader,
      ConeGeometry: () => ConeGeometry,
      ConstantAlphaFactor: () => ConstantAlphaFactor,
      ConstantColorFactor: () => ConstantColorFactor,
      Controls: () => Controls,
      CubeCamera: () => CubeCamera,
      CubeReflectionMapping: () => CubeReflectionMapping,
      CubeRefractionMapping: () => CubeRefractionMapping,
      CubeTexture: () => CubeTexture,
      CubeTextureLoader: () => CubeTextureLoader,
      CubeUVReflectionMapping: () => CubeUVReflectionMapping,
      CubicBezierCurve: () => CubicBezierCurve,
      CubicBezierCurve3: () => CubicBezierCurve3,
      CubicInterpolant: () => CubicInterpolant,
      CullFaceBack: () => CullFaceBack,
      CullFaceFront: () => CullFaceFront,
      CullFaceFrontBack: () => CullFaceFrontBack,
      CullFaceNone: () => CullFaceNone,
      Curve: () => Curve,
      CurvePath: () => CurvePath,
      CustomBlending: () => CustomBlending,
      CustomToneMapping: () => CustomToneMapping,
      CylinderGeometry: () => CylinderGeometry,
      Cylindrical: () => Cylindrical,
      Data3DTexture: () => Data3DTexture,
      DataArrayTexture: () => DataArrayTexture,
      DataTexture: () => DataTexture,
      DataTextureLoader: () => DataTextureLoader,
      DataUtils: () => DataUtils,
      DecrementStencilOp: () => DecrementStencilOp,
      DecrementWrapStencilOp: () => DecrementWrapStencilOp,
      DefaultLoadingManager: () => DefaultLoadingManager,
      DepthFormat: () => DepthFormat,
      DepthStencilFormat: () => DepthStencilFormat,
      DepthTexture: () => DepthTexture,
      DetachedBindMode: () => DetachedBindMode,
      DirectionalLight: () => DirectionalLight,
      DirectionalLightHelper: () => DirectionalLightHelper,
      DiscreteInterpolant: () => DiscreteInterpolant,
      DisplayP3ColorSpace: () => DisplayP3ColorSpace,
      DodecahedronGeometry: () => DodecahedronGeometry,
      DoubleSide: () => DoubleSide,
      DstAlphaFactor: () => DstAlphaFactor,
      DstColorFactor: () => DstColorFactor,
      DynamicCopyUsage: () => DynamicCopyUsage,
      DynamicDrawUsage: () => DynamicDrawUsage,
      DynamicReadUsage: () => DynamicReadUsage,
      EdgesGeometry: () => EdgesGeometry,
      EllipseCurve: () => EllipseCurve,
      EqualCompare: () => EqualCompare,
      EqualDepth: () => EqualDepth,
      EqualStencilFunc: () => EqualStencilFunc,
      EquirectangularReflectionMapping: () => EquirectangularReflectionMapping,
      EquirectangularRefractionMapping: () => EquirectangularRefractionMapping,
      Euler: () => Euler,
      EventDispatcher: () => EventDispatcher,
      ExtrudeGeometry: () => ExtrudeGeometry,
      FileLoader: () => FileLoader,
      Float16BufferAttribute: () => Float16BufferAttribute,
      Float32BufferAttribute: () => Float32BufferAttribute,
      FloatType: () => FloatType,
      Fog: () => Fog,
      FogExp2: () => FogExp2,
      FramebufferTexture: () => FramebufferTexture,
      FrontSide: () => FrontSide,
      Frustum: () => Frustum,
      GLBufferAttribute: () => GLBufferAttribute,
      GLSL1: () => GLSL1,
      GLSL3: () => GLSL3,
      GreaterCompare: () => GreaterCompare,
      GreaterDepth: () => GreaterDepth,
      GreaterEqualCompare: () => GreaterEqualCompare,
      GreaterEqualDepth: () => GreaterEqualDepth,
      GreaterEqualStencilFunc: () => GreaterEqualStencilFunc,
      GreaterStencilFunc: () => GreaterStencilFunc,
      GridHelper: () => GridHelper,
      Group: () => Group,
      HalfFloatType: () => HalfFloatType,
      HemisphereLight: () => HemisphereLight,
      HemisphereLightHelper: () => HemisphereLightHelper,
      IcosahedronGeometry: () => IcosahedronGeometry,
      ImageBitmapLoader: () => ImageBitmapLoader,
      ImageLoader: () => ImageLoader,
      ImageUtils: () => ImageUtils,
      IncrementStencilOp: () => IncrementStencilOp,
      IncrementWrapStencilOp: () => IncrementWrapStencilOp,
      InstancedBufferAttribute: () => InstancedBufferAttribute,
      InstancedBufferGeometry: () => InstancedBufferGeometry,
      InstancedInterleavedBuffer: () => InstancedInterleavedBuffer,
      InstancedMesh: () => InstancedMesh,
      Int16BufferAttribute: () => Int16BufferAttribute,
      Int32BufferAttribute: () => Int32BufferAttribute,
      Int8BufferAttribute: () => Int8BufferAttribute,
      IntType: () => IntType,
      InterleavedBuffer: () => InterleavedBuffer,
      InterleavedBufferAttribute: () => InterleavedBufferAttribute,
      Interpolant: () => Interpolant,
      InterpolateDiscrete: () => InterpolateDiscrete,
      InterpolateLinear: () => InterpolateLinear,
      InterpolateSmooth: () => InterpolateSmooth,
      InvertStencilOp: () => InvertStencilOp,
      KeepStencilOp: () => KeepStencilOp,
      KeyframeTrack: () => KeyframeTrack,
      LOD: () => LOD,
      LatheGeometry: () => LatheGeometry,
      Layers: () => Layers,
      LessCompare: () => LessCompare,
      LessDepth: () => LessDepth,
      LessEqualCompare: () => LessEqualCompare,
      LessEqualDepth: () => LessEqualDepth,
      LessEqualStencilFunc: () => LessEqualStencilFunc,
      LessStencilFunc: () => LessStencilFunc,
      Light: () => Light,
      LightProbe: () => LightProbe,
      Line: () => Line,
      Line3: () => Line3,
      LineBasicMaterial: () => LineBasicMaterial,
      LineCurve: () => LineCurve,
      LineCurve3: () => LineCurve3,
      LineDashedMaterial: () => LineDashedMaterial,
      LineLoop: () => LineLoop,
      LineSegments: () => LineSegments,
      LinearDisplayP3ColorSpace: () => LinearDisplayP3ColorSpace,
      LinearFilter: () => LinearFilter,
      LinearInterpolant: () => LinearInterpolant,
      LinearMipMapLinearFilter: () => LinearMipMapLinearFilter,
      LinearMipMapNearestFilter: () => LinearMipMapNearestFilter,
      LinearMipmapLinearFilter: () => LinearMipmapLinearFilter,
      LinearMipmapNearestFilter: () => LinearMipmapNearestFilter,
      LinearSRGBColorSpace: () => LinearSRGBColorSpace,
      LinearToneMapping: () => LinearToneMapping,
      LinearTransfer: () => LinearTransfer,
      Loader: () => Loader,
      LoaderUtils: () => LoaderUtils,
      LoadingManager: () => LoadingManager,
      LoopOnce: () => LoopOnce,
      LoopPingPong: () => LoopPingPong,
      LoopRepeat: () => LoopRepeat,
      LuminanceAlphaFormat: () => LuminanceAlphaFormat,
      LuminanceFormat: () => LuminanceFormat,
      MOUSE: () => MOUSE,
      Material: () => Material,
      MaterialLoader: () => MaterialLoader,
      MathUtils: () => MathUtils,
      Matrix2: () => Matrix2,
      Matrix3: () => Matrix3,
      Matrix4: () => Matrix4,
      MaxEquation: () => MaxEquation,
      Mesh: () => Mesh,
      MeshBasicMaterial: () => MeshBasicMaterial,
      MeshDepthMaterial: () => MeshDepthMaterial,
      MeshDistanceMaterial: () => MeshDistanceMaterial,
      MeshLambertMaterial: () => MeshLambertMaterial,
      MeshMatcapMaterial: () => MeshMatcapMaterial,
      MeshNormalMaterial: () => MeshNormalMaterial,
      MeshPhongMaterial: () => MeshPhongMaterial,
      MeshPhysicalMaterial: () => MeshPhysicalMaterial,
      MeshStandardMaterial: () => MeshStandardMaterial,
      MeshToonMaterial: () => MeshToonMaterial,
      MinEquation: () => MinEquation,
      MirroredRepeatWrapping: () => MirroredRepeatWrapping,
      MixOperation: () => MixOperation,
      MultiplyBlending: () => MultiplyBlending,
      MultiplyOperation: () => MultiplyOperation,
      NearestFilter: () => NearestFilter,
      NearestMipMapLinearFilter: () => NearestMipMapLinearFilter,
      NearestMipMapNearestFilter: () => NearestMipMapNearestFilter,
      NearestMipmapLinearFilter: () => NearestMipmapLinearFilter,
      NearestMipmapNearestFilter: () => NearestMipmapNearestFilter,
      NeutralToneMapping: () => NeutralToneMapping,
      NeverCompare: () => NeverCompare,
      NeverDepth: () => NeverDepth,
      NeverStencilFunc: () => NeverStencilFunc,
      NoBlending: () => NoBlending,
      NoColorSpace: () => NoColorSpace,
      NoToneMapping: () => NoToneMapping,
      NormalAnimationBlendMode: () => NormalAnimationBlendMode,
      NormalBlending: () => NormalBlending,
      NotEqualCompare: () => NotEqualCompare,
      NotEqualDepth: () => NotEqualDepth,
      NotEqualStencilFunc: () => NotEqualStencilFunc,
      NumberKeyframeTrack: () => NumberKeyframeTrack,
      Object3D: () => Object3D,
      ObjectLoader: () => ObjectLoader,
      ObjectSpaceNormalMap: () => ObjectSpaceNormalMap,
      OctahedronGeometry: () => OctahedronGeometry,
      OneFactor: () => OneFactor,
      OneMinusConstantAlphaFactor: () => OneMinusConstantAlphaFactor,
      OneMinusConstantColorFactor: () => OneMinusConstantColorFactor,
      OneMinusDstAlphaFactor: () => OneMinusDstAlphaFactor,
      OneMinusDstColorFactor: () => OneMinusDstColorFactor,
      OneMinusSrcAlphaFactor: () => OneMinusSrcAlphaFactor,
      OneMinusSrcColorFactor: () => OneMinusSrcColorFactor,
      OrthographicCamera: () => OrthographicCamera,
      P3Primaries: () => P3Primaries,
      PCFShadowMap: () => PCFShadowMap,
      PCFSoftShadowMap: () => PCFSoftShadowMap,
      PMREMGenerator: () => PMREMGenerator,
      Path: () => Path,
      PerspectiveCamera: () => PerspectiveCamera,
      Plane: () => Plane,
      PlaneGeometry: () => PlaneGeometry,
      PlaneHelper: () => PlaneHelper,
      PointLight: () => PointLight,
      PointLightHelper: () => PointLightHelper,
      Points: () => Points,
      PointsMaterial: () => PointsMaterial,
      PolarGridHelper: () => PolarGridHelper,
      PolyhedronGeometry: () => PolyhedronGeometry,
      PositionalAudio: () => PositionalAudio,
      PropertyBinding: () => PropertyBinding,
      PropertyMixer: () => PropertyMixer,
      QuadraticBezierCurve: () => QuadraticBezierCurve,
      QuadraticBezierCurve3: () => QuadraticBezierCurve3,
      Quaternion: () => Quaternion,
      QuaternionKeyframeTrack: () => QuaternionKeyframeTrack,
      QuaternionLinearInterpolant: () => QuaternionLinearInterpolant,
      RED_GREEN_RGTC2_Format: () => RED_GREEN_RGTC2_Format,
      RED_RGTC1_Format: () => RED_RGTC1_Format,
      REVISION: () => REVISION,
      RGBADepthPacking: () => RGBADepthPacking,
      RGBAFormat: () => RGBAFormat,
      RGBAIntegerFormat: () => RGBAIntegerFormat,
      RGBA_ASTC_10x10_Format: () => RGBA_ASTC_10x10_Format,
      RGBA_ASTC_10x5_Format: () => RGBA_ASTC_10x5_Format,
      RGBA_ASTC_10x6_Format: () => RGBA_ASTC_10x6_Format,
      RGBA_ASTC_10x8_Format: () => RGBA_ASTC_10x8_Format,
      RGBA_ASTC_12x10_Format: () => RGBA_ASTC_12x10_Format,
      RGBA_ASTC_12x12_Format: () => RGBA_ASTC_12x12_Format,
      RGBA_ASTC_4x4_Format: () => RGBA_ASTC_4x4_Format,
      RGBA_ASTC_5x4_Format: () => RGBA_ASTC_5x4_Format,
      RGBA_ASTC_5x5_Format: () => RGBA_ASTC_5x5_Format,
      RGBA_ASTC_6x5_Format: () => RGBA_ASTC_6x5_Format,
      RGBA_ASTC_6x6_Format: () => RGBA_ASTC_6x6_Format,
      RGBA_ASTC_8x5_Format: () => RGBA_ASTC_8x5_Format,
      RGBA_ASTC_8x6_Format: () => RGBA_ASTC_8x6_Format,
      RGBA_ASTC_8x8_Format: () => RGBA_ASTC_8x8_Format,
      RGBA_BPTC_Format: () => RGBA_BPTC_Format,
      RGBA_ETC2_EAC_Format: () => RGBA_ETC2_EAC_Format,
      RGBA_PVRTC_2BPPV1_Format: () => RGBA_PVRTC_2BPPV1_Format,
      RGBA_PVRTC_4BPPV1_Format: () => RGBA_PVRTC_4BPPV1_Format,
      RGBA_S3TC_DXT1_Format: () => RGBA_S3TC_DXT1_Format,
      RGBA_S3TC_DXT3_Format: () => RGBA_S3TC_DXT3_Format,
      RGBA_S3TC_DXT5_Format: () => RGBA_S3TC_DXT5_Format,
      RGBDepthPacking: () => RGBDepthPacking,
      RGBFormat: () => RGBFormat,
      RGBIntegerFormat: () => RGBIntegerFormat,
      RGB_BPTC_SIGNED_Format: () => RGB_BPTC_SIGNED_Format,
      RGB_BPTC_UNSIGNED_Format: () => RGB_BPTC_UNSIGNED_Format,
      RGB_ETC1_Format: () => RGB_ETC1_Format,
      RGB_ETC2_Format: () => RGB_ETC2_Format,
      RGB_PVRTC_2BPPV1_Format: () => RGB_PVRTC_2BPPV1_Format,
      RGB_PVRTC_4BPPV1_Format: () => RGB_PVRTC_4BPPV1_Format,
      RGB_S3TC_DXT1_Format: () => RGB_S3TC_DXT1_Format,
      RGDepthPacking: () => RGDepthPacking,
      RGFormat: () => RGFormat,
      RGIntegerFormat: () => RGIntegerFormat,
      RawShaderMaterial: () => RawShaderMaterial,
      Ray: () => Ray,
      Raycaster: () => Raycaster,
      Rec709Primaries: () => Rec709Primaries,
      RectAreaLight: () => RectAreaLight,
      RedFormat: () => RedFormat,
      RedIntegerFormat: () => RedIntegerFormat,
      ReinhardToneMapping: () => ReinhardToneMapping,
      RenderTarget: () => RenderTarget,
      RepeatWrapping: () => RepeatWrapping,
      ReplaceStencilOp: () => ReplaceStencilOp,
      ReverseSubtractEquation: () => ReverseSubtractEquation,
      RingGeometry: () => RingGeometry,
      SIGNED_RED_GREEN_RGTC2_Format: () => SIGNED_RED_GREEN_RGTC2_Format,
      SIGNED_RED_RGTC1_Format: () => SIGNED_RED_RGTC1_Format,
      SRGBColorSpace: () => SRGBColorSpace,
      SRGBTransfer: () => SRGBTransfer,
      Scene: () => Scene,
      ShaderChunk: () => ShaderChunk,
      ShaderLib: () => ShaderLib,
      ShaderMaterial: () => ShaderMaterial,
      ShadowMaterial: () => ShadowMaterial,
      Shape: () => Shape,
      ShapeGeometry: () => ShapeGeometry,
      ShapePath: () => ShapePath,
      ShapeUtils: () => ShapeUtils,
      ShortType: () => ShortType,
      Skeleton: () => Skeleton,
      SkeletonHelper: () => SkeletonHelper,
      SkinnedMesh: () => SkinnedMesh,
      Source: () => Source,
      Sphere: () => Sphere,
      SphereGeometry: () => SphereGeometry,
      Spherical: () => Spherical,
      SphericalHarmonics3: () => SphericalHarmonics3,
      SplineCurve: () => SplineCurve,
      SpotLight: () => SpotLight,
      SpotLightHelper: () => SpotLightHelper,
      Sprite: () => Sprite,
      SpriteMaterial: () => SpriteMaterial,
      SrcAlphaFactor: () => SrcAlphaFactor,
      SrcAlphaSaturateFactor: () => SrcAlphaSaturateFactor,
      SrcColorFactor: () => SrcColorFactor,
      StaticCopyUsage: () => StaticCopyUsage,
      StaticDrawUsage: () => StaticDrawUsage,
      StaticReadUsage: () => StaticReadUsage,
      StereoCamera: () => StereoCamera,
      StreamCopyUsage: () => StreamCopyUsage,
      StreamDrawUsage: () => StreamDrawUsage,
      StreamReadUsage: () => StreamReadUsage,
      StringKeyframeTrack: () => StringKeyframeTrack,
      SubtractEquation: () => SubtractEquation,
      SubtractiveBlending: () => SubtractiveBlending,
      TOUCH: () => TOUCH,
      TangentSpaceNormalMap: () => TangentSpaceNormalMap,
      TetrahedronGeometry: () => TetrahedronGeometry,
      Texture: () => Texture,
      TextureLoader: () => TextureLoader,
      TextureUtils: () => TextureUtils,
      TorusGeometry: () => TorusGeometry,
      TorusKnotGeometry: () => TorusKnotGeometry,
      Triangle: () => Triangle,
      TriangleFanDrawMode: () => TriangleFanDrawMode,
      TriangleStripDrawMode: () => TriangleStripDrawMode,
      TrianglesDrawMode: () => TrianglesDrawMode,
      TubeGeometry: () => TubeGeometry,
      UVMapping: () => UVMapping,
      Uint16BufferAttribute: () => Uint16BufferAttribute,
      Uint32BufferAttribute: () => Uint32BufferAttribute,
      Uint8BufferAttribute: () => Uint8BufferAttribute,
      Uint8ClampedBufferAttribute: () => Uint8ClampedBufferAttribute,
      Uniform: () => Uniform,
      UniformsGroup: () => UniformsGroup,
      UniformsLib: () => UniformsLib,
      UniformsUtils: () => UniformsUtils,
      UnsignedByteType: () => UnsignedByteType,
      UnsignedInt248Type: () => UnsignedInt248Type,
      UnsignedInt5999Type: () => UnsignedInt5999Type,
      UnsignedIntType: () => UnsignedIntType,
      UnsignedShort4444Type: () => UnsignedShort4444Type,
      UnsignedShort5551Type: () => UnsignedShort5551Type,
      UnsignedShortType: () => UnsignedShortType,
      VSMShadowMap: () => VSMShadowMap,
      Vector2: () => Vector2,
      Vector3: () => Vector3,
      Vector4: () => Vector4,
      VectorKeyframeTrack: () => VectorKeyframeTrack,
      VideoTexture: () => VideoTexture,
      WebGL3DRenderTarget: () => WebGL3DRenderTarget,
      WebGLArrayRenderTarget: () => WebGLArrayRenderTarget,
      WebGLCoordinateSystem: () => WebGLCoordinateSystem,
      WebGLCubeRenderTarget: () => WebGLCubeRenderTarget,
      WebGLMultipleRenderTargets: () => WebGLMultipleRenderTargets,
      WebGLRenderTarget: () => WebGLRenderTarget,
      WebGLRenderer: () => WebGLRenderer,
      WebGLUtils: () => WebGLUtils,
      WebGPUCoordinateSystem: () => WebGPUCoordinateSystem,
      WireframeGeometry: () => WireframeGeometry,
      WrapAroundEnding: () => WrapAroundEnding,
      ZeroCurvatureEnding: () => ZeroCurvatureEnding,
      ZeroFactor: () => ZeroFactor,
      ZeroSlopeEnding: () => ZeroSlopeEnding,
      ZeroStencilOp: () => ZeroStencilOp,
      createCanvasElement: () => createCanvasElement
    });
    REVISION = "169";
    MOUSE = { LEFT: 0, MIDDLE: 1, RIGHT: 2, ROTATE: 0, DOLLY: 1, PAN: 2 };
    TOUCH = { ROTATE: 0, PAN: 1, DOLLY_PAN: 2, DOLLY_ROTATE: 3 };
    CullFaceNone = 0;
    CullFaceBack = 1;
    CullFaceFront = 2;
    CullFaceFrontBack = 3;
    BasicShadowMap = 0;
    PCFShadowMap = 1;
    PCFSoftShadowMap = 2;
    VSMShadowMap = 3;
    FrontSide = 0;
    BackSide = 1;
    DoubleSide = 2;
    NoBlending = 0;
    NormalBlending = 1;
    AdditiveBlending = 2;
    SubtractiveBlending = 3;
    MultiplyBlending = 4;
    CustomBlending = 5;
    AddEquation = 100;
    SubtractEquation = 101;
    ReverseSubtractEquation = 102;
    MinEquation = 103;
    MaxEquation = 104;
    ZeroFactor = 200;
    OneFactor = 201;
    SrcColorFactor = 202;
    OneMinusSrcColorFactor = 203;
    SrcAlphaFactor = 204;
    OneMinusSrcAlphaFactor = 205;
    DstAlphaFactor = 206;
    OneMinusDstAlphaFactor = 207;
    DstColorFactor = 208;
    OneMinusDstColorFactor = 209;
    SrcAlphaSaturateFactor = 210;
    ConstantColorFactor = 211;
    OneMinusConstantColorFactor = 212;
    ConstantAlphaFactor = 213;
    OneMinusConstantAlphaFactor = 214;
    NeverDepth = 0;
    AlwaysDepth = 1;
    LessDepth = 2;
    LessEqualDepth = 3;
    EqualDepth = 4;
    GreaterEqualDepth = 5;
    GreaterDepth = 6;
    NotEqualDepth = 7;
    MultiplyOperation = 0;
    MixOperation = 1;
    AddOperation = 2;
    NoToneMapping = 0;
    LinearToneMapping = 1;
    ReinhardToneMapping = 2;
    CineonToneMapping = 3;
    ACESFilmicToneMapping = 4;
    CustomToneMapping = 5;
    AgXToneMapping = 6;
    NeutralToneMapping = 7;
    AttachedBindMode = "attached";
    DetachedBindMode = "detached";
    UVMapping = 300;
    CubeReflectionMapping = 301;
    CubeRefractionMapping = 302;
    EquirectangularReflectionMapping = 303;
    EquirectangularRefractionMapping = 304;
    CubeUVReflectionMapping = 306;
    RepeatWrapping = 1e3;
    ClampToEdgeWrapping = 1001;
    MirroredRepeatWrapping = 1002;
    NearestFilter = 1003;
    NearestMipmapNearestFilter = 1004;
    NearestMipMapNearestFilter = 1004;
    NearestMipmapLinearFilter = 1005;
    NearestMipMapLinearFilter = 1005;
    LinearFilter = 1006;
    LinearMipmapNearestFilter = 1007;
    LinearMipMapNearestFilter = 1007;
    LinearMipmapLinearFilter = 1008;
    LinearMipMapLinearFilter = 1008;
    UnsignedByteType = 1009;
    ByteType = 1010;
    ShortType = 1011;
    UnsignedShortType = 1012;
    IntType = 1013;
    UnsignedIntType = 1014;
    FloatType = 1015;
    HalfFloatType = 1016;
    UnsignedShort4444Type = 1017;
    UnsignedShort5551Type = 1018;
    UnsignedInt248Type = 1020;
    UnsignedInt5999Type = 35902;
    AlphaFormat = 1021;
    RGBFormat = 1022;
    RGBAFormat = 1023;
    LuminanceFormat = 1024;
    LuminanceAlphaFormat = 1025;
    DepthFormat = 1026;
    DepthStencilFormat = 1027;
    RedFormat = 1028;
    RedIntegerFormat = 1029;
    RGFormat = 1030;
    RGIntegerFormat = 1031;
    RGBIntegerFormat = 1032;
    RGBAIntegerFormat = 1033;
    RGB_S3TC_DXT1_Format = 33776;
    RGBA_S3TC_DXT1_Format = 33777;
    RGBA_S3TC_DXT3_Format = 33778;
    RGBA_S3TC_DXT5_Format = 33779;
    RGB_PVRTC_4BPPV1_Format = 35840;
    RGB_PVRTC_2BPPV1_Format = 35841;
    RGBA_PVRTC_4BPPV1_Format = 35842;
    RGBA_PVRTC_2BPPV1_Format = 35843;
    RGB_ETC1_Format = 36196;
    RGB_ETC2_Format = 37492;
    RGBA_ETC2_EAC_Format = 37496;
    RGBA_ASTC_4x4_Format = 37808;
    RGBA_ASTC_5x4_Format = 37809;
    RGBA_ASTC_5x5_Format = 37810;
    RGBA_ASTC_6x5_Format = 37811;
    RGBA_ASTC_6x6_Format = 37812;
    RGBA_ASTC_8x5_Format = 37813;
    RGBA_ASTC_8x6_Format = 37814;
    RGBA_ASTC_8x8_Format = 37815;
    RGBA_ASTC_10x5_Format = 37816;
    RGBA_ASTC_10x6_Format = 37817;
    RGBA_ASTC_10x8_Format = 37818;
    RGBA_ASTC_10x10_Format = 37819;
    RGBA_ASTC_12x10_Format = 37820;
    RGBA_ASTC_12x12_Format = 37821;
    RGBA_BPTC_Format = 36492;
    RGB_BPTC_SIGNED_Format = 36494;
    RGB_BPTC_UNSIGNED_Format = 36495;
    RED_RGTC1_Format = 36283;
    SIGNED_RED_RGTC1_Format = 36284;
    RED_GREEN_RGTC2_Format = 36285;
    SIGNED_RED_GREEN_RGTC2_Format = 36286;
    LoopOnce = 2200;
    LoopRepeat = 2201;
    LoopPingPong = 2202;
    InterpolateDiscrete = 2300;
    InterpolateLinear = 2301;
    InterpolateSmooth = 2302;
    ZeroCurvatureEnding = 2400;
    ZeroSlopeEnding = 2401;
    WrapAroundEnding = 2402;
    NormalAnimationBlendMode = 2500;
    AdditiveAnimationBlendMode = 2501;
    TrianglesDrawMode = 0;
    TriangleStripDrawMode = 1;
    TriangleFanDrawMode = 2;
    BasicDepthPacking = 3200;
    RGBADepthPacking = 3201;
    RGBDepthPacking = 3202;
    RGDepthPacking = 3203;
    TangentSpaceNormalMap = 0;
    ObjectSpaceNormalMap = 1;
    NoColorSpace = "";
    SRGBColorSpace = "srgb";
    LinearSRGBColorSpace = "srgb-linear";
    DisplayP3ColorSpace = "display-p3";
    LinearDisplayP3ColorSpace = "display-p3-linear";
    LinearTransfer = "linear";
    SRGBTransfer = "srgb";
    Rec709Primaries = "rec709";
    P3Primaries = "p3";
    ZeroStencilOp = 0;
    KeepStencilOp = 7680;
    ReplaceStencilOp = 7681;
    IncrementStencilOp = 7682;
    DecrementStencilOp = 7683;
    IncrementWrapStencilOp = 34055;
    DecrementWrapStencilOp = 34056;
    InvertStencilOp = 5386;
    NeverStencilFunc = 512;
    LessStencilFunc = 513;
    EqualStencilFunc = 514;
    LessEqualStencilFunc = 515;
    GreaterStencilFunc = 516;
    NotEqualStencilFunc = 517;
    GreaterEqualStencilFunc = 518;
    AlwaysStencilFunc = 519;
    NeverCompare = 512;
    LessCompare = 513;
    EqualCompare = 514;
    LessEqualCompare = 515;
    GreaterCompare = 516;
    NotEqualCompare = 517;
    GreaterEqualCompare = 518;
    AlwaysCompare = 519;
    StaticDrawUsage = 35044;
    DynamicDrawUsage = 35048;
    StreamDrawUsage = 35040;
    StaticReadUsage = 35045;
    DynamicReadUsage = 35049;
    StreamReadUsage = 35041;
    StaticCopyUsage = 35046;
    DynamicCopyUsage = 35050;
    StreamCopyUsage = 35042;
    GLSL1 = "100";
    GLSL3 = "300 es";
    WebGLCoordinateSystem = 2e3;
    WebGPUCoordinateSystem = 2001;
    EventDispatcher = class {
      addEventListener(type, listener) {
        if (this._listeners === void 0) this._listeners = {};
        const listeners = this._listeners;
        if (listeners[type] === void 0) {
          listeners[type] = [];
        }
        if (listeners[type].indexOf(listener) === -1) {
          listeners[type].push(listener);
        }
      }
      hasEventListener(type, listener) {
        if (this._listeners === void 0) return false;
        const listeners = this._listeners;
        return listeners[type] !== void 0 && listeners[type].indexOf(listener) !== -1;
      }
      removeEventListener(type, listener) {
        if (this._listeners === void 0) return;
        const listeners = this._listeners;
        const listenerArray = listeners[type];
        if (listenerArray !== void 0) {
          const index = listenerArray.indexOf(listener);
          if (index !== -1) {
            listenerArray.splice(index, 1);
          }
        }
      }
      dispatchEvent(event) {
        if (this._listeners === void 0) return;
        const listeners = this._listeners;
        const listenerArray = listeners[event.type];
        if (listenerArray !== void 0) {
          event.target = this;
          const array = listenerArray.slice(0);
          for (let i2 = 0, l2 = array.length; i2 < l2; i2++) {
            array[i2].call(this, event);
          }
          event.target = null;
        }
      }
    };
    _lut = ["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "0a", "0b", "0c", "0d", "0e", "0f", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "1a", "1b", "1c", "1d", "1e", "1f", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "2a", "2b", "2c", "2d", "2e", "2f", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "3a", "3b", "3c", "3d", "3e", "3f", "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "4a", "4b", "4c", "4d", "4e", "4f", "50", "51", "52", "53", "54", "55", "56", "57", "58", "59", "5a", "5b", "5c", "5d", "5e", "5f", "60", "61", "62", "63", "64", "65", "66", "67", "68", "69", "6a", "6b", "6c", "6d", "6e", "6f", "70", "71", "72", "73", "74", "75", "76", "77", "78", "79", "7a", "7b", "7c", "7d", "7e", "7f", "80", "81", "82", "83", "84", "85", "86", "87", "88", "89", "8a", "8b", "8c", "8d", "8e", "8f", "90", "91", "92", "93", "94", "95", "96", "97", "98", "99", "9a", "9b", "9c", "9d", "9e", "9f", "a0", "a1", "a2", "a3", "a4", "a5", "a6", "a7", "a8", "a9", "aa", "ab", "ac", "ad", "ae", "af", "b0", "b1", "b2", "b3", "b4", "b5", "b6", "b7", "b8", "b9", "ba", "bb", "bc", "bd", "be", "bf", "c0", "c1", "c2", "c3", "c4", "c5", "c6", "c7", "c8", "c9", "ca", "cb", "cc", "cd", "ce", "cf", "d0", "d1", "d2", "d3", "d4", "d5", "d6", "d7", "d8", "d9", "da", "db", "dc", "dd", "de", "df", "e0", "e1", "e2", "e3", "e4", "e5", "e6", "e7", "e8", "e9", "ea", "eb", "ec", "ed", "ee", "ef", "f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7", "f8", "f9", "fa", "fb", "fc", "fd", "fe", "ff"];
    _seed = 1234567;
    DEG2RAD = Math.PI / 180;
    RAD2DEG = 180 / Math.PI;
    MathUtils = {
      DEG2RAD,
      RAD2DEG,
      generateUUID,
      clamp,
      euclideanModulo,
      mapLinear,
      inverseLerp,
      lerp,
      damp,
      pingpong,
      smoothstep,
      smootherstep,
      randInt,
      randFloat,
      randFloatSpread,
      seededRandom,
      degToRad,
      radToDeg,
      isPowerOfTwo,
      ceilPowerOfTwo,
      floorPowerOfTwo,
      setQuaternionFromProperEuler,
      normalize,
      denormalize
    };
    Vector2 = class _Vector2 {
      constructor(x = 0, y2 = 0) {
        _Vector2.prototype.isVector2 = true;
        this.x = x;
        this.y = y2;
      }
      get width() {
        return this.x;
      }
      set width(value) {
        this.x = value;
      }
      get height() {
        return this.y;
      }
      set height(value) {
        this.y = value;
      }
      set(x, y2) {
        this.x = x;
        this.y = y2;
        return this;
      }
      setScalar(scalar) {
        this.x = scalar;
        this.y = scalar;
        return this;
      }
      setX(x) {
        this.x = x;
        return this;
      }
      setY(y2) {
        this.y = y2;
        return this;
      }
      setComponent(index, value) {
        switch (index) {
          case 0:
            this.x = value;
            break;
          case 1:
            this.y = value;
            break;
          default:
            throw new Error("index is out of range: " + index);
        }
        return this;
      }
      getComponent(index) {
        switch (index) {
          case 0:
            return this.x;
          case 1:
            return this.y;
          default:
            throw new Error("index is out of range: " + index);
        }
      }
      clone() {
        return new this.constructor(this.x, this.y);
      }
      copy(v2) {
        this.x = v2.x;
        this.y = v2.y;
        return this;
      }
      add(v2) {
        this.x += v2.x;
        this.y += v2.y;
        return this;
      }
      addScalar(s) {
        this.x += s;
        this.y += s;
        return this;
      }
      addVectors(a, b) {
        this.x = a.x + b.x;
        this.y = a.y + b.y;
        return this;
      }
      addScaledVector(v2, s) {
        this.x += v2.x * s;
        this.y += v2.y * s;
        return this;
      }
      sub(v2) {
        this.x -= v2.x;
        this.y -= v2.y;
        return this;
      }
      subScalar(s) {
        this.x -= s;
        this.y -= s;
        return this;
      }
      subVectors(a, b) {
        this.x = a.x - b.x;
        this.y = a.y - b.y;
        return this;
      }
      multiply(v2) {
        this.x *= v2.x;
        this.y *= v2.y;
        return this;
      }
      multiplyScalar(scalar) {
        this.x *= scalar;
        this.y *= scalar;
        return this;
      }
      divide(v2) {
        this.x /= v2.x;
        this.y /= v2.y;
        return this;
      }
      divideScalar(scalar) {
        return this.multiplyScalar(1 / scalar);
      }
      applyMatrix3(m) {
        const x = this.x, y2 = this.y;
        const e = m.elements;
        this.x = e[0] * x + e[3] * y2 + e[6];
        this.y = e[1] * x + e[4] * y2 + e[7];
        return this;
      }
      min(v2) {
        this.x = Math.min(this.x, v2.x);
        this.y = Math.min(this.y, v2.y);
        return this;
      }
      max(v2) {
        this.x = Math.max(this.x, v2.x);
        this.y = Math.max(this.y, v2.y);
        return this;
      }
      clamp(min, max) {
        this.x = Math.max(min.x, Math.min(max.x, this.x));
        this.y = Math.max(min.y, Math.min(max.y, this.y));
        return this;
      }
      clampScalar(minVal, maxVal) {
        this.x = Math.max(minVal, Math.min(maxVal, this.x));
        this.y = Math.max(minVal, Math.min(maxVal, this.y));
        return this;
      }
      clampLength(min, max) {
        const length = this.length();
        return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));
      }
      floor() {
        this.x = Math.floor(this.x);
        this.y = Math.floor(this.y);
        return this;
      }
      ceil() {
        this.x = Math.ceil(this.x);
        this.y = Math.ceil(this.y);
        return this;
      }
      round() {
        this.x = Math.round(this.x);
        this.y = Math.round(this.y);
        return this;
      }
      roundToZero() {
        this.x = Math.trunc(this.x);
        this.y = Math.trunc(this.y);
        return this;
      }
      negate() {
        this.x = -this.x;
        this.y = -this.y;
        return this;
      }
      dot(v2) {
        return this.x * v2.x + this.y * v2.y;
      }
      cross(v2) {
        return this.x * v2.y - this.y * v2.x;
      }
      lengthSq() {
        return this.x * this.x + this.y * this.y;
      }
      length() {
        return Math.sqrt(this.x * this.x + this.y * this.y);
      }
      manhattanLength() {
        return Math.abs(this.x) + Math.abs(this.y);
      }
      normalize() {
        return this.divideScalar(this.length() || 1);
      }
      angle() {
        const angle = Math.atan2(-this.y, -this.x) + Math.PI;
        return angle;
      }
      angleTo(v2) {
        const denominator = Math.sqrt(this.lengthSq() * v2.lengthSq());
        if (denominator === 0) return Math.PI / 2;
        const theta = this.dot(v2) / denominator;
        return Math.acos(clamp(theta, -1, 1));
      }
      distanceTo(v2) {
        return Math.sqrt(this.distanceToSquared(v2));
      }
      distanceToSquared(v2) {
        const dx = this.x - v2.x, dy = this.y - v2.y;
        return dx * dx + dy * dy;
      }
      manhattanDistanceTo(v2) {
        return Math.abs(this.x - v2.x) + Math.abs(this.y - v2.y);
      }
      setLength(length) {
        return this.normalize().multiplyScalar(length);
      }
      lerp(v2, alpha) {
        this.x += (v2.x - this.x) * alpha;
        this.y += (v2.y - this.y) * alpha;
        return this;
      }
      lerpVectors(v1, v2, alpha) {
        this.x = v1.x + (v2.x - v1.x) * alpha;
        this.y = v1.y + (v2.y - v1.y) * alpha;
        return this;
      }
      equals(v2) {
        return v2.x === this.x && v2.y === this.y;
      }
      fromArray(array, offset = 0) {
        this.x = array[offset];
        this.y = array[offset + 1];
        return this;
      }
      toArray(array = [], offset = 0) {
        array[offset] = this.x;
        array[offset + 1] = this.y;
        return array;
      }
      fromBufferAttribute(attribute, index) {
        this.x = attribute.getX(index);
        this.y = attribute.getY(index);
        return this;
      }
      rotateAround(center, angle) {
        const c = Math.cos(angle), s = Math.sin(angle);
        const x = this.x - center.x;
        const y2 = this.y - center.y;
        this.x = x * c - y2 * s + center.x;
        this.y = x * s + y2 * c + center.y;
        return this;
      }
      random() {
        this.x = Math.random();
        this.y = Math.random();
        return this;
      }
      *[Symbol.iterator]() {
        yield this.x;
        yield this.y;
      }
    };
    Matrix3 = class _Matrix3 {
      constructor(n11, n12, n13, n21, n22, n23, n31, n32, n33) {
        _Matrix3.prototype.isMatrix3 = true;
        this.elements = [
          1,
          0,
          0,
          0,
          1,
          0,
          0,
          0,
          1
        ];
        if (n11 !== void 0) {
          this.set(n11, n12, n13, n21, n22, n23, n31, n32, n33);
        }
      }
      set(n11, n12, n13, n21, n22, n23, n31, n32, n33) {
        const te = this.elements;
        te[0] = n11;
        te[1] = n21;
        te[2] = n31;
        te[3] = n12;
        te[4] = n22;
        te[5] = n32;
        te[6] = n13;
        te[7] = n23;
        te[8] = n33;
        return this;
      }
      identity() {
        this.set(
          1,
          0,
          0,
          0,
          1,
          0,
          0,
          0,
          1
        );
        return this;
      }
      copy(m) {
        const te = this.elements;
        const me = m.elements;
        te[0] = me[0];
        te[1] = me[1];
        te[2] = me[2];
        te[3] = me[3];
        te[4] = me[4];
        te[5] = me[5];
        te[6] = me[6];
        te[7] = me[7];
        te[8] = me[8];
        return this;
      }
      extractBasis(xAxis, yAxis, zAxis) {
        xAxis.setFromMatrix3Column(this, 0);
        yAxis.setFromMatrix3Column(this, 1);
        zAxis.setFromMatrix3Column(this, 2);
        return this;
      }
      setFromMatrix4(m) {
        const me = m.elements;
        this.set(
          me[0],
          me[4],
          me[8],
          me[1],
          me[5],
          me[9],
          me[2],
          me[6],
          me[10]
        );
        return this;
      }
      multiply(m) {
        return this.multiplyMatrices(this, m);
      }
      premultiply(m) {
        return this.multiplyMatrices(m, this);
      }
      multiplyMatrices(a, b) {
        const ae = a.elements;
        const be = b.elements;
        const te = this.elements;
        const a11 = ae[0], a12 = ae[3], a13 = ae[6];
        const a21 = ae[1], a22 = ae[4], a23 = ae[7];
        const a31 = ae[2], a32 = ae[5], a33 = ae[8];
        const b11 = be[0], b12 = be[3], b13 = be[6];
        const b21 = be[1], b22 = be[4], b23 = be[7];
        const b31 = be[2], b32 = be[5], b33 = be[8];
        te[0] = a11 * b11 + a12 * b21 + a13 * b31;
        te[3] = a11 * b12 + a12 * b22 + a13 * b32;
        te[6] = a11 * b13 + a12 * b23 + a13 * b33;
        te[1] = a21 * b11 + a22 * b21 + a23 * b31;
        te[4] = a21 * b12 + a22 * b22 + a23 * b32;
        te[7] = a21 * b13 + a22 * b23 + a23 * b33;
        te[2] = a31 * b11 + a32 * b21 + a33 * b31;
        te[5] = a31 * b12 + a32 * b22 + a33 * b32;
        te[8] = a31 * b13 + a32 * b23 + a33 * b33;
        return this;
      }
      multiplyScalar(s) {
        const te = this.elements;
        te[0] *= s;
        te[3] *= s;
        te[6] *= s;
        te[1] *= s;
        te[4] *= s;
        te[7] *= s;
        te[2] *= s;
        te[5] *= s;
        te[8] *= s;
        return this;
      }
      determinant() {
        const te = this.elements;
        const a = te[0], b = te[1], c = te[2], d = te[3], e = te[4], f2 = te[5], g3 = te[6], h2 = te[7], i2 = te[8];
        return a * e * i2 - a * f2 * h2 - b * d * i2 + b * f2 * g3 + c * d * h2 - c * e * g3;
      }
      invert() {
        const te = this.elements, n11 = te[0], n21 = te[1], n31 = te[2], n12 = te[3], n22 = te[4], n32 = te[5], n13 = te[6], n23 = te[7], n33 = te[8], t11 = n33 * n22 - n32 * n23, t12 = n32 * n13 - n33 * n12, t13 = n23 * n12 - n22 * n13, det = n11 * t11 + n21 * t12 + n31 * t13;
        if (det === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
        const detInv = 1 / det;
        te[0] = t11 * detInv;
        te[1] = (n31 * n23 - n33 * n21) * detInv;
        te[2] = (n32 * n21 - n31 * n22) * detInv;
        te[3] = t12 * detInv;
        te[4] = (n33 * n11 - n31 * n13) * detInv;
        te[5] = (n31 * n12 - n32 * n11) * detInv;
        te[6] = t13 * detInv;
        te[7] = (n21 * n13 - n23 * n11) * detInv;
        te[8] = (n22 * n11 - n21 * n12) * detInv;
        return this;
      }
      transpose() {
        let tmp2;
        const m = this.elements;
        tmp2 = m[1];
        m[1] = m[3];
        m[3] = tmp2;
        tmp2 = m[2];
        m[2] = m[6];
        m[6] = tmp2;
        tmp2 = m[5];
        m[5] = m[7];
        m[7] = tmp2;
        return this;
      }
      getNormalMatrix(matrix4) {
        return this.setFromMatrix4(matrix4).invert().transpose();
      }
      transposeIntoArray(r2) {
        const m = this.elements;
        r2[0] = m[0];
        r2[1] = m[3];
        r2[2] = m[6];
        r2[3] = m[1];
        r2[4] = m[4];
        r2[5] = m[7];
        r2[6] = m[2];
        r2[7] = m[5];
        r2[8] = m[8];
        return this;
      }
      setUvTransform(tx, ty, sx, sy, rotation, cx, cy) {
        const c = Math.cos(rotation);
        const s = Math.sin(rotation);
        this.set(
          sx * c,
          sx * s,
          -sx * (c * cx + s * cy) + cx + tx,
          -sy * s,
          sy * c,
          -sy * (-s * cx + c * cy) + cy + ty,
          0,
          0,
          1
        );
        return this;
      }
      //
      scale(sx, sy) {
        this.premultiply(_m3.makeScale(sx, sy));
        return this;
      }
      rotate(theta) {
        this.premultiply(_m3.makeRotation(-theta));
        return this;
      }
      translate(tx, ty) {
        this.premultiply(_m3.makeTranslation(tx, ty));
        return this;
      }
      // for 2D Transforms
      makeTranslation(x, y2) {
        if (x.isVector2) {
          this.set(
            1,
            0,
            x.x,
            0,
            1,
            x.y,
            0,
            0,
            1
          );
        } else {
          this.set(
            1,
            0,
            x,
            0,
            1,
            y2,
            0,
            0,
            1
          );
        }
        return this;
      }
      makeRotation(theta) {
        const c = Math.cos(theta);
        const s = Math.sin(theta);
        this.set(
          c,
          -s,
          0,
          s,
          c,
          0,
          0,
          0,
          1
        );
        return this;
      }
      makeScale(x, y2) {
        this.set(
          x,
          0,
          0,
          0,
          y2,
          0,
          0,
          0,
          1
        );
        return this;
      }
      //
      equals(matrix2) {
        const te = this.elements;
        const me = matrix2.elements;
        for (let i2 = 0; i2 < 9; i2++) {
          if (te[i2] !== me[i2]) return false;
        }
        return true;
      }
      fromArray(array, offset = 0) {
        for (let i2 = 0; i2 < 9; i2++) {
          this.elements[i2] = array[i2 + offset];
        }
        return this;
      }
      toArray(array = [], offset = 0) {
        const te = this.elements;
        array[offset] = te[0];
        array[offset + 1] = te[1];
        array[offset + 2] = te[2];
        array[offset + 3] = te[3];
        array[offset + 4] = te[4];
        array[offset + 5] = te[5];
        array[offset + 6] = te[6];
        array[offset + 7] = te[7];
        array[offset + 8] = te[8];
        return array;
      }
      clone() {
        return new this.constructor().fromArray(this.elements);
      }
    };
    _m3 = /* @__PURE__ */ new Matrix3();
    TYPED_ARRAYS = {
      Int8Array,
      Uint8Array,
      Uint8ClampedArray,
      Int16Array,
      Uint16Array,
      Int32Array,
      Uint32Array,
      Float32Array,
      Float64Array
    };
    _cache = {};
    LINEAR_SRGB_TO_LINEAR_DISPLAY_P3 = /* @__PURE__ */ new Matrix3().set(
      0.8224621,
      0.177538,
      0,
      0.0331941,
      0.9668058,
      0,
      0.0170827,
      0.0723974,
      0.9105199
    );
    LINEAR_DISPLAY_P3_TO_LINEAR_SRGB = /* @__PURE__ */ new Matrix3().set(
      1.2249401,
      -0.2249404,
      0,
      -0.0420569,
      1.0420571,
      0,
      -0.0196376,
      -0.0786361,
      1.0982735
    );
    COLOR_SPACES = {
      [LinearSRGBColorSpace]: {
        transfer: LinearTransfer,
        primaries: Rec709Primaries,
        luminanceCoefficients: [0.2126, 0.7152, 0.0722],
        toReference: (color) => color,
        fromReference: (color) => color
      },
      [SRGBColorSpace]: {
        transfer: SRGBTransfer,
        primaries: Rec709Primaries,
        luminanceCoefficients: [0.2126, 0.7152, 0.0722],
        toReference: (color) => color.convertSRGBToLinear(),
        fromReference: (color) => color.convertLinearToSRGB()
      },
      [LinearDisplayP3ColorSpace]: {
        transfer: LinearTransfer,
        primaries: P3Primaries,
        luminanceCoefficients: [0.2289, 0.6917, 0.0793],
        toReference: (color) => color.applyMatrix3(LINEAR_DISPLAY_P3_TO_LINEAR_SRGB),
        fromReference: (color) => color.applyMatrix3(LINEAR_SRGB_TO_LINEAR_DISPLAY_P3)
      },
      [DisplayP3ColorSpace]: {
        transfer: SRGBTransfer,
        primaries: P3Primaries,
        luminanceCoefficients: [0.2289, 0.6917, 0.0793],
        toReference: (color) => color.convertSRGBToLinear().applyMatrix3(LINEAR_DISPLAY_P3_TO_LINEAR_SRGB),
        fromReference: (color) => color.applyMatrix3(LINEAR_SRGB_TO_LINEAR_DISPLAY_P3).convertLinearToSRGB()
      }
    };
    SUPPORTED_WORKING_COLOR_SPACES = /* @__PURE__ */ new Set([LinearSRGBColorSpace, LinearDisplayP3ColorSpace]);
    ColorManagement = {
      enabled: true,
      _workingColorSpace: LinearSRGBColorSpace,
      get workingColorSpace() {
        return this._workingColorSpace;
      },
      set workingColorSpace(colorSpace) {
        if (!SUPPORTED_WORKING_COLOR_SPACES.has(colorSpace)) {
          throw new Error(`Unsupported working color space, "${colorSpace}".`);
        }
        this._workingColorSpace = colorSpace;
      },
      convert: function(color, sourceColorSpace, targetColorSpace) {
        if (this.enabled === false || sourceColorSpace === targetColorSpace || !sourceColorSpace || !targetColorSpace) {
          return color;
        }
        const sourceToReference = COLOR_SPACES[sourceColorSpace].toReference;
        const targetFromReference = COLOR_SPACES[targetColorSpace].fromReference;
        return targetFromReference(sourceToReference(color));
      },
      fromWorkingColorSpace: function(color, targetColorSpace) {
        return this.convert(color, this._workingColorSpace, targetColorSpace);
      },
      toWorkingColorSpace: function(color, sourceColorSpace) {
        return this.convert(color, sourceColorSpace, this._workingColorSpace);
      },
      getPrimaries: function(colorSpace) {
        return COLOR_SPACES[colorSpace].primaries;
      },
      getTransfer: function(colorSpace) {
        if (colorSpace === NoColorSpace) return LinearTransfer;
        return COLOR_SPACES[colorSpace].transfer;
      },
      getLuminanceCoefficients: function(target2, colorSpace = this._workingColorSpace) {
        return target2.fromArray(COLOR_SPACES[colorSpace].luminanceCoefficients);
      }
    };
    ImageUtils = class {
      static getDataURL(image) {
        if (/^data:/i.test(image.src)) {
          return image.src;
        }
        if (typeof HTMLCanvasElement === "undefined") {
          return image.src;
        }
        let canvas;
        if (image instanceof HTMLCanvasElement) {
          canvas = image;
        } else {
          if (_canvas === void 0) _canvas = createElementNS("canvas");
          _canvas.width = image.width;
          _canvas.height = image.height;
          const context2 = _canvas.getContext("2d");
          if (image instanceof ImageData) {
            context2.putImageData(image, 0, 0);
          } else {
            context2.drawImage(image, 0, 0, image.width, image.height);
          }
          canvas = _canvas;
        }
        if (canvas.width > 2048 || canvas.height > 2048) {
          console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons", image);
          return canvas.toDataURL("image/jpeg", 0.6);
        } else {
          return canvas.toDataURL("image/png");
        }
      }
      static sRGBToLinear(image) {
        if (typeof HTMLImageElement !== "undefined" && image instanceof HTMLImageElement || typeof HTMLCanvasElement !== "undefined" && image instanceof HTMLCanvasElement || typeof ImageBitmap !== "undefined" && image instanceof ImageBitmap) {
          const canvas = createElementNS("canvas");
          canvas.width = image.width;
          canvas.height = image.height;
          const context2 = canvas.getContext("2d");
          context2.drawImage(image, 0, 0, image.width, image.height);
          const imageData = context2.getImageData(0, 0, image.width, image.height);
          const data = imageData.data;
          for (let i2 = 0; i2 < data.length; i2++) {
            data[i2] = SRGBToLinear(data[i2] / 255) * 255;
          }
          context2.putImageData(imageData, 0, 0);
          return canvas;
        } else if (image.data) {
          const data = image.data.slice(0);
          for (let i2 = 0; i2 < data.length; i2++) {
            if (data instanceof Uint8Array || data instanceof Uint8ClampedArray) {
              data[i2] = Math.floor(SRGBToLinear(data[i2] / 255) * 255);
            } else {
              data[i2] = SRGBToLinear(data[i2]);
            }
          }
          return {
            data,
            width: image.width,
            height: image.height
          };
        } else {
          console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied.");
          return image;
        }
      }
    };
    _sourceId = 0;
    Source = class {
      constructor(data = null) {
        this.isSource = true;
        Object.defineProperty(this, "id", { value: _sourceId++ });
        this.uuid = generateUUID();
        this.data = data;
        this.dataReady = true;
        this.version = 0;
      }
      set needsUpdate(value) {
        if (value === true) this.version++;
      }
      toJSON(meta) {
        const isRootObject = meta === void 0 || typeof meta === "string";
        if (!isRootObject && meta.images[this.uuid] !== void 0) {
          return meta.images[this.uuid];
        }
        const output = {
          uuid: this.uuid,
          url: ""
        };
        const data = this.data;
        if (data !== null) {
          let url;
          if (Array.isArray(data)) {
            url = [];
            for (let i2 = 0, l2 = data.length; i2 < l2; i2++) {
              if (data[i2].isDataTexture) {
                url.push(serializeImage(data[i2].image));
              } else {
                url.push(serializeImage(data[i2]));
              }
            }
          } else {
            url = serializeImage(data);
          }
          output.url = url;
        }
        if (!isRootObject) {
          meta.images[this.uuid] = output;
        }
        return output;
      }
    };
    _textureId = 0;
    Texture = class _Texture extends EventDispatcher {
      constructor(image = _Texture.DEFAULT_IMAGE, mapping = _Texture.DEFAULT_MAPPING, wrapS = ClampToEdgeWrapping, wrapT = ClampToEdgeWrapping, magFilter = LinearFilter, minFilter = LinearMipmapLinearFilter, format = RGBAFormat, type = UnsignedByteType, anisotropy = _Texture.DEFAULT_ANISOTROPY, colorSpace = NoColorSpace) {
        super();
        this.isTexture = true;
        Object.defineProperty(this, "id", { value: _textureId++ });
        this.uuid = generateUUID();
        this.name = "";
        this.source = new Source(image);
        this.mipmaps = [];
        this.mapping = mapping;
        this.channel = 0;
        this.wrapS = wrapS;
        this.wrapT = wrapT;
        this.magFilter = magFilter;
        this.minFilter = minFilter;
        this.anisotropy = anisotropy;
        this.format = format;
        this.internalFormat = null;
        this.type = type;
        this.offset = new Vector2(0, 0);
        this.repeat = new Vector2(1, 1);
        this.center = new Vector2(0, 0);
        this.rotation = 0;
        this.matrixAutoUpdate = true;
        this.matrix = new Matrix3();
        this.generateMipmaps = true;
        this.premultiplyAlpha = false;
        this.flipY = true;
        this.unpackAlignment = 4;
        this.colorSpace = colorSpace;
        this.userData = {};
        this.version = 0;
        this.onUpdate = null;
        this.isRenderTargetTexture = false;
        this.pmremVersion = 0;
      }
      get image() {
        return this.source.data;
      }
      set image(value = null) {
        this.source.data = value;
      }
      updateMatrix() {
        this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y);
      }
      clone() {
        return new this.constructor().copy(this);
      }
      copy(source) {
        this.name = source.name;
        this.source = source.source;
        this.mipmaps = source.mipmaps.slice(0);
        this.mapping = source.mapping;
        this.channel = source.channel;
        this.wrapS = source.wrapS;
        this.wrapT = source.wrapT;
        this.magFilter = source.magFilter;
        this.minFilter = source.minFilter;
        this.anisotropy = source.anisotropy;
        this.format = source.format;
        this.internalFormat = source.internalFormat;
        this.type = source.type;
        this.offset.copy(source.offset);
        this.repeat.copy(source.repeat);
        this.center.copy(source.center);
        this.rotation = source.rotation;
        this.matrixAutoUpdate = source.matrixAutoUpdate;
        this.matrix.copy(source.matrix);
        this.generateMipmaps = source.generateMipmaps;
        this.premultiplyAlpha = source.premultiplyAlpha;
        this.flipY = source.flipY;
        this.unpackAlignment = source.unpackAlignment;
        this.colorSpace = source.colorSpace;
        this.userData = JSON.parse(JSON.stringify(source.userData));
        this.needsUpdate = true;
        return this;
      }
      toJSON(meta) {
        const isRootObject = meta === void 0 || typeof meta === "string";
        if (!isRootObject && meta.textures[this.uuid] !== void 0) {
          return meta.textures[this.uuid];
        }
        const output = {
          metadata: {
            version: 4.6,
            type: "Texture",
            generator: "Texture.toJSON"
          },
          uuid: this.uuid,
          name: this.name,
          image: this.source.toJSON(meta).uuid,
          mapping: this.mapping,
          channel: this.channel,
          repeat: [this.repeat.x, this.repeat.y],
          offset: [this.offset.x, this.offset.y],
          center: [this.center.x, this.center.y],
          rotation: this.rotation,
          wrap: [this.wrapS, this.wrapT],
          format: this.format,
          internalFormat: this.internalFormat,
          type: this.type,
          colorSpace: this.colorSpace,
          minFilter: this.minFilter,
          magFilter: this.magFilter,
          anisotropy: this.anisotropy,
          flipY: this.flipY,
          generateMipmaps: this.generateMipmaps,
          premultiplyAlpha: this.premultiplyAlpha,
          unpackAlignment: this.unpackAlignment
        };
        if (Object.keys(this.userData).length > 0) output.userData = this.userData;
        if (!isRootObject) {
          meta.textures[this.uuid] = output;
        }
        return output;
      }
      dispose() {
        this.dispatchEvent({ type: "dispose" });
      }
      transformUv(uv) {
        if (this.mapping !== UVMapping) return uv;
        uv.applyMatrix3(this.matrix);
        if (uv.x < 0 || uv.x > 1) {
          switch (this.wrapS) {
            case RepeatWrapping:
              uv.x = uv.x - Math.floor(uv.x);
              break;
            case ClampToEdgeWrapping:
              uv.x = uv.x < 0 ? 0 : 1;
              break;
            case MirroredRepeatWrapping:
              if (Math.abs(Math.floor(uv.x) % 2) === 1) {
                uv.x = Math.ceil(uv.x) - uv.x;
              } else {
                uv.x = uv.x - Math.floor(uv.x);
              }
              break;
          }
        }
        if (uv.y < 0 || uv.y > 1) {
          switch (this.wrapT) {
            case RepeatWrapping:
              uv.y = uv.y - Math.floor(uv.y);
              break;
            case ClampToEdgeWrapping:
              uv.y = uv.y < 0 ? 0 : 1;
              break;
            case MirroredRepeatWrapping:
              if (Math.abs(Math.floor(uv.y) % 2) === 1) {
                uv.y = Math.ceil(uv.y) - uv.y;
              } else {
                uv.y = uv.y - Math.floor(uv.y);
              }
              break;
          }
        }
        if (this.flipY) {
          uv.y = 1 - uv.y;
        }
        return uv;
      }
      set needsUpdate(value) {
        if (value === true) {
          this.version++;
          this.source.needsUpdate = true;
        }
      }
      set needsPMREMUpdate(value) {
        if (value === true) {
          this.pmremVersion++;
        }
      }
    };
    Texture.DEFAULT_IMAGE = null;
    Texture.DEFAULT_MAPPING = UVMapping;
    Texture.DEFAULT_ANISOTROPY = 1;
    Vector4 = class _Vector4 {
      constructor(x = 0, y2 = 0, z2 = 0, w = 1) {
        _Vector4.prototype.isVector4 = true;
        this.x = x;
        this.y = y2;
        this.z = z2;
        this.w = w;
      }
      get width() {
        return this.z;
      }
      set width(value) {
        this.z = value;
      }
      get height() {
        return this.w;
      }
      set height(value) {
        this.w = value;
      }
      set(x, y2, z2, w) {
        this.x = x;
        this.y = y2;
        this.z = z2;
        this.w = w;
        return this;
      }
      setScalar(scalar) {
        this.x = scalar;
        this.y = scalar;
        this.z = scalar;
        this.w = scalar;
        return this;
      }
      setX(x) {
        this.x = x;
        return this;
      }
      setY(y2) {
        this.y = y2;
        return this;
      }
      setZ(z2) {
        this.z = z2;
        return this;
      }
      setW(w) {
        this.w = w;
        return this;
      }
      setComponent(index, value) {
        switch (index) {
          case 0:
            this.x = value;
            break;
          case 1:
            this.y = value;
            break;
          case 2:
            this.z = value;
            break;
          case 3:
            this.w = value;
            break;
          default:
            throw new Error("index is out of range: " + index);
        }
        return this;
      }
      getComponent(index) {
        switch (index) {
          case 0:
            return this.x;
          case 1:
            return this.y;
          case 2:
            return this.z;
          case 3:
            return this.w;
          default:
            throw new Error("index is out of range: " + index);
        }
      }
      clone() {
        return new this.constructor(this.x, this.y, this.z, this.w);
      }
      copy(v2) {
        this.x = v2.x;
        this.y = v2.y;
        this.z = v2.z;
        this.w = v2.w !== void 0 ? v2.w : 1;
        return this;
      }
      add(v2) {
        this.x += v2.x;
        this.y += v2.y;
        this.z += v2.z;
        this.w += v2.w;
        return this;
      }
      addScalar(s) {
        this.x += s;
        this.y += s;
        this.z += s;
        this.w += s;
        return this;
      }
      addVectors(a, b) {
        this.x = a.x + b.x;
        this.y = a.y + b.y;
        this.z = a.z + b.z;
        this.w = a.w + b.w;
        return this;
      }
      addScaledVector(v2, s) {
        this.x += v2.x * s;
        this.y += v2.y * s;
        this.z += v2.z * s;
        this.w += v2.w * s;
        return this;
      }
      sub(v2) {
        this.x -= v2.x;
        this.y -= v2.y;
        this.z -= v2.z;
        this.w -= v2.w;
        return this;
      }
      subScalar(s) {
        this.x -= s;
        this.y -= s;
        this.z -= s;
        this.w -= s;
        return this;
      }
      subVectors(a, b) {
        this.x = a.x - b.x;
        this.y = a.y - b.y;
        this.z = a.z - b.z;
        this.w = a.w - b.w;
        return this;
      }
      multiply(v2) {
        this.x *= v2.x;
        this.y *= v2.y;
        this.z *= v2.z;
        this.w *= v2.w;
        return this;
      }
      multiplyScalar(scalar) {
        this.x *= scalar;
        this.y *= scalar;
        this.z *= scalar;
        this.w *= scalar;
        return this;
      }
      applyMatrix4(m) {
        const x = this.x, y2 = this.y, z2 = this.z, w = this.w;
        const e = m.elements;
        this.x = e[0] * x + e[4] * y2 + e[8] * z2 + e[12] * w;
        this.y = e[1] * x + e[5] * y2 + e[9] * z2 + e[13] * w;
        this.z = e[2] * x + e[6] * y2 + e[10] * z2 + e[14] * w;
        this.w = e[3] * x + e[7] * y2 + e[11] * z2 + e[15] * w;
        return this;
      }
      divideScalar(scalar) {
        return this.multiplyScalar(1 / scalar);
      }
      setAxisAngleFromQuaternion(q3) {
        this.w = 2 * Math.acos(q3.w);
        const s = Math.sqrt(1 - q3.w * q3.w);
        if (s < 1e-4) {
          this.x = 1;
          this.y = 0;
          this.z = 0;
        } else {
          this.x = q3.x / s;
          this.y = q3.y / s;
          this.z = q3.z / s;
        }
        return this;
      }
      setAxisAngleFromRotationMatrix(m) {
        let angle, x, y2, z2;
        const epsilon = 0.01, epsilon2 = 0.1, te = m.elements, m11 = te[0], m12 = te[4], m13 = te[8], m21 = te[1], m22 = te[5], m23 = te[9], m31 = te[2], m32 = te[6], m33 = te[10];
        if (Math.abs(m12 - m21) < epsilon && Math.abs(m13 - m31) < epsilon && Math.abs(m23 - m32) < epsilon) {
          if (Math.abs(m12 + m21) < epsilon2 && Math.abs(m13 + m31) < epsilon2 && Math.abs(m23 + m32) < epsilon2 && Math.abs(m11 + m22 + m33 - 3) < epsilon2) {
            this.set(1, 0, 0, 0);
            return this;
          }
          angle = Math.PI;
          const xx = (m11 + 1) / 2;
          const yy = (m22 + 1) / 2;
          const zz = (m33 + 1) / 2;
          const xy = (m12 + m21) / 4;
          const xz = (m13 + m31) / 4;
          const yz = (m23 + m32) / 4;
          if (xx > yy && xx > zz) {
            if (xx < epsilon) {
              x = 0;
              y2 = 0.707106781;
              z2 = 0.707106781;
            } else {
              x = Math.sqrt(xx);
              y2 = xy / x;
              z2 = xz / x;
            }
          } else if (yy > zz) {
            if (yy < epsilon) {
              x = 0.707106781;
              y2 = 0;
              z2 = 0.707106781;
            } else {
              y2 = Math.sqrt(yy);
              x = xy / y2;
              z2 = yz / y2;
            }
          } else {
            if (zz < epsilon) {
              x = 0.707106781;
              y2 = 0.707106781;
              z2 = 0;
            } else {
              z2 = Math.sqrt(zz);
              x = xz / z2;
              y2 = yz / z2;
            }
          }
          this.set(x, y2, z2, angle);
          return this;
        }
        let s = Math.sqrt((m32 - m23) * (m32 - m23) + (m13 - m31) * (m13 - m31) + (m21 - m12) * (m21 - m12));
        if (Math.abs(s) < 1e-3) s = 1;
        this.x = (m32 - m23) / s;
        this.y = (m13 - m31) / s;
        this.z = (m21 - m12) / s;
        this.w = Math.acos((m11 + m22 + m33 - 1) / 2);
        return this;
      }
      setFromMatrixPosition(m) {
        const e = m.elements;
        this.x = e[12];
        this.y = e[13];
        this.z = e[14];
        this.w = e[15];
        return this;
      }
      min(v2) {
        this.x = Math.min(this.x, v2.x);
        this.y = Math.min(this.y, v2.y);
        this.z = Math.min(this.z, v2.z);
        this.w = Math.min(this.w, v2.w);
        return this;
      }
      max(v2) {
        this.x = Math.max(this.x, v2.x);
        this.y = Math.max(this.y, v2.y);
        this.z = Math.max(this.z, v2.z);
        this.w = Math.max(this.w, v2.w);
        return this;
      }
      clamp(min, max) {
        this.x = Math.max(min.x, Math.min(max.x, this.x));
        this.y = Math.max(min.y, Math.min(max.y, this.y));
        this.z = Math.max(min.z, Math.min(max.z, this.z));
        this.w = Math.max(min.w, Math.min(max.w, this.w));
        return this;
      }
      clampScalar(minVal, maxVal) {
        this.x = Math.max(minVal, Math.min(maxVal, this.x));
        this.y = Math.max(minVal, Math.min(maxVal, this.y));
        this.z = Math.max(minVal, Math.min(maxVal, this.z));
        this.w = Math.max(minVal, Math.min(maxVal, this.w));
        return this;
      }
      clampLength(min, max) {
        const length = this.length();
        return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));
      }
      floor() {
        this.x = Math.floor(this.x);
        this.y = Math.floor(this.y);
        this.z = Math.floor(this.z);
        this.w = Math.floor(this.w);
        return this;
      }
      ceil() {
        this.x = Math.ceil(this.x);
        this.y = Math.ceil(this.y);
        this.z = Math.ceil(this.z);
        this.w = Math.ceil(this.w);
        return this;
      }
      round() {
        this.x = Math.round(this.x);
        this.y = Math.round(this.y);
        this.z = Math.round(this.z);
        this.w = Math.round(this.w);
        return this;
      }
      roundToZero() {
        this.x = Math.trunc(this.x);
        this.y = Math.trunc(this.y);
        this.z = Math.trunc(this.z);
        this.w = Math.trunc(this.w);
        return this;
      }
      negate() {
        this.x = -this.x;
        this.y = -this.y;
        this.z = -this.z;
        this.w = -this.w;
        return this;
      }
      dot(v2) {
        return this.x * v2.x + this.y * v2.y + this.z * v2.z + this.w * v2.w;
      }
      lengthSq() {
        return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
      }
      length() {
        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
      }
      manhattanLength() {
        return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
      }
      normalize() {
        return this.divideScalar(this.length() || 1);
      }
      setLength(length) {
        return this.normalize().multiplyScalar(length);
      }
      lerp(v2, alpha) {
        this.x += (v2.x - this.x) * alpha;
        this.y += (v2.y - this.y) * alpha;
        this.z += (v2.z - this.z) * alpha;
        this.w += (v2.w - this.w) * alpha;
        return this;
      }
      lerpVectors(v1, v2, alpha) {
        this.x = v1.x + (v2.x - v1.x) * alpha;
        this.y = v1.y + (v2.y - v1.y) * alpha;
        this.z = v1.z + (v2.z - v1.z) * alpha;
        this.w = v1.w + (v2.w - v1.w) * alpha;
        return this;
      }
      equals(v2) {
        return v2.x === this.x && v2.y === this.y && v2.z === this.z && v2.w === this.w;
      }
      fromArray(array, offset = 0) {
        this.x = array[offset];
        this.y = array[offset + 1];
        this.z = array[offset + 2];
        this.w = array[offset + 3];
        return this;
      }
      toArray(array = [], offset = 0) {
        array[offset] = this.x;
        array[offset + 1] = this.y;
        array[offset + 2] = this.z;
        array[offset + 3] = this.w;
        return array;
      }
      fromBufferAttribute(attribute, index) {
        this.x = attribute.getX(index);
        this.y = attribute.getY(index);
        this.z = attribute.getZ(index);
        this.w = attribute.getW(index);
        return this;
      }
      random() {
        this.x = Math.random();
        this.y = Math.random();
        this.z = Math.random();
        this.w = Math.random();
        return this;
      }
      *[Symbol.iterator]() {
        yield this.x;
        yield this.y;
        yield this.z;
        yield this.w;
      }
    };
    RenderTarget = class extends EventDispatcher {
      constructor(width = 1, height = 1, options = {}) {
        super();
        this.isRenderTarget = true;
        this.width = width;
        this.height = height;
        this.depth = 1;
        this.scissor = new Vector4(0, 0, width, height);
        this.scissorTest = false;
        this.viewport = new Vector4(0, 0, width, height);
        const image = { width, height, depth: 1 };
        options = Object.assign({
          generateMipmaps: false,
          internalFormat: null,
          minFilter: LinearFilter,
          depthBuffer: true,
          stencilBuffer: false,
          resolveDepthBuffer: true,
          resolveStencilBuffer: true,
          depthTexture: null,
          samples: 0,
          count: 1
        }, options);
        const texture = new Texture(image, options.mapping, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.colorSpace);
        texture.flipY = false;
        texture.generateMipmaps = options.generateMipmaps;
        texture.internalFormat = options.internalFormat;
        this.textures = [];
        const count = options.count;
        for (let i2 = 0; i2 < count; i2++) {
          this.textures[i2] = texture.clone();
          this.textures[i2].isRenderTargetTexture = true;
        }
        this.depthBuffer = options.depthBuffer;
        this.stencilBuffer = options.stencilBuffer;
        this.resolveDepthBuffer = options.resolveDepthBuffer;
        this.resolveStencilBuffer = options.resolveStencilBuffer;
        this.depthTexture = options.depthTexture;
        this.samples = options.samples;
      }
      get texture() {
        return this.textures[0];
      }
      set texture(value) {
        this.textures[0] = value;
      }
      setSize(width, height, depth = 1) {
        if (this.width !== width || this.height !== height || this.depth !== depth) {
          this.width = width;
          this.height = height;
          this.depth = depth;
          for (let i2 = 0, il = this.textures.length; i2 < il; i2++) {
            this.textures[i2].image.width = width;
            this.textures[i2].image.height = height;
            this.textures[i2].image.depth = depth;
          }
          this.dispose();
        }
        this.viewport.set(0, 0, width, height);
        this.scissor.set(0, 0, width, height);
      }
      clone() {
        return new this.constructor().copy(this);
      }
      copy(source) {
        this.width = source.width;
        this.height = source.height;
        this.depth = source.depth;
        this.scissor.copy(source.scissor);
        this.scissorTest = source.scissorTest;
        this.viewport.copy(source.viewport);
        this.textures.length = 0;
        for (let i2 = 0, il = source.textures.length; i2 < il; i2++) {
          this.textures[i2] = source.textures[i2].clone();
          this.textures[i2].isRenderTargetTexture = true;
        }
        const image = Object.assign({}, source.texture.image);
        this.texture.source = new Source(image);
        this.depthBuffer = source.depthBuffer;
        this.stencilBuffer = source.stencilBuffer;
        this.resolveDepthBuffer = source.resolveDepthBuffer;
        this.resolveStencilBuffer = source.resolveStencilBuffer;
        if (source.depthTexture !== null) this.depthTexture = source.depthTexture.clone();
        this.samples = source.samples;
        return this;
      }
      dispose() {
        this.dispatchEvent({ type: "dispose" });
      }
    };
    WebGLRenderTarget = class extends RenderTarget {
      constructor(width = 1, height = 1, options = {}) {
        super(width, height, options);
        this.isWebGLRenderTarget = true;
      }
    };
    DataArrayTexture = class extends Texture {
      constructor(data = null, width = 1, height = 1, depth = 1) {
        super(null);
        this.isDataArrayTexture = true;
        this.image = { data, width, height, depth };
        this.magFilter = NearestFilter;
        this.minFilter = NearestFilter;
        this.wrapR = ClampToEdgeWrapping;
        this.generateMipmaps = false;
        this.flipY = false;
        this.unpackAlignment = 1;
        this.layerUpdates = /* @__PURE__ */ new Set();
      }
      addLayerUpdate(layerIndex) {
        this.layerUpdates.add(layerIndex);
      }
      clearLayerUpdates() {
        this.layerUpdates.clear();
      }
    };
    WebGLArrayRenderTarget = class extends WebGLRenderTarget {
      constructor(width = 1, height = 1, depth = 1, options = {}) {
        super(width, height, options);
        this.isWebGLArrayRenderTarget = true;
        this.depth = depth;
        this.texture = new DataArrayTexture(null, width, height, depth);
        this.texture.isRenderTargetTexture = true;
      }
    };
    Data3DTexture = class extends Texture {
      constructor(data = null, width = 1, height = 1, depth = 1) {
        super(null);
        this.isData3DTexture = true;
        this.image = { data, width, height, depth };
        this.magFilter = NearestFilter;
        this.minFilter = NearestFilter;
        this.wrapR = ClampToEdgeWrapping;
        this.generateMipmaps = false;
        this.flipY = false;
        this.unpackAlignment = 1;
      }
    };
    WebGL3DRenderTarget = class extends WebGLRenderTarget {
      constructor(width = 1, height = 1, depth = 1, options = {}) {
        super(width, height, options);
        this.isWebGL3DRenderTarget = true;
        this.depth = depth;
        this.texture = new Data3DTexture(null, width, height, depth);
        this.texture.isRenderTargetTexture = true;
      }
    };
    Quaternion = class {
      constructor(x = 0, y2 = 0, z2 = 0, w = 1) {
        this.isQuaternion = true;
        this._x = x;
        this._y = y2;
        this._z = z2;
        this._w = w;
      }
      static slerpFlat(dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t2) {
        let x0 = src0[srcOffset0 + 0], y0 = src0[srcOffset0 + 1], z0 = src0[srcOffset0 + 2], w0 = src0[srcOffset0 + 3];
        const x1 = src1[srcOffset1 + 0], y1 = src1[srcOffset1 + 1], z1 = src1[srcOffset1 + 2], w1 = src1[srcOffset1 + 3];
        if (t2 === 0) {
          dst[dstOffset + 0] = x0;
          dst[dstOffset + 1] = y0;
          dst[dstOffset + 2] = z0;
          dst[dstOffset + 3] = w0;
          return;
        }
        if (t2 === 1) {
          dst[dstOffset + 0] = x1;
          dst[dstOffset + 1] = y1;
          dst[dstOffset + 2] = z1;
          dst[dstOffset + 3] = w1;
          return;
        }
        if (w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1) {
          let s = 1 - t2;
          const cos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1, dir = cos >= 0 ? 1 : -1, sqrSin = 1 - cos * cos;
          if (sqrSin > Number.EPSILON) {
            const sin = Math.sqrt(sqrSin), len = Math.atan2(sin, cos * dir);
            s = Math.sin(s * len) / sin;
            t2 = Math.sin(t2 * len) / sin;
          }
          const tDir = t2 * dir;
          x0 = x0 * s + x1 * tDir;
          y0 = y0 * s + y1 * tDir;
          z0 = z0 * s + z1 * tDir;
          w0 = w0 * s + w1 * tDir;
          if (s === 1 - t2) {
            const f2 = 1 / Math.sqrt(x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0);
            x0 *= f2;
            y0 *= f2;
            z0 *= f2;
            w0 *= f2;
          }
        }
        dst[dstOffset] = x0;
        dst[dstOffset + 1] = y0;
        dst[dstOffset + 2] = z0;
        dst[dstOffset + 3] = w0;
      }
      static multiplyQuaternionsFlat(dst, dstOffset, src0, srcOffset0, src1, srcOffset1) {
        const x0 = src0[srcOffset0];
        const y0 = src0[srcOffset0 + 1];
        const z0 = src0[srcOffset0 + 2];
        const w0 = src0[srcOffset0 + 3];
        const x1 = src1[srcOffset1];
        const y1 = src1[srcOffset1 + 1];
        const z1 = src1[srcOffset1 + 2];
        const w1 = src1[srcOffset1 + 3];
        dst[dstOffset] = x0 * w1 + w0 * x1 + y0 * z1 - z0 * y1;
        dst[dstOffset + 1] = y0 * w1 + w0 * y1 + z0 * x1 - x0 * z1;
        dst[dstOffset + 2] = z0 * w1 + w0 * z1 + x0 * y1 - y0 * x1;
        dst[dstOffset + 3] = w0 * w1 - x0 * x1 - y0 * y1 - z0 * z1;
        return dst;
      }
      get x() {
        return this._x;
      }
      set x(value) {
        this._x = value;
        this._onChangeCallback();
      }
      get y() {
        return this._y;
      }
      set y(value) {
        this._y = value;
        this._onChangeCallback();
      }
      get z() {
        return this._z;
      }
      set z(value) {
        this._z = value;
        this._onChangeCallback();
      }
      get w() {
        return this._w;
      }
      set w(value) {
        this._w = value;
        this._onChangeCallback();
      }
      set(x, y2, z2, w) {
        this._x = x;
        this._y = y2;
        this._z = z2;
        this._w = w;
        this._onChangeCallback();
        return this;
      }
      clone() {
        return new this.constructor(this._x, this._y, this._z, this._w);
      }
      copy(quaternion) {
        this._x = quaternion.x;
        this._y = quaternion.y;
        this._z = quaternion.z;
        this._w = quaternion.w;
        this._onChangeCallback();
        return this;
      }
      setFromEuler(euler, update = true) {
        const x = euler._x, y2 = euler._y, z2 = euler._z, order = euler._order;
        const cos = Math.cos;
        const sin = Math.sin;
        const c1 = cos(x / 2);
        const c2 = cos(y2 / 2);
        const c3 = cos(z2 / 2);
        const s1 = sin(x / 2);
        const s2 = sin(y2 / 2);
        const s3 = sin(z2 / 2);
        switch (order) {
          case "XYZ":
            this._x = s1 * c2 * c3 + c1 * s2 * s3;
            this._y = c1 * s2 * c3 - s1 * c2 * s3;
            this._z = c1 * c2 * s3 + s1 * s2 * c3;
            this._w = c1 * c2 * c3 - s1 * s2 * s3;
            break;
          case "YXZ":
            this._x = s1 * c2 * c3 + c1 * s2 * s3;
            this._y = c1 * s2 * c3 - s1 * c2 * s3;
            this._z = c1 * c2 * s3 - s1 * s2 * c3;
            this._w = c1 * c2 * c3 + s1 * s2 * s3;
            break;
          case "ZXY":
            this._x = s1 * c2 * c3 - c1 * s2 * s3;
            this._y = c1 * s2 * c3 + s1 * c2 * s3;
            this._z = c1 * c2 * s3 + s1 * s2 * c3;
            this._w = c1 * c2 * c3 - s1 * s2 * s3;
            break;
          case "ZYX":
            this._x = s1 * c2 * c3 - c1 * s2 * s3;
            this._y = c1 * s2 * c3 + s1 * c2 * s3;
            this._z = c1 * c2 * s3 - s1 * s2 * c3;
            this._w = c1 * c2 * c3 + s1 * s2 * s3;
            break;
          case "YZX":
            this._x = s1 * c2 * c3 + c1 * s2 * s3;
            this._y = c1 * s2 * c3 + s1 * c2 * s3;
            this._z = c1 * c2 * s3 - s1 * s2 * c3;
            this._w = c1 * c2 * c3 - s1 * s2 * s3;
            break;
          case "XZY":
            this._x = s1 * c2 * c3 - c1 * s2 * s3;
            this._y = c1 * s2 * c3 - s1 * c2 * s3;
            this._z = c1 * c2 * s3 + s1 * s2 * c3;
            this._w = c1 * c2 * c3 + s1 * s2 * s3;
            break;
          default:
            console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + order);
        }
        if (update === true) this._onChangeCallback();
        return this;
      }
      setFromAxisAngle(axis, angle) {
        const halfAngle = angle / 2, s = Math.sin(halfAngle);
        this._x = axis.x * s;
        this._y = axis.y * s;
        this._z = axis.z * s;
        this._w = Math.cos(halfAngle);
        this._onChangeCallback();
        return this;
      }
      setFromRotationMatrix(m) {
        const te = m.elements, m11 = te[0], m12 = te[4], m13 = te[8], m21 = te[1], m22 = te[5], m23 = te[9], m31 = te[2], m32 = te[6], m33 = te[10], trace = m11 + m22 + m33;
        if (trace > 0) {
          const s = 0.5 / Math.sqrt(trace + 1);
          this._w = 0.25 / s;
          this._x = (m32 - m23) * s;
          this._y = (m13 - m31) * s;
          this._z = (m21 - m12) * s;
        } else if (m11 > m22 && m11 > m33) {
          const s = 2 * Math.sqrt(1 + m11 - m22 - m33);
          this._w = (m32 - m23) / s;
          this._x = 0.25 * s;
          this._y = (m12 + m21) / s;
          this._z = (m13 + m31) / s;
        } else if (m22 > m33) {
          const s = 2 * Math.sqrt(1 + m22 - m11 - m33);
          this._w = (m13 - m31) / s;
          this._x = (m12 + m21) / s;
          this._y = 0.25 * s;
          this._z = (m23 + m32) / s;
        } else {
          const s = 2 * Math.sqrt(1 + m33 - m11 - m22);
          this._w = (m21 - m12) / s;
          this._x = (m13 + m31) / s;
          this._y = (m23 + m32) / s;
          this._z = 0.25 * s;
        }
        this._onChangeCallback();
        return this;
      }
      setFromUnitVectors(vFrom, vTo) {
        let r2 = vFrom.dot(vTo) + 1;
        if (r2 < Number.EPSILON) {
          r2 = 0;
          if (Math.abs(vFrom.x) > Math.abs(vFrom.z)) {
            this._x = -vFrom.y;
            this._y = vFrom.x;
            this._z = 0;
            this._w = r2;
          } else {
            this._x = 0;
            this._y = -vFrom.z;
            this._z = vFrom.y;
            this._w = r2;
          }
        } else {
          this._x = vFrom.y * vTo.z - vFrom.z * vTo.y;
          this._y = vFrom.z * vTo.x - vFrom.x * vTo.z;
          this._z = vFrom.x * vTo.y - vFrom.y * vTo.x;
          this._w = r2;
        }
        return this.normalize();
      }
      angleTo(q3) {
        return 2 * Math.acos(Math.abs(clamp(this.dot(q3), -1, 1)));
      }
      rotateTowards(q3, step) {
        const angle = this.angleTo(q3);
        if (angle === 0) return this;
        const t2 = Math.min(1, step / angle);
        this.slerp(q3, t2);
        return this;
      }
      identity() {
        return this.set(0, 0, 0, 1);
      }
      invert() {
        return this.conjugate();
      }
      conjugate() {
        this._x *= -1;
        this._y *= -1;
        this._z *= -1;
        this._onChangeCallback();
        return this;
      }
      dot(v2) {
        return this._x * v2._x + this._y * v2._y + this._z * v2._z + this._w * v2._w;
      }
      lengthSq() {
        return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
      }
      length() {
        return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
      }
      normalize() {
        let l2 = this.length();
        if (l2 === 0) {
          this._x = 0;
          this._y = 0;
          this._z = 0;
          this._w = 1;
        } else {
          l2 = 1 / l2;
          this._x = this._x * l2;
          this._y = this._y * l2;
          this._z = this._z * l2;
          this._w = this._w * l2;
        }
        this._onChangeCallback();
        return this;
      }
      multiply(q3) {
        return this.multiplyQuaternions(this, q3);
      }
      premultiply(q3) {
        return this.multiplyQuaternions(q3, this);
      }
      multiplyQuaternions(a, b) {
        const qax = a._x, qay = a._y, qaz = a._z, qaw = a._w;
        const qbx = b._x, qby = b._y, qbz = b._z, qbw = b._w;
        this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
        this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
        this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
        this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;
        this._onChangeCallback();
        return this;
      }
      slerp(qb, t2) {
        if (t2 === 0) return this;
        if (t2 === 1) return this.copy(qb);
        const x = this._x, y2 = this._y, z2 = this._z, w = this._w;
        let cosHalfTheta = w * qb._w + x * qb._x + y2 * qb._y + z2 * qb._z;
        if (cosHalfTheta < 0) {
          this._w = -qb._w;
          this._x = -qb._x;
          this._y = -qb._y;
          this._z = -qb._z;
          cosHalfTheta = -cosHalfTheta;
        } else {
          this.copy(qb);
        }
        if (cosHalfTheta >= 1) {
          this._w = w;
          this._x = x;
          this._y = y2;
          this._z = z2;
          return this;
        }
        const sqrSinHalfTheta = 1 - cosHalfTheta * cosHalfTheta;
        if (sqrSinHalfTheta <= Number.EPSILON) {
          const s = 1 - t2;
          this._w = s * w + t2 * this._w;
          this._x = s * x + t2 * this._x;
          this._y = s * y2 + t2 * this._y;
          this._z = s * z2 + t2 * this._z;
          this.normalize();
          return this;
        }
        const sinHalfTheta = Math.sqrt(sqrSinHalfTheta);
        const halfTheta = Math.atan2(sinHalfTheta, cosHalfTheta);
        const ratioA = Math.sin((1 - t2) * halfTheta) / sinHalfTheta, ratioB = Math.sin(t2 * halfTheta) / sinHalfTheta;
        this._w = w * ratioA + this._w * ratioB;
        this._x = x * ratioA + this._x * ratioB;
        this._y = y2 * ratioA + this._y * ratioB;
        this._z = z2 * ratioA + this._z * ratioB;
        this._onChangeCallback();
        return this;
      }
      slerpQuaternions(qa, qb, t2) {
        return this.copy(qa).slerp(qb, t2);
      }
      random() {
        const theta1 = 2 * Math.PI * Math.random();
        const theta2 = 2 * Math.PI * Math.random();
        const x0 = Math.random();
        const r1 = Math.sqrt(1 - x0);
        const r2 = Math.sqrt(x0);
        return this.set(
          r1 * Math.sin(theta1),
          r1 * Math.cos(theta1),
          r2 * Math.sin(theta2),
          r2 * Math.cos(theta2)
        );
      }
      equals(quaternion) {
        return quaternion._x === this._x && quaternion._y === this._y && quaternion._z === this._z && quaternion._w === this._w;
      }
      fromArray(array, offset = 0) {
        this._x = array[offset];
        this._y = array[offset + 1];
        this._z = array[offset + 2];
        this._w = array[offset + 3];
        this._onChangeCallback();
        return this;
      }
      toArray(array = [], offset = 0) {
        array[offset] = this._x;
        array[offset + 1] = this._y;
        array[offset + 2] = this._z;
        array[offset + 3] = this._w;
        return array;
      }
      fromBufferAttribute(attribute, index) {
        this._x = attribute.getX(index);
        this._y = attribute.getY(index);
        this._z = attribute.getZ(index);
        this._w = attribute.getW(index);
        this._onChangeCallback();
        return this;
      }
      toJSON() {
        return this.toArray();
      }
      _onChange(callback) {
        this._onChangeCallback = callback;
        return this;
      }
      _onChangeCallback() {
      }
      *[Symbol.iterator]() {
        yield this._x;
        yield this._y;
        yield this._z;
        yield this._w;
      }
    };
    Vector3 = class _Vector3 {
      constructor(x = 0, y2 = 0, z2 = 0) {
        _Vector3.prototype.isVector3 = true;
        this.x = x;
        this.y = y2;
        this.z = z2;
      }
      set(x, y2, z2) {
        if (z2 === void 0) z2 = this.z;
        this.x = x;
        this.y = y2;
        this.z = z2;
        return this;
      }
      setScalar(scalar) {
        this.x = scalar;
        this.y = scalar;
        this.z = scalar;
        return this;
      }
      setX(x) {
        this.x = x;
        return this;
      }
      setY(y2) {
        this.y = y2;
        return this;
      }
      setZ(z2) {
        this.z = z2;
        return this;
      }
      setComponent(index, value) {
        switch (index) {
          case 0:
            this.x = value;
            break;
          case 1:
            this.y = value;
            break;
          case 2:
            this.z = value;
            break;
          default:
            throw new Error("index is out of range: " + index);
        }
        return this;
      }
      getComponent(index) {
        switch (index) {
          case 0:
            return this.x;
          case 1:
            return this.y;
          case 2:
            return this.z;
          default:
            throw new Error("index is out of range: " + index);
        }
      }
      clone() {
        return new this.constructor(this.x, this.y, this.z);
      }
      copy(v2) {
        this.x = v2.x;
        this.y = v2.y;
        this.z = v2.z;
        return this;
      }
      add(v2) {
        this.x += v2.x;
        this.y += v2.y;
        this.z += v2.z;
        return this;
      }
      addScalar(s) {
        this.x += s;
        this.y += s;
        this.z += s;
        return this;
      }
      addVectors(a, b) {
        this.x = a.x + b.x;
        this.y = a.y + b.y;
        this.z = a.z + b.z;
        return this;
      }
      addScaledVector(v2, s) {
        this.x += v2.x * s;
        this.y += v2.y * s;
        this.z += v2.z * s;
        return this;
      }
      sub(v2) {
        this.x -= v2.x;
        this.y -= v2.y;
        this.z -= v2.z;
        return this;
      }
      subScalar(s) {
        this.x -= s;
        this.y -= s;
        this.z -= s;
        return this;
      }
      subVectors(a, b) {
        this.x = a.x - b.x;
        this.y = a.y - b.y;
        this.z = a.z - b.z;
        return this;
      }
      multiply(v2) {
        this.x *= v2.x;
        this.y *= v2.y;
        this.z *= v2.z;
        return this;
      }
      multiplyScalar(scalar) {
        this.x *= scalar;
        this.y *= scalar;
        this.z *= scalar;
        return this;
      }
      multiplyVectors(a, b) {
        this.x = a.x * b.x;
        this.y = a.y * b.y;
        this.z = a.z * b.z;
        return this;
      }
      applyEuler(euler) {
        return this.applyQuaternion(_quaternion$4.setFromEuler(euler));
      }
      applyAxisAngle(axis, angle) {
        return this.applyQuaternion(_quaternion$4.setFromAxisAngle(axis, angle));
      }
      applyMatrix3(m) {
        const x = this.x, y2 = this.y, z2 = this.z;
        const e = m.elements;
        this.x = e[0] * x + e[3] * y2 + e[6] * z2;
        this.y = e[1] * x + e[4] * y2 + e[7] * z2;
        this.z = e[2] * x + e[5] * y2 + e[8] * z2;
        return this;
      }
      applyNormalMatrix(m) {
        return this.applyMatrix3(m).normalize();
      }
      applyMatrix4(m) {
        const x = this.x, y2 = this.y, z2 = this.z;
        const e = m.elements;
        const w = 1 / (e[3] * x + e[7] * y2 + e[11] * z2 + e[15]);
        this.x = (e[0] * x + e[4] * y2 + e[8] * z2 + e[12]) * w;
        this.y = (e[1] * x + e[5] * y2 + e[9] * z2 + e[13]) * w;
        this.z = (e[2] * x + e[6] * y2 + e[10] * z2 + e[14]) * w;
        return this;
      }
      applyQuaternion(q3) {
        const vx = this.x, vy = this.y, vz = this.z;
        const qx = q3.x, qy = q3.y, qz = q3.z, qw = q3.w;
        const tx = 2 * (qy * vz - qz * vy);
        const ty = 2 * (qz * vx - qx * vz);
        const tz = 2 * (qx * vy - qy * vx);
        this.x = vx + qw * tx + qy * tz - qz * ty;
        this.y = vy + qw * ty + qz * tx - qx * tz;
        this.z = vz + qw * tz + qx * ty - qy * tx;
        return this;
      }
      project(camera) {
        return this.applyMatrix4(camera.matrixWorldInverse).applyMatrix4(camera.projectionMatrix);
      }
      unproject(camera) {
        return this.applyMatrix4(camera.projectionMatrixInverse).applyMatrix4(camera.matrixWorld);
      }
      transformDirection(m) {
        const x = this.x, y2 = this.y, z2 = this.z;
        const e = m.elements;
        this.x = e[0] * x + e[4] * y2 + e[8] * z2;
        this.y = e[1] * x + e[5] * y2 + e[9] * z2;
        this.z = e[2] * x + e[6] * y2 + e[10] * z2;
        return this.normalize();
      }
      divide(v2) {
        this.x /= v2.x;
        this.y /= v2.y;
        this.z /= v2.z;
        return this;
      }
      divideScalar(scalar) {
        return this.multiplyScalar(1 / scalar);
      }
      min(v2) {
        this.x = Math.min(this.x, v2.x);
        this.y = Math.min(this.y, v2.y);
        this.z = Math.min(this.z, v2.z);
        return this;
      }
      max(v2) {
        this.x = Math.max(this.x, v2.x);
        this.y = Math.max(this.y, v2.y);
        this.z = Math.max(this.z, v2.z);
        return this;
      }
      clamp(min, max) {
        this.x = Math.max(min.x, Math.min(max.x, this.x));
        this.y = Math.max(min.y, Math.min(max.y, this.y));
        this.z = Math.max(min.z, Math.min(max.z, this.z));
        return this;
      }
      clampScalar(minVal, maxVal) {
        this.x = Math.max(minVal, Math.min(maxVal, this.x));
        this.y = Math.max(minVal, Math.min(maxVal, this.y));
        this.z = Math.max(minVal, Math.min(maxVal, this.z));
        return this;
      }
      clampLength(min, max) {
        const length = this.length();
        return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));
      }
      floor() {
        this.x = Math.floor(this.x);
        this.y = Math.floor(this.y);
        this.z = Math.floor(this.z);
        return this;
      }
      ceil() {
        this.x = Math.ceil(this.x);
        this.y = Math.ceil(this.y);
        this.z = Math.ceil(this.z);
        return this;
      }
      round() {
        this.x = Math.round(this.x);
        this.y = Math.round(this.y);
        this.z = Math.round(this.z);
        return this;
      }
      roundToZero() {
        this.x = Math.trunc(this.x);
        this.y = Math.trunc(this.y);
        this.z = Math.trunc(this.z);
        return this;
      }
      negate() {
        this.x = -this.x;
        this.y = -this.y;
        this.z = -this.z;
        return this;
      }
      dot(v2) {
        return this.x * v2.x + this.y * v2.y + this.z * v2.z;
      }
      // TODO lengthSquared?
      lengthSq() {
        return this.x * this.x + this.y * this.y + this.z * this.z;
      }
      length() {
        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
      }
      manhattanLength() {
        return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
      }
      normalize() {
        return this.divideScalar(this.length() || 1);
      }
      setLength(length) {
        return this.normalize().multiplyScalar(length);
      }
      lerp(v2, alpha) {
        this.x += (v2.x - this.x) * alpha;
        this.y += (v2.y - this.y) * alpha;
        this.z += (v2.z - this.z) * alpha;
        return this;
      }
      lerpVectors(v1, v2, alpha) {
        this.x = v1.x + (v2.x - v1.x) * alpha;
        this.y = v1.y + (v2.y - v1.y) * alpha;
        this.z = v1.z + (v2.z - v1.z) * alpha;
        return this;
      }
      cross(v2) {
        return this.crossVectors(this, v2);
      }
      crossVectors(a, b) {
        const ax = a.x, ay = a.y, az = a.z;
        const bx = b.x, by = b.y, bz = b.z;
        this.x = ay * bz - az * by;
        this.y = az * bx - ax * bz;
        this.z = ax * by - ay * bx;
        return this;
      }
      projectOnVector(v2) {
        const denominator = v2.lengthSq();
        if (denominator === 0) return this.set(0, 0, 0);
        const scalar = v2.dot(this) / denominator;
        return this.copy(v2).multiplyScalar(scalar);
      }
      projectOnPlane(planeNormal) {
        _vector$c.copy(this).projectOnVector(planeNormal);
        return this.sub(_vector$c);
      }
      reflect(normal) {
        return this.sub(_vector$c.copy(normal).multiplyScalar(2 * this.dot(normal)));
      }
      angleTo(v2) {
        const denominator = Math.sqrt(this.lengthSq() * v2.lengthSq());
        if (denominator === 0) return Math.PI / 2;
        const theta = this.dot(v2) / denominator;
        return Math.acos(clamp(theta, -1, 1));
      }
      distanceTo(v2) {
        return Math.sqrt(this.distanceToSquared(v2));
      }
      distanceToSquared(v2) {
        const dx = this.x - v2.x, dy = this.y - v2.y, dz = this.z - v2.z;
        return dx * dx + dy * dy + dz * dz;
      }
      manhattanDistanceTo(v2) {
        return Math.abs(this.x - v2.x) + Math.abs(this.y - v2.y) + Math.abs(this.z - v2.z);
      }
      setFromSpherical(s) {
        return this.setFromSphericalCoords(s.radius, s.phi, s.theta);
      }
      setFromSphericalCoords(radius, phi, theta) {
        const sinPhiRadius = Math.sin(phi) * radius;
        this.x = sinPhiRadius * Math.sin(theta);
        this.y = Math.cos(phi) * radius;
        this.z = sinPhiRadius * Math.cos(theta);
        return this;
      }
      setFromCylindrical(c) {
        return this.setFromCylindricalCoords(c.radius, c.theta, c.y);
      }
      setFromCylindricalCoords(radius, theta, y2) {
        this.x = radius * Math.sin(theta);
        this.y = y2;
        this.z = radius * Math.cos(theta);
        return this;
      }
      setFromMatrixPosition(m) {
        const e = m.elements;
        this.x = e[12];
        this.y = e[13];
        this.z = e[14];
        return this;
      }
      setFromMatrixScale(m) {
        const sx = this.setFromMatrixColumn(m, 0).length();
        const sy = this.setFromMatrixColumn(m, 1).length();
        const sz = this.setFromMatrixColumn(m, 2).length();
        this.x = sx;
        this.y = sy;
        this.z = sz;
        return this;
      }
      setFromMatrixColumn(m, index) {
        return this.fromArray(m.elements, index * 4);
      }
      setFromMatrix3Column(m, index) {
        return this.fromArray(m.elements, index * 3);
      }
      setFromEuler(e) {
        this.x = e._x;
        this.y = e._y;
        this.z = e._z;
        return this;
      }
      setFromColor(c) {
        this.x = c.r;
        this.y = c.g;
        this.z = c.b;
        return this;
      }
      equals(v2) {
        return v2.x === this.x && v2.y === this.y && v2.z === this.z;
      }
      fromArray(array, offset = 0) {
        this.x = array[offset];
        this.y = array[offset + 1];
        this.z = array[offset + 2];
        return this;
      }
      toArray(array = [], offset = 0) {
        array[offset] = this.x;
        array[offset + 1] = this.y;
        array[offset + 2] = this.z;
        return array;
      }
      fromBufferAttribute(attribute, index) {
        this.x = attribute.getX(index);
        this.y = attribute.getY(index);
        this.z = attribute.getZ(index);
        return this;
      }
      random() {
        this.x = Math.random();
        this.y = Math.random();
        this.z = Math.random();
        return this;
      }
      randomDirection() {
        const theta = Math.random() * Math.PI * 2;
        const u3 = Math.random() * 2 - 1;
        const c = Math.sqrt(1 - u3 * u3);
        this.x = c * Math.cos(theta);
        this.y = u3;
        this.z = c * Math.sin(theta);
        return this;
      }
      *[Symbol.iterator]() {
        yield this.x;
        yield this.y;
        yield this.z;
      }
    };
    _vector$c = /* @__PURE__ */ new Vector3();
    _quaternion$4 = /* @__PURE__ */ new Quaternion();
    Box3 = class {
      constructor(min = new Vector3(Infinity, Infinity, Infinity), max = new Vector3(-Infinity, -Infinity, -Infinity)) {
        this.isBox3 = true;
        this.min = min;
        this.max = max;
      }
      set(min, max) {
        this.min.copy(min);
        this.max.copy(max);
        return this;
      }
      setFromArray(array) {
        this.makeEmpty();
        for (let i2 = 0, il = array.length; i2 < il; i2 += 3) {
          this.expandByPoint(_vector$b.fromArray(array, i2));
        }
        return this;
      }
      setFromBufferAttribute(attribute) {
        this.makeEmpty();
        for (let i2 = 0, il = attribute.count; i2 < il; i2++) {
          this.expandByPoint(_vector$b.fromBufferAttribute(attribute, i2));
        }
        return this;
      }
      setFromPoints(points) {
        this.makeEmpty();
        for (let i2 = 0, il = points.length; i2 < il; i2++) {
          this.expandByPoint(points[i2]);
        }
        return this;
      }
      setFromCenterAndSize(center, size) {
        const halfSize = _vector$b.copy(size).multiplyScalar(0.5);
        this.min.copy(center).sub(halfSize);
        this.max.copy(center).add(halfSize);
        return this;
      }
      setFromObject(object, precise = false) {
        this.makeEmpty();
        return this.expandByObject(object, precise);
      }
      clone() {
        return new this.constructor().copy(this);
      }
      copy(box) {
        this.min.copy(box.min);
        this.max.copy(box.max);
        return this;
      }
      makeEmpty() {
        this.min.x = this.min.y = this.min.z = Infinity;
        this.max.x = this.max.y = this.max.z = -Infinity;
        return this;
      }
      isEmpty() {
        return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;
      }
      getCenter(target2) {
        return this.isEmpty() ? target2.set(0, 0, 0) : target2.addVectors(this.min, this.max).multiplyScalar(0.5);
      }
      getSize(target2) {
        return this.isEmpty() ? target2.set(0, 0, 0) : target2.subVectors(this.max, this.min);
      }
      expandByPoint(point) {
        this.min.min(point);
        this.max.max(point);
        return this;
      }
      expandByVector(vector) {
        this.min.sub(vector);
        this.max.add(vector);
        return this;
      }
      expandByScalar(scalar) {
        this.min.addScalar(-scalar);
        this.max.addScalar(scalar);
        return this;
      }
      expandByObject(object, precise = false) {
        object.updateWorldMatrix(false, false);
        const geometry = object.geometry;
        if (geometry !== void 0) {
          const positionAttribute = geometry.getAttribute("position");
          if (precise === true && positionAttribute !== void 0 && object.isInstancedMesh !== true) {
            for (let i2 = 0, l2 = positionAttribute.count; i2 < l2; i2++) {
              if (object.isMesh === true) {
                object.getVertexPosition(i2, _vector$b);
              } else {
                _vector$b.fromBufferAttribute(positionAttribute, i2);
              }
              _vector$b.applyMatrix4(object.matrixWorld);
              this.expandByPoint(_vector$b);
            }
          } else {
            if (object.boundingBox !== void 0) {
              if (object.boundingBox === null) {
                object.computeBoundingBox();
              }
              _box$4.copy(object.boundingBox);
            } else {
              if (geometry.boundingBox === null) {
                geometry.computeBoundingBox();
              }
              _box$4.copy(geometry.boundingBox);
            }
            _box$4.applyMatrix4(object.matrixWorld);
            this.union(_box$4);
          }
        }
        const children = object.children;
        for (let i2 = 0, l2 = children.length; i2 < l2; i2++) {
          this.expandByObject(children[i2], precise);
        }
        return this;
      }
      containsPoint(point) {
        return point.x >= this.min.x && point.x <= this.max.x && point.y >= this.min.y && point.y <= this.max.y && point.z >= this.min.z && point.z <= this.max.z;
      }
      containsBox(box) {
        return this.min.x <= box.min.x && box.max.x <= this.max.x && this.min.y <= box.min.y && box.max.y <= this.max.y && this.min.z <= box.min.z && box.max.z <= this.max.z;
      }
      getParameter(point, target2) {
        return target2.set(
          (point.x - this.min.x) / (this.max.x - this.min.x),
          (point.y - this.min.y) / (this.max.y - this.min.y),
          (point.z - this.min.z) / (this.max.z - this.min.z)
        );
      }
      intersectsBox(box) {
        return box.max.x >= this.min.x && box.min.x <= this.max.x && box.max.y >= this.min.y && box.min.y <= this.max.y && box.max.z >= this.min.z && box.min.z <= this.max.z;
      }
      intersectsSphere(sphere) {
        this.clampPoint(sphere.center, _vector$b);
        return _vector$b.distanceToSquared(sphere.center) <= sphere.radius * sphere.radius;
      }
      intersectsPlane(plane) {
        let min, max;
        if (plane.normal.x > 0) {
          min = plane.normal.x * this.min.x;
          max = plane.normal.x * this.max.x;
        } else {
          min = plane.normal.x * this.max.x;
          max = plane.normal.x * this.min.x;
        }
        if (plane.normal.y > 0) {
          min += plane.normal.y * this.min.y;
          max += plane.normal.y * this.max.y;
        } else {
          min += plane.normal.y * this.max.y;
          max += plane.normal.y * this.min.y;
        }
        if (plane.normal.z > 0) {
          min += plane.normal.z * this.min.z;
          max += plane.normal.z * this.max.z;
        } else {
          min += plane.normal.z * this.max.z;
          max += plane.normal.z * this.min.z;
        }
        return min <= -plane.constant && max >= -plane.constant;
      }
      intersectsTriangle(triangle) {
        if (this.isEmpty()) {
          return false;
        }
        this.getCenter(_center);
        _extents.subVectors(this.max, _center);
        _v0$3.subVectors(triangle.a, _center);
        _v1$7.subVectors(triangle.b, _center);
        _v2$4.subVectors(triangle.c, _center);
        _f0.subVectors(_v1$7, _v0$3);
        _f1.subVectors(_v2$4, _v1$7);
        _f2.subVectors(_v0$3, _v2$4);
        let axes = [
          0,
          -_f0.z,
          _f0.y,
          0,
          -_f1.z,
          _f1.y,
          0,
          -_f2.z,
          _f2.y,
          _f0.z,
          0,
          -_f0.x,
          _f1.z,
          0,
          -_f1.x,
          _f2.z,
          0,
          -_f2.x,
          -_f0.y,
          _f0.x,
          0,
          -_f1.y,
          _f1.x,
          0,
          -_f2.y,
          _f2.x,
          0
        ];
        if (!satForAxes(axes, _v0$3, _v1$7, _v2$4, _extents)) {
          return false;
        }
        axes = [1, 0, 0, 0, 1, 0, 0, 0, 1];
        if (!satForAxes(axes, _v0$3, _v1$7, _v2$4, _extents)) {
          return false;
        }
        _triangleNormal.crossVectors(_f0, _f1);
        axes = [_triangleNormal.x, _triangleNormal.y, _triangleNormal.z];
        return satForAxes(axes, _v0$3, _v1$7, _v2$4, _extents);
      }
      clampPoint(point, target2) {
        return target2.copy(point).clamp(this.min, this.max);
      }
      distanceToPoint(point) {
        return this.clampPoint(point, _vector$b).distanceTo(point);
      }
      getBoundingSphere(target2) {
        if (this.isEmpty()) {
          target2.makeEmpty();
        } else {
          this.getCenter(target2.center);
          target2.radius = this.getSize(_vector$b).length() * 0.5;
        }
        return target2;
      }
      intersect(box) {
        this.min.max(box.min);
        this.max.min(box.max);
        if (this.isEmpty()) this.makeEmpty();
        return this;
      }
      union(box) {
        this.min.min(box.min);
        this.max.max(box.max);
        return this;
      }
      applyMatrix4(matrix2) {
        if (this.isEmpty()) return this;
        _points[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(matrix2);
        _points[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(matrix2);
        _points[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(matrix2);
        _points[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(matrix2);
        _points[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(matrix2);
        _points[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(matrix2);
        _points[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(matrix2);
        _points[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(matrix2);
        this.setFromPoints(_points);
        return this;
      }
      translate(offset) {
        this.min.add(offset);
        this.max.add(offset);
        return this;
      }
      equals(box) {
        return box.min.equals(this.min) && box.max.equals(this.max);
      }
    };
    _points = [
      /* @__PURE__ */ new Vector3(),
      /* @__PURE__ */ new Vector3(),
      /* @__PURE__ */ new Vector3(),
      /* @__PURE__ */ new Vector3(),
      /* @__PURE__ */ new Vector3(),
      /* @__PURE__ */ new Vector3(),
      /* @__PURE__ */ new Vector3(),
      /* @__PURE__ */ new Vector3()
    ];
    _vector$b = /* @__PURE__ */ new Vector3();
    _box$4 = /* @__PURE__ */ new Box3();
    _v0$3 = /* @__PURE__ */ new Vector3();
    _v1$7 = /* @__PURE__ */ new Vector3();
    _v2$4 = /* @__PURE__ */ new Vector3();
    _f0 = /* @__PURE__ */ new Vector3();
    _f1 = /* @__PURE__ */ new Vector3();
    _f2 = /* @__PURE__ */ new Vector3();
    _center = /* @__PURE__ */ new Vector3();
    _extents = /* @__PURE__ */ new Vector3();
    _triangleNormal = /* @__PURE__ */ new Vector3();
    _testAxis = /* @__PURE__ */ new Vector3();
    _box$3 = /* @__PURE__ */ new Box3();
    _v1$6 = /* @__PURE__ */ new Vector3();
    _v2$3 = /* @__PURE__ */ new Vector3();
    Sphere = class {
      constructor(center = new Vector3(), radius = -1) {
        this.isSphere = true;
        this.center = center;
        this.radius = radius;
      }
      set(center, radius) {
        this.center.copy(center);
        this.radius = radius;
        return this;
      }
      setFromPoints(points, optionalCenter) {
        const center = this.center;
        if (optionalCenter !== void 0) {
          center.copy(optionalCenter);
        } else {
          _box$3.setFromPoints(points).getCenter(center);
        }
        let maxRadiusSq = 0;
        for (let i2 = 0, il = points.length; i2 < il; i2++) {
          maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(points[i2]));
        }
        this.radius = Math.sqrt(maxRadiusSq);
        return this;
      }
      copy(sphere) {
        this.center.copy(sphere.center);
        this.radius = sphere.radius;
        return this;
      }
      isEmpty() {
        return this.radius < 0;
      }
      makeEmpty() {
        this.center.set(0, 0, 0);
        this.radius = -1;
        return this;
      }
      containsPoint(point) {
        return point.distanceToSquared(this.center) <= this.radius * this.radius;
      }
      distanceToPoint(point) {
        return point.distanceTo(this.center) - this.radius;
      }
      intersectsSphere(sphere) {
        const radiusSum = this.radius + sphere.radius;
        return sphere.center.distanceToSquared(this.center) <= radiusSum * radiusSum;
      }
      intersectsBox(box) {
        return box.intersectsSphere(this);
      }
      intersectsPlane(plane) {
        return Math.abs(plane.distanceToPoint(this.center)) <= this.radius;
      }
      clampPoint(point, target2) {
        const deltaLengthSq = this.center.distanceToSquared(point);
        target2.copy(point);
        if (deltaLengthSq > this.radius * this.radius) {
          target2.sub(this.center).normalize();
          target2.multiplyScalar(this.radius).add(this.center);
        }
        return target2;
      }
      getBoundingBox(target2) {
        if (this.isEmpty()) {
          target2.makeEmpty();
          return target2;
        }
        target2.set(this.center, this.center);
        target2.expandByScalar(this.radius);
        return target2;
      }
      applyMatrix4(matrix2) {
        this.center.applyMatrix4(matrix2);
        this.radius = this.radius * matrix2.getMaxScaleOnAxis();
        return this;
      }
      translate(offset) {
        this.center.add(offset);
        return this;
      }
      expandByPoint(point) {
        if (this.isEmpty()) {
          this.center.copy(point);
          this.radius = 0;
          return this;
        }
        _v1$6.subVectors(point, this.center);
        const lengthSq = _v1$6.lengthSq();
        if (lengthSq > this.radius * this.radius) {
          const length = Math.sqrt(lengthSq);
          const delta = (length - this.radius) * 0.5;
          this.center.addScaledVector(_v1$6, delta / length);
          this.radius += delta;
        }
        return this;
      }
      union(sphere) {
        if (sphere.isEmpty()) {
          return this;
        }
        if (this.isEmpty()) {
          this.copy(sphere);
          return this;
        }
        if (this.center.equals(sphere.center) === true) {
          this.radius = Math.max(this.radius, sphere.radius);
        } else {
          _v2$3.subVectors(sphere.center, this.center).setLength(sphere.radius);
          this.expandByPoint(_v1$6.copy(sphere.center).add(_v2$3));
          this.expandByPoint(_v1$6.copy(sphere.center).sub(_v2$3));
        }
        return this;
      }
      equals(sphere) {
        return sphere.center.equals(this.center) && sphere.radius === this.radius;
      }
      clone() {
        return new this.constructor().copy(this);
      }
    };
    _vector$a = /* @__PURE__ */ new Vector3();
    _segCenter = /* @__PURE__ */ new Vector3();
    _segDir = /* @__PURE__ */ new Vector3();
    _diff = /* @__PURE__ */ new Vector3();
    _edge1 = /* @__PURE__ */ new Vector3();
    _edge2 = /* @__PURE__ */ new Vector3();
    _normal$1 = /* @__PURE__ */ new Vector3();
    Ray = class {
      constructor(origin = new Vector3(), direction = new Vector3(0, 0, -1)) {
        this.origin = origin;
        this.direction = direction;
      }
      set(origin, direction) {
        this.origin.copy(origin);
        this.direction.copy(direction);
        return this;
      }
      copy(ray) {
        this.origin.copy(ray.origin);
        this.direction.copy(ray.direction);
        return this;
      }
      at(t2, target2) {
        return target2.copy(this.origin).addScaledVector(this.direction, t2);
      }
      lookAt(v2) {
        this.direction.copy(v2).sub(this.origin).normalize();
        return this;
      }
      recast(t2) {
        this.origin.copy(this.at(t2, _vector$a));
        return this;
      }
      closestPointToPoint(point, target2) {
        target2.subVectors(point, this.origin);
        const directionDistance = target2.dot(this.direction);
        if (directionDistance < 0) {
          return target2.copy(this.origin);
        }
        return target2.copy(this.origin).addScaledVector(this.direction, directionDistance);
      }
      distanceToPoint(point) {
        return Math.sqrt(this.distanceSqToPoint(point));
      }
      distanceSqToPoint(point) {
        const directionDistance = _vector$a.subVectors(point, this.origin).dot(this.direction);
        if (directionDistance < 0) {
          return this.origin.distanceToSquared(point);
        }
        _vector$a.copy(this.origin).addScaledVector(this.direction, directionDistance);
        return _vector$a.distanceToSquared(point);
      }
      distanceSqToSegment(v0, v1, optionalPointOnRay, optionalPointOnSegment) {
        _segCenter.copy(v0).add(v1).multiplyScalar(0.5);
        _segDir.copy(v1).sub(v0).normalize();
        _diff.copy(this.origin).sub(_segCenter);
        const segExtent = v0.distanceTo(v1) * 0.5;
        const a01 = -this.direction.dot(_segDir);
        const b0 = _diff.dot(this.direction);
        const b1 = -_diff.dot(_segDir);
        const c = _diff.lengthSq();
        const det = Math.abs(1 - a01 * a01);
        let s0, s1, sqrDist, extDet;
        if (det > 0) {
          s0 = a01 * b1 - b0;
          s1 = a01 * b0 - b1;
          extDet = segExtent * det;
          if (s0 >= 0) {
            if (s1 >= -extDet) {
              if (s1 <= extDet) {
                const invDet = 1 / det;
                s0 *= invDet;
                s1 *= invDet;
                sqrDist = s0 * (s0 + a01 * s1 + 2 * b0) + s1 * (a01 * s0 + s1 + 2 * b1) + c;
              } else {
                s1 = segExtent;
                s0 = Math.max(0, -(a01 * s1 + b0));
                sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
              }
            } else {
              s1 = -segExtent;
              s0 = Math.max(0, -(a01 * s1 + b0));
              sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
            }
          } else {
            if (s1 <= -extDet) {
              s0 = Math.max(0, -(-a01 * segExtent + b0));
              s1 = s0 > 0 ? -segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);
              sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
            } else if (s1 <= extDet) {
              s0 = 0;
              s1 = Math.min(Math.max(-segExtent, -b1), segExtent);
              sqrDist = s1 * (s1 + 2 * b1) + c;
            } else {
              s0 = Math.max(0, -(a01 * segExtent + b0));
              s1 = s0 > 0 ? segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);
              sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
            }
          }
        } else {
          s1 = a01 > 0 ? -segExtent : segExtent;
          s0 = Math.max(0, -(a01 * s1 + b0));
          sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
        }
        if (optionalPointOnRay) {
          optionalPointOnRay.copy(this.origin).addScaledVector(this.direction, s0);
        }
        if (optionalPointOnSegment) {
          optionalPointOnSegment.copy(_segCenter).addScaledVector(_segDir, s1);
        }
        return sqrDist;
      }
      intersectSphere(sphere, target2) {
        _vector$a.subVectors(sphere.center, this.origin);
        const tca = _vector$a.dot(this.direction);
        const d2 = _vector$a.dot(_vector$a) - tca * tca;
        const radius2 = sphere.radius * sphere.radius;
        if (d2 > radius2) return null;
        const thc = Math.sqrt(radius2 - d2);
        const t0 = tca - thc;
        const t1 = tca + thc;
        if (t1 < 0) return null;
        if (t0 < 0) return this.at(t1, target2);
        return this.at(t0, target2);
      }
      intersectsSphere(sphere) {
        return this.distanceSqToPoint(sphere.center) <= sphere.radius * sphere.radius;
      }
      distanceToPlane(plane) {
        const denominator = plane.normal.dot(this.direction);
        if (denominator === 0) {
          if (plane.distanceToPoint(this.origin) === 0) {
            return 0;
          }
          return null;
        }
        const t2 = -(this.origin.dot(plane.normal) + plane.constant) / denominator;
        return t2 >= 0 ? t2 : null;
      }
      intersectPlane(plane, target2) {
        const t2 = this.distanceToPlane(plane);
        if (t2 === null) {
          return null;
        }
        return this.at(t2, target2);
      }
      intersectsPlane(plane) {
        const distToPoint = plane.distanceToPoint(this.origin);
        if (distToPoint === 0) {
          return true;
        }
        const denominator = plane.normal.dot(this.direction);
        if (denominator * distToPoint < 0) {
          return true;
        }
        return false;
      }
      intersectBox(box, target2) {
        let tmin, tmax, tymin, tymax, tzmin, tzmax;
        const invdirx = 1 / this.direction.x, invdiry = 1 / this.direction.y, invdirz = 1 / this.direction.z;
        const origin = this.origin;
        if (invdirx >= 0) {
          tmin = (box.min.x - origin.x) * invdirx;
          tmax = (box.max.x - origin.x) * invdirx;
        } else {
          tmin = (box.max.x - origin.x) * invdirx;
          tmax = (box.min.x - origin.x) * invdirx;
        }
        if (invdiry >= 0) {
          tymin = (box.min.y - origin.y) * invdiry;
          tymax = (box.max.y - origin.y) * invdiry;
        } else {
          tymin = (box.max.y - origin.y) * invdiry;
          tymax = (box.min.y - origin.y) * invdiry;
        }
        if (tmin > tymax || tymin > tmax) return null;
        if (tymin > tmin || isNaN(tmin)) tmin = tymin;
        if (tymax < tmax || isNaN(tmax)) tmax = tymax;
        if (invdirz >= 0) {
          tzmin = (box.min.z - origin.z) * invdirz;
          tzmax = (box.max.z - origin.z) * invdirz;
        } else {
          tzmin = (box.max.z - origin.z) * invdirz;
          tzmax = (box.min.z - origin.z) * invdirz;
        }
        if (tmin > tzmax || tzmin > tmax) return null;
        if (tzmin > tmin || tmin !== tmin) tmin = tzmin;
        if (tzmax < tmax || tmax !== tmax) tmax = tzmax;
        if (tmax < 0) return null;
        return this.at(tmin >= 0 ? tmin : tmax, target2);
      }
      intersectsBox(box) {
        return this.intersectBox(box, _vector$a) !== null;
      }
      intersectTriangle(a, b, c, backfaceCulling, target2) {
        _edge1.subVectors(b, a);
        _edge2.subVectors(c, a);
        _normal$1.crossVectors(_edge1, _edge2);
        let DdN = this.direction.dot(_normal$1);
        let sign2;
        if (DdN > 0) {
          if (backfaceCulling) return null;
          sign2 = 1;
        } else if (DdN < 0) {
          sign2 = -1;
          DdN = -DdN;
        } else {
          return null;
        }
        _diff.subVectors(this.origin, a);
        const DdQxE2 = sign2 * this.direction.dot(_edge2.crossVectors(_diff, _edge2));
        if (DdQxE2 < 0) {
          return null;
        }
        const DdE1xQ = sign2 * this.direction.dot(_edge1.cross(_diff));
        if (DdE1xQ < 0) {
          return null;
        }
        if (DdQxE2 + DdE1xQ > DdN) {
          return null;
        }
        const QdN = -sign2 * _diff.dot(_normal$1);
        if (QdN < 0) {
          return null;
        }
        return this.at(QdN / DdN, target2);
      }
      applyMatrix4(matrix4) {
        this.origin.applyMatrix4(matrix4);
        this.direction.transformDirection(matrix4);
        return this;
      }
      equals(ray) {
        return ray.origin.equals(this.origin) && ray.direction.equals(this.direction);
      }
      clone() {
        return new this.constructor().copy(this);
      }
    };
    Matrix4 = class _Matrix4 {
      constructor(n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44) {
        _Matrix4.prototype.isMatrix4 = true;
        this.elements = [
          1,
          0,
          0,
          0,
          0,
          1,
          0,
          0,
          0,
          0,
          1,
          0,
          0,
          0,
          0,
          1
        ];
        if (n11 !== void 0) {
          this.set(n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44);
        }
      }
      set(n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44) {
        const te = this.elements;
        te[0] = n11;
        te[4] = n12;
        te[8] = n13;
        te[12] = n14;
        te[1] = n21;
        te[5] = n22;
        te[9] = n23;
        te[13] = n24;
        te[2] = n31;
        te[6] = n32;
        te[10] = n33;
        te[14] = n34;
        te[3] = n41;
        te[7] = n42;
        te[11] = n43;
        te[15] = n44;
        return this;
      }
      identity() {
        this.set(
          1,
          0,
          0,
          0,
          0,
          1,
          0,
          0,
          0,
          0,
          1,
          0,
          0,
          0,
          0,
          1
        );
        return this;
      }
      clone() {
        return new _Matrix4().fromArray(this.elements);
      }
      copy(m) {
        const te = this.elements;
        const me = m.elements;
        te[0] = me[0];
        te[1] = me[1];
        te[2] = me[2];
        te[3] = me[3];
        te[4] = me[4];
        te[5] = me[5];
        te[6] = me[6];
        te[7] = me[7];
        te[8] = me[8];
        te[9] = me[9];
        te[10] = me[10];
        te[11] = me[11];
        te[12] = me[12];
        te[13] = me[13];
        te[14] = me[14];
        te[15] = me[15];
        return this;
      }
      copyPosition(m) {
        const te = this.elements, me = m.elements;
        te[12] = me[12];
        te[13] = me[13];
        te[14] = me[14];
        return this;
      }
      setFromMatrix3(m) {
        const me = m.elements;
        this.set(
          me[0],
          me[3],
          me[6],
          0,
          me[1],
          me[4],
          me[7],
          0,
          me[2],
          me[5],
          me[8],
          0,
          0,
          0,
          0,
          1
        );
        return this;
      }
      extractBasis(xAxis, yAxis, zAxis) {
        xAxis.setFromMatrixColumn(this, 0);
        yAxis.setFromMatrixColumn(this, 1);
        zAxis.setFromMatrixColumn(this, 2);
        return this;
      }
      makeBasis(xAxis, yAxis, zAxis) {
        this.set(
          xAxis.x,
          yAxis.x,
          zAxis.x,
          0,
          xAxis.y,
          yAxis.y,
          zAxis.y,
          0,
          xAxis.z,
          yAxis.z,
          zAxis.z,
          0,
          0,
          0,
          0,
          1
        );
        return this;
      }
      extractRotation(m) {
        const te = this.elements;
        const me = m.elements;
        const scaleX = 1 / _v1$5.setFromMatrixColumn(m, 0).length();
        const scaleY = 1 / _v1$5.setFromMatrixColumn(m, 1).length();
        const scaleZ = 1 / _v1$5.setFromMatrixColumn(m, 2).length();
        te[0] = me[0] * scaleX;
        te[1] = me[1] * scaleX;
        te[2] = me[2] * scaleX;
        te[3] = 0;
        te[4] = me[4] * scaleY;
        te[5] = me[5] * scaleY;
        te[6] = me[6] * scaleY;
        te[7] = 0;
        te[8] = me[8] * scaleZ;
        te[9] = me[9] * scaleZ;
        te[10] = me[10] * scaleZ;
        te[11] = 0;
        te[12] = 0;
        te[13] = 0;
        te[14] = 0;
        te[15] = 1;
        return this;
      }
      makeRotationFromEuler(euler) {
        const te = this.elements;
        const x = euler.x, y2 = euler.y, z2 = euler.z;
        const a = Math.cos(x), b = Math.sin(x);
        const c = Math.cos(y2), d = Math.sin(y2);
        const e = Math.cos(z2), f2 = Math.sin(z2);
        if (euler.order === "XYZ") {
          const ae = a * e, af = a * f2, be = b * e, bf = b * f2;
          te[0] = c * e;
          te[4] = -c * f2;
          te[8] = d;
          te[1] = af + be * d;
          te[5] = ae - bf * d;
          te[9] = -b * c;
          te[2] = bf - ae * d;
          te[6] = be + af * d;
          te[10] = a * c;
        } else if (euler.order === "YXZ") {
          const ce = c * e, cf = c * f2, de = d * e, df = d * f2;
          te[0] = ce + df * b;
          te[4] = de * b - cf;
          te[8] = a * d;
          te[1] = a * f2;
          te[5] = a * e;
          te[9] = -b;
          te[2] = cf * b - de;
          te[6] = df + ce * b;
          te[10] = a * c;
        } else if (euler.order === "ZXY") {
          const ce = c * e, cf = c * f2, de = d * e, df = d * f2;
          te[0] = ce - df * b;
          te[4] = -a * f2;
          te[8] = de + cf * b;
          te[1] = cf + de * b;
          te[5] = a * e;
          te[9] = df - ce * b;
          te[2] = -a * d;
          te[6] = b;
          te[10] = a * c;
        } else if (euler.order === "ZYX") {
          const ae = a * e, af = a * f2, be = b * e, bf = b * f2;
          te[0] = c * e;
          te[4] = be * d - af;
          te[8] = ae * d + bf;
          te[1] = c * f2;
          te[5] = bf * d + ae;
          te[9] = af * d - be;
          te[2] = -d;
          te[6] = b * c;
          te[10] = a * c;
        } else if (euler.order === "YZX") {
          const ac = a * c, ad = a * d, bc = b * c, bd = b * d;
          te[0] = c * e;
          te[4] = bd - ac * f2;
          te[8] = bc * f2 + ad;
          te[1] = f2;
          te[5] = a * e;
          te[9] = -b * e;
          te[2] = -d * e;
          te[6] = ad * f2 + bc;
          te[10] = ac - bd * f2;
        } else if (euler.order === "XZY") {
          const ac = a * c, ad = a * d, bc = b * c, bd = b * d;
          te[0] = c * e;
          te[4] = -f2;
          te[8] = d * e;
          te[1] = ac * f2 + bd;
          te[5] = a * e;
          te[9] = ad * f2 - bc;
          te[2] = bc * f2 - ad;
          te[6] = b * e;
          te[10] = bd * f2 + ac;
        }
        te[3] = 0;
        te[7] = 0;
        te[11] = 0;
        te[12] = 0;
        te[13] = 0;
        te[14] = 0;
        te[15] = 1;
        return this;
      }
      makeRotationFromQuaternion(q3) {
        return this.compose(_zero, q3, _one);
      }
      lookAt(eye, target2, up) {
        const te = this.elements;
        _z.subVectors(eye, target2);
        if (_z.lengthSq() === 0) {
          _z.z = 1;
        }
        _z.normalize();
        _x.crossVectors(up, _z);
        if (_x.lengthSq() === 0) {
          if (Math.abs(up.z) === 1) {
            _z.x += 1e-4;
          } else {
            _z.z += 1e-4;
          }
          _z.normalize();
          _x.crossVectors(up, _z);
        }
        _x.normalize();
        _y.crossVectors(_z, _x);
        te[0] = _x.x;
        te[4] = _y.x;
        te[8] = _z.x;
        te[1] = _x.y;
        te[5] = _y.y;
        te[9] = _z.y;
        te[2] = _x.z;
        te[6] = _y.z;
        te[10] = _z.z;
        return this;
      }
      multiply(m) {
        return this.multiplyMatrices(this, m);
      }
      premultiply(m) {
        return this.multiplyMatrices(m, this);
      }
      multiplyMatrices(a, b) {
        const ae = a.elements;
        const be = b.elements;
        const te = this.elements;
        const a11 = ae[0], a12 = ae[4], a13 = ae[8], a14 = ae[12];
        const a21 = ae[1], a22 = ae[5], a23 = ae[9], a24 = ae[13];
        const a31 = ae[2], a32 = ae[6], a33 = ae[10], a34 = ae[14];
        const a41 = ae[3], a42 = ae[7], a43 = ae[11], a44 = ae[15];
        const b11 = be[0], b12 = be[4], b13 = be[8], b14 = be[12];
        const b21 = be[1], b22 = be[5], b23 = be[9], b24 = be[13];
        const b31 = be[2], b32 = be[6], b33 = be[10], b34 = be[14];
        const b41 = be[3], b42 = be[7], b43 = be[11], b44 = be[15];
        te[0] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
        te[4] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
        te[8] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
        te[12] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;
        te[1] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
        te[5] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
        te[9] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
        te[13] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;
        te[2] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
        te[6] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
        te[10] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
        te[14] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;
        te[3] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
        te[7] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
        te[11] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
        te[15] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;
        return this;
      }
      multiplyScalar(s) {
        const te = this.elements;
        te[0] *= s;
        te[4] *= s;
        te[8] *= s;
        te[12] *= s;
        te[1] *= s;
        te[5] *= s;
        te[9] *= s;
        te[13] *= s;
        te[2] *= s;
        te[6] *= s;
        te[10] *= s;
        te[14] *= s;
        te[3] *= s;
        te[7] *= s;
        te[11] *= s;
        te[15] *= s;
        return this;
      }
      determinant() {
        const te = this.elements;
        const n11 = te[0], n12 = te[4], n13 = te[8], n14 = te[12];
        const n21 = te[1], n22 = te[5], n23 = te[9], n24 = te[13];
        const n31 = te[2], n32 = te[6], n33 = te[10], n34 = te[14];
        const n41 = te[3], n42 = te[7], n43 = te[11], n44 = te[15];
        return n41 * (+n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34) + n42 * (+n11 * n23 * n34 - n11 * n24 * n33 + n14 * n21 * n33 - n13 * n21 * n34 + n13 * n24 * n31 - n14 * n23 * n31) + n43 * (+n11 * n24 * n32 - n11 * n22 * n34 - n14 * n21 * n32 + n12 * n21 * n34 + n14 * n22 * n31 - n12 * n24 * n31) + n44 * (-n13 * n22 * n31 - n11 * n23 * n32 + n11 * n22 * n33 + n13 * n21 * n32 - n12 * n21 * n33 + n12 * n23 * n31);
      }
      transpose() {
        const te = this.elements;
        let tmp2;
        tmp2 = te[1];
        te[1] = te[4];
        te[4] = tmp2;
        tmp2 = te[2];
        te[2] = te[8];
        te[8] = tmp2;
        tmp2 = te[6];
        te[6] = te[9];
        te[9] = tmp2;
        tmp2 = te[3];
        te[3] = te[12];
        te[12] = tmp2;
        tmp2 = te[7];
        te[7] = te[13];
        te[13] = tmp2;
        tmp2 = te[11];
        te[11] = te[14];
        te[14] = tmp2;
        return this;
      }
      setPosition(x, y2, z2) {
        const te = this.elements;
        if (x.isVector3) {
          te[12] = x.x;
          te[13] = x.y;
          te[14] = x.z;
        } else {
          te[12] = x;
          te[13] = y2;
          te[14] = z2;
        }
        return this;
      }
      invert() {
        const te = this.elements, n11 = te[0], n21 = te[1], n31 = te[2], n41 = te[3], n12 = te[4], n22 = te[5], n32 = te[6], n42 = te[7], n13 = te[8], n23 = te[9], n33 = te[10], n43 = te[11], n14 = te[12], n24 = te[13], n34 = te[14], n44 = te[15], t11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44, t12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44, t13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44, t14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;
        const det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;
        if (det === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
        const detInv = 1 / det;
        te[0] = t11 * detInv;
        te[1] = (n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44) * detInv;
        te[2] = (n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44) * detInv;
        te[3] = (n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43) * detInv;
        te[4] = t12 * detInv;
        te[5] = (n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44) * detInv;
        te[6] = (n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44) * detInv;
        te[7] = (n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43) * detInv;
        te[8] = t13 * detInv;
        te[9] = (n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44) * detInv;
        te[10] = (n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44) * detInv;
        te[11] = (n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43) * detInv;
        te[12] = t14 * detInv;
        te[13] = (n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34) * detInv;
        te[14] = (n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34) * detInv;
        te[15] = (n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33) * detInv;
        return this;
      }
      scale(v2) {
        const te = this.elements;
        const x = v2.x, y2 = v2.y, z2 = v2.z;
        te[0] *= x;
        te[4] *= y2;
        te[8] *= z2;
        te[1] *= x;
        te[5] *= y2;
        te[9] *= z2;
        te[2] *= x;
        te[6] *= y2;
        te[10] *= z2;
        te[3] *= x;
        te[7] *= y2;
        te[11] *= z2;
        return this;
      }
      getMaxScaleOnAxis() {
        const te = this.elements;
        const scaleXSq = te[0] * te[0] + te[1] * te[1] + te[2] * te[2];
        const scaleYSq = te[4] * te[4] + te[5] * te[5] + te[6] * te[6];
        const scaleZSq = te[8] * te[8] + te[9] * te[9] + te[10] * te[10];
        return Math.sqrt(Math.max(scaleXSq, scaleYSq, scaleZSq));
      }
      makeTranslation(x, y2, z2) {
        if (x.isVector3) {
          this.set(
            1,
            0,
            0,
            x.x,
            0,
            1,
            0,
            x.y,
            0,
            0,
            1,
            x.z,
            0,
            0,
            0,
            1
          );
        } else {
          this.set(
            1,
            0,
            0,
            x,
            0,
            1,
            0,
            y2,
            0,
            0,
            1,
            z2,
            0,
            0,
            0,
            1
          );
        }
        return this;
      }
      makeRotationX(theta) {
        const c = Math.cos(theta), s = Math.sin(theta);
        this.set(
          1,
          0,
          0,
          0,
          0,
          c,
          -s,
          0,
          0,
          s,
          c,
          0,
          0,
          0,
          0,
          1
        );
        return this;
      }
      makeRotationY(theta) {
        const c = Math.cos(theta), s = Math.sin(theta);
        this.set(
          c,
          0,
          s,
          0,
          0,
          1,
          0,
          0,
          -s,
          0,
          c,
          0,
          0,
          0,
          0,
          1
        );
        return this;
      }
      makeRotationZ(theta) {
        const c = Math.cos(theta), s = Math.sin(theta);
        this.set(
          c,
          -s,
          0,
          0,
          s,
          c,
          0,
          0,
          0,
          0,
          1,
          0,
          0,
          0,
          0,
          1
        );
        return this;
      }
      makeRotationAxis(axis, angle) {
        const c = Math.cos(angle);
        const s = Math.sin(angle);
        const t2 = 1 - c;
        const x = axis.x, y2 = axis.y, z2 = axis.z;
        const tx = t2 * x, ty = t2 * y2;
        this.set(
          tx * x + c,
          tx * y2 - s * z2,
          tx * z2 + s * y2,
          0,
          tx * y2 + s * z2,
          ty * y2 + c,
          ty * z2 - s * x,
          0,
          tx * z2 - s * y2,
          ty * z2 + s * x,
          t2 * z2 * z2 + c,
          0,
          0,
          0,
          0,
          1
        );
        return this;
      }
      makeScale(x, y2, z2) {
        this.set(
          x,
          0,
          0,
          0,
          0,
          y2,
          0,
          0,
          0,
          0,
          z2,
          0,
          0,
          0,
          0,
          1
        );
        return this;
      }
      makeShear(xy, xz, yx, yz, zx, zy) {
        this.set(
          1,
          yx,
          zx,
          0,
          xy,
          1,
          zy,
          0,
          xz,
          yz,
          1,
          0,
          0,
          0,
          0,
          1
        );
        return this;
      }
      compose(position, quaternion, scale) {
        const te = this.elements;
        const x = quaternion._x, y2 = quaternion._y, z2 = quaternion._z, w = quaternion._w;
        const x2 = x + x, y22 = y2 + y2, z22 = z2 + z2;
        const xx = x * x2, xy = x * y22, xz = x * z22;
        const yy = y2 * y22, yz = y2 * z22, zz = z2 * z22;
        const wx = w * x2, wy = w * y22, wz = w * z22;
        const sx = scale.x, sy = scale.y, sz = scale.z;
        te[0] = (1 - (yy + zz)) * sx;
        te[1] = (xy + wz) * sx;
        te[2] = (xz - wy) * sx;
        te[3] = 0;
        te[4] = (xy - wz) * sy;
        te[5] = (1 - (xx + zz)) * sy;
        te[6] = (yz + wx) * sy;
        te[7] = 0;
        te[8] = (xz + wy) * sz;
        te[9] = (yz - wx) * sz;
        te[10] = (1 - (xx + yy)) * sz;
        te[11] = 0;
        te[12] = position.x;
        te[13] = position.y;
        te[14] = position.z;
        te[15] = 1;
        return this;
      }
      decompose(position, quaternion, scale) {
        const te = this.elements;
        let sx = _v1$5.set(te[0], te[1], te[2]).length();
        const sy = _v1$5.set(te[4], te[5], te[6]).length();
        const sz = _v1$5.set(te[8], te[9], te[10]).length();
        const det = this.determinant();
        if (det < 0) sx = -sx;
        position.x = te[12];
        position.y = te[13];
        position.z = te[14];
        _m1$4.copy(this);
        const invSX = 1 / sx;
        const invSY = 1 / sy;
        const invSZ = 1 / sz;
        _m1$4.elements[0] *= invSX;
        _m1$4.elements[1] *= invSX;
        _m1$4.elements[2] *= invSX;
        _m1$4.elements[4] *= invSY;
        _m1$4.elements[5] *= invSY;
        _m1$4.elements[6] *= invSY;
        _m1$4.elements[8] *= invSZ;
        _m1$4.elements[9] *= invSZ;
        _m1$4.elements[10] *= invSZ;
        quaternion.setFromRotationMatrix(_m1$4);
        scale.x = sx;
        scale.y = sy;
        scale.z = sz;
        return this;
      }
      makePerspective(left, right, top, bottom, near, far, coordinateSystem = WebGLCoordinateSystem) {
        const te = this.elements;
        const x = 2 * near / (right - left);
        const y2 = 2 * near / (top - bottom);
        const a = (right + left) / (right - left);
        const b = (top + bottom) / (top - bottom);
        let c, d;
        if (coordinateSystem === WebGLCoordinateSystem) {
          c = -(far + near) / (far - near);
          d = -2 * far * near / (far - near);
        } else if (coordinateSystem === WebGPUCoordinateSystem) {
          c = -far / (far - near);
          d = -far * near / (far - near);
        } else {
          throw new Error("THREE.Matrix4.makePerspective(): Invalid coordinate system: " + coordinateSystem);
        }
        te[0] = x;
        te[4] = 0;
        te[8] = a;
        te[12] = 0;
        te[1] = 0;
        te[5] = y2;
        te[9] = b;
        te[13] = 0;
        te[2] = 0;
        te[6] = 0;
        te[10] = c;
        te[14] = d;
        te[3] = 0;
        te[7] = 0;
        te[11] = -1;
        te[15] = 0;
        return this;
      }
      makeOrthographic(left, right, top, bottom, near, far, coordinateSystem = WebGLCoordinateSystem) {
        const te = this.elements;
        const w = 1 / (right - left);
        const h2 = 1 / (top - bottom);
        const p3 = 1 / (far - near);
        const x = (right + left) * w;
        const y2 = (top + bottom) * h2;
        let z2, zInv;
        if (coordinateSystem === WebGLCoordinateSystem) {
          z2 = (far + near) * p3;
          zInv = -2 * p3;
        } else if (coordinateSystem === WebGPUCoordinateSystem) {
          z2 = near * p3;
          zInv = -1 * p3;
        } else {
          throw new Error("THREE.Matrix4.makeOrthographic(): Invalid coordinate system: " + coordinateSystem);
        }
        te[0] = 2 * w;
        te[4] = 0;
        te[8] = 0;
        te[12] = -x;
        te[1] = 0;
        te[5] = 2 * h2;
        te[9] = 0;
        te[13] = -y2;
        te[2] = 0;
        te[6] = 0;
        te[10] = zInv;
        te[14] = -z2;
        te[3] = 0;
        te[7] = 0;
        te[11] = 0;
        te[15] = 1;
        return this;
      }
      equals(matrix2) {
        const te = this.elements;
        const me = matrix2.elements;
        for (let i2 = 0; i2 < 16; i2++) {
          if (te[i2] !== me[i2]) return false;
        }
        return true;
      }
      fromArray(array, offset = 0) {
        for (let i2 = 0; i2 < 16; i2++) {
          this.elements[i2] = array[i2 + offset];
        }
        return this;
      }
      toArray(array = [], offset = 0) {
        const te = this.elements;
        array[offset] = te[0];
        array[offset + 1] = te[1];
        array[offset + 2] = te[2];
        array[offset + 3] = te[3];
        array[offset + 4] = te[4];
        array[offset + 5] = te[5];
        array[offset + 6] = te[6];
        array[offset + 7] = te[7];
        array[offset + 8] = te[8];
        array[offset + 9] = te[9];
        array[offset + 10] = te[10];
        array[offset + 11] = te[11];
        array[offset + 12] = te[12];
        array[offset + 13] = te[13];
        array[offset + 14] = te[14];
        array[offset + 15] = te[15];
        return array;
      }
    };
    _v1$5 = /* @__PURE__ */ new Vector3();
    _m1$4 = /* @__PURE__ */ new Matrix4();
    _zero = /* @__PURE__ */ new Vector3(0, 0, 0);
    _one = /* @__PURE__ */ new Vector3(1, 1, 1);
    _x = /* @__PURE__ */ new Vector3();
    _y = /* @__PURE__ */ new Vector3();
    _z = /* @__PURE__ */ new Vector3();
    _matrix$2 = /* @__PURE__ */ new Matrix4();
    _quaternion$3 = /* @__PURE__ */ new Quaternion();
    Euler = class _Euler {
      constructor(x = 0, y2 = 0, z2 = 0, order = _Euler.DEFAULT_ORDER) {
        this.isEuler = true;
        this._x = x;
        this._y = y2;
        this._z = z2;
        this._order = order;
      }
      get x() {
        return this._x;
      }
      set x(value) {
        this._x = value;
        this._onChangeCallback();
      }
      get y() {
        return this._y;
      }
      set y(value) {
        this._y = value;
        this._onChangeCallback();
      }
      get z() {
        return this._z;
      }
      set z(value) {
        this._z = value;
        this._onChangeCallback();
      }
      get order() {
        return this._order;
      }
      set order(value) {
        this._order = value;
        this._onChangeCallback();
      }
      set(x, y2, z2, order = this._order) {
        this._x = x;
        this._y = y2;
        this._z = z2;
        this._order = order;
        this._onChangeCallback();
        return this;
      }
      clone() {
        return new this.constructor(this._x, this._y, this._z, this._order);
      }
      copy(euler) {
        this._x = euler._x;
        this._y = euler._y;
        this._z = euler._z;
        this._order = euler._order;
        this._onChangeCallback();
        return this;
      }
      setFromRotationMatrix(m, order = this._order, update = true) {
        const te = m.elements;
        const m11 = te[0], m12 = te[4], m13 = te[8];
        const m21 = te[1], m22 = te[5], m23 = te[9];
        const m31 = te[2], m32 = te[6], m33 = te[10];
        switch (order) {
          case "XYZ":
            this._y = Math.asin(clamp(m13, -1, 1));
            if (Math.abs(m13) < 0.9999999) {
              this._x = Math.atan2(-m23, m33);
              this._z = Math.atan2(-m12, m11);
            } else {
              this._x = Math.atan2(m32, m22);
              this._z = 0;
            }
            break;
          case "YXZ":
            this._x = Math.asin(-clamp(m23, -1, 1));
            if (Math.abs(m23) < 0.9999999) {
              this._y = Math.atan2(m13, m33);
              this._z = Math.atan2(m21, m22);
            } else {
              this._y = Math.atan2(-m31, m11);
              this._z = 0;
            }
            break;
          case "ZXY":
            this._x = Math.asin(clamp(m32, -1, 1));
            if (Math.abs(m32) < 0.9999999) {
              this._y = Math.atan2(-m31, m33);
              this._z = Math.atan2(-m12, m22);
            } else {
              this._y = 0;
              this._z = Math.atan2(m21, m11);
            }
            break;
          case "ZYX":
            this._y = Math.asin(-clamp(m31, -1, 1));
            if (Math.abs(m31) < 0.9999999) {
              this._x = Math.atan2(m32, m33);
              this._z = Math.atan2(m21, m11);
            } else {
              this._x = 0;
              this._z = Math.atan2(-m12, m22);
            }
            break;
          case "YZX":
            this._z = Math.asin(clamp(m21, -1, 1));
            if (Math.abs(m21) < 0.9999999) {
              this._x = Math.atan2(-m23, m22);
              this._y = Math.atan2(-m31, m11);
            } else {
              this._x = 0;
              this._y = Math.atan2(m13, m33);
            }
            break;
          case "XZY":
            this._z = Math.asin(-clamp(m12, -1, 1));
            if (Math.abs(m12) < 0.9999999) {
              this._x = Math.atan2(m32, m22);
              this._y = Math.atan2(m13, m11);
            } else {
              this._x = Math.atan2(-m23, m33);
              this._y = 0;
            }
            break;
          default:
            console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + order);
        }
        this._order = order;
        if (update === true) this._onChangeCallback();
        return this;
      }
      setFromQuaternion(q3, order, update) {
        _matrix$2.makeRotationFromQuaternion(q3);
        return this.setFromRotationMatrix(_matrix$2, order, update);
      }
      setFromVector3(v2, order = this._order) {
        return this.set(v2.x, v2.y, v2.z, order);
      }
      reorder(newOrder) {
        _quaternion$3.setFromEuler(this);
        return this.setFromQuaternion(_quaternion$3, newOrder);
      }
      equals(euler) {
        return euler._x === this._x && euler._y === this._y && euler._z === this._z && euler._order === this._order;
      }
      fromArray(array) {
        this._x = array[0];
        this._y = array[1];
        this._z = array[2];
        if (array[3] !== void 0) this._order = array[3];
        this._onChangeCallback();
        return this;
      }
      toArray(array = [], offset = 0) {
        array[offset] = this._x;
        array[offset + 1] = this._y;
        array[offset + 2] = this._z;
        array[offset + 3] = this._order;
        return array;
      }
      _onChange(callback) {
        this._onChangeCallback = callback;
        return this;
      }
      _onChangeCallback() {
      }
      *[Symbol.iterator]() {
        yield this._x;
        yield this._y;
        yield this._z;
        yield this._order;
      }
    };
    Euler.DEFAULT_ORDER = "XYZ";
    Layers = class {
      constructor() {
        this.mask = 1 | 0;
      }
      set(channel) {
        this.mask = (1 << channel | 0) >>> 0;
      }
      enable(channel) {
        this.mask |= 1 << channel | 0;
      }
      enableAll() {
        this.mask = 4294967295 | 0;
      }
      toggle(channel) {
        this.mask ^= 1 << channel | 0;
      }
      disable(channel) {
        this.mask &= ~(1 << channel | 0);
      }
      disableAll() {
        this.mask = 0;
      }
      test(layers) {
        return (this.mask & layers.mask) !== 0;
      }
      isEnabled(channel) {
        return (this.mask & (1 << channel | 0)) !== 0;
      }
    };
    _object3DId = 0;
    _v1$4 = /* @__PURE__ */ new Vector3();
    _q1 = /* @__PURE__ */ new Quaternion();
    _m1$3 = /* @__PURE__ */ new Matrix4();
    _target = /* @__PURE__ */ new Vector3();
    _position$3 = /* @__PURE__ */ new Vector3();
    _scale$2 = /* @__PURE__ */ new Vector3();
    _quaternion$2 = /* @__PURE__ */ new Quaternion();
    _xAxis = /* @__PURE__ */ new Vector3(1, 0, 0);
    _yAxis = /* @__PURE__ */ new Vector3(0, 1, 0);
    _zAxis = /* @__PURE__ */ new Vector3(0, 0, 1);
    _addedEvent = { type: "added" };
    _removedEvent = { type: "removed" };
    _childaddedEvent = { type: "childadded", child: null };
    _childremovedEvent = { type: "childremoved", child: null };
    Object3D = class _Object3D extends EventDispatcher {
      constructor() {
        super();
        this.isObject3D = true;
        Object.defineProperty(this, "id", { value: _object3DId++ });
        this.uuid = generateUUID();
        this.name = "";
        this.type = "Object3D";
        this.parent = null;
        this.children = [];
        this.up = _Object3D.DEFAULT_UP.clone();
        const position = new Vector3();
        const rotation = new Euler();
        const quaternion = new Quaternion();
        const scale = new Vector3(1, 1, 1);
        function onRotationChange() {
          quaternion.setFromEuler(rotation, false);
        }
        function onQuaternionChange() {
          rotation.setFromQuaternion(quaternion, void 0, false);
        }
        rotation._onChange(onRotationChange);
        quaternion._onChange(onQuaternionChange);
        Object.defineProperties(this, {
          position: {
            configurable: true,
            enumerable: true,
            value: position
          },
          rotation: {
            configurable: true,
            enumerable: true,
            value: rotation
          },
          quaternion: {
            configurable: true,
            enumerable: true,
            value: quaternion
          },
          scale: {
            configurable: true,
            enumerable: true,
            value: scale
          },
          modelViewMatrix: {
            value: new Matrix4()
          },
          normalMatrix: {
            value: new Matrix3()
          }
        });
        this.matrix = new Matrix4();
        this.matrixWorld = new Matrix4();
        this.matrixAutoUpdate = _Object3D.DEFAULT_MATRIX_AUTO_UPDATE;
        this.matrixWorldAutoUpdate = _Object3D.DEFAULT_MATRIX_WORLD_AUTO_UPDATE;
        this.matrixWorldNeedsUpdate = false;
        this.layers = new Layers();
        this.visible = true;
        this.castShadow = false;
        this.receiveShadow = false;
        this.frustumCulled = true;
        this.renderOrder = 0;
        this.animations = [];
        this.userData = {};
      }
      onBeforeShadow() {
      }
      onAfterShadow() {
      }
      onBeforeRender() {
      }
      onAfterRender() {
      }
      applyMatrix4(matrix2) {
        if (this.matrixAutoUpdate) this.updateMatrix();
        this.matrix.premultiply(matrix2);
        this.matrix.decompose(this.position, this.quaternion, this.scale);
      }
      applyQuaternion(q3) {
        this.quaternion.premultiply(q3);
        return this;
      }
      setRotationFromAxisAngle(axis, angle) {
        this.quaternion.setFromAxisAngle(axis, angle);
      }
      setRotationFromEuler(euler) {
        this.quaternion.setFromEuler(euler, true);
      }
      setRotationFromMatrix(m) {
        this.quaternion.setFromRotationMatrix(m);
      }
      setRotationFromQuaternion(q3) {
        this.quaternion.copy(q3);
      }
      rotateOnAxis(axis, angle) {
        _q1.setFromAxisAngle(axis, angle);
        this.quaternion.multiply(_q1);
        return this;
      }
      rotateOnWorldAxis(axis, angle) {
        _q1.setFromAxisAngle(axis, angle);
        this.quaternion.premultiply(_q1);
        return this;
      }
      rotateX(angle) {
        return this.rotateOnAxis(_xAxis, angle);
      }
      rotateY(angle) {
        return this.rotateOnAxis(_yAxis, angle);
      }
      rotateZ(angle) {
        return this.rotateOnAxis(_zAxis, angle);
      }
      translateOnAxis(axis, distance) {
        _v1$4.copy(axis).applyQuaternion(this.quaternion);
        this.position.add(_v1$4.multiplyScalar(distance));
        return this;
      }
      translateX(distance) {
        return this.translateOnAxis(_xAxis, distance);
      }
      translateY(distance) {
        return this.translateOnAxis(_yAxis, distance);
      }
      translateZ(distance) {
        return this.translateOnAxis(_zAxis, distance);
      }
      localToWorld(vector) {
        this.updateWorldMatrix(true, false);
        return vector.applyMatrix4(this.matrixWorld);
      }
      worldToLocal(vector) {
        this.updateWorldMatrix(true, false);
        return vector.applyMatrix4(_m1$3.copy(this.matrixWorld).invert());
      }
      lookAt(x, y2, z2) {
        if (x.isVector3) {
          _target.copy(x);
        } else {
          _target.set(x, y2, z2);
        }
        const parent = this.parent;
        this.updateWorldMatrix(true, false);
        _position$3.setFromMatrixPosition(this.matrixWorld);
        if (this.isCamera || this.isLight) {
          _m1$3.lookAt(_position$3, _target, this.up);
        } else {
          _m1$3.lookAt(_target, _position$3, this.up);
        }
        this.quaternion.setFromRotationMatrix(_m1$3);
        if (parent) {
          _m1$3.extractRotation(parent.matrixWorld);
          _q1.setFromRotationMatrix(_m1$3);
          this.quaternion.premultiply(_q1.invert());
        }
      }
      add(object) {
        if (arguments.length > 1) {
          for (let i2 = 0; i2 < arguments.length; i2++) {
            this.add(arguments[i2]);
          }
          return this;
        }
        if (object === this) {
          console.error("THREE.Object3D.add: object can't be added as a child of itself.", object);
          return this;
        }
        if (object && object.isObject3D) {
          object.removeFromParent();
          object.parent = this;
          this.children.push(object);
          object.dispatchEvent(_addedEvent);
          _childaddedEvent.child = object;
          this.dispatchEvent(_childaddedEvent);
          _childaddedEvent.child = null;
        } else {
          console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", object);
        }
        return this;
      }
      remove(object) {
        if (arguments.length > 1) {
          for (let i2 = 0; i2 < arguments.length; i2++) {
            this.remove(arguments[i2]);
          }
          return this;
        }
        const index = this.children.indexOf(object);
        if (index !== -1) {
          object.parent = null;
          this.children.splice(index, 1);
          object.dispatchEvent(_removedEvent);
          _childremovedEvent.child = object;
          this.dispatchEvent(_childremovedEvent);
          _childremovedEvent.child = null;
        }
        return this;
      }
      removeFromParent() {
        const parent = this.parent;
        if (parent !== null) {
          parent.remove(this);
        }
        return this;
      }
      clear() {
        return this.remove(...this.children);
      }
      attach(object) {
        this.updateWorldMatrix(true, false);
        _m1$3.copy(this.matrixWorld).invert();
        if (object.parent !== null) {
          object.parent.updateWorldMatrix(true, false);
          _m1$3.multiply(object.parent.matrixWorld);
        }
        object.applyMatrix4(_m1$3);
        object.removeFromParent();
        object.parent = this;
        this.children.push(object);
        object.updateWorldMatrix(false, true);
        object.dispatchEvent(_addedEvent);
        _childaddedEvent.child = object;
        this.dispatchEvent(_childaddedEvent);
        _childaddedEvent.child = null;
        return this;
      }
      getObjectById(id) {
        return this.getObjectByProperty("id", id);
      }
      getObjectByName(name) {
        return this.getObjectByProperty("name", name);
      }
      getObjectByProperty(name, value) {
        if (this[name] === value) return this;
        for (let i2 = 0, l2 = this.children.length; i2 < l2; i2++) {
          const child = this.children[i2];
          const object = child.getObjectByProperty(name, value);
          if (object !== void 0) {
            return object;
          }
        }
        return void 0;
      }
      getObjectsByProperty(name, value, result = []) {
        if (this[name] === value) result.push(this);
        const children = this.children;
        for (let i2 = 0, l2 = children.length; i2 < l2; i2++) {
          children[i2].getObjectsByProperty(name, value, result);
        }
        return result;
      }
      getWorldPosition(target2) {
        this.updateWorldMatrix(true, false);
        return target2.setFromMatrixPosition(this.matrixWorld);
      }
      getWorldQuaternion(target2) {
        this.updateWorldMatrix(true, false);
        this.matrixWorld.decompose(_position$3, target2, _scale$2);
        return target2;
      }
      getWorldScale(target2) {
        this.updateWorldMatrix(true, false);
        this.matrixWorld.decompose(_position$3, _quaternion$2, target2);
        return target2;
      }
      getWorldDirection(target2) {
        this.updateWorldMatrix(true, false);
        const e = this.matrixWorld.elements;
        return target2.set(e[8], e[9], e[10]).normalize();
      }
      raycast() {
      }
      traverse(callback) {
        callback(this);
        const children = this.children;
        for (let i2 = 0, l2 = children.length; i2 < l2; i2++) {
          children[i2].traverse(callback);
        }
      }
      traverseVisible(callback) {
        if (this.visible === false) return;
        callback(this);
        const children = this.children;
        for (let i2 = 0, l2 = children.length; i2 < l2; i2++) {
          children[i2].traverseVisible(callback);
        }
      }
      traverseAncestors(callback) {
        const parent = this.parent;
        if (parent !== null) {
          callback(parent);
          parent.traverseAncestors(callback);
        }
      }
      updateMatrix() {
        this.matrix.compose(this.position, this.quaternion, this.scale);
        this.matrixWorldNeedsUpdate = true;
      }
      updateMatrixWorld(force) {
        if (this.matrixAutoUpdate) this.updateMatrix();
        if (this.matrixWorldNeedsUpdate || force) {
          if (this.matrixWorldAutoUpdate === true) {
            if (this.parent === null) {
              this.matrixWorld.copy(this.matrix);
            } else {
              this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);
            }
          }
          this.matrixWorldNeedsUpdate = false;
          force = true;
        }
        const children = this.children;
        for (let i2 = 0, l2 = children.length; i2 < l2; i2++) {
          const child = children[i2];
          child.updateMatrixWorld(force);
        }
      }
      updateWorldMatrix(updateParents, updateChildren) {
        const parent = this.parent;
        if (updateParents === true && parent !== null) {
          parent.updateWorldMatrix(true, false);
        }
        if (this.matrixAutoUpdate) this.updateMatrix();
        if (this.matrixWorldAutoUpdate === true) {
          if (this.parent === null) {
            this.matrixWorld.copy(this.matrix);
          } else {
            this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);
          }
        }
        if (updateChildren === true) {
          const children = this.children;
          for (let i2 = 0, l2 = children.length; i2 < l2; i2++) {
            const child = children[i2];
            child.updateWorldMatrix(false, true);
          }
        }
      }
      toJSON(meta) {
        const isRootObject = meta === void 0 || typeof meta === "string";
        const output = {};
        if (isRootObject) {
          meta = {
            geometries: {},
            materials: {},
            textures: {},
            images: {},
            shapes: {},
            skeletons: {},
            animations: {},
            nodes: {}
          };
          output.metadata = {
            version: 4.6,
            type: "Object",
            generator: "Object3D.toJSON"
          };
        }
        const object = {};
        object.uuid = this.uuid;
        object.type = this.type;
        if (this.name !== "") object.name = this.name;
        if (this.castShadow === true) object.castShadow = true;
        if (this.receiveShadow === true) object.receiveShadow = true;
        if (this.visible === false) object.visible = false;
        if (this.frustumCulled === false) object.frustumCulled = false;
        if (this.renderOrder !== 0) object.renderOrder = this.renderOrder;
        if (Object.keys(this.userData).length > 0) object.userData = this.userData;
        object.layers = this.layers.mask;
        object.matrix = this.matrix.toArray();
        object.up = this.up.toArray();
        if (this.matrixAutoUpdate === false) object.matrixAutoUpdate = false;
        if (this.isInstancedMesh) {
          object.type = "InstancedMesh";
          object.count = this.count;
          object.instanceMatrix = this.instanceMatrix.toJSON();
          if (this.instanceColor !== null) object.instanceColor = this.instanceColor.toJSON();
        }
        if (this.isBatchedMesh) {
          object.type = "BatchedMesh";
          object.perObjectFrustumCulled = this.perObjectFrustumCulled;
          object.sortObjects = this.sortObjects;
          object.drawRanges = this._drawRanges;
          object.reservedRanges = this._reservedRanges;
          object.visibility = this._visibility;
          object.active = this._active;
          object.bounds = this._bounds.map((bound) => ({
            boxInitialized: bound.boxInitialized,
            boxMin: bound.box.min.toArray(),
            boxMax: bound.box.max.toArray(),
            sphereInitialized: bound.sphereInitialized,
            sphereRadius: bound.sphere.radius,
            sphereCenter: bound.sphere.center.toArray()
          }));
          object.maxInstanceCount = this._maxInstanceCount;
          object.maxVertexCount = this._maxVertexCount;
          object.maxIndexCount = this._maxIndexCount;
          object.geometryInitialized = this._geometryInitialized;
          object.geometryCount = this._geometryCount;
          object.matricesTexture = this._matricesTexture.toJSON(meta);
          if (this._colorsTexture !== null) object.colorsTexture = this._colorsTexture.toJSON(meta);
          if (this.boundingSphere !== null) {
            object.boundingSphere = {
              center: object.boundingSphere.center.toArray(),
              radius: object.boundingSphere.radius
            };
          }
          if (this.boundingBox !== null) {
            object.boundingBox = {
              min: object.boundingBox.min.toArray(),
              max: object.boundingBox.max.toArray()
            };
          }
        }
        function serialize(library, element) {
          if (library[element.uuid] === void 0) {
            library[element.uuid] = element.toJSON(meta);
          }
          return element.uuid;
        }
        if (this.isScene) {
          if (this.background) {
            if (this.background.isColor) {
              object.background = this.background.toJSON();
            } else if (this.background.isTexture) {
              object.background = this.background.toJSON(meta).uuid;
            }
          }
          if (this.environment && this.environment.isTexture && this.environment.isRenderTargetTexture !== true) {
            object.environment = this.environment.toJSON(meta).uuid;
          }
        } else if (this.isMesh || this.isLine || this.isPoints) {
          object.geometry = serialize(meta.geometries, this.geometry);
          const parameters = this.geometry.parameters;
          if (parameters !== void 0 && parameters.shapes !== void 0) {
            const shapes = parameters.shapes;
            if (Array.isArray(shapes)) {
              for (let i2 = 0, l2 = shapes.length; i2 < l2; i2++) {
                const shape = shapes[i2];
                serialize(meta.shapes, shape);
              }
            } else {
              serialize(meta.shapes, shapes);
            }
          }
        }
        if (this.isSkinnedMesh) {
          object.bindMode = this.bindMode;
          object.bindMatrix = this.bindMatrix.toArray();
          if (this.skeleton !== void 0) {
            serialize(meta.skeletons, this.skeleton);
            object.skeleton = this.skeleton.uuid;
          }
        }
        if (this.material !== void 0) {
          if (Array.isArray(this.material)) {
            const uuids = [];
            for (let i2 = 0, l2 = this.material.length; i2 < l2; i2++) {
              uuids.push(serialize(meta.materials, this.material[i2]));
            }
            object.material = uuids;
          } else {
            object.material = serialize(meta.materials, this.material);
          }
        }
        if (this.children.length > 0) {
          object.children = [];
          for (let i2 = 0; i2 < this.children.length; i2++) {
            object.children.push(this.children[i2].toJSON(meta).object);
          }
        }
        if (this.animations.length > 0) {
          object.animations = [];
          for (let i2 = 0; i2 < this.animations.length; i2++) {
            const animation = this.animations[i2];
            object.animations.push(serialize(meta.animations, animation));
          }
        }
        if (isRootObject) {
          const geometries = extractFromCache(meta.geometries);
          const materials = extractFromCache(meta.materials);
          const textures = extractFromCache(meta.textures);
          const images = extractFromCache(meta.images);
          const shapes = extractFromCache(meta.shapes);
          const skeletons = extractFromCache(meta.skeletons);
          const animations = extractFromCache(meta.animations);
          const nodes = extractFromCache(meta.nodes);
          if (geometries.length > 0) output.geometries = geometries;
          if (materials.length > 0) output.materials = materials;
          if (textures.length > 0) output.textures = textures;
          if (images.length > 0) output.images = images;
          if (shapes.length > 0) output.shapes = shapes;
          if (skeletons.length > 0) output.skeletons = skeletons;
          if (animations.length > 0) output.animations = animations;
          if (nodes.length > 0) output.nodes = nodes;
        }
        output.object = object;
        return output;
        function extractFromCache(cache) {
          const values = [];
          for (const key in cache) {
            const data = cache[key];
            delete data.metadata;
            values.push(data);
          }
          return values;
        }
      }
      clone(recursive) {
        return new this.constructor().copy(this, recursive);
      }
      copy(source, recursive = true) {
        this.name = source.name;
        this.up.copy(source.up);
        this.position.copy(source.position);
        this.rotation.order = source.rotation.order;
        this.quaternion.copy(source.quaternion);
        this.scale.copy(source.scale);
        this.matrix.copy(source.matrix);
        this.matrixWorld.copy(source.matrixWorld);
        this.matrixAutoUpdate = source.matrixAutoUpdate;
        this.matrixWorldAutoUpdate = source.matrixWorldAutoUpdate;
        this.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;
        this.layers.mask = source.layers.mask;
        this.visible = source.visible;
        this.castShadow = source.castShadow;
        this.receiveShadow = source.receiveShadow;
        this.frustumCulled = source.frustumCulled;
        this.renderOrder = source.renderOrder;
        this.animations = source.animations.slice();
        this.userData = JSON.parse(JSON.stringify(source.userData));
        if (recursive === true) {
          for (let i2 = 0; i2 < source.children.length; i2++) {
            const child = source.children[i2];
            this.add(child.clone());
          }
        }
        return this;
      }
    };
    Object3D.DEFAULT_UP = /* @__PURE__ */ new Vector3(0, 1, 0);
    Object3D.DEFAULT_MATRIX_AUTO_UPDATE = true;
    Object3D.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = true;
    _v0$2 = /* @__PURE__ */ new Vector3();
    _v1$3 = /* @__PURE__ */ new Vector3();
    _v2$2 = /* @__PURE__ */ new Vector3();
    _v3$2 = /* @__PURE__ */ new Vector3();
    _vab = /* @__PURE__ */ new Vector3();
    _vac = /* @__PURE__ */ new Vector3();
    _vbc = /* @__PURE__ */ new Vector3();
    _vap = /* @__PURE__ */ new Vector3();
    _vbp = /* @__PURE__ */ new Vector3();
    _vcp = /* @__PURE__ */ new Vector3();
    _v40 = /* @__PURE__ */ new Vector4();
    _v41 = /* @__PURE__ */ new Vector4();
    _v42 = /* @__PURE__ */ new Vector4();
    Triangle = class _Triangle {
      constructor(a = new Vector3(), b = new Vector3(), c = new Vector3()) {
        this.a = a;
        this.b = b;
        this.c = c;
      }
      static getNormal(a, b, c, target2) {
        target2.subVectors(c, b);
        _v0$2.subVectors(a, b);
        target2.cross(_v0$2);
        const targetLengthSq = target2.lengthSq();
        if (targetLengthSq > 0) {
          return target2.multiplyScalar(1 / Math.sqrt(targetLengthSq));
        }
        return target2.set(0, 0, 0);
      }
      // static/instance method to calculate barycentric coordinates
      // based on: http://www.blackpawn.com/texts/pointinpoly/default.html
      static getBarycoord(point, a, b, c, target2) {
        _v0$2.subVectors(c, a);
        _v1$3.subVectors(b, a);
        _v2$2.subVectors(point, a);
        const dot00 = _v0$2.dot(_v0$2);
        const dot01 = _v0$2.dot(_v1$3);
        const dot02 = _v0$2.dot(_v2$2);
        const dot11 = _v1$3.dot(_v1$3);
        const dot12 = _v1$3.dot(_v2$2);
        const denom = dot00 * dot11 - dot01 * dot01;
        if (denom === 0) {
          target2.set(0, 0, 0);
          return null;
        }
        const invDenom = 1 / denom;
        const u3 = (dot11 * dot02 - dot01 * dot12) * invDenom;
        const v2 = (dot00 * dot12 - dot01 * dot02) * invDenom;
        return target2.set(1 - u3 - v2, v2, u3);
      }
      static containsPoint(point, a, b, c) {
        if (this.getBarycoord(point, a, b, c, _v3$2) === null) {
          return false;
        }
        return _v3$2.x >= 0 && _v3$2.y >= 0 && _v3$2.x + _v3$2.y <= 1;
      }
      static getInterpolation(point, p1, p22, p3, v1, v2, v3, target2) {
        if (this.getBarycoord(point, p1, p22, p3, _v3$2) === null) {
          target2.x = 0;
          target2.y = 0;
          if ("z" in target2) target2.z = 0;
          if ("w" in target2) target2.w = 0;
          return null;
        }
        target2.setScalar(0);
        target2.addScaledVector(v1, _v3$2.x);
        target2.addScaledVector(v2, _v3$2.y);
        target2.addScaledVector(v3, _v3$2.z);
        return target2;
      }
      static getInterpolatedAttribute(attr, i1, i2, i3, barycoord, target2) {
        _v40.setScalar(0);
        _v41.setScalar(0);
        _v42.setScalar(0);
        _v40.fromBufferAttribute(attr, i1);
        _v41.fromBufferAttribute(attr, i2);
        _v42.fromBufferAttribute(attr, i3);
        target2.setScalar(0);
        target2.addScaledVector(_v40, barycoord.x);
        target2.addScaledVector(_v41, barycoord.y);
        target2.addScaledVector(_v42, barycoord.z);
        return target2;
      }
      static isFrontFacing(a, b, c, direction) {
        _v0$2.subVectors(c, b);
        _v1$3.subVectors(a, b);
        return _v0$2.cross(_v1$3).dot(direction) < 0 ? true : false;
      }
      set(a, b, c) {
        this.a.copy(a);
        this.b.copy(b);
        this.c.copy(c);
        return this;
      }
      setFromPointsAndIndices(points, i0, i1, i2) {
        this.a.copy(points[i0]);
        this.b.copy(points[i1]);
        this.c.copy(points[i2]);
        return this;
      }
      setFromAttributeAndIndices(attribute, i0, i1, i2) {
        this.a.fromBufferAttribute(attribute, i0);
        this.b.fromBufferAttribute(attribute, i1);
        this.c.fromBufferAttribute(attribute, i2);
        return this;
      }
      clone() {
        return new this.constructor().copy(this);
      }
      copy(triangle) {
        this.a.copy(triangle.a);
        this.b.copy(triangle.b);
        this.c.copy(triangle.c);
        return this;
      }
      getArea() {
        _v0$2.subVectors(this.c, this.b);
        _v1$3.subVectors(this.a, this.b);
        return _v0$2.cross(_v1$3).length() * 0.5;
      }
      getMidpoint(target2) {
        return target2.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);
      }
      getNormal(target2) {
        return _Triangle.getNormal(this.a, this.b, this.c, target2);
      }
      getPlane(target2) {
        return target2.setFromCoplanarPoints(this.a, this.b, this.c);
      }
      getBarycoord(point, target2) {
        return _Triangle.getBarycoord(point, this.a, this.b, this.c, target2);
      }
      getInterpolation(point, v1, v2, v3, target2) {
        return _Triangle.getInterpolation(point, this.a, this.b, this.c, v1, v2, v3, target2);
      }
      containsPoint(point) {
        return _Triangle.containsPoint(point, this.a, this.b, this.c);
      }
      isFrontFacing(direction) {
        return _Triangle.isFrontFacing(this.a, this.b, this.c, direction);
      }
      intersectsBox(box) {
        return box.intersectsTriangle(this);
      }
      closestPointToPoint(p3, target2) {
        const a = this.a, b = this.b, c = this.c;
        let v2, w;
        _vab.subVectors(b, a);
        _vac.subVectors(c, a);
        _vap.subVectors(p3, a);
        const d1 = _vab.dot(_vap);
        const d2 = _vac.dot(_vap);
        if (d1 <= 0 && d2 <= 0) {
          return target2.copy(a);
        }
        _vbp.subVectors(p3, b);
        const d3 = _vab.dot(_vbp);
        const d4 = _vac.dot(_vbp);
        if (d3 >= 0 && d4 <= d3) {
          return target2.copy(b);
        }
        const vc = d1 * d4 - d3 * d2;
        if (vc <= 0 && d1 >= 0 && d3 <= 0) {
          v2 = d1 / (d1 - d3);
          return target2.copy(a).addScaledVector(_vab, v2);
        }
        _vcp.subVectors(p3, c);
        const d5 = _vab.dot(_vcp);
        const d6 = _vac.dot(_vcp);
        if (d6 >= 0 && d5 <= d6) {
          return target2.copy(c);
        }
        const vb = d5 * d2 - d1 * d6;
        if (vb <= 0 && d2 >= 0 && d6 <= 0) {
          w = d2 / (d2 - d6);
          return target2.copy(a).addScaledVector(_vac, w);
        }
        const va = d3 * d6 - d5 * d4;
        if (va <= 0 && d4 - d3 >= 0 && d5 - d6 >= 0) {
          _vbc.subVectors(c, b);
          w = (d4 - d3) / (d4 - d3 + (d5 - d6));
          return target2.copy(b).addScaledVector(_vbc, w);
        }
        const denom = 1 / (va + vb + vc);
        v2 = vb * denom;
        w = vc * denom;
        return target2.copy(a).addScaledVector(_vab, v2).addScaledVector(_vac, w);
      }
      equals(triangle) {
        return triangle.a.equals(this.a) && triangle.b.equals(this.b) && triangle.c.equals(this.c);
      }
    };
    _colorKeywords = {
      "aliceblue": 15792383,
      "antiquewhite": 16444375,
      "aqua": 65535,
      "aquamarine": 8388564,
      "azure": 15794175,
      "beige": 16119260,
      "bisque": 16770244,
      "black": 0,
      "blanchedalmond": 16772045,
      "blue": 255,
      "blueviolet": 9055202,
      "brown": 10824234,
      "burlywood": 14596231,
      "cadetblue": 6266528,
      "chartreuse": 8388352,
      "chocolate": 13789470,
      "coral": 16744272,
      "cornflowerblue": 6591981,
      "cornsilk": 16775388,
      "crimson": 14423100,
      "cyan": 65535,
      "darkblue": 139,
      "darkcyan": 35723,
      "darkgoldenrod": 12092939,
      "darkgray": 11119017,
      "darkgreen": 25600,
      "darkgrey": 11119017,
      "darkkhaki": 12433259,
      "darkmagenta": 9109643,
      "darkolivegreen": 5597999,
      "darkorange": 16747520,
      "darkorchid": 10040012,
      "darkred": 9109504,
      "darksalmon": 15308410,
      "darkseagreen": 9419919,
      "darkslateblue": 4734347,
      "darkslategray": 3100495,
      "darkslategrey": 3100495,
      "darkturquoise": 52945,
      "darkviolet": 9699539,
      "deeppink": 16716947,
      "deepskyblue": 49151,
      "dimgray": 6908265,
      "dimgrey": 6908265,
      "dodgerblue": 2003199,
      "firebrick": 11674146,
      "floralwhite": 16775920,
      "forestgreen": 2263842,
      "fuchsia": 16711935,
      "gainsboro": 14474460,
      "ghostwhite": 16316671,
      "gold": 16766720,
      "goldenrod": 14329120,
      "gray": 8421504,
      "green": 32768,
      "greenyellow": 11403055,
      "grey": 8421504,
      "honeydew": 15794160,
      "hotpink": 16738740,
      "indianred": 13458524,
      "indigo": 4915330,
      "ivory": 16777200,
      "khaki": 15787660,
      "lavender": 15132410,
      "lavenderblush": 16773365,
      "lawngreen": 8190976,
      "lemonchiffon": 16775885,
      "lightblue": 11393254,
      "lightcoral": 15761536,
      "lightcyan": 14745599,
      "lightgoldenrodyellow": 16448210,
      "lightgray": 13882323,
      "lightgreen": 9498256,
      "lightgrey": 13882323,
      "lightpink": 16758465,
      "lightsalmon": 16752762,
      "lightseagreen": 2142890,
      "lightskyblue": 8900346,
      "lightslategray": 7833753,
      "lightslategrey": 7833753,
      "lightsteelblue": 11584734,
      "lightyellow": 16777184,
      "lime": 65280,
      "limegreen": 3329330,
      "linen": 16445670,
      "magenta": 16711935,
      "maroon": 8388608,
      "mediumaquamarine": 6737322,
      "mediumblue": 205,
      "mediumorchid": 12211667,
      "mediumpurple": 9662683,
      "mediumseagreen": 3978097,
      "mediumslateblue": 8087790,
      "mediumspringgreen": 64154,
      "mediumturquoise": 4772300,
      "mediumvioletred": 13047173,
      "midnightblue": 1644912,
      "mintcream": 16121850,
      "mistyrose": 16770273,
      "moccasin": 16770229,
      "navajowhite": 16768685,
      "navy": 128,
      "oldlace": 16643558,
      "olive": 8421376,
      "olivedrab": 7048739,
      "orange": 16753920,
      "orangered": 16729344,
      "orchid": 14315734,
      "palegoldenrod": 15657130,
      "palegreen": 10025880,
      "paleturquoise": 11529966,
      "palevioletred": 14381203,
      "papayawhip": 16773077,
      "peachpuff": 16767673,
      "peru": 13468991,
      "pink": 16761035,
      "plum": 14524637,
      "powderblue": 11591910,
      "purple": 8388736,
      "rebeccapurple": 6697881,
      "red": 16711680,
      "rosybrown": 12357519,
      "royalblue": 4286945,
      "saddlebrown": 9127187,
      "salmon": 16416882,
      "sandybrown": 16032864,
      "seagreen": 3050327,
      "seashell": 16774638,
      "sienna": 10506797,
      "silver": 12632256,
      "skyblue": 8900331,
      "slateblue": 6970061,
      "slategray": 7372944,
      "slategrey": 7372944,
      "snow": 16775930,
      "springgreen": 65407,
      "steelblue": 4620980,
      "tan": 13808780,
      "teal": 32896,
      "thistle": 14204888,
      "tomato": 16737095,
      "turquoise": 4251856,
      "violet": 15631086,
      "wheat": 16113331,
      "white": 16777215,
      "whitesmoke": 16119285,
      "yellow": 16776960,
      "yellowgreen": 10145074
    };
    _hslA = { h: 0, s: 0, l: 0 };
    _hslB = { h: 0, s: 0, l: 0 };
    Color = class {
      constructor(r2, g3, b) {
        this.isColor = true;
        this.r = 1;
        this.g = 1;
        this.b = 1;
        return this.set(r2, g3, b);
      }
      set(r2, g3, b) {
        if (g3 === void 0 && b === void 0) {
          const value = r2;
          if (value && value.isColor) {
            this.copy(value);
          } else if (typeof value === "number") {
            this.setHex(value);
          } else if (typeof value === "string") {
            this.setStyle(value);
          }
        } else {
          this.setRGB(r2, g3, b);
        }
        return this;
      }
      setScalar(scalar) {
        this.r = scalar;
        this.g = scalar;
        this.b = scalar;
        return this;
      }
      setHex(hex, colorSpace = SRGBColorSpace) {
        hex = Math.floor(hex);
        this.r = (hex >> 16 & 255) / 255;
        this.g = (hex >> 8 & 255) / 255;
        this.b = (hex & 255) / 255;
        ColorManagement.toWorkingColorSpace(this, colorSpace);
        return this;
      }
      setRGB(r2, g3, b, colorSpace = ColorManagement.workingColorSpace) {
        this.r = r2;
        this.g = g3;
        this.b = b;
        ColorManagement.toWorkingColorSpace(this, colorSpace);
        return this;
      }
      setHSL(h2, s, l2, colorSpace = ColorManagement.workingColorSpace) {
        h2 = euclideanModulo(h2, 1);
        s = clamp(s, 0, 1);
        l2 = clamp(l2, 0, 1);
        if (s === 0) {
          this.r = this.g = this.b = l2;
        } else {
          const p3 = l2 <= 0.5 ? l2 * (1 + s) : l2 + s - l2 * s;
          const q3 = 2 * l2 - p3;
          this.r = hue2rgb(q3, p3, h2 + 1 / 3);
          this.g = hue2rgb(q3, p3, h2);
          this.b = hue2rgb(q3, p3, h2 - 1 / 3);
        }
        ColorManagement.toWorkingColorSpace(this, colorSpace);
        return this;
      }
      setStyle(style, colorSpace = SRGBColorSpace) {
        function handleAlpha(string) {
          if (string === void 0) return;
          if (parseFloat(string) < 1) {
            console.warn("THREE.Color: Alpha component of " + style + " will be ignored.");
          }
        }
        let m;
        if (m = /^(\w+)\(([^\)]*)\)/.exec(style)) {
          let color;
          const name = m[1];
          const components = m[2];
          switch (name) {
            case "rgb":
            case "rgba":
              if (color = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(components)) {
                handleAlpha(color[4]);
                return this.setRGB(
                  Math.min(255, parseInt(color[1], 10)) / 255,
                  Math.min(255, parseInt(color[2], 10)) / 255,
                  Math.min(255, parseInt(color[3], 10)) / 255,
                  colorSpace
                );
              }
              if (color = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(components)) {
                handleAlpha(color[4]);
                return this.setRGB(
                  Math.min(100, parseInt(color[1], 10)) / 100,
                  Math.min(100, parseInt(color[2], 10)) / 100,
                  Math.min(100, parseInt(color[3], 10)) / 100,
                  colorSpace
                );
              }
              break;
            case "hsl":
            case "hsla":
              if (color = /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(components)) {
                handleAlpha(color[4]);
                return this.setHSL(
                  parseFloat(color[1]) / 360,
                  parseFloat(color[2]) / 100,
                  parseFloat(color[3]) / 100,
                  colorSpace
                );
              }
              break;
            default:
              console.warn("THREE.Color: Unknown color model " + style);
          }
        } else if (m = /^\#([A-Fa-f\d]+)$/.exec(style)) {
          const hex = m[1];
          const size = hex.length;
          if (size === 3) {
            return this.setRGB(
              parseInt(hex.charAt(0), 16) / 15,
              parseInt(hex.charAt(1), 16) / 15,
              parseInt(hex.charAt(2), 16) / 15,
              colorSpace
            );
          } else if (size === 6) {
            return this.setHex(parseInt(hex, 16), colorSpace);
          } else {
            console.warn("THREE.Color: Invalid hex color " + style);
          }
        } else if (style && style.length > 0) {
          return this.setColorName(style, colorSpace);
        }
        return this;
      }
      setColorName(style, colorSpace = SRGBColorSpace) {
        const hex = _colorKeywords[style.toLowerCase()];
        if (hex !== void 0) {
          this.setHex(hex, colorSpace);
        } else {
          console.warn("THREE.Color: Unknown color " + style);
        }
        return this;
      }
      clone() {
        return new this.constructor(this.r, this.g, this.b);
      }
      copy(color) {
        this.r = color.r;
        this.g = color.g;
        this.b = color.b;
        return this;
      }
      copySRGBToLinear(color) {
        this.r = SRGBToLinear(color.r);
        this.g = SRGBToLinear(color.g);
        this.b = SRGBToLinear(color.b);
        return this;
      }
      copyLinearToSRGB(color) {
        this.r = LinearToSRGB(color.r);
        this.g = LinearToSRGB(color.g);
        this.b = LinearToSRGB(color.b);
        return this;
      }
      convertSRGBToLinear() {
        this.copySRGBToLinear(this);
        return this;
      }
      convertLinearToSRGB() {
        this.copyLinearToSRGB(this);
        return this;
      }
      getHex(colorSpace = SRGBColorSpace) {
        ColorManagement.fromWorkingColorSpace(_color.copy(this), colorSpace);
        return Math.round(clamp(_color.r * 255, 0, 255)) * 65536 + Math.round(clamp(_color.g * 255, 0, 255)) * 256 + Math.round(clamp(_color.b * 255, 0, 255));
      }
      getHexString(colorSpace = SRGBColorSpace) {
        return ("000000" + this.getHex(colorSpace).toString(16)).slice(-6);
      }
      getHSL(target2, colorSpace = ColorManagement.workingColorSpace) {
        ColorManagement.fromWorkingColorSpace(_color.copy(this), colorSpace);
        const r2 = _color.r, g3 = _color.g, b = _color.b;
        const max = Math.max(r2, g3, b);
        const min = Math.min(r2, g3, b);
        let hue, saturation;
        const lightness = (min + max) / 2;
        if (min === max) {
          hue = 0;
          saturation = 0;
        } else {
          const delta = max - min;
          saturation = lightness <= 0.5 ? delta / (max + min) : delta / (2 - max - min);
          switch (max) {
            case r2:
              hue = (g3 - b) / delta + (g3 < b ? 6 : 0);
              break;
            case g3:
              hue = (b - r2) / delta + 2;
              break;
            case b:
              hue = (r2 - g3) / delta + 4;
              break;
          }
          hue /= 6;
        }
        target2.h = hue;
        target2.s = saturation;
        target2.l = lightness;
        return target2;
      }
      getRGB(target2, colorSpace = ColorManagement.workingColorSpace) {
        ColorManagement.fromWorkingColorSpace(_color.copy(this), colorSpace);
        target2.r = _color.r;
        target2.g = _color.g;
        target2.b = _color.b;
        return target2;
      }
      getStyle(colorSpace = SRGBColorSpace) {
        ColorManagement.fromWorkingColorSpace(_color.copy(this), colorSpace);
        const r2 = _color.r, g3 = _color.g, b = _color.b;
        if (colorSpace !== SRGBColorSpace) {
          return `color(${colorSpace} ${r2.toFixed(3)} ${g3.toFixed(3)} ${b.toFixed(3)})`;
        }
        return `rgb(${Math.round(r2 * 255)},${Math.round(g3 * 255)},${Math.round(b * 255)})`;
      }
      offsetHSL(h2, s, l2) {
        this.getHSL(_hslA);
        return this.setHSL(_hslA.h + h2, _hslA.s + s, _hslA.l + l2);
      }
      add(color) {
        this.r += color.r;
        this.g += color.g;
        this.b += color.b;
        return this;
      }
      addColors(color1, color2) {
        this.r = color1.r + color2.r;
        this.g = color1.g + color2.g;
        this.b = color1.b + color2.b;
        return this;
      }
      addScalar(s) {
        this.r += s;
        this.g += s;
        this.b += s;
        return this;
      }
      sub(color) {
        this.r = Math.max(0, this.r - color.r);
        this.g = Math.max(0, this.g - color.g);
        this.b = Math.max(0, this.b - color.b);
        return this;
      }
      multiply(color) {
        this.r *= color.r;
        this.g *= color.g;
        this.b *= color.b;
        return this;
      }
      multiplyScalar(s) {
        this.r *= s;
        this.g *= s;
        this.b *= s;
        return this;
      }
      lerp(color, alpha) {
        this.r += (color.r - this.r) * alpha;
        this.g += (color.g - this.g) * alpha;
        this.b += (color.b - this.b) * alpha;
        return this;
      }
      lerpColors(color1, color2, alpha) {
        this.r = color1.r + (color2.r - color1.r) * alpha;
        this.g = color1.g + (color2.g - color1.g) * alpha;
        this.b = color1.b + (color2.b - color1.b) * alpha;
        return this;
      }
      lerpHSL(color, alpha) {
        this.getHSL(_hslA);
        color.getHSL(_hslB);
        const h2 = lerp(_hslA.h, _hslB.h, alpha);
        const s = lerp(_hslA.s, _hslB.s, alpha);
        const l2 = lerp(_hslA.l, _hslB.l, alpha);
        this.setHSL(h2, s, l2);
        return this;
      }
      setFromVector3(v2) {
        this.r = v2.x;
        this.g = v2.y;
        this.b = v2.z;
        return this;
      }
      applyMatrix3(m) {
        const r2 = this.r, g3 = this.g, b = this.b;
        const e = m.elements;
        this.r = e[0] * r2 + e[3] * g3 + e[6] * b;
        this.g = e[1] * r2 + e[4] * g3 + e[7] * b;
        this.b = e[2] * r2 + e[5] * g3 + e[8] * b;
        return this;
      }
      equals(c) {
        return c.r === this.r && c.g === this.g && c.b === this.b;
      }
      fromArray(array, offset = 0) {
        this.r = array[offset];
        this.g = array[offset + 1];
        this.b = array[offset + 2];
        return this;
      }
      toArray(array = [], offset = 0) {
        array[offset] = this.r;
        array[offset + 1] = this.g;
        array[offset + 2] = this.b;
        return array;
      }
      fromBufferAttribute(attribute, index) {
        this.r = attribute.getX(index);
        this.g = attribute.getY(index);
        this.b = attribute.getZ(index);
        return this;
      }
      toJSON() {
        return this.getHex();
      }
      *[Symbol.iterator]() {
        yield this.r;
        yield this.g;
        yield this.b;
      }
    };
    _color = /* @__PURE__ */ new Color();
    Color.NAMES = _colorKeywords;
    _materialId = 0;
    Material = class extends EventDispatcher {
      constructor() {
        super();
        this.isMaterial = true;
        Object.defineProperty(this, "id", { value: _materialId++ });
        this.uuid = generateUUID();
        this.name = "";
        this.type = "Material";
        this.blending = NormalBlending;
        this.side = FrontSide;
        this.vertexColors = false;
        this.opacity = 1;
        this.transparent = false;
        this.alphaHash = false;
        this.blendSrc = SrcAlphaFactor;
        this.blendDst = OneMinusSrcAlphaFactor;
        this.blendEquation = AddEquation;
        this.blendSrcAlpha = null;
        this.blendDstAlpha = null;
        this.blendEquationAlpha = null;
        this.blendColor = new Color(0, 0, 0);
        this.blendAlpha = 0;
        this.depthFunc = LessEqualDepth;
        this.depthTest = true;
        this.depthWrite = true;
        this.stencilWriteMask = 255;
        this.stencilFunc = AlwaysStencilFunc;
        this.stencilRef = 0;
        this.stencilFuncMask = 255;
        this.stencilFail = KeepStencilOp;
        this.stencilZFail = KeepStencilOp;
        this.stencilZPass = KeepStencilOp;
        this.stencilWrite = false;
        this.clippingPlanes = null;
        this.clipIntersection = false;
        this.clipShadows = false;
        this.shadowSide = null;
        this.colorWrite = true;
        this.precision = null;
        this.polygonOffset = false;
        this.polygonOffsetFactor = 0;
        this.polygonOffsetUnits = 0;
        this.dithering = false;
        this.alphaToCoverage = false;
        this.premultipliedAlpha = false;
        this.forceSinglePass = false;
        this.visible = true;
        this.toneMapped = true;
        this.userData = {};
        this.version = 0;
        this._alphaTest = 0;
      }
      get alphaTest() {
        return this._alphaTest;
      }
      set alphaTest(value) {
        if (this._alphaTest > 0 !== value > 0) {
          this.version++;
        }
        this._alphaTest = value;
      }
      // onBeforeRender and onBeforeCompile only supported in WebGLRenderer
      onBeforeRender() {
      }
      onBeforeCompile() {
      }
      customProgramCacheKey() {
        return this.onBeforeCompile.toString();
      }
      setValues(values) {
        if (values === void 0) return;
        for (const key in values) {
          const newValue = values[key];
          if (newValue === void 0) {
            console.warn(`THREE.Material: parameter '${key}' has value of undefined.`);
            continue;
          }
          const currentValue = this[key];
          if (currentValue === void 0) {
            console.warn(`THREE.Material: '${key}' is not a property of THREE.${this.type}.`);
            continue;
          }
          if (currentValue && currentValue.isColor) {
            currentValue.set(newValue);
          } else if (currentValue && currentValue.isVector3 && (newValue && newValue.isVector3)) {
            currentValue.copy(newValue);
          } else {
            this[key] = newValue;
          }
        }
      }
      toJSON(meta) {
        const isRootObject = meta === void 0 || typeof meta === "string";
        if (isRootObject) {
          meta = {
            textures: {},
            images: {}
          };
        }
        const data = {
          metadata: {
            version: 4.6,
            type: "Material",
            generator: "Material.toJSON"
          }
        };
        data.uuid = this.uuid;
        data.type = this.type;
        if (this.name !== "") data.name = this.name;
        if (this.color && this.color.isColor) data.color = this.color.getHex();
        if (this.roughness !== void 0) data.roughness = this.roughness;
        if (this.metalness !== void 0) data.metalness = this.metalness;
        if (this.sheen !== void 0) data.sheen = this.sheen;
        if (this.sheenColor && this.sheenColor.isColor) data.sheenColor = this.sheenColor.getHex();
        if (this.sheenRoughness !== void 0) data.sheenRoughness = this.sheenRoughness;
        if (this.emissive && this.emissive.isColor) data.emissive = this.emissive.getHex();
        if (this.emissiveIntensity !== void 0 && this.emissiveIntensity !== 1) data.emissiveIntensity = this.emissiveIntensity;
        if (this.specular && this.specular.isColor) data.specular = this.specular.getHex();
        if (this.specularIntensity !== void 0) data.specularIntensity = this.specularIntensity;
        if (this.specularColor && this.specularColor.isColor) data.specularColor = this.specularColor.getHex();
        if (this.shininess !== void 0) data.shininess = this.shininess;
        if (this.clearcoat !== void 0) data.clearcoat = this.clearcoat;
        if (this.clearcoatRoughness !== void 0) data.clearcoatRoughness = this.clearcoatRoughness;
        if (this.clearcoatMap && this.clearcoatMap.isTexture) {
          data.clearcoatMap = this.clearcoatMap.toJSON(meta).uuid;
        }
        if (this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture) {
          data.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(meta).uuid;
        }
        if (this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture) {
          data.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(meta).uuid;
          data.clearcoatNormalScale = this.clearcoatNormalScale.toArray();
        }
        if (this.dispersion !== void 0) data.dispersion = this.dispersion;
        if (this.iridescence !== void 0) data.iridescence = this.iridescence;
        if (this.iridescenceIOR !== void 0) data.iridescenceIOR = this.iridescenceIOR;
        if (this.iridescenceThicknessRange !== void 0) data.iridescenceThicknessRange = this.iridescenceThicknessRange;
        if (this.iridescenceMap && this.iridescenceMap.isTexture) {
          data.iridescenceMap = this.iridescenceMap.toJSON(meta).uuid;
        }
        if (this.iridescenceThicknessMap && this.iridescenceThicknessMap.isTexture) {
          data.iridescenceThicknessMap = this.iridescenceThicknessMap.toJSON(meta).uuid;
        }
        if (this.anisotropy !== void 0) data.anisotropy = this.anisotropy;
        if (this.anisotropyRotation !== void 0) data.anisotropyRotation = this.anisotropyRotation;
        if (this.anisotropyMap && this.anisotropyMap.isTexture) {
          data.anisotropyMap = this.anisotropyMap.toJSON(meta).uuid;
        }
        if (this.map && this.map.isTexture) data.map = this.map.toJSON(meta).uuid;
        if (this.matcap && this.matcap.isTexture) data.matcap = this.matcap.toJSON(meta).uuid;
        if (this.alphaMap && this.alphaMap.isTexture) data.alphaMap = this.alphaMap.toJSON(meta).uuid;
        if (this.lightMap && this.lightMap.isTexture) {
          data.lightMap = this.lightMap.toJSON(meta).uuid;
          data.lightMapIntensity = this.lightMapIntensity;
        }
        if (this.aoMap && this.aoMap.isTexture) {
          data.aoMap = this.aoMap.toJSON(meta).uuid;
          data.aoMapIntensity = this.aoMapIntensity;
        }
        if (this.bumpMap && this.bumpMap.isTexture) {
          data.bumpMap = this.bumpMap.toJSON(meta).uuid;
          data.bumpScale = this.bumpScale;
        }
        if (this.normalMap && this.normalMap.isTexture) {
          data.normalMap = this.normalMap.toJSON(meta).uuid;
          data.normalMapType = this.normalMapType;
          data.normalScale = this.normalScale.toArray();
        }
        if (this.displacementMap && this.displacementMap.isTexture) {
          data.displacementMap = this.displacementMap.toJSON(meta).uuid;
          data.displacementScale = this.displacementScale;
          data.displacementBias = this.displacementBias;
        }
        if (this.roughnessMap && this.roughnessMap.isTexture) data.roughnessMap = this.roughnessMap.toJSON(meta).uuid;
        if (this.metalnessMap && this.metalnessMap.isTexture) data.metalnessMap = this.metalnessMap.toJSON(meta).uuid;
        if (this.emissiveMap && this.emissiveMap.isTexture) data.emissiveMap = this.emissiveMap.toJSON(meta).uuid;
        if (this.specularMap && this.specularMap.isTexture) data.specularMap = this.specularMap.toJSON(meta).uuid;
        if (this.specularIntensityMap && this.specularIntensityMap.isTexture) data.specularIntensityMap = this.specularIntensityMap.toJSON(meta).uuid;
        if (this.specularColorMap && this.specularColorMap.isTexture) data.specularColorMap = this.specularColorMap.toJSON(meta).uuid;
        if (this.envMap && this.envMap.isTexture) {
          data.envMap = this.envMap.toJSON(meta).uuid;
          if (this.combine !== void 0) data.combine = this.combine;
        }
        if (this.envMapRotation !== void 0) data.envMapRotation = this.envMapRotation.toArray();
        if (this.envMapIntensity !== void 0) data.envMapIntensity = this.envMapIntensity;
        if (this.reflectivity !== void 0) data.reflectivity = this.reflectivity;
        if (this.refractionRatio !== void 0) data.refractionRatio = this.refractionRatio;
        if (this.gradientMap && this.gradientMap.isTexture) {
          data.gradientMap = this.gradientMap.toJSON(meta).uuid;
        }
        if (this.transmission !== void 0) data.transmission = this.transmission;
        if (this.transmissionMap && this.transmissionMap.isTexture) data.transmissionMap = this.transmissionMap.toJSON(meta).uuid;
        if (this.thickness !== void 0) data.thickness = this.thickness;
        if (this.thicknessMap && this.thicknessMap.isTexture) data.thicknessMap = this.thicknessMap.toJSON(meta).uuid;
        if (this.attenuationDistance !== void 0 && this.attenuationDistance !== Infinity) data.attenuationDistance = this.attenuationDistance;
        if (this.attenuationColor !== void 0) data.attenuationColor = this.attenuationColor.getHex();
        if (this.size !== void 0) data.size = this.size;
        if (this.shadowSide !== null) data.shadowSide = this.shadowSide;
        if (this.sizeAttenuation !== void 0) data.sizeAttenuation = this.sizeAttenuation;
        if (this.blending !== NormalBlending) data.blending = this.blending;
        if (this.side !== FrontSide) data.side = this.side;
        if (this.vertexColors === true) data.vertexColors = true;
        if (this.opacity < 1) data.opacity = this.opacity;
        if (this.transparent === true) data.transparent = true;
        if (this.blendSrc !== SrcAlphaFactor) data.blendSrc = this.blendSrc;
        if (this.blendDst !== OneMinusSrcAlphaFactor) data.blendDst = this.blendDst;
        if (this.blendEquation !== AddEquation) data.blendEquation = this.blendEquation;
        if (this.blendSrcAlpha !== null) data.blendSrcAlpha = this.blendSrcAlpha;
        if (this.blendDstAlpha !== null) data.blendDstAlpha = this.blendDstAlpha;
        if (this.blendEquationAlpha !== null) data.blendEquationAlpha = this.blendEquationAlpha;
        if (this.blendColor && this.blendColor.isColor) data.blendColor = this.blendColor.getHex();
        if (this.blendAlpha !== 0) data.blendAlpha = this.blendAlpha;
        if (this.depthFunc !== LessEqualDepth) data.depthFunc = this.depthFunc;
        if (this.depthTest === false) data.depthTest = this.depthTest;
        if (this.depthWrite === false) data.depthWrite = this.depthWrite;
        if (this.colorWrite === false) data.colorWrite = this.colorWrite;
        if (this.stencilWriteMask !== 255) data.stencilWriteMask = this.stencilWriteMask;
        if (this.stencilFunc !== AlwaysStencilFunc) data.stencilFunc = this.stencilFunc;
        if (this.stencilRef !== 0) data.stencilRef = this.stencilRef;
        if (this.stencilFuncMask !== 255) data.stencilFuncMask = this.stencilFuncMask;
        if (this.stencilFail !== KeepStencilOp) data.stencilFail = this.stencilFail;
        if (this.stencilZFail !== KeepStencilOp) data.stencilZFail = this.stencilZFail;
        if (this.stencilZPass !== KeepStencilOp) data.stencilZPass = this.stencilZPass;
        if (this.stencilWrite === true) data.stencilWrite = this.stencilWrite;
        if (this.rotation !== void 0 && this.rotation !== 0) data.rotation = this.rotation;
        if (this.polygonOffset === true) data.polygonOffset = true;
        if (this.polygonOffsetFactor !== 0) data.polygonOffsetFactor = this.polygonOffsetFactor;
        if (this.polygonOffsetUnits !== 0) data.polygonOffsetUnits = this.polygonOffsetUnits;
        if (this.linewidth !== void 0 && this.linewidth !== 1) data.linewidth = this.linewidth;
        if (this.dashSize !== void 0) data.dashSize = this.dashSize;
        if (this.gapSize !== void 0) data.gapSize = this.gapSize;
        if (this.scale !== void 0) data.scale = this.scale;
        if (this.dithering === true) data.dithering = true;
        if (this.alphaTest > 0) data.alphaTest = this.alphaTest;
        if (this.alphaHash === true) data.alphaHash = true;
        if (this.alphaToCoverage === true) data.alphaToCoverage = true;
        if (this.premultipliedAlpha === true) data.premultipliedAlpha = true;
        if (this.forceSinglePass === true) data.forceSinglePass = true;
        if (this.wireframe === true) data.wireframe = true;
        if (this.wireframeLinewidth > 1) data.wireframeLinewidth = this.wireframeLinewidth;
        if (this.wireframeLinecap !== "round") data.wireframeLinecap = this.wireframeLinecap;
        if (this.wireframeLinejoin !== "round") data.wireframeLinejoin = this.wireframeLinejoin;
        if (this.flatShading === true) data.flatShading = true;
        if (this.visible === false) data.visible = false;
        if (this.toneMapped === false) data.toneMapped = false;
        if (this.fog === false) data.fog = false;
        if (Object.keys(this.userData).length > 0) data.userData = this.userData;
        function extractFromCache(cache) {
          const values = [];
          for (const key in cache) {
            const data2 = cache[key];
            delete data2.metadata;
            values.push(data2);
          }
          return values;
        }
        if (isRootObject) {
          const textures = extractFromCache(meta.textures);
          const images = extractFromCache(meta.images);
          if (textures.length > 0) data.textures = textures;
          if (images.length > 0) data.images = images;
        }
        return data;
      }
      clone() {
        return new this.constructor().copy(this);
      }
      copy(source) {
        this.name = source.name;
        this.blending = source.blending;
        this.side = source.side;
        this.vertexColors = source.vertexColors;
        this.opacity = source.opacity;
        this.transparent = source.transparent;
        this.blendSrc = source.blendSrc;
        this.blendDst = source.blendDst;
        this.blendEquation = source.blendEquation;
        this.blendSrcAlpha = source.blendSrcAlpha;
        this.blendDstAlpha = source.blendDstAlpha;
        this.blendEquationAlpha = source.blendEquationAlpha;
        this.blendColor.copy(source.blendColor);
        this.blendAlpha = source.blendAlpha;
        this.depthFunc = source.depthFunc;
        this.depthTest = source.depthTest;
        this.depthWrite = source.depthWrite;
        this.stencilWriteMask = source.stencilWriteMask;
        this.stencilFunc = source.stencilFunc;
        this.stencilRef = source.stencilRef;
        this.stencilFuncMask = source.stencilFuncMask;
        this.stencilFail = source.stencilFail;
        this.stencilZFail = source.stencilZFail;
        this.stencilZPass = source.stencilZPass;
        this.stencilWrite = source.stencilWrite;
        const srcPlanes = source.clippingPlanes;
        let dstPlanes = null;
        if (srcPlanes !== null) {
          const n = srcPlanes.length;
          dstPlanes = new Array(n);
          for (let i2 = 0; i2 !== n; ++i2) {
            dstPlanes[i2] = srcPlanes[i2].clone();
          }
        }
        this.clippingPlanes = dstPlanes;
        this.clipIntersection = source.clipIntersection;
        this.clipShadows = source.clipShadows;
        this.shadowSide = source.shadowSide;
        this.colorWrite = source.colorWrite;
        this.precision = source.precision;
        this.polygonOffset = source.polygonOffset;
        this.polygonOffsetFactor = source.polygonOffsetFactor;
        this.polygonOffsetUnits = source.polygonOffsetUnits;
        this.dithering = source.dithering;
        this.alphaTest = source.alphaTest;
        this.alphaHash = source.alphaHash;
        this.alphaToCoverage = source.alphaToCoverage;
        this.premultipliedAlpha = source.premultipliedAlpha;
        this.forceSinglePass = source.forceSinglePass;
        this.visible = source.visible;
        this.toneMapped = source.toneMapped;
        this.userData = JSON.parse(JSON.stringify(source.userData));
        return this;
      }
      dispose() {
        this.dispatchEvent({ type: "dispose" });
      }
      set needsUpdate(value) {
        if (value === true) this.version++;
      }
      onBuild() {
        console.warn("Material: onBuild() has been removed.");
      }
    };
    MeshBasicMaterial = class extends Material {
      constructor(parameters) {
        super();
        this.isMeshBasicMaterial = true;
        this.type = "MeshBasicMaterial";
        this.color = new Color(16777215);
        this.map = null;
        this.lightMap = null;
        this.lightMapIntensity = 1;
        this.aoMap = null;
        this.aoMapIntensity = 1;
        this.specularMap = null;
        this.alphaMap = null;
        this.envMap = null;
        this.envMapRotation = new Euler();
        this.combine = MultiplyOperation;
        this.reflectivity = 1;
        this.refractionRatio = 0.98;
        this.wireframe = false;
        this.wireframeLinewidth = 1;
        this.wireframeLinecap = "round";
        this.wireframeLinejoin = "round";
        this.fog = true;
        this.setValues(parameters);
      }
      copy(source) {
        super.copy(source);
        this.color.copy(source.color);
        this.map = source.map;
        this.lightMap = source.lightMap;
        this.lightMapIntensity = source.lightMapIntensity;
        this.aoMap = source.aoMap;
        this.aoMapIntensity = source.aoMapIntensity;
        this.specularMap = source.specularMap;
        this.alphaMap = source.alphaMap;
        this.envMap = source.envMap;
        this.envMapRotation.copy(source.envMapRotation);
        this.combine = source.combine;
        this.reflectivity = source.reflectivity;
        this.refractionRatio = source.refractionRatio;
        this.wireframe = source.wireframe;
        this.wireframeLinewidth = source.wireframeLinewidth;
        this.wireframeLinecap = source.wireframeLinecap;
        this.wireframeLinejoin = source.wireframeLinejoin;
        this.fog = source.fog;
        return this;
      }
    };
    _tables = /* @__PURE__ */ _generateTables();
    DataUtils = {
      toHalfFloat,
      fromHalfFloat
    };
    _vector$9 = /* @__PURE__ */ new Vector3();
    _vector2$1 = /* @__PURE__ */ new Vector2();
    BufferAttribute = class {
      constructor(array, itemSize, normalized = false) {
        if (Array.isArray(array)) {
          throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
        }
        this.isBufferAttribute = true;
        this.name = "";
        this.array = array;
        this.itemSize = itemSize;
        this.count = array !== void 0 ? array.length / itemSize : 0;
        this.normalized = normalized;
        this.usage = StaticDrawUsage;
        this.updateRanges = [];
        this.gpuType = FloatType;
        this.version = 0;
      }
      onUploadCallback() {
      }
      set needsUpdate(value) {
        if (value === true) this.version++;
      }
      setUsage(value) {
        this.usage = value;
        return this;
      }
      addUpdateRange(start, count) {
        this.updateRanges.push({ start, count });
      }
      clearUpdateRanges() {
        this.updateRanges.length = 0;
      }
      copy(source) {
        this.name = source.name;
        this.array = new source.array.constructor(source.array);
        this.itemSize = source.itemSize;
        this.count = source.count;
        this.normalized = source.normalized;
        this.usage = source.usage;
        this.gpuType = source.gpuType;
        return this;
      }
      copyAt(index1, attribute, index2) {
        index1 *= this.itemSize;
        index2 *= attribute.itemSize;
        for (let i2 = 0, l2 = this.itemSize; i2 < l2; i2++) {
          this.array[index1 + i2] = attribute.array[index2 + i2];
        }
        return this;
      }
      copyArray(array) {
        this.array.set(array);
        return this;
      }
      applyMatrix3(m) {
        if (this.itemSize === 2) {
          for (let i2 = 0, l2 = this.count; i2 < l2; i2++) {
            _vector2$1.fromBufferAttribute(this, i2);
            _vector2$1.applyMatrix3(m);
            this.setXY(i2, _vector2$1.x, _vector2$1.y);
          }
        } else if (this.itemSize === 3) {
          for (let i2 = 0, l2 = this.count; i2 < l2; i2++) {
            _vector$9.fromBufferAttribute(this, i2);
            _vector$9.applyMatrix3(m);
            this.setXYZ(i2, _vector$9.x, _vector$9.y, _vector$9.z);
          }
        }
        return this;
      }
      applyMatrix4(m) {
        for (let i2 = 0, l2 = this.count; i2 < l2; i2++) {
          _vector$9.fromBufferAttribute(this, i2);
          _vector$9.applyMatrix4(m);
          this.setXYZ(i2, _vector$9.x, _vector$9.y, _vector$9.z);
        }
        return this;
      }
      applyNormalMatrix(m) {
        for (let i2 = 0, l2 = this.count; i2 < l2; i2++) {
          _vector$9.fromBufferAttribute(this, i2);
          _vector$9.applyNormalMatrix(m);
          this.setXYZ(i2, _vector$9.x, _vector$9.y, _vector$9.z);
        }
        return this;
      }
      transformDirection(m) {
        for (let i2 = 0, l2 = this.count; i2 < l2; i2++) {
          _vector$9.fromBufferAttribute(this, i2);
          _vector$9.transformDirection(m);
          this.setXYZ(i2, _vector$9.x, _vector$9.y, _vector$9.z);
        }
        return this;
      }
      set(value, offset = 0) {
        this.array.set(value, offset);
        return this;
      }
      getComponent(index, component) {
        let value = this.array[index * this.itemSize + component];
        if (this.normalized) value = denormalize(value, this.array);
        return value;
      }
      setComponent(index, component, value) {
        if (this.normalized) value = normalize(value, this.array);
        this.array[index * this.itemSize + component] = value;
        return this;
      }
      getX(index) {
        let x = this.array[index * this.itemSize];
        if (this.normalized) x = denormalize(x, this.array);
        return x;
      }
      setX(index, x) {
        if (this.normalized) x = normalize(x, this.array);
        this.array[index * this.itemSize] = x;
        return this;
      }
      getY(index) {
        let y2 = this.array[index * this.itemSize + 1];
        if (this.normalized) y2 = denormalize(y2, this.array);
        return y2;
      }
      setY(index, y2) {
        if (this.normalized) y2 = normalize(y2, this.array);
        this.array[index * this.itemSize + 1] = y2;
        return this;
      }
      getZ(index) {
        let z2 = this.array[index * this.itemSize + 2];
        if (this.normalized) z2 = denormalize(z2, this.array);
        return z2;
      }
      setZ(index, z2) {
        if (this.normalized) z2 = normalize(z2, this.array);
        this.array[index * this.itemSize + 2] = z2;
        return this;
      }
      getW(index) {
        let w = this.array[index * this.itemSize + 3];
        if (this.normalized) w = denormalize(w, this.array);
        return w;
      }
      setW(index, w) {
        if (this.normalized) w = normalize(w, this.array);
        this.array[index * this.itemSize + 3] = w;
        return this;
      }
      setXY(index, x, y2) {
        index *= this.itemSize;
        if (this.normalized) {
          x = normalize(x, this.array);
          y2 = normalize(y2, this.array);
        }
        this.array[index + 0] = x;
        this.array[index + 1] = y2;
        return this;
      }
      setXYZ(index, x, y2, z2) {
        index *= this.itemSize;
        if (this.normalized) {
          x = normalize(x, this.array);
          y2 = normalize(y2, this.array);
          z2 = normalize(z2, this.array);
        }
        this.array[index + 0] = x;
        this.array[index + 1] = y2;
        this.array[index + 2] = z2;
        return this;
      }
      setXYZW(index, x, y2, z2, w) {
        index *= this.itemSize;
        if (this.normalized) {
          x = normalize(x, this.array);
          y2 = normalize(y2, this.array);
          z2 = normalize(z2, this.array);
          w = normalize(w, this.array);
        }
        this.array[index + 0] = x;
        this.array[index + 1] = y2;
        this.array[index + 2] = z2;
        this.array[index + 3] = w;
        return this;
      }
      onUpload(callback) {
        this.onUploadCallback = callback;
        return this;
      }
      clone() {
        return new this.constructor(this.array, this.itemSize).copy(this);
      }
      toJSON() {
        const data = {
          itemSize: this.itemSize,
          type: this.array.constructor.name,
          array: Array.from(this.array),
          normalized: this.normalized
        };
        if (this.name !== "") data.name = this.name;
        if (this.usage !== StaticDrawUsage) data.usage = this.usage;
        return data;
      }
    };
    Int8BufferAttribute = class extends BufferAttribute {
      constructor(array, itemSize, normalized) {
        super(new Int8Array(array), itemSize, normalized);
      }
    };
    Uint8BufferAttribute = class extends BufferAttribute {
      constructor(array, itemSize, normalized) {
        super(new Uint8Array(array), itemSize, normalized);
      }
    };
    Uint8ClampedBufferAttribute = class extends BufferAttribute {
      constructor(array, itemSize, normalized) {
        super(new Uint8ClampedArray(array), itemSize, normalized);
      }
    };
    Int16BufferAttribute = class extends BufferAttribute {
      constructor(array, itemSize, normalized) {
        super(new Int16Array(array), itemSize, normalized);
      }
    };
    Uint16BufferAttribute = class extends BufferAttribute {
      constructor(array, itemSize, normalized) {
        super(new Uint16Array(array), itemSize, normalized);
      }
    };
    Int32BufferAttribute = class extends BufferAttribute {
      constructor(array, itemSize, normalized) {
        super(new Int32Array(array), itemSize, normalized);
      }
    };
    Uint32BufferAttribute = class extends BufferAttribute {
      constructor(array, itemSize, normalized) {
        super(new Uint32Array(array), itemSize, normalized);
      }
    };
    Float16BufferAttribute = class extends BufferAttribute {
      constructor(array, itemSize, normalized) {
        super(new Uint16Array(array), itemSize, normalized);
        this.isFloat16BufferAttribute = true;
      }
      getX(index) {
        let x = fromHalfFloat(this.array[index * this.itemSize]);
        if (this.normalized) x = denormalize(x, this.array);
        return x;
      }
      setX(index, x) {
        if (this.normalized) x = normalize(x, this.array);
        this.array[index * this.itemSize] = toHalfFloat(x);
        return this;
      }
      getY(index) {
        let y2 = fromHalfFloat(this.array[index * this.itemSize + 1]);
        if (this.normalized) y2 = denormalize(y2, this.array);
        return y2;
      }
      setY(index, y2) {
        if (this.normalized) y2 = normalize(y2, this.array);
        this.array[index * this.itemSize + 1] = toHalfFloat(y2);
        return this;
      }
      getZ(index) {
        let z2 = fromHalfFloat(this.array[index * this.itemSize + 2]);
        if (this.normalized) z2 = denormalize(z2, this.array);
        return z2;
      }
      setZ(index, z2) {
        if (this.normalized) z2 = normalize(z2, this.array);
        this.array[index * this.itemSize + 2] = toHalfFloat(z2);
        return this;
      }
      getW(index) {
        let w = fromHalfFloat(this.array[index * this.itemSize + 3]);
        if (this.normalized) w = denormalize(w, this.array);
        return w;
      }
      setW(index, w) {
        if (this.normalized) w = normalize(w, this.array);
        this.array[index * this.itemSize + 3] = toHalfFloat(w);
        return this;
      }
      setXY(index, x, y2) {
        index *= this.itemSize;
        if (this.normalized) {
          x = normalize(x, this.array);
          y2 = normalize(y2, this.array);
        }
        this.array[index + 0] = toHalfFloat(x);
        this.array[index + 1] = toHalfFloat(y2);
        return this;
      }
      setXYZ(index, x, y2, z2) {
        index *= this.itemSize;
        if (this.normalized) {
          x = normalize(x, this.array);
          y2 = normalize(y2, this.array);
          z2 = normalize(z2, this.array);
        }
        this.array[index + 0] = toHalfFloat(x);
        this.array[index + 1] = toHalfFloat(y2);
        this.array[index + 2] = toHalfFloat(z2);
        return this;
      }
      setXYZW(index, x, y2, z2, w) {
        index *= this.itemSize;
        if (this.normalized) {
          x = normalize(x, this.array);
          y2 = normalize(y2, this.array);
          z2 = normalize(z2, this.array);
          w = normalize(w, this.array);
        }
        this.array[index + 0] = toHalfFloat(x);
        this.array[index + 1] = toHalfFloat(y2);
        this.array[index + 2] = toHalfFloat(z2);
        this.array[index + 3] = toHalfFloat(w);
        return this;
      }
    };
    Float32BufferAttribute = class extends BufferAttribute {
      constructor(array, itemSize, normalized) {
        super(new Float32Array(array), itemSize, normalized);
      }
    };
    _id$2 = 0;
    _m1$2 = /* @__PURE__ */ new Matrix4();
    _obj = /* @__PURE__ */ new Object3D();
    _offset = /* @__PURE__ */ new Vector3();
    _box$2 = /* @__PURE__ */ new Box3();
    _boxMorphTargets = /* @__PURE__ */ new Box3();
    _vector$8 = /* @__PURE__ */ new Vector3();
    BufferGeometry = class _BufferGeometry extends EventDispatcher {
      constructor() {
        super();
        this.isBufferGeometry = true;
        Object.defineProperty(this, "id", { value: _id$2++ });
        this.uuid = generateUUID();
        this.name = "";
        this.type = "BufferGeometry";
        this.index = null;
        this.attributes = {};
        this.morphAttributes = {};
        this.morphTargetsRelative = false;
        this.groups = [];
        this.boundingBox = null;
        this.boundingSphere = null;
        this.drawRange = { start: 0, count: Infinity };
        this.userData = {};
      }
      getIndex() {
        return this.index;
      }
      setIndex(index) {
        if (Array.isArray(index)) {
          this.index = new (arrayNeedsUint32(index) ? Uint32BufferAttribute : Uint16BufferAttribute)(index, 1);
        } else {
          this.index = index;
        }
        return this;
      }
      getAttribute(name) {
        return this.attributes[name];
      }
      setAttribute(name, attribute) {
        this.attributes[name] = attribute;
        return this;
      }
      deleteAttribute(name) {
        delete this.attributes[name];
        return this;
      }
      hasAttribute(name) {
        return this.attributes[name] !== void 0;
      }
      addGroup(start, count, materialIndex = 0) {
        this.groups.push({
          start,
          count,
          materialIndex
        });
      }
      clearGroups() {
        this.groups = [];
      }
      setDrawRange(start, count) {
        this.drawRange.start = start;
        this.drawRange.count = count;
      }
      applyMatrix4(matrix2) {
        const position = this.attributes.position;
        if (position !== void 0) {
          position.applyMatrix4(matrix2);
          position.needsUpdate = true;
        }
        const normal = this.attributes.normal;
        if (normal !== void 0) {
          const normalMatrix = new Matrix3().getNormalMatrix(matrix2);
          normal.applyNormalMatrix(normalMatrix);
          normal.needsUpdate = true;
        }
        const tangent = this.attributes.tangent;
        if (tangent !== void 0) {
          tangent.transformDirection(matrix2);
          tangent.needsUpdate = true;
        }
        if (this.boundingBox !== null) {
          this.computeBoundingBox();
        }
        if (this.boundingSphere !== null) {
          this.computeBoundingSphere();
        }
        return this;
      }
      applyQuaternion(q3) {
        _m1$2.makeRotationFromQuaternion(q3);
        this.applyMatrix4(_m1$2);
        return this;
      }
      rotateX(angle) {
        _m1$2.makeRotationX(angle);
        this.applyMatrix4(_m1$2);
        return this;
      }
      rotateY(angle) {
        _m1$2.makeRotationY(angle);
        this.applyMatrix4(_m1$2);
        return this;
      }
      rotateZ(angle) {
        _m1$2.makeRotationZ(angle);
        this.applyMatrix4(_m1$2);
        return this;
      }
      translate(x, y2, z2) {
        _m1$2.makeTranslation(x, y2, z2);
        this.applyMatrix4(_m1$2);
        return this;
      }
      scale(x, y2, z2) {
        _m1$2.makeScale(x, y2, z2);
        this.applyMatrix4(_m1$2);
        return this;
      }
      lookAt(vector) {
        _obj.lookAt(vector);
        _obj.updateMatrix();
        this.applyMatrix4(_obj.matrix);
        return this;
      }
      center() {
        this.computeBoundingBox();
        this.boundingBox.getCenter(_offset).negate();
        this.translate(_offset.x, _offset.y, _offset.z);
        return this;
      }
      setFromPoints(points) {
        const position = [];
        for (let i2 = 0, l2 = points.length; i2 < l2; i2++) {
          const point = points[i2];
          position.push(point.x, point.y, point.z || 0);
        }
        this.setAttribute("position", new Float32BufferAttribute(position, 3));
        return this;
      }
      computeBoundingBox() {
        if (this.boundingBox === null) {
          this.boundingBox = new Box3();
        }
        const position = this.attributes.position;
        const morphAttributesPosition = this.morphAttributes.position;
        if (position && position.isGLBufferAttribute) {
          console.error("THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box.", this);
          this.boundingBox.set(
            new Vector3(-Infinity, -Infinity, -Infinity),
            new Vector3(Infinity, Infinity, Infinity)
          );
          return;
        }
        if (position !== void 0) {
          this.boundingBox.setFromBufferAttribute(position);
          if (morphAttributesPosition) {
            for (let i2 = 0, il = morphAttributesPosition.length; i2 < il; i2++) {
              const morphAttribute = morphAttributesPosition[i2];
              _box$2.setFromBufferAttribute(morphAttribute);
              if (this.morphTargetsRelative) {
                _vector$8.addVectors(this.boundingBox.min, _box$2.min);
                this.boundingBox.expandByPoint(_vector$8);
                _vector$8.addVectors(this.boundingBox.max, _box$2.max);
                this.boundingBox.expandByPoint(_vector$8);
              } else {
                this.boundingBox.expandByPoint(_box$2.min);
                this.boundingBox.expandByPoint(_box$2.max);
              }
            }
          }
        } else {
          this.boundingBox.makeEmpty();
        }
        if (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) {
          console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this);
        }
      }
      computeBoundingSphere() {
        if (this.boundingSphere === null) {
          this.boundingSphere = new Sphere();
        }
        const position = this.attributes.position;
        const morphAttributesPosition = this.morphAttributes.position;
        if (position && position.isGLBufferAttribute) {
          console.error("THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere.", this);
          this.boundingSphere.set(new Vector3(), Infinity);
          return;
        }
        if (position) {
          const center = this.boundingSphere.center;
          _box$2.setFromBufferAttribute(position);
          if (morphAttributesPosition) {
            for (let i2 = 0, il = morphAttributesPosition.length; i2 < il; i2++) {
              const morphAttribute = morphAttributesPosition[i2];
              _boxMorphTargets.setFromBufferAttribute(morphAttribute);
              if (this.morphTargetsRelative) {
                _vector$8.addVectors(_box$2.min, _boxMorphTargets.min);
                _box$2.expandByPoint(_vector$8);
                _vector$8.addVectors(_box$2.max, _boxMorphTargets.max);
                _box$2.expandByPoint(_vector$8);
              } else {
                _box$2.expandByPoint(_boxMorphTargets.min);
                _box$2.expandByPoint(_boxMorphTargets.max);
              }
            }
          }
          _box$2.getCenter(center);
          let maxRadiusSq = 0;
          for (let i2 = 0, il = position.count; i2 < il; i2++) {
            _vector$8.fromBufferAttribute(position, i2);
            maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector$8));
          }
          if (morphAttributesPosition) {
            for (let i2 = 0, il = morphAttributesPosition.length; i2 < il; i2++) {
              const morphAttribute = morphAttributesPosition[i2];
              const morphTargetsRelative = this.morphTargetsRelative;
              for (let j2 = 0, jl = morphAttribute.count; j2 < jl; j2++) {
                _vector$8.fromBufferAttribute(morphAttribute, j2);
                if (morphTargetsRelative) {
                  _offset.fromBufferAttribute(position, j2);
                  _vector$8.add(_offset);
                }
                maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector$8));
              }
            }
          }
          this.boundingSphere.radius = Math.sqrt(maxRadiusSq);
          if (isNaN(this.boundingSphere.radius)) {
            console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this);
          }
        }
      }
      computeTangents() {
        const index = this.index;
        const attributes = this.attributes;
        if (index === null || attributes.position === void 0 || attributes.normal === void 0 || attributes.uv === void 0) {
          console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
          return;
        }
        const positionAttribute = attributes.position;
        const normalAttribute = attributes.normal;
        const uvAttribute = attributes.uv;
        if (this.hasAttribute("tangent") === false) {
          this.setAttribute("tangent", new BufferAttribute(new Float32Array(4 * positionAttribute.count), 4));
        }
        const tangentAttribute = this.getAttribute("tangent");
        const tan1 = [], tan2 = [];
        for (let i2 = 0; i2 < positionAttribute.count; i2++) {
          tan1[i2] = new Vector3();
          tan2[i2] = new Vector3();
        }
        const vA = new Vector3(), vB = new Vector3(), vC = new Vector3(), uvA = new Vector2(), uvB = new Vector2(), uvC = new Vector2(), sdir = new Vector3(), tdir = new Vector3();
        function handleTriangle(a, b, c) {
          vA.fromBufferAttribute(positionAttribute, a);
          vB.fromBufferAttribute(positionAttribute, b);
          vC.fromBufferAttribute(positionAttribute, c);
          uvA.fromBufferAttribute(uvAttribute, a);
          uvB.fromBufferAttribute(uvAttribute, b);
          uvC.fromBufferAttribute(uvAttribute, c);
          vB.sub(vA);
          vC.sub(vA);
          uvB.sub(uvA);
          uvC.sub(uvA);
          const r2 = 1 / (uvB.x * uvC.y - uvC.x * uvB.y);
          if (!isFinite(r2)) return;
          sdir.copy(vB).multiplyScalar(uvC.y).addScaledVector(vC, -uvB.y).multiplyScalar(r2);
          tdir.copy(vC).multiplyScalar(uvB.x).addScaledVector(vB, -uvC.x).multiplyScalar(r2);
          tan1[a].add(sdir);
          tan1[b].add(sdir);
          tan1[c].add(sdir);
          tan2[a].add(tdir);
          tan2[b].add(tdir);
          tan2[c].add(tdir);
        }
        let groups = this.groups;
        if (groups.length === 0) {
          groups = [{
            start: 0,
            count: index.count
          }];
        }
        for (let i2 = 0, il = groups.length; i2 < il; ++i2) {
          const group = groups[i2];
          const start = group.start;
          const count = group.count;
          for (let j2 = start, jl = start + count; j2 < jl; j2 += 3) {
            handleTriangle(
              index.getX(j2 + 0),
              index.getX(j2 + 1),
              index.getX(j2 + 2)
            );
          }
        }
        const tmp2 = new Vector3(), tmp22 = new Vector3();
        const n = new Vector3(), n2 = new Vector3();
        function handleVertex(v2) {
          n.fromBufferAttribute(normalAttribute, v2);
          n2.copy(n);
          const t2 = tan1[v2];
          tmp2.copy(t2);
          tmp2.sub(n.multiplyScalar(n.dot(t2))).normalize();
          tmp22.crossVectors(n2, t2);
          const test = tmp22.dot(tan2[v2]);
          const w = test < 0 ? -1 : 1;
          tangentAttribute.setXYZW(v2, tmp2.x, tmp2.y, tmp2.z, w);
        }
        for (let i2 = 0, il = groups.length; i2 < il; ++i2) {
          const group = groups[i2];
          const start = group.start;
          const count = group.count;
          for (let j2 = start, jl = start + count; j2 < jl; j2 += 3) {
            handleVertex(index.getX(j2 + 0));
            handleVertex(index.getX(j2 + 1));
            handleVertex(index.getX(j2 + 2));
          }
        }
      }
      computeVertexNormals() {
        const index = this.index;
        const positionAttribute = this.getAttribute("position");
        if (positionAttribute !== void 0) {
          let normalAttribute = this.getAttribute("normal");
          if (normalAttribute === void 0) {
            normalAttribute = new BufferAttribute(new Float32Array(positionAttribute.count * 3), 3);
            this.setAttribute("normal", normalAttribute);
          } else {
            for (let i2 = 0, il = normalAttribute.count; i2 < il; i2++) {
              normalAttribute.setXYZ(i2, 0, 0, 0);
            }
          }
          const pA = new Vector3(), pB = new Vector3(), pC = new Vector3();
          const nA = new Vector3(), nB = new Vector3(), nC = new Vector3();
          const cb = new Vector3(), ab = new Vector3();
          if (index) {
            for (let i2 = 0, il = index.count; i2 < il; i2 += 3) {
              const vA = index.getX(i2 + 0);
              const vB = index.getX(i2 + 1);
              const vC = index.getX(i2 + 2);
              pA.fromBufferAttribute(positionAttribute, vA);
              pB.fromBufferAttribute(positionAttribute, vB);
              pC.fromBufferAttribute(positionAttribute, vC);
              cb.subVectors(pC, pB);
              ab.subVectors(pA, pB);
              cb.cross(ab);
              nA.fromBufferAttribute(normalAttribute, vA);
              nB.fromBufferAttribute(normalAttribute, vB);
              nC.fromBufferAttribute(normalAttribute, vC);
              nA.add(cb);
              nB.add(cb);
              nC.add(cb);
              normalAttribute.setXYZ(vA, nA.x, nA.y, nA.z);
              normalAttribute.setXYZ(vB, nB.x, nB.y, nB.z);
              normalAttribute.setXYZ(vC, nC.x, nC.y, nC.z);
            }
          } else {
            for (let i2 = 0, il = positionAttribute.count; i2 < il; i2 += 3) {
              pA.fromBufferAttribute(positionAttribute, i2 + 0);
              pB.fromBufferAttribute(positionAttribute, i2 + 1);
              pC.fromBufferAttribute(positionAttribute, i2 + 2);
              cb.subVectors(pC, pB);
              ab.subVectors(pA, pB);
              cb.cross(ab);
              normalAttribute.setXYZ(i2 + 0, cb.x, cb.y, cb.z);
              normalAttribute.setXYZ(i2 + 1, cb.x, cb.y, cb.z);
              normalAttribute.setXYZ(i2 + 2, cb.x, cb.y, cb.z);
            }
          }
          this.normalizeNormals();
          normalAttribute.needsUpdate = true;
        }
      }
      normalizeNormals() {
        const normals = this.attributes.normal;
        for (let i2 = 0, il = normals.count; i2 < il; i2++) {
          _vector$8.fromBufferAttribute(normals, i2);
          _vector$8.normalize();
          normals.setXYZ(i2, _vector$8.x, _vector$8.y, _vector$8.z);
        }
      }
      toNonIndexed() {
        function convertBufferAttribute(attribute, indices2) {
          const array = attribute.array;
          const itemSize = attribute.itemSize;
          const normalized = attribute.normalized;
          const array2 = new array.constructor(indices2.length * itemSize);
          let index = 0, index2 = 0;
          for (let i2 = 0, l2 = indices2.length; i2 < l2; i2++) {
            if (attribute.isInterleavedBufferAttribute) {
              index = indices2[i2] * attribute.data.stride + attribute.offset;
            } else {
              index = indices2[i2] * itemSize;
            }
            for (let j2 = 0; j2 < itemSize; j2++) {
              array2[index2++] = array[index++];
            }
          }
          return new BufferAttribute(array2, itemSize, normalized);
        }
        if (this.index === null) {
          console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed.");
          return this;
        }
        const geometry2 = new _BufferGeometry();
        const indices = this.index.array;
        const attributes = this.attributes;
        for (const name in attributes) {
          const attribute = attributes[name];
          const newAttribute = convertBufferAttribute(attribute, indices);
          geometry2.setAttribute(name, newAttribute);
        }
        const morphAttributes = this.morphAttributes;
        for (const name in morphAttributes) {
          const morphArray = [];
          const morphAttribute = morphAttributes[name];
          for (let i2 = 0, il = morphAttribute.length; i2 < il; i2++) {
            const attribute = morphAttribute[i2];
            const newAttribute = convertBufferAttribute(attribute, indices);
            morphArray.push(newAttribute);
          }
          geometry2.morphAttributes[name] = morphArray;
        }
        geometry2.morphTargetsRelative = this.morphTargetsRelative;
        const groups = this.groups;
        for (let i2 = 0, l2 = groups.length; i2 < l2; i2++) {
          const group = groups[i2];
          geometry2.addGroup(group.start, group.count, group.materialIndex);
        }
        return geometry2;
      }
      toJSON() {
        const data = {
          metadata: {
            version: 4.6,
            type: "BufferGeometry",
            generator: "BufferGeometry.toJSON"
          }
        };
        data.uuid = this.uuid;
        data.type = this.type;
        if (this.name !== "") data.name = this.name;
        if (Object.keys(this.userData).length > 0) data.userData = this.userData;
        if (this.parameters !== void 0) {
          const parameters = this.parameters;
          for (const key in parameters) {
            if (parameters[key] !== void 0) data[key] = parameters[key];
          }
          return data;
        }
        data.data = { attributes: {} };
        const index = this.index;
        if (index !== null) {
          data.data.index = {
            type: index.array.constructor.name,
            array: Array.prototype.slice.call(index.array)
          };
        }
        const attributes = this.attributes;
        for (const key in attributes) {
          const attribute = attributes[key];
          data.data.attributes[key] = attribute.toJSON(data.data);
        }
        const morphAttributes = {};
        let hasMorphAttributes = false;
        for (const key in this.morphAttributes) {
          const attributeArray = this.morphAttributes[key];
          const array = [];
          for (let i2 = 0, il = attributeArray.length; i2 < il; i2++) {
            const attribute = attributeArray[i2];
            array.push(attribute.toJSON(data.data));
          }
          if (array.length > 0) {
            morphAttributes[key] = array;
            hasMorphAttributes = true;
          }
        }
        if (hasMorphAttributes) {
          data.data.morphAttributes = morphAttributes;
          data.data.morphTargetsRelative = this.morphTargetsRelative;
        }
        const groups = this.groups;
        if (groups.length > 0) {
          data.data.groups = JSON.parse(JSON.stringify(groups));
        }
        const boundingSphere = this.boundingSphere;
        if (boundingSphere !== null) {
          data.data.boundingSphere = {
            center: boundingSphere.center.toArray(),
            radius: boundingSphere.radius
          };
        }
        return data;
      }
      clone() {
        return new this.constructor().copy(this);
      }
      copy(source) {
        this.index = null;
        this.attributes = {};
        this.morphAttributes = {};
        this.groups = [];
        this.boundingBox = null;
        this.boundingSphere = null;
        const data = {};
        this.name = source.name;
        const index = source.index;
        if (index !== null) {
          this.setIndex(index.clone(data));
        }
        const attributes = source.attributes;
        for (const name in attributes) {
          const attribute = attributes[name];
          this.setAttribute(name, attribute.clone(data));
        }
        const morphAttributes = source.morphAttributes;
        for (const name in morphAttributes) {
          const array = [];
          const morphAttribute = morphAttributes[name];
          for (let i2 = 0, l2 = morphAttribute.length; i2 < l2; i2++) {
            array.push(morphAttribute[i2].clone(data));
          }
          this.morphAttributes[name] = array;
        }
        this.morphTargetsRelative = source.morphTargetsRelative;
        const groups = source.groups;
        for (let i2 = 0, l2 = groups.length; i2 < l2; i2++) {
          const group = groups[i2];
          this.addGroup(group.start, group.count, group.materialIndex);
        }
        const boundingBox = source.boundingBox;
        if (boundingBox !== null) {
          this.boundingBox = boundingBox.clone();
        }
        const boundingSphere = source.boundingSphere;
        if (boundingSphere !== null) {
          this.boundingSphere = boundingSphere.clone();
        }
        this.drawRange.start = source.drawRange.start;
        this.drawRange.count = source.drawRange.count;
        this.userData = source.userData;
        return this;
      }
      dispose() {
        this.dispatchEvent({ type: "dispose" });
      }
    };
    _inverseMatrix$3 = /* @__PURE__ */ new Matrix4();
    _ray$3 = /* @__PURE__ */ new Ray();
    _sphere$6 = /* @__PURE__ */ new Sphere();
    _sphereHitAt = /* @__PURE__ */ new Vector3();
    _vA$1 = /* @__PURE__ */ new Vector3();
    _vB$1 = /* @__PURE__ */ new Vector3();
    _vC$1 = /* @__PURE__ */ new Vector3();
    _tempA = /* @__PURE__ */ new Vector3();
    _morphA = /* @__PURE__ */ new Vector3();
    _intersectionPoint = /* @__PURE__ */ new Vector3();
    _intersectionPointWorld = /* @__PURE__ */ new Vector3();
    Mesh = class extends Object3D {
      constructor(geometry = new BufferGeometry(), material = new MeshBasicMaterial()) {
        super();
        this.isMesh = true;
        this.type = "Mesh";
        this.geometry = geometry;
        this.material = material;
        this.updateMorphTargets();
      }
      copy(source, recursive) {
        super.copy(source, recursive);
        if (source.morphTargetInfluences !== void 0) {
          this.morphTargetInfluences = source.morphTargetInfluences.slice();
        }
        if (source.morphTargetDictionary !== void 0) {
          this.morphTargetDictionary = Object.assign({}, source.morphTargetDictionary);
        }
        this.material = Array.isArray(source.material) ? source.material.slice() : source.material;
        this.geometry = source.geometry;
        return this;
      }
      updateMorphTargets() {
        const geometry = this.geometry;
        const morphAttributes = geometry.morphAttributes;
        const keys = Object.keys(morphAttributes);
        if (keys.length > 0) {
          const morphAttribute = morphAttributes[keys[0]];
          if (morphAttribute !== void 0) {
            this.morphTargetInfluences = [];
            this.morphTargetDictionary = {};
            for (let m = 0, ml = morphAttribute.length; m < ml; m++) {
              const name = morphAttribute[m].name || String(m);
              this.morphTargetInfluences.push(0);
              this.morphTargetDictionary[name] = m;
            }
          }
        }
      }
      getVertexPosition(index, target2) {
        const geometry = this.geometry;
        const position = geometry.attributes.position;
        const morphPosition = geometry.morphAttributes.position;
        const morphTargetsRelative = geometry.morphTargetsRelative;
        target2.fromBufferAttribute(position, index);
        const morphInfluences = this.morphTargetInfluences;
        if (morphPosition && morphInfluences) {
          _morphA.set(0, 0, 0);
          for (let i2 = 0, il = morphPosition.length; i2 < il; i2++) {
            const influence = morphInfluences[i2];
            const morphAttribute = morphPosition[i2];
            if (influence === 0) continue;
            _tempA.fromBufferAttribute(morphAttribute, index);
            if (morphTargetsRelative) {
              _morphA.addScaledVector(_tempA, influence);
            } else {
              _morphA.addScaledVector(_tempA.sub(target2), influence);
            }
          }
          target2.add(_morphA);
        }
        return target2;
      }
      raycast(raycaster, intersects2) {
        const geometry = this.geometry;
        const material = this.material;
        const matrixWorld = this.matrixWorld;
        if (material === void 0) return;
        if (geometry.boundingSphere === null) geometry.computeBoundingSphere();
        _sphere$6.copy(geometry.boundingSphere);
        _sphere$6.applyMatrix4(matrixWorld);
        _ray$3.copy(raycaster.ray).recast(raycaster.near);
        if (_sphere$6.containsPoint(_ray$3.origin) === false) {
          if (_ray$3.intersectSphere(_sphere$6, _sphereHitAt) === null) return;
          if (_ray$3.origin.distanceToSquared(_sphereHitAt) > __pow(raycaster.far - raycaster.near, 2)) return;
        }
        _inverseMatrix$3.copy(matrixWorld).invert();
        _ray$3.copy(raycaster.ray).applyMatrix4(_inverseMatrix$3);
        if (geometry.boundingBox !== null) {
          if (_ray$3.intersectsBox(geometry.boundingBox) === false) return;
        }
        this._computeIntersections(raycaster, intersects2, _ray$3);
      }
      _computeIntersections(raycaster, intersects2, rayLocalSpace) {
        let intersection;
        const geometry = this.geometry;
        const material = this.material;
        const index = geometry.index;
        const position = geometry.attributes.position;
        const uv = geometry.attributes.uv;
        const uv1 = geometry.attributes.uv1;
        const normal = geometry.attributes.normal;
        const groups = geometry.groups;
        const drawRange = geometry.drawRange;
        if (index !== null) {
          if (Array.isArray(material)) {
            for (let i2 = 0, il = groups.length; i2 < il; i2++) {
              const group = groups[i2];
              const groupMaterial = material[group.materialIndex];
              const start = Math.max(group.start, drawRange.start);
              const end = Math.min(index.count, Math.min(group.start + group.count, drawRange.start + drawRange.count));
              for (let j2 = start, jl = end; j2 < jl; j2 += 3) {
                const a = index.getX(j2);
                const b = index.getX(j2 + 1);
                const c = index.getX(j2 + 2);
                intersection = checkGeometryIntersection(this, groupMaterial, raycaster, rayLocalSpace, uv, uv1, normal, a, b, c);
                if (intersection) {
                  intersection.faceIndex = Math.floor(j2 / 3);
                  intersection.face.materialIndex = group.materialIndex;
                  intersects2.push(intersection);
                }
              }
            }
          } else {
            const start = Math.max(0, drawRange.start);
            const end = Math.min(index.count, drawRange.start + drawRange.count);
            for (let i2 = start, il = end; i2 < il; i2 += 3) {
              const a = index.getX(i2);
              const b = index.getX(i2 + 1);
              const c = index.getX(i2 + 2);
              intersection = checkGeometryIntersection(this, material, raycaster, rayLocalSpace, uv, uv1, normal, a, b, c);
              if (intersection) {
                intersection.faceIndex = Math.floor(i2 / 3);
                intersects2.push(intersection);
              }
            }
          }
        } else if (position !== void 0) {
          if (Array.isArray(material)) {
            for (let i2 = 0, il = groups.length; i2 < il; i2++) {
              const group = groups[i2];
              const groupMaterial = material[group.materialIndex];
              const start = Math.max(group.start, drawRange.start);
              const end = Math.min(position.count, Math.min(group.start + group.count, drawRange.start + drawRange.count));
              for (let j2 = start, jl = end; j2 < jl; j2 += 3) {
                const a = j2;
                const b = j2 + 1;
                const c = j2 + 2;
                intersection = checkGeometryIntersection(this, groupMaterial, raycaster, rayLocalSpace, uv, uv1, normal, a, b, c);
                if (intersection) {
                  intersection.faceIndex = Math.floor(j2 / 3);
                  intersection.face.materialIndex = group.materialIndex;
                  intersects2.push(intersection);
                }
              }
            }
          } else {
            const start = Math.max(0, drawRange.start);
            const end = Math.min(position.count, drawRange.start + drawRange.count);
            for (let i2 = start, il = end; i2 < il; i2 += 3) {
              const a = i2;
              const b = i2 + 1;
              const c = i2 + 2;
              intersection = checkGeometryIntersection(this, material, raycaster, rayLocalSpace, uv, uv1, normal, a, b, c);
              if (intersection) {
                intersection.faceIndex = Math.floor(i2 / 3);
                intersects2.push(intersection);
              }
            }
          }
        }
      }
    };
    BoxGeometry = class _BoxGeometry extends BufferGeometry {
      constructor(width = 1, height = 1, depth = 1, widthSegments = 1, heightSegments = 1, depthSegments = 1) {
        super();
        this.type = "BoxGeometry";
        this.parameters = {
          width,
          height,
          depth,
          widthSegments,
          heightSegments,
          depthSegments
        };
        const scope = this;
        widthSegments = Math.floor(widthSegments);
        heightSegments = Math.floor(heightSegments);
        depthSegments = Math.floor(depthSegments);
        const indices = [];
        const vertices = [];
        const normals = [];
        const uvs = [];
        let numberOfVertices = 0;
        let groupStart = 0;
        buildPlane("z", "y", "x", -1, -1, depth, height, width, depthSegments, heightSegments, 0);
        buildPlane("z", "y", "x", 1, -1, depth, height, -width, depthSegments, heightSegments, 1);
        buildPlane("x", "z", "y", 1, 1, width, depth, height, widthSegments, depthSegments, 2);
        buildPlane("x", "z", "y", 1, -1, width, depth, -height, widthSegments, depthSegments, 3);
        buildPlane("x", "y", "z", 1, -1, width, height, depth, widthSegments, heightSegments, 4);
        buildPlane("x", "y", "z", -1, -1, width, height, -depth, widthSegments, heightSegments, 5);
        this.setIndex(indices);
        this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
        this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
        this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
        function buildPlane(u3, v2, w, udir, vdir, width2, height2, depth2, gridX, gridY, materialIndex) {
          const segmentWidth = width2 / gridX;
          const segmentHeight = height2 / gridY;
          const widthHalf = width2 / 2;
          const heightHalf = height2 / 2;
          const depthHalf = depth2 / 2;
          const gridX1 = gridX + 1;
          const gridY1 = gridY + 1;
          let vertexCounter = 0;
          let groupCount = 0;
          const vector = new Vector3();
          for (let iy = 0; iy < gridY1; iy++) {
            const y2 = iy * segmentHeight - heightHalf;
            for (let ix = 0; ix < gridX1; ix++) {
              const x = ix * segmentWidth - widthHalf;
              vector[u3] = x * udir;
              vector[v2] = y2 * vdir;
              vector[w] = depthHalf;
              vertices.push(vector.x, vector.y, vector.z);
              vector[u3] = 0;
              vector[v2] = 0;
              vector[w] = depth2 > 0 ? 1 : -1;
              normals.push(vector.x, vector.y, vector.z);
              uvs.push(ix / gridX);
              uvs.push(1 - iy / gridY);
              vertexCounter += 1;
            }
          }
          for (let iy = 0; iy < gridY; iy++) {
            for (let ix = 0; ix < gridX; ix++) {
              const a = numberOfVertices + ix + gridX1 * iy;
              const b = numberOfVertices + ix + gridX1 * (iy + 1);
              const c = numberOfVertices + (ix + 1) + gridX1 * (iy + 1);
              const d = numberOfVertices + (ix + 1) + gridX1 * iy;
              indices.push(a, b, d);
              indices.push(b, c, d);
              groupCount += 6;
            }
          }
          scope.addGroup(groupStart, groupCount, materialIndex);
          groupStart += groupCount;
          numberOfVertices += vertexCounter;
        }
      }
      copy(source) {
        super.copy(source);
        this.parameters = Object.assign({}, source.parameters);
        return this;
      }
      static fromJSON(data) {
        return new _BoxGeometry(data.width, data.height, data.depth, data.widthSegments, data.heightSegments, data.depthSegments);
      }
    };
    UniformsUtils = { clone: cloneUniforms, merge: mergeUniforms };
    default_vertex = "void main() {\n	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}";
    default_fragment = "void main() {\n	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}";
    ShaderMaterial = class extends Material {
      constructor(parameters) {
        super();
        this.isShaderMaterial = true;
        this.type = "ShaderMaterial";
        this.defines = {};
        this.uniforms = {};
        this.uniformsGroups = [];
        this.vertexShader = default_vertex;
        this.fragmentShader = default_fragment;
        this.linewidth = 1;
        this.wireframe = false;
        this.wireframeLinewidth = 1;
        this.fog = false;
        this.lights = false;
        this.clipping = false;
        this.forceSinglePass = true;
        this.extensions = {
          clipCullDistance: false,
          // set to use vertex shader clipping
          multiDraw: false
          // set to use vertex shader multi_draw / enable gl_DrawID
        };
        this.defaultAttributeValues = {
          "color": [1, 1, 1],
          "uv": [0, 0],
          "uv1": [0, 0]
        };
        this.index0AttributeName = void 0;
        this.uniformsNeedUpdate = false;
        this.glslVersion = null;
        if (parameters !== void 0) {
          this.setValues(parameters);
        }
      }
      copy(source) {
        super.copy(source);
        this.fragmentShader = source.fragmentShader;
        this.vertexShader = source.vertexShader;
        this.uniforms = cloneUniforms(source.uniforms);
        this.uniformsGroups = cloneUniformsGroups(source.uniformsGroups);
        this.defines = Object.assign({}, source.defines);
        this.wireframe = source.wireframe;
        this.wireframeLinewidth = source.wireframeLinewidth;
        this.fog = source.fog;
        this.lights = source.lights;
        this.clipping = source.clipping;
        this.extensions = Object.assign({}, source.extensions);
        this.glslVersion = source.glslVersion;
        return this;
      }
      toJSON(meta) {
        const data = super.toJSON(meta);
        data.glslVersion = this.glslVersion;
        data.uniforms = {};
        for (const name in this.uniforms) {
          const uniform = this.uniforms[name];
          const value = uniform.value;
          if (value && value.isTexture) {
            data.uniforms[name] = {
              type: "t",
              value: value.toJSON(meta).uuid
            };
          } else if (value && value.isColor) {
            data.uniforms[name] = {
              type: "c",
              value: value.getHex()
            };
          } else if (value && value.isVector2) {
            data.uniforms[name] = {
              type: "v2",
              value: value.toArray()
            };
          } else if (value && value.isVector3) {
            data.uniforms[name] = {
              type: "v3",
              value: value.toArray()
            };
          } else if (value && value.isVector4) {
            data.uniforms[name] = {
              type: "v4",
              value: value.toArray()
            };
          } else if (value && value.isMatrix3) {
            data.uniforms[name] = {
              type: "m3",
              value: value.toArray()
            };
          } else if (value && value.isMatrix4) {
            data.uniforms[name] = {
              type: "m4",
              value: value.toArray()
            };
          } else {
            data.uniforms[name] = {
              value
            };
          }
        }
        if (Object.keys(this.defines).length > 0) data.defines = this.defines;
        data.vertexShader = this.vertexShader;
        data.fragmentShader = this.fragmentShader;
        data.lights = this.lights;
        data.clipping = this.clipping;
        const extensions = {};
        for (const key in this.extensions) {
          if (this.extensions[key] === true) extensions[key] = true;
        }
        if (Object.keys(extensions).length > 0) data.extensions = extensions;
        return data;
      }
    };
    Camera = class extends Object3D {
      constructor() {
        super();
        this.isCamera = true;
        this.type = "Camera";
        this.matrixWorldInverse = new Matrix4();
        this.projectionMatrix = new Matrix4();
        this.projectionMatrixInverse = new Matrix4();
        this.coordinateSystem = WebGLCoordinateSystem;
      }
      copy(source, recursive) {
        super.copy(source, recursive);
        this.matrixWorldInverse.copy(source.matrixWorldInverse);
        this.projectionMatrix.copy(source.projectionMatrix);
        this.projectionMatrixInverse.copy(source.projectionMatrixInverse);
        this.coordinateSystem = source.coordinateSystem;
        return this;
      }
      getWorldDirection(target2) {
        return super.getWorldDirection(target2).negate();
      }
      updateMatrixWorld(force) {
        super.updateMatrixWorld(force);
        this.matrixWorldInverse.copy(this.matrixWorld).invert();
      }
      updateWorldMatrix(updateParents, updateChildren) {
        super.updateWorldMatrix(updateParents, updateChildren);
        this.matrixWorldInverse.copy(this.matrixWorld).invert();
      }
      clone() {
        return new this.constructor().copy(this);
      }
    };
    _v3$1 = /* @__PURE__ */ new Vector3();
    _minTarget = /* @__PURE__ */ new Vector2();
    _maxTarget = /* @__PURE__ */ new Vector2();
    PerspectiveCamera = class extends Camera {
      constructor(fov2 = 50, aspect2 = 1, near = 0.1, far = 2e3) {
        super();
        this.isPerspectiveCamera = true;
        this.type = "PerspectiveCamera";
        this.fov = fov2;
        this.zoom = 1;
        this.near = near;
        this.far = far;
        this.focus = 10;
        this.aspect = aspect2;
        this.view = null;
        this.filmGauge = 35;
        this.filmOffset = 0;
        this.updateProjectionMatrix();
      }
      copy(source, recursive) {
        super.copy(source, recursive);
        this.fov = source.fov;
        this.zoom = source.zoom;
        this.near = source.near;
        this.far = source.far;
        this.focus = source.focus;
        this.aspect = source.aspect;
        this.view = source.view === null ? null : Object.assign({}, source.view);
        this.filmGauge = source.filmGauge;
        this.filmOffset = source.filmOffset;
        return this;
      }
      /**
       * Sets the FOV by focal length in respect to the current .filmGauge.
       *
       * The default film gauge is 35, so that the focal length can be specified for
       * a 35mm (full frame) camera.
       *
       * Values for focal length and film gauge must have the same unit.
       */
      setFocalLength(focalLength) {
        const vExtentSlope = 0.5 * this.getFilmHeight() / focalLength;
        this.fov = RAD2DEG * 2 * Math.atan(vExtentSlope);
        this.updateProjectionMatrix();
      }
      /**
       * Calculates the focal length from the current .fov and .filmGauge.
       */
      getFocalLength() {
        const vExtentSlope = Math.tan(DEG2RAD * 0.5 * this.fov);
        return 0.5 * this.getFilmHeight() / vExtentSlope;
      }
      getEffectiveFOV() {
        return RAD2DEG * 2 * Math.atan(
          Math.tan(DEG2RAD * 0.5 * this.fov) / this.zoom
        );
      }
      getFilmWidth() {
        return this.filmGauge * Math.min(this.aspect, 1);
      }
      getFilmHeight() {
        return this.filmGauge / Math.max(this.aspect, 1);
      }
      /**
       * Computes the 2D bounds of the camera's viewable rectangle at a given distance along the viewing direction.
       * Sets minTarget and maxTarget to the coordinates of the lower-left and upper-right corners of the view rectangle.
       */
      getViewBounds(distance, minTarget, maxTarget) {
        _v3$1.set(-1, -1, 0.5).applyMatrix4(this.projectionMatrixInverse);
        minTarget.set(_v3$1.x, _v3$1.y).multiplyScalar(-distance / _v3$1.z);
        _v3$1.set(1, 1, 0.5).applyMatrix4(this.projectionMatrixInverse);
        maxTarget.set(_v3$1.x, _v3$1.y).multiplyScalar(-distance / _v3$1.z);
      }
      /**
       * Computes the width and height of the camera's viewable rectangle at a given distance along the viewing direction.
       * Copies the result into the target Vector2, where x is width and y is height.
       */
      getViewSize(distance, target2) {
        this.getViewBounds(distance, _minTarget, _maxTarget);
        return target2.subVectors(_maxTarget, _minTarget);
      }
      /**
       * Sets an offset in a larger frustum. This is useful for multi-window or
       * multi-monitor/multi-machine setups.
       *
       * For example, if you have 3x2 monitors and each monitor is 1920x1080 and
       * the monitors are in grid like this
       *
       *   +---+---+---+
       *   | A | B | C |
       *   +---+---+---+
       *   | D | E | F |
       *   +---+---+---+
       *
       * then for each monitor you would call it like this
       *
       *   const w = 1920;
       *   const h = 1080;
       *   const fullWidth = w * 3;
       *   const fullHeight = h * 2;
       *
       *   --A--
       *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );
       *   --B--
       *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );
       *   --C--
       *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );
       *   --D--
       *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );
       *   --E--
       *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );
       *   --F--
       *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );
       *
       *   Note there is no reason monitors have to be the same size or in a grid.
       */
      setViewOffset(fullWidth, fullHeight, x, y2, width, height) {
        this.aspect = fullWidth / fullHeight;
        if (this.view === null) {
          this.view = {
            enabled: true,
            fullWidth: 1,
            fullHeight: 1,
            offsetX: 0,
            offsetY: 0,
            width: 1,
            height: 1
          };
        }
        this.view.enabled = true;
        this.view.fullWidth = fullWidth;
        this.view.fullHeight = fullHeight;
        this.view.offsetX = x;
        this.view.offsetY = y2;
        this.view.width = width;
        this.view.height = height;
        this.updateProjectionMatrix();
      }
      clearViewOffset() {
        if (this.view !== null) {
          this.view.enabled = false;
        }
        this.updateProjectionMatrix();
      }
      updateProjectionMatrix() {
        const near = this.near;
        let top = near * Math.tan(DEG2RAD * 0.5 * this.fov) / this.zoom;
        let height = 2 * top;
        let width = this.aspect * height;
        let left = -0.5 * width;
        const view = this.view;
        if (this.view !== null && this.view.enabled) {
          const fullWidth = view.fullWidth, fullHeight = view.fullHeight;
          left += view.offsetX * width / fullWidth;
          top -= view.offsetY * height / fullHeight;
          width *= view.width / fullWidth;
          height *= view.height / fullHeight;
        }
        const skew = this.filmOffset;
        if (skew !== 0) left += near * skew / this.getFilmWidth();
        this.projectionMatrix.makePerspective(left, left + width, top, top - height, near, this.far, this.coordinateSystem);
        this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
      }
      toJSON(meta) {
        const data = super.toJSON(meta);
        data.object.fov = this.fov;
        data.object.zoom = this.zoom;
        data.object.near = this.near;
        data.object.far = this.far;
        data.object.focus = this.focus;
        data.object.aspect = this.aspect;
        if (this.view !== null) data.object.view = Object.assign({}, this.view);
        data.object.filmGauge = this.filmGauge;
        data.object.filmOffset = this.filmOffset;
        return data;
      }
    };
    fov = -90;
    aspect = 1;
    CubeCamera = class extends Object3D {
      constructor(near, far, renderTarget) {
        super();
        this.type = "CubeCamera";
        this.renderTarget = renderTarget;
        this.coordinateSystem = null;
        this.activeMipmapLevel = 0;
        const cameraPX = new PerspectiveCamera(fov, aspect, near, far);
        cameraPX.layers = this.layers;
        this.add(cameraPX);
        const cameraNX = new PerspectiveCamera(fov, aspect, near, far);
        cameraNX.layers = this.layers;
        this.add(cameraNX);
        const cameraPY = new PerspectiveCamera(fov, aspect, near, far);
        cameraPY.layers = this.layers;
        this.add(cameraPY);
        const cameraNY = new PerspectiveCamera(fov, aspect, near, far);
        cameraNY.layers = this.layers;
        this.add(cameraNY);
        const cameraPZ = new PerspectiveCamera(fov, aspect, near, far);
        cameraPZ.layers = this.layers;
        this.add(cameraPZ);
        const cameraNZ = new PerspectiveCamera(fov, aspect, near, far);
        cameraNZ.layers = this.layers;
        this.add(cameraNZ);
      }
      updateCoordinateSystem() {
        const coordinateSystem = this.coordinateSystem;
        const cameras = this.children.concat();
        const [cameraPX, cameraNX, cameraPY, cameraNY, cameraPZ, cameraNZ] = cameras;
        for (const camera of cameras) this.remove(camera);
        if (coordinateSystem === WebGLCoordinateSystem) {
          cameraPX.up.set(0, 1, 0);
          cameraPX.lookAt(1, 0, 0);
          cameraNX.up.set(0, 1, 0);
          cameraNX.lookAt(-1, 0, 0);
          cameraPY.up.set(0, 0, -1);
          cameraPY.lookAt(0, 1, 0);
          cameraNY.up.set(0, 0, 1);
          cameraNY.lookAt(0, -1, 0);
          cameraPZ.up.set(0, 1, 0);
          cameraPZ.lookAt(0, 0, 1);
          cameraNZ.up.set(0, 1, 0);
          cameraNZ.lookAt(0, 0, -1);
        } else if (coordinateSystem === WebGPUCoordinateSystem) {
          cameraPX.up.set(0, -1, 0);
          cameraPX.lookAt(-1, 0, 0);
          cameraNX.up.set(0, -1, 0);
          cameraNX.lookAt(1, 0, 0);
          cameraPY.up.set(0, 0, 1);
          cameraPY.lookAt(0, 1, 0);
          cameraNY.up.set(0, 0, -1);
          cameraNY.lookAt(0, -1, 0);
          cameraPZ.up.set(0, -1, 0);
          cameraPZ.lookAt(0, 0, 1);
          cameraNZ.up.set(0, -1, 0);
          cameraNZ.lookAt(0, 0, -1);
        } else {
          throw new Error("THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: " + coordinateSystem);
        }
        for (const camera of cameras) {
          this.add(camera);
          camera.updateMatrixWorld();
        }
      }
      update(renderer, scene) {
        if (this.parent === null) this.updateMatrixWorld();
        const { renderTarget, activeMipmapLevel } = this;
        if (this.coordinateSystem !== renderer.coordinateSystem) {
          this.coordinateSystem = renderer.coordinateSystem;
          this.updateCoordinateSystem();
        }
        const [cameraPX, cameraNX, cameraPY, cameraNY, cameraPZ, cameraNZ] = this.children;
        const currentRenderTarget = renderer.getRenderTarget();
        const currentActiveCubeFace = renderer.getActiveCubeFace();
        const currentActiveMipmapLevel = renderer.getActiveMipmapLevel();
        const currentXrEnabled = renderer.xr.enabled;
        renderer.xr.enabled = false;
        const generateMipmaps = renderTarget.texture.generateMipmaps;
        renderTarget.texture.generateMipmaps = false;
        renderer.setRenderTarget(renderTarget, 0, activeMipmapLevel);
        renderer.render(scene, cameraPX);
        renderer.setRenderTarget(renderTarget, 1, activeMipmapLevel);
        renderer.render(scene, cameraNX);
        renderer.setRenderTarget(renderTarget, 2, activeMipmapLevel);
        renderer.render(scene, cameraPY);
        renderer.setRenderTarget(renderTarget, 3, activeMipmapLevel);
        renderer.render(scene, cameraNY);
        renderer.setRenderTarget(renderTarget, 4, activeMipmapLevel);
        renderer.render(scene, cameraPZ);
        renderTarget.texture.generateMipmaps = generateMipmaps;
        renderer.setRenderTarget(renderTarget, 5, activeMipmapLevel);
        renderer.render(scene, cameraNZ);
        renderer.setRenderTarget(currentRenderTarget, currentActiveCubeFace, currentActiveMipmapLevel);
        renderer.xr.enabled = currentXrEnabled;
        renderTarget.texture.needsPMREMUpdate = true;
      }
    };
    CubeTexture = class extends Texture {
      constructor(images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, colorSpace) {
        images = images !== void 0 ? images : [];
        mapping = mapping !== void 0 ? mapping : CubeReflectionMapping;
        super(images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, colorSpace);
        this.isCubeTexture = true;
        this.flipY = false;
      }
      get images() {
        return this.image;
      }
      set images(value) {
        this.image = value;
      }
    };
    WebGLCubeRenderTarget = class extends WebGLRenderTarget {
      constructor(size = 1, options = {}) {
        super(size, size, options);
        this.isWebGLCubeRenderTarget = true;
        const image = { width: size, height: size, depth: 1 };
        const images = [image, image, image, image, image, image];
        this.texture = new CubeTexture(images, options.mapping, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.colorSpace);
        this.texture.isRenderTargetTexture = true;
        this.texture.generateMipmaps = options.generateMipmaps !== void 0 ? options.generateMipmaps : false;
        this.texture.minFilter = options.minFilter !== void 0 ? options.minFilter : LinearFilter;
      }
      fromEquirectangularTexture(renderer, texture) {
        this.texture.type = texture.type;
        this.texture.colorSpace = texture.colorSpace;
        this.texture.generateMipmaps = texture.generateMipmaps;
        this.texture.minFilter = texture.minFilter;
        this.texture.magFilter = texture.magFilter;
        const shader = {
          uniforms: {
            tEquirect: { value: null }
          },
          vertexShader: (
            /* glsl */
            `

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`
          ),
          fragmentShader: (
            /* glsl */
            `

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`
          )
        };
        const geometry = new BoxGeometry(5, 5, 5);
        const material = new ShaderMaterial({
          name: "CubemapFromEquirect",
          uniforms: cloneUniforms(shader.uniforms),
          vertexShader: shader.vertexShader,
          fragmentShader: shader.fragmentShader,
          side: BackSide,
          blending: NoBlending
        });
        material.uniforms.tEquirect.value = texture;
        const mesh = new Mesh(geometry, material);
        const currentMinFilter = texture.minFilter;
        if (texture.minFilter === LinearMipmapLinearFilter) texture.minFilter = LinearFilter;
        const camera = new CubeCamera(1, 10, this);
        camera.update(renderer, mesh);
        texture.minFilter = currentMinFilter;
        mesh.geometry.dispose();
        mesh.material.dispose();
        return this;
      }
      clear(renderer, color, depth, stencil) {
        const currentRenderTarget = renderer.getRenderTarget();
        for (let i2 = 0; i2 < 6; i2++) {
          renderer.setRenderTarget(this, i2);
          renderer.clear(color, depth, stencil);
        }
        renderer.setRenderTarget(currentRenderTarget);
      }
    };
    _vector1 = /* @__PURE__ */ new Vector3();
    _vector2 = /* @__PURE__ */ new Vector3();
    _normalMatrix = /* @__PURE__ */ new Matrix3();
    Plane = class {
      constructor(normal = new Vector3(1, 0, 0), constant = 0) {
        this.isPlane = true;
        this.normal = normal;
        this.constant = constant;
      }
      set(normal, constant) {
        this.normal.copy(normal);
        this.constant = constant;
        return this;
      }
      setComponents(x, y2, z2, w) {
        this.normal.set(x, y2, z2);
        this.constant = w;
        return this;
      }
      setFromNormalAndCoplanarPoint(normal, point) {
        this.normal.copy(normal);
        this.constant = -point.dot(this.normal);
        return this;
      }
      setFromCoplanarPoints(a, b, c) {
        const normal = _vector1.subVectors(c, b).cross(_vector2.subVectors(a, b)).normalize();
        this.setFromNormalAndCoplanarPoint(normal, a);
        return this;
      }
      copy(plane) {
        this.normal.copy(plane.normal);
        this.constant = plane.constant;
        return this;
      }
      normalize() {
        const inverseNormalLength = 1 / this.normal.length();
        this.normal.multiplyScalar(inverseNormalLength);
        this.constant *= inverseNormalLength;
        return this;
      }
      negate() {
        this.constant *= -1;
        this.normal.negate();
        return this;
      }
      distanceToPoint(point) {
        return this.normal.dot(point) + this.constant;
      }
      distanceToSphere(sphere) {
        return this.distanceToPoint(sphere.center) - sphere.radius;
      }
      projectPoint(point, target2) {
        return target2.copy(point).addScaledVector(this.normal, -this.distanceToPoint(point));
      }
      intersectLine(line, target2) {
        const direction = line.delta(_vector1);
        const denominator = this.normal.dot(direction);
        if (denominator === 0) {
          if (this.distanceToPoint(line.start) === 0) {
            return target2.copy(line.start);
          }
          return null;
        }
        const t2 = -(line.start.dot(this.normal) + this.constant) / denominator;
        if (t2 < 0 || t2 > 1) {
          return null;
        }
        return target2.copy(line.start).addScaledVector(direction, t2);
      }
      intersectsLine(line) {
        const startSign = this.distanceToPoint(line.start);
        const endSign = this.distanceToPoint(line.end);
        return startSign < 0 && endSign > 0 || endSign < 0 && startSign > 0;
      }
      intersectsBox(box) {
        return box.intersectsPlane(this);
      }
      intersectsSphere(sphere) {
        return sphere.intersectsPlane(this);
      }
      coplanarPoint(target2) {
        return target2.copy(this.normal).multiplyScalar(-this.constant);
      }
      applyMatrix4(matrix2, optionalNormalMatrix) {
        const normalMatrix = optionalNormalMatrix || _normalMatrix.getNormalMatrix(matrix2);
        const referencePoint = this.coplanarPoint(_vector1).applyMatrix4(matrix2);
        const normal = this.normal.applyMatrix3(normalMatrix).normalize();
        this.constant = -referencePoint.dot(normal);
        return this;
      }
      translate(offset) {
        this.constant -= offset.dot(this.normal);
        return this;
      }
      equals(plane) {
        return plane.normal.equals(this.normal) && plane.constant === this.constant;
      }
      clone() {
        return new this.constructor().copy(this);
      }
    };
    _sphere$5 = /* @__PURE__ */ new Sphere();
    _vector$7 = /* @__PURE__ */ new Vector3();
    Frustum = class {
      constructor(p0 = new Plane(), p1 = new Plane(), p22 = new Plane(), p3 = new Plane(), p4 = new Plane(), p5 = new Plane()) {
        this.planes = [p0, p1, p22, p3, p4, p5];
      }
      set(p0, p1, p22, p3, p4, p5) {
        const planes = this.planes;
        planes[0].copy(p0);
        planes[1].copy(p1);
        planes[2].copy(p22);
        planes[3].copy(p3);
        planes[4].copy(p4);
        planes[5].copy(p5);
        return this;
      }
      copy(frustum) {
        const planes = this.planes;
        for (let i2 = 0; i2 < 6; i2++) {
          planes[i2].copy(frustum.planes[i2]);
        }
        return this;
      }
      setFromProjectionMatrix(m, coordinateSystem = WebGLCoordinateSystem) {
        const planes = this.planes;
        const me = m.elements;
        const me0 = me[0], me1 = me[1], me2 = me[2], me3 = me[3];
        const me4 = me[4], me5 = me[5], me6 = me[6], me7 = me[7];
        const me8 = me[8], me9 = me[9], me10 = me[10], me11 = me[11];
        const me12 = me[12], me13 = me[13], me14 = me[14], me15 = me[15];
        planes[0].setComponents(me3 - me0, me7 - me4, me11 - me8, me15 - me12).normalize();
        planes[1].setComponents(me3 + me0, me7 + me4, me11 + me8, me15 + me12).normalize();
        planes[2].setComponents(me3 + me1, me7 + me5, me11 + me9, me15 + me13).normalize();
        planes[3].setComponents(me3 - me1, me7 - me5, me11 - me9, me15 - me13).normalize();
        planes[4].setComponents(me3 - me2, me7 - me6, me11 - me10, me15 - me14).normalize();
        if (coordinateSystem === WebGLCoordinateSystem) {
          planes[5].setComponents(me3 + me2, me7 + me6, me11 + me10, me15 + me14).normalize();
        } else if (coordinateSystem === WebGPUCoordinateSystem) {
          planes[5].setComponents(me2, me6, me10, me14).normalize();
        } else {
          throw new Error("THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: " + coordinateSystem);
        }
        return this;
      }
      intersectsObject(object) {
        if (object.boundingSphere !== void 0) {
          if (object.boundingSphere === null) object.computeBoundingSphere();
          _sphere$5.copy(object.boundingSphere).applyMatrix4(object.matrixWorld);
        } else {
          const geometry = object.geometry;
          if (geometry.boundingSphere === null) geometry.computeBoundingSphere();
          _sphere$5.copy(geometry.boundingSphere).applyMatrix4(object.matrixWorld);
        }
        return this.intersectsSphere(_sphere$5);
      }
      intersectsSprite(sprite) {
        _sphere$5.center.set(0, 0, 0);
        _sphere$5.radius = 0.7071067811865476;
        _sphere$5.applyMatrix4(sprite.matrixWorld);
        return this.intersectsSphere(_sphere$5);
      }
      intersectsSphere(sphere) {
        const planes = this.planes;
        const center = sphere.center;
        const negRadius = -sphere.radius;
        for (let i2 = 0; i2 < 6; i2++) {
          const distance = planes[i2].distanceToPoint(center);
          if (distance < negRadius) {
            return false;
          }
        }
        return true;
      }
      intersectsBox(box) {
        const planes = this.planes;
        for (let i2 = 0; i2 < 6; i2++) {
          const plane = planes[i2];
          _vector$7.x = plane.normal.x > 0 ? box.max.x : box.min.x;
          _vector$7.y = plane.normal.y > 0 ? box.max.y : box.min.y;
          _vector$7.z = plane.normal.z > 0 ? box.max.z : box.min.z;
          if (plane.distanceToPoint(_vector$7) < 0) {
            return false;
          }
        }
        return true;
      }
      containsPoint(point) {
        const planes = this.planes;
        for (let i2 = 0; i2 < 6; i2++) {
          if (planes[i2].distanceToPoint(point) < 0) {
            return false;
          }
        }
        return true;
      }
      clone() {
        return new this.constructor().copy(this);
      }
    };
    PlaneGeometry = class _PlaneGeometry extends BufferGeometry {
      constructor(width = 1, height = 1, widthSegments = 1, heightSegments = 1) {
        super();
        this.type = "PlaneGeometry";
        this.parameters = {
          width,
          height,
          widthSegments,
          heightSegments
        };
        const width_half = width / 2;
        const height_half = height / 2;
        const gridX = Math.floor(widthSegments);
        const gridY = Math.floor(heightSegments);
        const gridX1 = gridX + 1;
        const gridY1 = gridY + 1;
        const segment_width = width / gridX;
        const segment_height = height / gridY;
        const indices = [];
        const vertices = [];
        const normals = [];
        const uvs = [];
        for (let iy = 0; iy < gridY1; iy++) {
          const y2 = iy * segment_height - height_half;
          for (let ix = 0; ix < gridX1; ix++) {
            const x = ix * segment_width - width_half;
            vertices.push(x, -y2, 0);
            normals.push(0, 0, 1);
            uvs.push(ix / gridX);
            uvs.push(1 - iy / gridY);
          }
        }
        for (let iy = 0; iy < gridY; iy++) {
          for (let ix = 0; ix < gridX; ix++) {
            const a = ix + gridX1 * iy;
            const b = ix + gridX1 * (iy + 1);
            const c = ix + 1 + gridX1 * (iy + 1);
            const d = ix + 1 + gridX1 * iy;
            indices.push(a, b, d);
            indices.push(b, c, d);
          }
        }
        this.setIndex(indices);
        this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
        this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
        this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
      }
      copy(source) {
        super.copy(source);
        this.parameters = Object.assign({}, source.parameters);
        return this;
      }
      static fromJSON(data) {
        return new _PlaneGeometry(data.width, data.height, data.widthSegments, data.heightSegments);
      }
    };
    alphahash_fragment = "#ifdef USE_ALPHAHASH\n	if ( diffuseColor.a < getAlphaHashThreshold( vPosition ) ) discard;\n#endif";
    alphahash_pars_fragment = "#ifdef USE_ALPHAHASH\n	const float ALPHA_HASH_SCALE = 0.05;\n	float hash2D( vec2 value ) {\n		return fract( 1.0e4 * sin( 17.0 * value.x + 0.1 * value.y ) * ( 0.1 + abs( sin( 13.0 * value.y + value.x ) ) ) );\n	}\n	float hash3D( vec3 value ) {\n		return hash2D( vec2( hash2D( value.xy ), value.z ) );\n	}\n	float getAlphaHashThreshold( vec3 position ) {\n		float maxDeriv = max(\n			length( dFdx( position.xyz ) ),\n			length( dFdy( position.xyz ) )\n		);\n		float pixScale = 1.0 / ( ALPHA_HASH_SCALE * maxDeriv );\n		vec2 pixScales = vec2(\n			exp2( floor( log2( pixScale ) ) ),\n			exp2( ceil( log2( pixScale ) ) )\n		);\n		vec2 alpha = vec2(\n			hash3D( floor( pixScales.x * position.xyz ) ),\n			hash3D( floor( pixScales.y * position.xyz ) )\n		);\n		float lerpFactor = fract( log2( pixScale ) );\n		float x = ( 1.0 - lerpFactor ) * alpha.x + lerpFactor * alpha.y;\n		float a = min( lerpFactor, 1.0 - lerpFactor );\n		vec3 cases = vec3(\n			x * x / ( 2.0 * a * ( 1.0 - a ) ),\n			( x - 0.5 * a ) / ( 1.0 - a ),\n			1.0 - ( ( 1.0 - x ) * ( 1.0 - x ) / ( 2.0 * a * ( 1.0 - a ) ) )\n		);\n		float threshold = ( x < ( 1.0 - a ) )\n			? ( ( x < a ) ? cases.x : cases.y )\n			: cases.z;\n		return clamp( threshold , 1.0e-6, 1.0 );\n	}\n#endif";
    alphamap_fragment = "#ifdef USE_ALPHAMAP\n	diffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;\n#endif";
    alphamap_pars_fragment = "#ifdef USE_ALPHAMAP\n	uniform sampler2D alphaMap;\n#endif";
    alphatest_fragment = "#ifdef USE_ALPHATEST\n	#ifdef ALPHA_TO_COVERAGE\n	diffuseColor.a = smoothstep( alphaTest, alphaTest + fwidth( diffuseColor.a ), diffuseColor.a );\n	if ( diffuseColor.a == 0.0 ) discard;\n	#else\n	if ( diffuseColor.a < alphaTest ) discard;\n	#endif\n#endif";
    alphatest_pars_fragment = "#ifdef USE_ALPHATEST\n	uniform float alphaTest;\n#endif";
    aomap_fragment = "#ifdef USE_AOMAP\n	float ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;\n	reflectedLight.indirectDiffuse *= ambientOcclusion;\n	#if defined( USE_CLEARCOAT ) \n		clearcoatSpecularIndirect *= ambientOcclusion;\n	#endif\n	#if defined( USE_SHEEN ) \n		sheenSpecularIndirect *= ambientOcclusion;\n	#endif\n	#if defined( USE_ENVMAP ) && defined( STANDARD )\n		float dotNV = saturate( dot( geometryNormal, geometryViewDir ) );\n		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );\n	#endif\n#endif";
    aomap_pars_fragment = "#ifdef USE_AOMAP\n	uniform sampler2D aoMap;\n	uniform float aoMapIntensity;\n#endif";
    batching_pars_vertex = "#ifdef USE_BATCHING\n	#if ! defined( GL_ANGLE_multi_draw )\n	#define gl_DrawID _gl_DrawID\n	uniform int _gl_DrawID;\n	#endif\n	uniform highp sampler2D batchingTexture;\n	uniform highp usampler2D batchingIdTexture;\n	mat4 getBatchingMatrix( const in float i ) {\n		int size = textureSize( batchingTexture, 0 ).x;\n		int j = int( i ) * 4;\n		int x = j % size;\n		int y = j / size;\n		vec4 v1 = texelFetch( batchingTexture, ivec2( x, y ), 0 );\n		vec4 v2 = texelFetch( batchingTexture, ivec2( x + 1, y ), 0 );\n		vec4 v3 = texelFetch( batchingTexture, ivec2( x + 2, y ), 0 );\n		vec4 v4 = texelFetch( batchingTexture, ivec2( x + 3, y ), 0 );\n		return mat4( v1, v2, v3, v4 );\n	}\n	float getIndirectIndex( const in int i ) {\n		int size = textureSize( batchingIdTexture, 0 ).x;\n		int x = i % size;\n		int y = i / size;\n		return float( texelFetch( batchingIdTexture, ivec2( x, y ), 0 ).r );\n	}\n#endif\n#ifdef USE_BATCHING_COLOR\n	uniform sampler2D batchingColorTexture;\n	vec3 getBatchingColor( const in float i ) {\n		int size = textureSize( batchingColorTexture, 0 ).x;\n		int j = int( i );\n		int x = j % size;\n		int y = j / size;\n		return texelFetch( batchingColorTexture, ivec2( x, y ), 0 ).rgb;\n	}\n#endif";
    batching_vertex = "#ifdef USE_BATCHING\n	mat4 batchingMatrix = getBatchingMatrix( getIndirectIndex( gl_DrawID ) );\n#endif";
    begin_vertex = "vec3 transformed = vec3( position );\n#ifdef USE_ALPHAHASH\n	vPosition = vec3( position );\n#endif";
    beginnormal_vertex = "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n	vec3 objectTangent = vec3( tangent.xyz );\n#endif";
    bsdfs = "float G_BlinnPhong_Implicit( ) {\n	return 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {\n	vec3 halfDir = normalize( lightDir + viewDir );\n	float dotNH = saturate( dot( normal, halfDir ) );\n	float dotVH = saturate( dot( viewDir, halfDir ) );\n	vec3 F = F_Schlick( specularColor, 1.0, dotVH );\n	float G = G_BlinnPhong_Implicit( );\n	float D = D_BlinnPhong( shininess, dotNH );\n	return F * ( G * D );\n} // validated";
    iridescence_fragment = "#ifdef USE_IRIDESCENCE\n	const mat3 XYZ_TO_REC709 = mat3(\n		 3.2404542, -0.9692660,  0.0556434,\n		-1.5371385,  1.8760108, -0.2040259,\n		-0.4985314,  0.0415560,  1.0572252\n	);\n	vec3 Fresnel0ToIor( vec3 fresnel0 ) {\n		vec3 sqrtF0 = sqrt( fresnel0 );\n		return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );\n	}\n	vec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {\n		return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );\n	}\n	float IorToFresnel0( float transmittedIor, float incidentIor ) {\n		return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));\n	}\n	vec3 evalSensitivity( float OPD, vec3 shift ) {\n		float phase = 2.0 * PI * OPD * 1.0e-9;\n		vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );\n		vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );\n		vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );\n		vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );\n		xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );\n		xyz /= 1.0685e-7;\n		vec3 rgb = XYZ_TO_REC709 * xyz;\n		return rgb;\n	}\n	vec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {\n		vec3 I;\n		float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );\n		float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );\n		float cosTheta2Sq = 1.0 - sinTheta2Sq;\n		if ( cosTheta2Sq < 0.0 ) {\n			return vec3( 1.0 );\n		}\n		float cosTheta2 = sqrt( cosTheta2Sq );\n		float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );\n		float R12 = F_Schlick( R0, 1.0, cosTheta1 );\n		float T121 = 1.0 - R12;\n		float phi12 = 0.0;\n		if ( iridescenceIOR < outsideIOR ) phi12 = PI;\n		float phi21 = PI - phi12;\n		vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );		vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );\n		vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );\n		vec3 phi23 = vec3( 0.0 );\n		if ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;\n		if ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;\n		if ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;\n		float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;\n		vec3 phi = vec3( phi21 ) + phi23;\n		vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );\n		vec3 r123 = sqrt( R123 );\n		vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );\n		vec3 C0 = R12 + Rs;\n		I = C0;\n		vec3 Cm = Rs - T121;\n		for ( int m = 1; m <= 2; ++ m ) {\n			Cm *= r123;\n			vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );\n			I += Cm * Sm;\n		}\n		return max( I, vec3( 0.0 ) );\n	}\n#endif";
    bumpmap_pars_fragment = "#ifdef USE_BUMPMAP\n	uniform sampler2D bumpMap;\n	uniform float bumpScale;\n	vec2 dHdxy_fwd() {\n		vec2 dSTdx = dFdx( vBumpMapUv );\n		vec2 dSTdy = dFdy( vBumpMapUv );\n		float Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;\n		float dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;\n		float dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;\n		return vec2( dBx, dBy );\n	}\n	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n		vec3 vSigmaX = normalize( dFdx( surf_pos.xyz ) );\n		vec3 vSigmaY = normalize( dFdy( surf_pos.xyz ) );\n		vec3 vN = surf_norm;\n		vec3 R1 = cross( vSigmaY, vN );\n		vec3 R2 = cross( vN, vSigmaX );\n		float fDet = dot( vSigmaX, R1 ) * faceDirection;\n		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n		return normalize( abs( fDet ) * surf_norm - vGrad );\n	}\n#endif";
    clipping_planes_fragment = "#if NUM_CLIPPING_PLANES > 0\n	vec4 plane;\n	#ifdef ALPHA_TO_COVERAGE\n		float distanceToPlane, distanceGradient;\n		float clipOpacity = 1.0;\n		#pragma unroll_loop_start\n		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n			plane = clippingPlanes[ i ];\n			distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;\n			distanceGradient = fwidth( distanceToPlane ) / 2.0;\n			clipOpacity *= smoothstep( - distanceGradient, distanceGradient, distanceToPlane );\n			if ( clipOpacity == 0.0 ) discard;\n		}\n		#pragma unroll_loop_end\n		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n			float unionClipOpacity = 1.0;\n			#pragma unroll_loop_start\n			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n				plane = clippingPlanes[ i ];\n				distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;\n				distanceGradient = fwidth( distanceToPlane ) / 2.0;\n				unionClipOpacity *= 1.0 - smoothstep( - distanceGradient, distanceGradient, distanceToPlane );\n			}\n			#pragma unroll_loop_end\n			clipOpacity *= 1.0 - unionClipOpacity;\n		#endif\n		diffuseColor.a *= clipOpacity;\n		if ( diffuseColor.a == 0.0 ) discard;\n	#else\n		#pragma unroll_loop_start\n		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n			plane = clippingPlanes[ i ];\n			if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n		}\n		#pragma unroll_loop_end\n		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n			bool clipped = true;\n			#pragma unroll_loop_start\n			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n				plane = clippingPlanes[ i ];\n				clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n			}\n			#pragma unroll_loop_end\n			if ( clipped ) discard;\n		#endif\n	#endif\n#endif";
    clipping_planes_pars_fragment = "#if NUM_CLIPPING_PLANES > 0\n	varying vec3 vClipPosition;\n	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif";
    clipping_planes_pars_vertex = "#if NUM_CLIPPING_PLANES > 0\n	varying vec3 vClipPosition;\n#endif";
    clipping_planes_vertex = "#if NUM_CLIPPING_PLANES > 0\n	vClipPosition = - mvPosition.xyz;\n#endif";
    color_fragment = "#if defined( USE_COLOR_ALPHA )\n	diffuseColor *= vColor;\n#elif defined( USE_COLOR )\n	diffuseColor.rgb *= vColor;\n#endif";
    color_pars_fragment = "#if defined( USE_COLOR_ALPHA )\n	varying vec4 vColor;\n#elif defined( USE_COLOR )\n	varying vec3 vColor;\n#endif";
    color_pars_vertex = "#if defined( USE_COLOR_ALPHA )\n	varying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )\n	varying vec3 vColor;\n#endif";
    color_vertex = "#if defined( USE_COLOR_ALPHA )\n	vColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )\n	vColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n	vColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n	vColor.xyz *= instanceColor.xyz;\n#endif\n#ifdef USE_BATCHING_COLOR\n	vec3 batchingColor = getBatchingColor( getIndirectIndex( gl_DrawID ) );\n	vColor.xyz *= batchingColor.xyz;\n#endif";
    common = "#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nvec3 pow2( const in vec3 x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }\nhighp float rand( const in vec2 uv ) {\n	const highp float a = 12.9898, b = 78.233, c = 43758.5453;\n	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n	return fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n	float precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n	float precisionSafeLength( vec3 v ) {\n		float maxComponent = max3( abs( v ) );\n		return length( v / maxComponent ) * maxComponent;\n	}\n#endif\nstruct IncidentLight {\n	vec3 color;\n	vec3 direction;\n	bool visible;\n};\nstruct ReflectedLight {\n	vec3 directDiffuse;\n	vec3 directSpecular;\n	vec3 indirectDiffuse;\n	vec3 indirectSpecular;\n};\n#ifdef USE_ALPHAHASH\n	varying vec3 vPosition;\n#endif\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n	mat3 tmp;\n	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n	return tmp;\n}\nbool isPerspectiveMatrix( mat4 m ) {\n	return m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n	return vec2( u, v );\n}\nvec3 BRDF_Lambert( const in vec3 diffuseColor ) {\n	return RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {\n	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nfloat F_Schlick( const in float f0, const in float f90, const in float dotVH ) {\n	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n} // validated";
    cube_uv_reflection_fragment = "#ifdef ENVMAP_TYPE_CUBE_UV\n	#define cubeUV_minMipLevel 4.0\n	#define cubeUV_minTileSize 16.0\n	float getFace( vec3 direction ) {\n		vec3 absDirection = abs( direction );\n		float face = - 1.0;\n		if ( absDirection.x > absDirection.z ) {\n			if ( absDirection.x > absDirection.y )\n				face = direction.x > 0.0 ? 0.0 : 3.0;\n			else\n				face = direction.y > 0.0 ? 1.0 : 4.0;\n		} else {\n			if ( absDirection.z > absDirection.y )\n				face = direction.z > 0.0 ? 2.0 : 5.0;\n			else\n				face = direction.y > 0.0 ? 1.0 : 4.0;\n		}\n		return face;\n	}\n	vec2 getUV( vec3 direction, float face ) {\n		vec2 uv;\n		if ( face == 0.0 ) {\n			uv = vec2( direction.z, direction.y ) / abs( direction.x );\n		} else if ( face == 1.0 ) {\n			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n		} else if ( face == 2.0 ) {\n			uv = vec2( - direction.x, direction.y ) / abs( direction.z );\n		} else if ( face == 3.0 ) {\n			uv = vec2( - direction.z, direction.y ) / abs( direction.x );\n		} else if ( face == 4.0 ) {\n			uv = vec2( - direction.x, direction.z ) / abs( direction.y );\n		} else {\n			uv = vec2( direction.x, direction.y ) / abs( direction.z );\n		}\n		return 0.5 * ( uv + 1.0 );\n	}\n	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n		float face = getFace( direction );\n		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n		mipInt = max( mipInt, cubeUV_minMipLevel );\n		float faceSize = exp2( mipInt );\n		highp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;\n		if ( face > 2.0 ) {\n			uv.y += faceSize;\n			face -= 3.0;\n		}\n		uv.x += face * faceSize;\n		uv.x += filterInt * 3.0 * cubeUV_minTileSize;\n		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );\n		uv.x *= CUBEUV_TEXEL_WIDTH;\n		uv.y *= CUBEUV_TEXEL_HEIGHT;\n		#ifdef texture2DGradEXT\n			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;\n		#else\n			return texture2D( envMap, uv ).rgb;\n		#endif\n	}\n	#define cubeUV_r0 1.0\n	#define cubeUV_m0 - 2.0\n	#define cubeUV_r1 0.8\n	#define cubeUV_m1 - 1.0\n	#define cubeUV_r4 0.4\n	#define cubeUV_m4 2.0\n	#define cubeUV_r5 0.305\n	#define cubeUV_m5 3.0\n	#define cubeUV_r6 0.21\n	#define cubeUV_m6 4.0\n	float roughnessToMip( float roughness ) {\n		float mip = 0.0;\n		if ( roughness >= cubeUV_r1 ) {\n			mip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;\n		} else if ( roughness >= cubeUV_r4 ) {\n			mip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;\n		} else if ( roughness >= cubeUV_r5 ) {\n			mip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;\n		} else if ( roughness >= cubeUV_r6 ) {\n			mip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;\n		} else {\n			mip = - 2.0 * log2( 1.16 * roughness );		}\n		return mip;\n	}\n	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n		float mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );\n		float mipF = fract( mip );\n		float mipInt = floor( mip );\n		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n		if ( mipF == 0.0 ) {\n			return vec4( color0, 1.0 );\n		} else {\n			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n			return vec4( mix( color0, color1, mipF ), 1.0 );\n		}\n	}\n#endif";
    defaultnormal_vertex = "vec3 transformedNormal = objectNormal;\n#ifdef USE_TANGENT\n	vec3 transformedTangent = objectTangent;\n#endif\n#ifdef USE_BATCHING\n	mat3 bm = mat3( batchingMatrix );\n	transformedNormal /= vec3( dot( bm[ 0 ], bm[ 0 ] ), dot( bm[ 1 ], bm[ 1 ] ), dot( bm[ 2 ], bm[ 2 ] ) );\n	transformedNormal = bm * transformedNormal;\n	#ifdef USE_TANGENT\n		transformedTangent = bm * transformedTangent;\n	#endif\n#endif\n#ifdef USE_INSTANCING\n	mat3 im = mat3( instanceMatrix );\n	transformedNormal /= vec3( dot( im[ 0 ], im[ 0 ] ), dot( im[ 1 ], im[ 1 ] ), dot( im[ 2 ], im[ 2 ] ) );\n	transformedNormal = im * transformedNormal;\n	#ifdef USE_TANGENT\n		transformedTangent = im * transformedTangent;\n	#endif\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n	transformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n	transformedTangent = ( modelViewMatrix * vec4( transformedTangent, 0.0 ) ).xyz;\n	#ifdef FLIP_SIDED\n		transformedTangent = - transformedTangent;\n	#endif\n#endif";
    displacementmap_pars_vertex = "#ifdef USE_DISPLACEMENTMAP\n	uniform sampler2D displacementMap;\n	uniform float displacementScale;\n	uniform float displacementBias;\n#endif";
    displacementmap_vertex = "#ifdef USE_DISPLACEMENTMAP\n	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );\n#endif";
    emissivemap_fragment = "#ifdef USE_EMISSIVEMAP\n	vec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );\n	totalEmissiveRadiance *= emissiveColor.rgb;\n#endif";
    emissivemap_pars_fragment = "#ifdef USE_EMISSIVEMAP\n	uniform sampler2D emissiveMap;\n#endif";
    colorspace_fragment = "gl_FragColor = linearToOutputTexel( gl_FragColor );";
    colorspace_pars_fragment = "\nconst mat3 LINEAR_SRGB_TO_LINEAR_DISPLAY_P3 = mat3(\n	vec3( 0.8224621, 0.177538, 0.0 ),\n	vec3( 0.0331941, 0.9668058, 0.0 ),\n	vec3( 0.0170827, 0.0723974, 0.9105199 )\n);\nconst mat3 LINEAR_DISPLAY_P3_TO_LINEAR_SRGB = mat3(\n	vec3( 1.2249401, - 0.2249404, 0.0 ),\n	vec3( - 0.0420569, 1.0420571, 0.0 ),\n	vec3( - 0.0196376, - 0.0786361, 1.0982735 )\n);\nvec4 LinearSRGBToLinearDisplayP3( in vec4 value ) {\n	return vec4( value.rgb * LINEAR_SRGB_TO_LINEAR_DISPLAY_P3, value.a );\n}\nvec4 LinearDisplayP3ToLinearSRGB( in vec4 value ) {\n	return vec4( value.rgb * LINEAR_DISPLAY_P3_TO_LINEAR_SRGB, value.a );\n}\nvec4 LinearTransferOETF( in vec4 value ) {\n	return value;\n}\nvec4 sRGBTransferOETF( in vec4 value ) {\n	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}";
    envmap_fragment = "#ifdef USE_ENVMAP\n	#ifdef ENV_WORLDPOS\n		vec3 cameraToFrag;\n		if ( isOrthographic ) {\n			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n		} else {\n			cameraToFrag = normalize( vWorldPosition - cameraPosition );\n		}\n		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n		#ifdef ENVMAP_MODE_REFLECTION\n			vec3 reflectVec = reflect( cameraToFrag, worldNormal );\n		#else\n			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n		#endif\n	#else\n		vec3 reflectVec = vReflect;\n	#endif\n	#ifdef ENVMAP_TYPE_CUBE\n		vec4 envColor = textureCube( envMap, envMapRotation * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n	#else\n		vec4 envColor = vec4( 0.0 );\n	#endif\n	#ifdef ENVMAP_BLENDING_MULTIPLY\n		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n	#elif defined( ENVMAP_BLENDING_MIX )\n		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n	#elif defined( ENVMAP_BLENDING_ADD )\n		outgoingLight += envColor.xyz * specularStrength * reflectivity;\n	#endif\n#endif";
    envmap_common_pars_fragment = "#ifdef USE_ENVMAP\n	uniform float envMapIntensity;\n	uniform float flipEnvMap;\n	uniform mat3 envMapRotation;\n	#ifdef ENVMAP_TYPE_CUBE\n		uniform samplerCube envMap;\n	#else\n		uniform sampler2D envMap;\n	#endif\n	\n#endif";
    envmap_pars_fragment = "#ifdef USE_ENVMAP\n	uniform float reflectivity;\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n		#define ENV_WORLDPOS\n	#endif\n	#ifdef ENV_WORLDPOS\n		varying vec3 vWorldPosition;\n		uniform float refractionRatio;\n	#else\n		varying vec3 vReflect;\n	#endif\n#endif";
    envmap_pars_vertex = "#ifdef USE_ENVMAP\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n		#define ENV_WORLDPOS\n	#endif\n	#ifdef ENV_WORLDPOS\n		\n		varying vec3 vWorldPosition;\n	#else\n		varying vec3 vReflect;\n		uniform float refractionRatio;\n	#endif\n#endif";
    envmap_vertex = "#ifdef USE_ENVMAP\n	#ifdef ENV_WORLDPOS\n		vWorldPosition = worldPosition.xyz;\n	#else\n		vec3 cameraToVertex;\n		if ( isOrthographic ) {\n			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n		} else {\n			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n		}\n		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n		#ifdef ENVMAP_MODE_REFLECTION\n			vReflect = reflect( cameraToVertex, worldNormal );\n		#else\n			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n		#endif\n	#endif\n#endif";
    fog_vertex = "#ifdef USE_FOG\n	vFogDepth = - mvPosition.z;\n#endif";
    fog_pars_vertex = "#ifdef USE_FOG\n	varying float vFogDepth;\n#endif";
    fog_fragment = "#ifdef USE_FOG\n	#ifdef FOG_EXP2\n		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\n	#else\n		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\n	#endif\n	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif";
    fog_pars_fragment = "#ifdef USE_FOG\n	uniform vec3 fogColor;\n	varying float vFogDepth;\n	#ifdef FOG_EXP2\n		uniform float fogDensity;\n	#else\n		uniform float fogNear;\n		uniform float fogFar;\n	#endif\n#endif";
    gradientmap_pars_fragment = "#ifdef USE_GRADIENTMAP\n	uniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n	float dotNL = dot( normal, lightDirection );\n	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n	#ifdef USE_GRADIENTMAP\n		return vec3( texture2D( gradientMap, coord ).r );\n	#else\n		vec2 fw = fwidth( coord ) * 0.5;\n		return mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );\n	#endif\n}";
    lightmap_pars_fragment = "#ifdef USE_LIGHTMAP\n	uniform sampler2D lightMap;\n	uniform float lightMapIntensity;\n#endif";
    lights_lambert_fragment = "LambertMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularStrength = specularStrength;";
    lights_lambert_pars_fragment = "varying vec3 vViewPosition;\nstruct LambertMaterial {\n	vec3 diffuseColor;\n	float specularStrength;\n};\nvoid RE_Direct_Lambert( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {\n	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );\n	vec3 irradiance = dotNL * directLight.color;\n	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct				RE_Direct_Lambert\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_Lambert";
    lights_pars_begin = "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\n#if defined( USE_LIGHT_PROBES )\n	uniform vec3 lightProbe[ 9 ];\n#endif\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n	float x = normal.x, y = normal.y, z = normal.z;\n	vec3 result = shCoefficients[ 0 ] * 0.886227;\n	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n	return result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {\n	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n	return irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n	vec3 irradiance = ambientLightColor;\n	return irradiance;\n}\nfloat getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n	float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n	if ( cutoffDistance > 0.0 ) {\n		distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n	}\n	return distanceFalloff;\n}\nfloat getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {\n	return smoothstep( coneCosine, penumbraCosine, angleCosine );\n}\n#if NUM_DIR_LIGHTS > 0\n	struct DirectionalLight {\n		vec3 direction;\n		vec3 color;\n	};\n	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n	void getDirectionalLightInfo( const in DirectionalLight directionalLight, out IncidentLight light ) {\n		light.color = directionalLight.color;\n		light.direction = directionalLight.direction;\n		light.visible = true;\n	}\n#endif\n#if NUM_POINT_LIGHTS > 0\n	struct PointLight {\n		vec3 position;\n		vec3 color;\n		float distance;\n		float decay;\n	};\n	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n	void getPointLightInfo( const in PointLight pointLight, const in vec3 geometryPosition, out IncidentLight light ) {\n		vec3 lVector = pointLight.position - geometryPosition;\n		light.direction = normalize( lVector );\n		float lightDistance = length( lVector );\n		light.color = pointLight.color;\n		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );\n		light.visible = ( light.color != vec3( 0.0 ) );\n	}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n	struct SpotLight {\n		vec3 position;\n		vec3 direction;\n		vec3 color;\n		float distance;\n		float decay;\n		float coneCos;\n		float penumbraCos;\n	};\n	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n	void getSpotLightInfo( const in SpotLight spotLight, const in vec3 geometryPosition, out IncidentLight light ) {\n		vec3 lVector = spotLight.position - geometryPosition;\n		light.direction = normalize( lVector );\n		float angleCos = dot( light.direction, spotLight.direction );\n		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n		if ( spotAttenuation > 0.0 ) {\n			float lightDistance = length( lVector );\n			light.color = spotLight.color * spotAttenuation;\n			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );\n			light.visible = ( light.color != vec3( 0.0 ) );\n		} else {\n			light.color = vec3( 0.0 );\n			light.visible = false;\n		}\n	}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n	struct RectAreaLight {\n		vec3 color;\n		vec3 position;\n		vec3 halfWidth;\n		vec3 halfHeight;\n	};\n	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;\n	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n	struct HemisphereLight {\n		vec3 direction;\n		vec3 skyColor;\n		vec3 groundColor;\n	};\n	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {\n		float dotNL = dot( normal, hemiLight.direction );\n		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n		return irradiance;\n	}\n#endif";
    envmap_physical_pars_fragment = "#ifdef USE_ENVMAP\n	vec3 getIBLIrradiance( const in vec3 normal ) {\n		#ifdef ENVMAP_TYPE_CUBE_UV\n			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * worldNormal, 1.0 );\n			return PI * envMapColor.rgb * envMapIntensity;\n		#else\n			return vec3( 0.0 );\n		#endif\n	}\n	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {\n		#ifdef ENVMAP_TYPE_CUBE_UV\n			vec3 reflectVec = reflect( - viewDir, normal );\n			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * reflectVec, roughness );\n			return envMapColor.rgb * envMapIntensity;\n		#else\n			return vec3( 0.0 );\n		#endif\n	}\n	#ifdef USE_ANISOTROPY\n		vec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {\n			#ifdef ENVMAP_TYPE_CUBE_UV\n				vec3 bentNormal = cross( bitangent, viewDir );\n				bentNormal = normalize( cross( bentNormal, bitangent ) );\n				bentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );\n				return getIBLRadiance( viewDir, bentNormal, roughness );\n			#else\n				return vec3( 0.0 );\n			#endif\n		}\n	#endif\n#endif";
    lights_toon_fragment = "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;";
    lights_toon_pars_fragment = "varying vec3 vViewPosition;\nstruct ToonMaterial {\n	vec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n	vec3 irradiance = getGradientIrradiance( geometryNormal, directLight.direction ) * directLight.color;\n	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct				RE_Direct_Toon\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon";
    lights_phong_fragment = "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;";
    lights_phong_pars_fragment = "varying vec3 vViewPosition;\nstruct BlinnPhongMaterial {\n	vec3 diffuseColor;\n	vec3 specularColor;\n	float specularShininess;\n	float specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );\n	vec3 irradiance = dotNL * directLight.color;\n	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometryViewDir, geometryNormal, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct				RE_Direct_BlinnPhong\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong";
    lights_physical_fragment = "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( nonPerturbedNormal ) ), abs( dFdy( nonPerturbedNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;\nmaterial.roughness = min( material.roughness, 1.0 );\n#ifdef IOR\n	material.ior = ior;\n	#ifdef USE_SPECULAR\n		float specularIntensityFactor = specularIntensity;\n		vec3 specularColorFactor = specularColor;\n		#ifdef USE_SPECULAR_COLORMAP\n			specularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;\n		#endif\n		#ifdef USE_SPECULAR_INTENSITYMAP\n			specularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;\n		#endif\n		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );\n	#else\n		float specularIntensityFactor = 1.0;\n		vec3 specularColorFactor = vec3( 1.0 );\n		material.specularF90 = 1.0;\n	#endif\n	material.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );\n#else\n	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );\n	material.specularF90 = 1.0;\n#endif\n#ifdef USE_CLEARCOAT\n	material.clearcoat = clearcoat;\n	material.clearcoatRoughness = clearcoatRoughness;\n	material.clearcoatF0 = vec3( 0.04 );\n	material.clearcoatF90 = 1.0;\n	#ifdef USE_CLEARCOATMAP\n		material.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;\n	#endif\n	#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;\n	#endif\n	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n	material.clearcoatRoughness += geometryRoughness;\n	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_DISPERSION\n	material.dispersion = dispersion;\n#endif\n#ifdef USE_IRIDESCENCE\n	material.iridescence = iridescence;\n	material.iridescenceIOR = iridescenceIOR;\n	#ifdef USE_IRIDESCENCEMAP\n		material.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;\n	#endif\n	#ifdef USE_IRIDESCENCE_THICKNESSMAP\n		material.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;\n	#else\n		material.iridescenceThickness = iridescenceThicknessMaximum;\n	#endif\n#endif\n#ifdef USE_SHEEN\n	material.sheenColor = sheenColor;\n	#ifdef USE_SHEEN_COLORMAP\n		material.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;\n	#endif\n	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );\n	#ifdef USE_SHEEN_ROUGHNESSMAP\n		material.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;\n	#endif\n#endif\n#ifdef USE_ANISOTROPY\n	#ifdef USE_ANISOTROPYMAP\n		mat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );\n		vec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;\n		vec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;\n	#else\n		vec2 anisotropyV = anisotropyVector;\n	#endif\n	material.anisotropy = length( anisotropyV );\n	if( material.anisotropy == 0.0 ) {\n		anisotropyV = vec2( 1.0, 0.0 );\n	} else {\n		anisotropyV /= material.anisotropy;\n		material.anisotropy = saturate( material.anisotropy );\n	}\n	material.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );\n	material.anisotropyT = tbn[ 0 ] * anisotropyV.x + tbn[ 1 ] * anisotropyV.y;\n	material.anisotropyB = tbn[ 1 ] * anisotropyV.x - tbn[ 0 ] * anisotropyV.y;\n#endif";
    lights_physical_pars_fragment = "struct PhysicalMaterial {\n	vec3 diffuseColor;\n	float roughness;\n	vec3 specularColor;\n	float specularF90;\n	float dispersion;\n	#ifdef USE_CLEARCOAT\n		float clearcoat;\n		float clearcoatRoughness;\n		vec3 clearcoatF0;\n		float clearcoatF90;\n	#endif\n	#ifdef USE_IRIDESCENCE\n		float iridescence;\n		float iridescenceIOR;\n		float iridescenceThickness;\n		vec3 iridescenceFresnel;\n		vec3 iridescenceF0;\n	#endif\n	#ifdef USE_SHEEN\n		vec3 sheenColor;\n		float sheenRoughness;\n	#endif\n	#ifdef IOR\n		float ior;\n	#endif\n	#ifdef USE_TRANSMISSION\n		float transmission;\n		float transmissionAlpha;\n		float thickness;\n		float attenuationDistance;\n		vec3 attenuationColor;\n	#endif\n	#ifdef USE_ANISOTROPY\n		float anisotropy;\n		float alphaT;\n		vec3 anisotropyT;\n		vec3 anisotropyB;\n	#endif\n};\nvec3 clearcoatSpecularDirect = vec3( 0.0 );\nvec3 clearcoatSpecularIndirect = vec3( 0.0 );\nvec3 sheenSpecularDirect = vec3( 0.0 );\nvec3 sheenSpecularIndirect = vec3(0.0 );\nvec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {\n    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );\n    float x2 = x * x;\n    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );\n    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );\n}\nfloat V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n	float a2 = pow2( alpha );\n	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n	return 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n	float a2 = pow2( alpha );\n	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n	return RECIPROCAL_PI * a2 / pow2( denom );\n}\n#ifdef USE_ANISOTROPY\n	float V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {\n		float gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );\n		float gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );\n		float v = 0.5 / ( gv + gl );\n		return saturate(v);\n	}\n	float D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {\n		float a2 = alphaT * alphaB;\n		highp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );\n		highp float v2 = dot( v, v );\n		float w2 = a2 / v2;\n		return RECIPROCAL_PI * a2 * pow2 ( w2 );\n	}\n#endif\n#ifdef USE_CLEARCOAT\n	vec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {\n		vec3 f0 = material.clearcoatF0;\n		float f90 = material.clearcoatF90;\n		float roughness = material.clearcoatRoughness;\n		float alpha = pow2( roughness );\n		vec3 halfDir = normalize( lightDir + viewDir );\n		float dotNL = saturate( dot( normal, lightDir ) );\n		float dotNV = saturate( dot( normal, viewDir ) );\n		float dotNH = saturate( dot( normal, halfDir ) );\n		float dotVH = saturate( dot( viewDir, halfDir ) );\n		vec3 F = F_Schlick( f0, f90, dotVH );\n		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n		float D = D_GGX( alpha, dotNH );\n		return F * ( V * D );\n	}\n#endif\nvec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {\n	vec3 f0 = material.specularColor;\n	float f90 = material.specularF90;\n	float roughness = material.roughness;\n	float alpha = pow2( roughness );\n	vec3 halfDir = normalize( lightDir + viewDir );\n	float dotNL = saturate( dot( normal, lightDir ) );\n	float dotNV = saturate( dot( normal, viewDir ) );\n	float dotNH = saturate( dot( normal, halfDir ) );\n	float dotVH = saturate( dot( viewDir, halfDir ) );\n	vec3 F = F_Schlick( f0, f90, dotVH );\n	#ifdef USE_IRIDESCENCE\n		F = mix( F, material.iridescenceFresnel, material.iridescence );\n	#endif\n	#ifdef USE_ANISOTROPY\n		float dotTL = dot( material.anisotropyT, lightDir );\n		float dotTV = dot( material.anisotropyT, viewDir );\n		float dotTH = dot( material.anisotropyT, halfDir );\n		float dotBL = dot( material.anisotropyB, lightDir );\n		float dotBV = dot( material.anisotropyB, viewDir );\n		float dotBH = dot( material.anisotropyB, halfDir );\n		float V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );\n		float D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );\n	#else\n		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n		float D = D_GGX( alpha, dotNH );\n	#endif\n	return F * ( V * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n	const float LUT_SIZE = 64.0;\n	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n	const float LUT_BIAS = 0.5 / LUT_SIZE;\n	float dotNV = saturate( dot( N, V ) );\n	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n	uv = uv * LUT_SCALE + LUT_BIAS;\n	return uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n	float l = length( f );\n	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n	float x = dot( v1, v2 );\n	float y = abs( x );\n	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n	float b = 3.4175940 + ( 4.1616724 + y ) * y;\n	float v = a / b;\n	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n	return cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n	vec3 lightNormal = cross( v1, v2 );\n	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n	vec3 T1, T2;\n	T1 = normalize( V - N * dot( V, N ) );\n	T2 = - cross( N, T1 );\n	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n	vec3 coords[ 4 ];\n	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n	coords[ 0 ] = normalize( coords[ 0 ] );\n	coords[ 1 ] = normalize( coords[ 1 ] );\n	coords[ 2 ] = normalize( coords[ 2 ] );\n	coords[ 3 ] = normalize( coords[ 3 ] );\n	vec3 vectorFormFactor = vec3( 0.0 );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n	return vec3( result );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie( float roughness, float dotNH ) {\n	float alpha = pow2( roughness );\n	float invAlpha = 1.0 / alpha;\n	float cos2h = dotNH * dotNH;\n	float sin2h = max( 1.0 - cos2h, 0.0078125 );\n	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );\n}\nfloat V_Neubelt( float dotNV, float dotNL ) {\n	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );\n}\nvec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {\n	vec3 halfDir = normalize( lightDir + viewDir );\n	float dotNL = saturate( dot( normal, lightDir ) );\n	float dotNV = saturate( dot( normal, viewDir ) );\n	float dotNH = saturate( dot( normal, halfDir ) );\n	float D = D_Charlie( sheenRoughness, dotNH );\n	float V = V_Neubelt( dotNV, dotNL );\n	return sheenColor * ( D * V );\n}\n#endif\nfloat IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n	float dotNV = saturate( dot( normal, viewDir ) );\n	float r2 = roughness * roughness;\n	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;\n	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;\n	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );\n	return saturate( DG * RECIPROCAL_PI );\n}\nvec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n	float dotNV = saturate( dot( normal, viewDir ) );\n	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n	vec4 r = roughness * c0 + c1;\n	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;\n	return fab;\n}\nvec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {\n	vec2 fab = DFGApprox( normal, viewDir, roughness );\n	return specularColor * fab.x + specularF90 * fab.y;\n}\n#ifdef USE_IRIDESCENCE\nvoid computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#else\nvoid computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#endif\n	vec2 fab = DFGApprox( normal, viewDir, roughness );\n	#ifdef USE_IRIDESCENCE\n		vec3 Fr = mix( specularColor, iridescenceF0, iridescence );\n	#else\n		vec3 Fr = specularColor;\n	#endif\n	vec3 FssEss = Fr * fab.x + specularF90 * fab.y;\n	float Ess = fab.x + fab.y;\n	float Ems = 1.0 - Ess;\n	vec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n	singleScatter += FssEss;\n	multiScatter += Fms * Ems;\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n		vec3 normal = geometryNormal;\n		vec3 viewDir = geometryViewDir;\n		vec3 position = geometryPosition;\n		vec3 lightPos = rectAreaLight.position;\n		vec3 halfWidth = rectAreaLight.halfWidth;\n		vec3 halfHeight = rectAreaLight.halfHeight;\n		vec3 lightColor = rectAreaLight.color;\n		float roughness = material.roughness;\n		vec3 rectCoords[ 4 ];\n		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n		vec2 uv = LTC_Uv( normal, viewDir, roughness );\n		vec4 t1 = texture2D( ltc_1, uv );\n		vec4 t2 = texture2D( ltc_2, uv );\n		mat3 mInv = mat3(\n			vec3( t1.x, 0, t1.y ),\n			vec3(    0, 1,    0 ),\n			vec3( t1.z, 0, t1.w )\n		);\n		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n	}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );\n	vec3 irradiance = dotNL * directLight.color;\n	#ifdef USE_CLEARCOAT\n		float dotNLcc = saturate( dot( geometryClearcoatNormal, directLight.direction ) );\n		vec3 ccIrradiance = dotNLcc * directLight.color;\n		clearcoatSpecularDirect += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometryViewDir, geometryClearcoatNormal, material );\n	#endif\n	#ifdef USE_SHEEN\n		sheenSpecularDirect += irradiance * BRDF_Sheen( directLight.direction, geometryViewDir, geometryNormal, material.sheenColor, material.sheenRoughness );\n	#endif\n	reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometryViewDir, geometryNormal, material );\n	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n	#ifdef USE_CLEARCOAT\n		clearcoatSpecularIndirect += clearcoatRadiance * EnvironmentBRDF( geometryClearcoatNormal, geometryViewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n	#endif\n	#ifdef USE_SHEEN\n		sheenSpecularIndirect += irradiance * material.sheenColor * IBLSheenBRDF( geometryNormal, geometryViewDir, material.sheenRoughness );\n	#endif\n	vec3 singleScattering = vec3( 0.0 );\n	vec3 multiScattering = vec3( 0.0 );\n	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n	#ifdef USE_IRIDESCENCE\n		computeMultiscatteringIridescence( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );\n	#else\n		computeMultiscattering( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );\n	#endif\n	vec3 totalScattering = singleScattering + multiScattering;\n	vec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );\n	reflectedLight.indirectSpecular += radiance * singleScattering;\n	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct				RE_Direct_Physical\n#define RE_Direct_RectArea		RE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular		RE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}";
    lights_fragment_begin = "\nvec3 geometryPosition = - vViewPosition;\nvec3 geometryNormal = normal;\nvec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\nvec3 geometryClearcoatNormal = vec3( 0.0 );\n#ifdef USE_CLEARCOAT\n	geometryClearcoatNormal = clearcoatNormal;\n#endif\n#ifdef USE_IRIDESCENCE\n	float dotNVi = saturate( dot( normal, geometryViewDir ) );\n	if ( material.iridescenceThickness == 0.0 ) {\n		material.iridescence = 0.0;\n	} else {\n		material.iridescence = saturate( material.iridescence );\n	}\n	if ( material.iridescence > 0.0 ) {\n		material.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );\n		material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );\n	}\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n	PointLight pointLight;\n	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n	PointLightShadow pointLightShadow;\n	#endif\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n		pointLight = pointLights[ i ];\n		getPointLightInfo( pointLight, geometryPosition, directLight );\n		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n		pointLightShadow = pointLightShadows[ i ];\n		directLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowIntensity, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n	SpotLight spotLight;\n	vec4 spotColor;\n	vec3 spotLightCoord;\n	bool inSpotLightMap;\n	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n	SpotLightShadow spotLightShadow;\n	#endif\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n		spotLight = spotLights[ i ];\n		getSpotLightInfo( spotLight, geometryPosition, directLight );\n		#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )\n		#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX\n		#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n		#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS\n		#else\n		#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )\n		#endif\n		#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )\n			spotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;\n			inSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );\n			spotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );\n			directLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;\n		#endif\n		#undef SPOT_LIGHT_MAP_INDEX\n		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n		spotLightShadow = spotLightShadows[ i ];\n		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowIntensity, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n	DirectionalLight directionalLight;\n	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n	DirectionalLightShadow directionalLightShadow;\n	#endif\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n		directionalLight = directionalLights[ i ];\n		getDirectionalLightInfo( directionalLight, directLight );\n		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n		directionalLightShadow = directionalLightShadows[ i ];\n		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowIntensity, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n	RectAreaLight rectAreaLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n		rectAreaLight = rectAreaLights[ i ];\n		RE_Direct_RectArea( rectAreaLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n	vec3 iblIrradiance = vec3( 0.0 );\n	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n	#if defined( USE_LIGHT_PROBES )\n		irradiance += getLightProbeIrradiance( lightProbe, geometryNormal );\n	#endif\n	#if ( NUM_HEMI_LIGHTS > 0 )\n		#pragma unroll_loop_start\n		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );\n		}\n		#pragma unroll_loop_end\n	#endif\n#endif\n#if defined( RE_IndirectSpecular )\n	vec3 radiance = vec3( 0.0 );\n	vec3 clearcoatRadiance = vec3( 0.0 );\n#endif";
    lights_fragment_maps = "#if defined( RE_IndirectDiffuse )\n	#ifdef USE_LIGHTMAP\n		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );\n		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n		irradiance += lightMapIrradiance;\n	#endif\n	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n		iblIrradiance += getIBLIrradiance( geometryNormal );\n	#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n	#ifdef USE_ANISOTROPY\n		radiance += getIBLAnisotropyRadiance( geometryViewDir, geometryNormal, material.roughness, material.anisotropyB, material.anisotropy );\n	#else\n		radiance += getIBLRadiance( geometryViewDir, geometryNormal, material.roughness );\n	#endif\n	#ifdef USE_CLEARCOAT\n		clearcoatRadiance += getIBLRadiance( geometryViewDir, geometryClearcoatNormal, material.clearcoatRoughness );\n	#endif\n#endif";
    lights_fragment_end = "#if defined( RE_IndirectDiffuse )\n	RE_IndirectDiffuse( irradiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n#endif";
    logdepthbuf_fragment = "#if defined( USE_LOGDEPTHBUF )\n	gl_FragDepth = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif";
    logdepthbuf_pars_fragment = "#if defined( USE_LOGDEPTHBUF )\n	uniform float logDepthBufFC;\n	varying float vFragDepth;\n	varying float vIsPerspective;\n#endif";
    logdepthbuf_pars_vertex = "#ifdef USE_LOGDEPTHBUF\n	varying float vFragDepth;\n	varying float vIsPerspective;\n#endif";
    logdepthbuf_vertex = "#ifdef USE_LOGDEPTHBUF\n	vFragDepth = 1.0 + gl_Position.w;\n	vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n#endif";
    map_fragment = "#ifdef USE_MAP\n	vec4 sampledDiffuseColor = texture2D( map, vMapUv );\n	#ifdef DECODE_VIDEO_TEXTURE\n		sampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );\n	\n	#endif\n	diffuseColor *= sampledDiffuseColor;\n#endif";
    map_pars_fragment = "#ifdef USE_MAP\n	uniform sampler2D map;\n#endif";
    map_particle_fragment = "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n	#if defined( USE_POINTS_UV )\n		vec2 uv = vUv;\n	#else\n		vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n	#endif\n#endif\n#ifdef USE_MAP\n	diffuseColor *= texture2D( map, uv );\n#endif\n#ifdef USE_ALPHAMAP\n	diffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif";
    map_particle_pars_fragment = "#if defined( USE_POINTS_UV )\n	varying vec2 vUv;\n#else\n	#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n		uniform mat3 uvTransform;\n	#endif\n#endif\n#ifdef USE_MAP\n	uniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n	uniform sampler2D alphaMap;\n#endif";
    metalnessmap_fragment = "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n	vec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );\n	metalnessFactor *= texelMetalness.b;\n#endif";
    metalnessmap_pars_fragment = "#ifdef USE_METALNESSMAP\n	uniform sampler2D metalnessMap;\n#endif";
    morphinstance_vertex = "#ifdef USE_INSTANCING_MORPH\n	float morphTargetInfluences[ MORPHTARGETS_COUNT ];\n	float morphTargetBaseInfluence = texelFetch( morphTexture, ivec2( 0, gl_InstanceID ), 0 ).r;\n	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n		morphTargetInfluences[i] =  texelFetch( morphTexture, ivec2( i + 1, gl_InstanceID ), 0 ).r;\n	}\n#endif";
    morphcolor_vertex = "#if defined( USE_MORPHCOLORS )\n	vColor *= morphTargetBaseInfluence;\n	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n		#if defined( USE_COLOR_ALPHA )\n			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];\n		#elif defined( USE_COLOR )\n			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];\n		#endif\n	}\n#endif";
    morphnormal_vertex = "#ifdef USE_MORPHNORMALS\n	objectNormal *= morphTargetBaseInfluence;\n	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n		if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];\n	}\n#endif";
    morphtarget_pars_vertex = "#ifdef USE_MORPHTARGETS\n	#ifndef USE_INSTANCING_MORPH\n		uniform float morphTargetBaseInfluence;\n		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];\n	#endif\n	uniform sampler2DArray morphTargetsTexture;\n	uniform ivec2 morphTargetsTextureSize;\n	vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {\n		int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;\n		int y = texelIndex / morphTargetsTextureSize.x;\n		int x = texelIndex - y * morphTargetsTextureSize.x;\n		ivec3 morphUV = ivec3( x, y, morphTargetIndex );\n		return texelFetch( morphTargetsTexture, morphUV, 0 );\n	}\n#endif";
    morphtarget_vertex = "#ifdef USE_MORPHTARGETS\n	transformed *= morphTargetBaseInfluence;\n	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n		if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];\n	}\n#endif";
    normal_fragment_begin = "float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n	vec3 fdx = dFdx( vViewPosition );\n	vec3 fdy = dFdy( vViewPosition );\n	vec3 normal = normalize( cross( fdx, fdy ) );\n#else\n	vec3 normal = normalize( vNormal );\n	#ifdef DOUBLE_SIDED\n		normal *= faceDirection;\n	#endif\n#endif\n#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )\n	#ifdef USE_TANGENT\n		mat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );\n	#else\n		mat3 tbn = getTangentFrame( - vViewPosition, normal,\n		#if defined( USE_NORMALMAP )\n			vNormalMapUv\n		#elif defined( USE_CLEARCOAT_NORMALMAP )\n			vClearcoatNormalMapUv\n		#else\n			vUv\n		#endif\n		);\n	#endif\n	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )\n		tbn[0] *= faceDirection;\n		tbn[1] *= faceDirection;\n	#endif\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n	#ifdef USE_TANGENT\n		mat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );\n	#else\n		mat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );\n	#endif\n	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )\n		tbn2[0] *= faceDirection;\n		tbn2[1] *= faceDirection;\n	#endif\n#endif\nvec3 nonPerturbedNormal = normal;";
    normal_fragment_maps = "#ifdef USE_NORMALMAP_OBJECTSPACE\n	normal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;\n	#ifdef FLIP_SIDED\n		normal = - normal;\n	#endif\n	#ifdef DOUBLE_SIDED\n		normal = normal * faceDirection;\n	#endif\n	normal = normalize( normalMatrix * normal );\n#elif defined( USE_NORMALMAP_TANGENTSPACE )\n	vec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;\n	mapN.xy *= normalScale;\n	normal = normalize( tbn * mapN );\n#elif defined( USE_BUMPMAP )\n	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif";
    normal_pars_fragment = "#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n	#ifdef USE_TANGENT\n		varying vec3 vTangent;\n		varying vec3 vBitangent;\n	#endif\n#endif";
    normal_pars_vertex = "#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n	#ifdef USE_TANGENT\n		varying vec3 vTangent;\n		varying vec3 vBitangent;\n	#endif\n#endif";
    normal_vertex = "#ifndef FLAT_SHADED\n	vNormal = normalize( transformedNormal );\n	#ifdef USE_TANGENT\n		vTangent = normalize( transformedTangent );\n		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n	#endif\n#endif";
    normalmap_pars_fragment = "#ifdef USE_NORMALMAP\n	uniform sampler2D normalMap;\n	uniform vec2 normalScale;\n#endif\n#ifdef USE_NORMALMAP_OBJECTSPACE\n	uniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )\n	mat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {\n		vec3 q0 = dFdx( eye_pos.xyz );\n		vec3 q1 = dFdy( eye_pos.xyz );\n		vec2 st0 = dFdx( uv.st );\n		vec2 st1 = dFdy( uv.st );\n		vec3 N = surf_norm;\n		vec3 q1perp = cross( q1, N );\n		vec3 q0perp = cross( N, q0 );\n		vec3 T = q1perp * st0.x + q0perp * st1.x;\n		vec3 B = q1perp * st0.y + q0perp * st1.y;\n		float det = max( dot( T, T ), dot( B, B ) );\n		float scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );\n		return mat3( T * scale, B * scale, N );\n	}\n#endif";
    clearcoat_normal_fragment_begin = "#ifdef USE_CLEARCOAT\n	vec3 clearcoatNormal = nonPerturbedNormal;\n#endif";
    clearcoat_normal_fragment_maps = "#ifdef USE_CLEARCOAT_NORMALMAP\n	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;\n	clearcoatMapN.xy *= clearcoatNormalScale;\n	clearcoatNormal = normalize( tbn2 * clearcoatMapN );\n#endif";
    clearcoat_pars_fragment = "#ifdef USE_CLEARCOATMAP\n	uniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n	uniform sampler2D clearcoatNormalMap;\n	uniform vec2 clearcoatNormalScale;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n	uniform sampler2D clearcoatRoughnessMap;\n#endif";
    iridescence_pars_fragment = "#ifdef USE_IRIDESCENCEMAP\n	uniform sampler2D iridescenceMap;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n	uniform sampler2D iridescenceThicknessMap;\n#endif";
    opaque_fragment = "#ifdef OPAQUE\ndiffuseColor.a = 1.0;\n#endif\n#ifdef USE_TRANSMISSION\ndiffuseColor.a *= material.transmissionAlpha;\n#endif\ngl_FragColor = vec4( outgoingLight, diffuseColor.a );";
    packing = "vec3 packNormalToRGB( const in vec3 normal ) {\n	return normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n	return 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;const float ShiftRight8 = 1. / 256.;\nconst float Inv255 = 1. / 255.;\nconst vec4 PackFactors = vec4( 1.0, 256.0, 256.0 * 256.0, 256.0 * 256.0 * 256.0 );\nconst vec2 UnpackFactors2 = vec2( UnpackDownscale, 1.0 / PackFactors.g );\nconst vec3 UnpackFactors3 = vec3( UnpackDownscale / PackFactors.rg, 1.0 / PackFactors.b );\nconst vec4 UnpackFactors4 = vec4( UnpackDownscale / PackFactors.rgb, 1.0 / PackFactors.a );\nvec4 packDepthToRGBA( const in float v ) {\n	if( v <= 0.0 )\n		return vec4( 0., 0., 0., 0. );\n	if( v >= 1.0 )\n		return vec4( 1., 1., 1., 1. );\n	float vuf;\n	float af = modf( v * PackFactors.a, vuf );\n	float bf = modf( vuf * ShiftRight8, vuf );\n	float gf = modf( vuf * ShiftRight8, vuf );\n	return vec4( vuf * Inv255, gf * PackUpscale, bf * PackUpscale, af );\n}\nvec3 packDepthToRGB( const in float v ) {\n	if( v <= 0.0 )\n		return vec3( 0., 0., 0. );\n	if( v >= 1.0 )\n		return vec3( 1., 1., 1. );\n	float vuf;\n	float bf = modf( v * PackFactors.b, vuf );\n	float gf = modf( vuf * ShiftRight8, vuf );\n	return vec3( vuf * Inv255, gf * PackUpscale, bf );\n}\nvec2 packDepthToRG( const in float v ) {\n	if( v <= 0.0 )\n		return vec2( 0., 0. );\n	if( v >= 1.0 )\n		return vec2( 1., 1. );\n	float vuf;\n	float gf = modf( v * 256., vuf );\n	return vec2( vuf * Inv255, gf );\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n	return dot( v, UnpackFactors4 );\n}\nfloat unpackRGBToDepth( const in vec3 v ) {\n	return dot( v, UnpackFactors3 );\n}\nfloat unpackRGToDepth( const in vec2 v ) {\n	return v.r * UnpackFactors2.r + v.g * UnpackFactors2.g;\n}\nvec4 pack2HalfToRGBA( const in vec2 v ) {\n	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );\n	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );\n}\nvec2 unpackRGBATo2Half( const in vec4 v ) {\n	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n	return ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {\n	return depth * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {\n	return ( near * far ) / ( ( far - near ) * depth - far );\n}";
    premultiplied_alpha_fragment = "#ifdef PREMULTIPLIED_ALPHA\n	gl_FragColor.rgb *= gl_FragColor.a;\n#endif";
    project_vertex = "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_BATCHING\n	mvPosition = batchingMatrix * mvPosition;\n#endif\n#ifdef USE_INSTANCING\n	mvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;";
    dithering_fragment = "#ifdef DITHERING\n	gl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif";
    dithering_pars_fragment = "#ifdef DITHERING\n	vec3 dithering( vec3 color ) {\n		float grid_position = rand( gl_FragCoord.xy );\n		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n		return color + dither_shift_RGB;\n	}\n#endif";
    roughnessmap_fragment = "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n	vec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );\n	roughnessFactor *= texelRoughness.g;\n#endif";
    roughnessmap_pars_fragment = "#ifdef USE_ROUGHNESSMAP\n	uniform sampler2D roughnessMap;\n#endif";
    shadowmap_pars_fragment = "#if NUM_SPOT_LIGHT_COORDS > 0\n	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];\n#endif\n#if NUM_SPOT_LIGHT_MAPS > 0\n	uniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];\n#endif\n#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n		struct DirectionalLightShadow {\n			float shadowIntensity;\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n		struct SpotLightShadow {\n			float shadowIntensity;\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n		struct PointLightShadow {\n			float shadowIntensity;\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n			float shadowCameraNear;\n			float shadowCameraFar;\n		};\n		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n	#endif\n	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n	}\n	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n		return unpackRGBATo2Half( texture2D( shadow, uv ) );\n	}\n	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n		float occlusion = 1.0;\n		vec2 distribution = texture2DDistribution( shadow, uv );\n		float hard_shadow = step( compare , distribution.x );\n		if (hard_shadow != 1.0 ) {\n			float distance = compare - distribution.x ;\n			float variance = max( 0.00000, distribution.y * distribution.y );\n			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n		}\n		return occlusion;\n	}\n	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n		float shadow = 1.0;\n		shadowCoord.xyz /= shadowCoord.w;\n		shadowCoord.z += shadowBias;\n		bool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;\n		bool frustumTest = inFrustum && shadowCoord.z <= 1.0;\n		if ( frustumTest ) {\n		#if defined( SHADOWMAP_TYPE_PCF )\n			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n			float dx0 = - texelSize.x * shadowRadius;\n			float dy0 = - texelSize.y * shadowRadius;\n			float dx1 = + texelSize.x * shadowRadius;\n			float dy1 = + texelSize.y * shadowRadius;\n			float dx2 = dx0 / 2.0;\n			float dy2 = dy0 / 2.0;\n			float dx3 = dx1 / 2.0;\n			float dy3 = dy1 / 2.0;\n			shadow = (\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n			) * ( 1.0 / 17.0 );\n		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n			float dx = texelSize.x;\n			float dy = texelSize.y;\n			vec2 uv = shadowCoord.xy;\n			vec2 f = fract( uv * shadowMapSize + 0.5 );\n			uv -= f * texelSize;\n			shadow = (\n				texture2DCompare( shadowMap, uv, shadowCoord.z ) +\n				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),\n					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n					 f.x ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),\n					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n					 f.x ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),\n					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n					 f.y ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),\n					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n					 f.y ) +\n				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),\n						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n						  f.x ),\n					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),\n						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n						  f.x ),\n					 f.y )\n			) * ( 1.0 / 9.0 );\n		#elif defined( SHADOWMAP_TYPE_VSM )\n			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n		#else\n			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n		#endif\n		}\n		return mix( 1.0, shadow, shadowIntensity );\n	}\n	vec2 cubeToUV( vec3 v, float texelSizeY ) {\n		vec3 absV = abs( v );\n		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n		absV *= scaleToCube;\n		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n		vec2 planar = v.xy;\n		float almostATexel = 1.5 * texelSizeY;\n		float almostOne = 1.0 - almostATexel;\n		if ( absV.z >= almostOne ) {\n			if ( v.z > 0.0 )\n				planar.x = 4.0 - v.x;\n		} else if ( absV.x >= almostOne ) {\n			float signX = sign( v.x );\n			planar.x = v.z * signX + 2.0 * signX;\n		} else if ( absV.y >= almostOne ) {\n			float signY = sign( v.y );\n			planar.x = v.x + 2.0 * signY + 2.0;\n			planar.y = v.z * signY - 2.0;\n		}\n		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n	}\n	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n		float shadow = 1.0;\n		vec3 lightToPosition = shadowCoord.xyz;\n		\n		float lightToPositionLength = length( lightToPosition );\n		if ( lightToPositionLength - shadowCameraFar <= 0.0 && lightToPositionLength - shadowCameraNear >= 0.0 ) {\n			float dp = ( lightToPositionLength - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );			dp += shadowBias;\n			vec3 bd3D = normalize( lightToPosition );\n			vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n			#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n				vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n				shadow = (\n					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n					texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n				) * ( 1.0 / 9.0 );\n			#else\n				shadow = texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n			#endif\n		}\n		return mix( 1.0, shadow, shadowIntensity );\n	}\n#endif";
    shadowmap_pars_vertex = "#if NUM_SPOT_LIGHT_COORDS > 0\n	uniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];\n	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];\n#endif\n#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n		struct DirectionalLightShadow {\n			float shadowIntensity;\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n		struct SpotLightShadow {\n			float shadowIntensity;\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n		struct PointLightShadow {\n			float shadowIntensity;\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n			float shadowCameraNear;\n			float shadowCameraFar;\n		};\n		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n	#endif\n#endif";
    shadowmap_vertex = "#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )\n	vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n	vec4 shadowWorldPosition;\n#endif\n#if defined( USE_SHADOWMAP )\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n		#pragma unroll_loop_start\n		for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n			vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n		}\n		#pragma unroll_loop_end\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n		#pragma unroll_loop_start\n		for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n			vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n		}\n		#pragma unroll_loop_end\n	#endif\n#endif\n#if NUM_SPOT_LIGHT_COORDS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {\n		shadowWorldPosition = worldPosition;\n		#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n			shadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;\n		#endif\n		vSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;\n	}\n	#pragma unroll_loop_end\n#endif";
    shadowmask_pars_fragment = "float getShadowMask() {\n	float shadow = 1.0;\n	#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n	DirectionalLightShadow directionalLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n		directionalLight = directionalLightShadows[ i ];\n		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowIntensity, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n	SpotLightShadow spotLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n		spotLight = spotLightShadows[ i ];\n		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowIntensity, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n	PointLightShadow pointLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n		pointLight = pointLightShadows[ i ];\n		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowIntensity, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#endif\n	return shadow;\n}";
    skinbase_vertex = "#ifdef USE_SKINNING\n	mat4 boneMatX = getBoneMatrix( skinIndex.x );\n	mat4 boneMatY = getBoneMatrix( skinIndex.y );\n	mat4 boneMatZ = getBoneMatrix( skinIndex.z );\n	mat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif";
    skinning_pars_vertex = "#ifdef USE_SKINNING\n	uniform mat4 bindMatrix;\n	uniform mat4 bindMatrixInverse;\n	uniform highp sampler2D boneTexture;\n	mat4 getBoneMatrix( const in float i ) {\n		int size = textureSize( boneTexture, 0 ).x;\n		int j = int( i ) * 4;\n		int x = j % size;\n		int y = j / size;\n		vec4 v1 = texelFetch( boneTexture, ivec2( x, y ), 0 );\n		vec4 v2 = texelFetch( boneTexture, ivec2( x + 1, y ), 0 );\n		vec4 v3 = texelFetch( boneTexture, ivec2( x + 2, y ), 0 );\n		vec4 v4 = texelFetch( boneTexture, ivec2( x + 3, y ), 0 );\n		return mat4( v1, v2, v3, v4 );\n	}\n#endif";
    skinning_vertex = "#ifdef USE_SKINNING\n	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n	vec4 skinned = vec4( 0.0 );\n	skinned += boneMatX * skinVertex * skinWeight.x;\n	skinned += boneMatY * skinVertex * skinWeight.y;\n	skinned += boneMatZ * skinVertex * skinWeight.z;\n	skinned += boneMatW * skinVertex * skinWeight.w;\n	transformed = ( bindMatrixInverse * skinned ).xyz;\n#endif";
    skinnormal_vertex = "#ifdef USE_SKINNING\n	mat4 skinMatrix = mat4( 0.0 );\n	skinMatrix += skinWeight.x * boneMatX;\n	skinMatrix += skinWeight.y * boneMatY;\n	skinMatrix += skinWeight.z * boneMatZ;\n	skinMatrix += skinWeight.w * boneMatW;\n	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n	#ifdef USE_TANGENT\n		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n	#endif\n#endif";
    specularmap_fragment = "float specularStrength;\n#ifdef USE_SPECULARMAP\n	vec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );\n	specularStrength = texelSpecular.r;\n#else\n	specularStrength = 1.0;\n#endif";
    specularmap_pars_fragment = "#ifdef USE_SPECULARMAP\n	uniform sampler2D specularMap;\n#endif";
    tonemapping_fragment = "#if defined( TONE_MAPPING )\n	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif";
    tonemapping_pars_fragment = "#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n	return saturate( toneMappingExposure * color );\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n	color *= toneMappingExposure;\n	return saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 CineonToneMapping( vec3 color ) {\n	color *= toneMappingExposure;\n	color = max( vec3( 0.0 ), color - 0.004 );\n	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n	return a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n	const mat3 ACESInputMat = mat3(\n		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),\n		vec3( 0.04823, 0.01566, 0.83777 )\n	);\n	const mat3 ACESOutputMat = mat3(\n		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),\n		vec3( -0.07367, -0.00605,  1.07602 )\n	);\n	color *= toneMappingExposure / 0.6;\n	color = ACESInputMat * color;\n	color = RRTAndODTFit( color );\n	color = ACESOutputMat * color;\n	return saturate( color );\n}\nconst mat3 LINEAR_REC2020_TO_LINEAR_SRGB = mat3(\n	vec3( 1.6605, - 0.1246, - 0.0182 ),\n	vec3( - 0.5876, 1.1329, - 0.1006 ),\n	vec3( - 0.0728, - 0.0083, 1.1187 )\n);\nconst mat3 LINEAR_SRGB_TO_LINEAR_REC2020 = mat3(\n	vec3( 0.6274, 0.0691, 0.0164 ),\n	vec3( 0.3293, 0.9195, 0.0880 ),\n	vec3( 0.0433, 0.0113, 0.8956 )\n);\nvec3 agxDefaultContrastApprox( vec3 x ) {\n	vec3 x2 = x * x;\n	vec3 x4 = x2 * x2;\n	return + 15.5 * x4 * x2\n		- 40.14 * x4 * x\n		+ 31.96 * x4\n		- 6.868 * x2 * x\n		+ 0.4298 * x2\n		+ 0.1191 * x\n		- 0.00232;\n}\nvec3 AgXToneMapping( vec3 color ) {\n	const mat3 AgXInsetMatrix = mat3(\n		vec3( 0.856627153315983, 0.137318972929847, 0.11189821299995 ),\n		vec3( 0.0951212405381588, 0.761241990602591, 0.0767994186031903 ),\n		vec3( 0.0482516061458583, 0.101439036467562, 0.811302368396859 )\n	);\n	const mat3 AgXOutsetMatrix = mat3(\n		vec3( 1.1271005818144368, - 0.1413297634984383, - 0.14132976349843826 ),\n		vec3( - 0.11060664309660323, 1.157823702216272, - 0.11060664309660294 ),\n		vec3( - 0.016493938717834573, - 0.016493938717834257, 1.2519364065950405 )\n	);\n	const float AgxMinEv = - 12.47393;	const float AgxMaxEv = 4.026069;\n	color *= toneMappingExposure;\n	color = LINEAR_SRGB_TO_LINEAR_REC2020 * color;\n	color = AgXInsetMatrix * color;\n	color = max( color, 1e-10 );	color = log2( color );\n	color = ( color - AgxMinEv ) / ( AgxMaxEv - AgxMinEv );\n	color = clamp( color, 0.0, 1.0 );\n	color = agxDefaultContrastApprox( color );\n	color = AgXOutsetMatrix * color;\n	color = pow( max( vec3( 0.0 ), color ), vec3( 2.2 ) );\n	color = LINEAR_REC2020_TO_LINEAR_SRGB * color;\n	color = clamp( color, 0.0, 1.0 );\n	return color;\n}\nvec3 NeutralToneMapping( vec3 color ) {\n	const float StartCompression = 0.8 - 0.04;\n	const float Desaturation = 0.15;\n	color *= toneMappingExposure;\n	float x = min( color.r, min( color.g, color.b ) );\n	float offset = x < 0.08 ? x - 6.25 * x * x : 0.04;\n	color -= offset;\n	float peak = max( color.r, max( color.g, color.b ) );\n	if ( peak < StartCompression ) return color;\n	float d = 1. - StartCompression;\n	float newPeak = 1. - d * d / ( peak + d - StartCompression );\n	color *= newPeak / peak;\n	float g = 1. - 1. / ( Desaturation * ( peak - newPeak ) + 1. );\n	return mix( color, vec3( newPeak ), g );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }";
    transmission_fragment = "#ifdef USE_TRANSMISSION\n	material.transmission = transmission;\n	material.transmissionAlpha = 1.0;\n	material.thickness = thickness;\n	material.attenuationDistance = attenuationDistance;\n	material.attenuationColor = attenuationColor;\n	#ifdef USE_TRANSMISSIONMAP\n		material.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;\n	#endif\n	#ifdef USE_THICKNESSMAP\n		material.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;\n	#endif\n	vec3 pos = vWorldPosition;\n	vec3 v = normalize( cameraPosition - pos );\n	vec3 n = inverseTransformDirection( normal, viewMatrix );\n	vec4 transmitted = getIBLVolumeRefraction(\n		n, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,\n		pos, modelMatrix, viewMatrix, projectionMatrix, material.dispersion, material.ior, material.thickness,\n		material.attenuationColor, material.attenuationDistance );\n	material.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );\n	totalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );\n#endif";
    transmission_pars_fragment = "#ifdef USE_TRANSMISSION\n	uniform float transmission;\n	uniform float thickness;\n	uniform float attenuationDistance;\n	uniform vec3 attenuationColor;\n	#ifdef USE_TRANSMISSIONMAP\n		uniform sampler2D transmissionMap;\n	#endif\n	#ifdef USE_THICKNESSMAP\n		uniform sampler2D thicknessMap;\n	#endif\n	uniform vec2 transmissionSamplerSize;\n	uniform sampler2D transmissionSamplerMap;\n	uniform mat4 modelMatrix;\n	uniform mat4 projectionMatrix;\n	varying vec3 vWorldPosition;\n	float w0( float a ) {\n		return ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );\n	}\n	float w1( float a ) {\n		return ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );\n	}\n	float w2( float a ){\n		return ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );\n	}\n	float w3( float a ) {\n		return ( 1.0 / 6.0 ) * ( a * a * a );\n	}\n	float g0( float a ) {\n		return w0( a ) + w1( a );\n	}\n	float g1( float a ) {\n		return w2( a ) + w3( a );\n	}\n	float h0( float a ) {\n		return - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );\n	}\n	float h1( float a ) {\n		return 1.0 + w3( a ) / ( w2( a ) + w3( a ) );\n	}\n	vec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {\n		uv = uv * texelSize.zw + 0.5;\n		vec2 iuv = floor( uv );\n		vec2 fuv = fract( uv );\n		float g0x = g0( fuv.x );\n		float g1x = g1( fuv.x );\n		float h0x = h0( fuv.x );\n		float h1x = h1( fuv.x );\n		float h0y = h0( fuv.y );\n		float h1y = h1( fuv.y );\n		vec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;\n		vec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;\n		vec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;\n		vec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;\n		return g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +\n			g1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );\n	}\n	vec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {\n		vec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );\n		vec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );\n		vec2 fLodSizeInv = 1.0 / fLodSize;\n		vec2 cLodSizeInv = 1.0 / cLodSize;\n		vec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );\n		vec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );\n		return mix( fSample, cSample, fract( lod ) );\n	}\n	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {\n		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );\n		vec3 modelScale;\n		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );\n		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );\n		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );\n		return normalize( refractionVector ) * thickness * modelScale;\n	}\n	float applyIorToRoughness( const in float roughness, const in float ior ) {\n		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );\n	}\n	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {\n		float lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );\n		return textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );\n	}\n	vec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {\n		if ( isinf( attenuationDistance ) ) {\n			return vec3( 1.0 );\n		} else {\n			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;\n			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance;\n		}\n	}\n	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,\n		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,\n		const in mat4 viewMatrix, const in mat4 projMatrix, const in float dispersion, const in float ior, const in float thickness,\n		const in vec3 attenuationColor, const in float attenuationDistance ) {\n		vec4 transmittedLight;\n		vec3 transmittance;\n		#ifdef USE_DISPERSION\n			float halfSpread = ( ior - 1.0 ) * 0.025 * dispersion;\n			vec3 iors = vec3( ior - halfSpread, ior, ior + halfSpread );\n			for ( int i = 0; i < 3; i ++ ) {\n				vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, iors[ i ], modelMatrix );\n				vec3 refractedRayExit = position + transmissionRay;\n		\n				vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n				vec2 refractionCoords = ndcPos.xy / ndcPos.w;\n				refractionCoords += 1.0;\n				refractionCoords /= 2.0;\n		\n				vec4 transmissionSample = getTransmissionSample( refractionCoords, roughness, iors[ i ] );\n				transmittedLight[ i ] = transmissionSample[ i ];\n				transmittedLight.a += transmissionSample.a;\n				transmittance[ i ] = diffuseColor[ i ] * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance )[ i ];\n			}\n			transmittedLight.a /= 3.0;\n		\n		#else\n		\n			vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );\n			vec3 refractedRayExit = position + transmissionRay;\n			vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n			vec2 refractionCoords = ndcPos.xy / ndcPos.w;\n			refractionCoords += 1.0;\n			refractionCoords /= 2.0;\n			transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );\n			transmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );\n		\n		#endif\n		vec3 attenuatedColor = transmittance * transmittedLight.rgb;\n		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );\n		float transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;\n		return vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );\n	}\n#endif";
    uv_pars_fragment = "#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n	varying vec2 vUv;\n#endif\n#ifdef USE_MAP\n	varying vec2 vMapUv;\n#endif\n#ifdef USE_ALPHAMAP\n	varying vec2 vAlphaMapUv;\n#endif\n#ifdef USE_LIGHTMAP\n	varying vec2 vLightMapUv;\n#endif\n#ifdef USE_AOMAP\n	varying vec2 vAoMapUv;\n#endif\n#ifdef USE_BUMPMAP\n	varying vec2 vBumpMapUv;\n#endif\n#ifdef USE_NORMALMAP\n	varying vec2 vNormalMapUv;\n#endif\n#ifdef USE_EMISSIVEMAP\n	varying vec2 vEmissiveMapUv;\n#endif\n#ifdef USE_METALNESSMAP\n	varying vec2 vMetalnessMapUv;\n#endif\n#ifdef USE_ROUGHNESSMAP\n	varying vec2 vRoughnessMapUv;\n#endif\n#ifdef USE_ANISOTROPYMAP\n	varying vec2 vAnisotropyMapUv;\n#endif\n#ifdef USE_CLEARCOATMAP\n	varying vec2 vClearcoatMapUv;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n	varying vec2 vClearcoatNormalMapUv;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n	varying vec2 vClearcoatRoughnessMapUv;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n	varying vec2 vIridescenceMapUv;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n	varying vec2 vIridescenceThicknessMapUv;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n	varying vec2 vSheenColorMapUv;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n	varying vec2 vSheenRoughnessMapUv;\n#endif\n#ifdef USE_SPECULARMAP\n	varying vec2 vSpecularMapUv;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n	varying vec2 vSpecularColorMapUv;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n	varying vec2 vSpecularIntensityMapUv;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n	uniform mat3 transmissionMapTransform;\n	varying vec2 vTransmissionMapUv;\n#endif\n#ifdef USE_THICKNESSMAP\n	uniform mat3 thicknessMapTransform;\n	varying vec2 vThicknessMapUv;\n#endif";
    uv_pars_vertex = "#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n	varying vec2 vUv;\n#endif\n#ifdef USE_MAP\n	uniform mat3 mapTransform;\n	varying vec2 vMapUv;\n#endif\n#ifdef USE_ALPHAMAP\n	uniform mat3 alphaMapTransform;\n	varying vec2 vAlphaMapUv;\n#endif\n#ifdef USE_LIGHTMAP\n	uniform mat3 lightMapTransform;\n	varying vec2 vLightMapUv;\n#endif\n#ifdef USE_AOMAP\n	uniform mat3 aoMapTransform;\n	varying vec2 vAoMapUv;\n#endif\n#ifdef USE_BUMPMAP\n	uniform mat3 bumpMapTransform;\n	varying vec2 vBumpMapUv;\n#endif\n#ifdef USE_NORMALMAP\n	uniform mat3 normalMapTransform;\n	varying vec2 vNormalMapUv;\n#endif\n#ifdef USE_DISPLACEMENTMAP\n	uniform mat3 displacementMapTransform;\n	varying vec2 vDisplacementMapUv;\n#endif\n#ifdef USE_EMISSIVEMAP\n	uniform mat3 emissiveMapTransform;\n	varying vec2 vEmissiveMapUv;\n#endif\n#ifdef USE_METALNESSMAP\n	uniform mat3 metalnessMapTransform;\n	varying vec2 vMetalnessMapUv;\n#endif\n#ifdef USE_ROUGHNESSMAP\n	uniform mat3 roughnessMapTransform;\n	varying vec2 vRoughnessMapUv;\n#endif\n#ifdef USE_ANISOTROPYMAP\n	uniform mat3 anisotropyMapTransform;\n	varying vec2 vAnisotropyMapUv;\n#endif\n#ifdef USE_CLEARCOATMAP\n	uniform mat3 clearcoatMapTransform;\n	varying vec2 vClearcoatMapUv;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n	uniform mat3 clearcoatNormalMapTransform;\n	varying vec2 vClearcoatNormalMapUv;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n	uniform mat3 clearcoatRoughnessMapTransform;\n	varying vec2 vClearcoatRoughnessMapUv;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n	uniform mat3 sheenColorMapTransform;\n	varying vec2 vSheenColorMapUv;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n	uniform mat3 sheenRoughnessMapTransform;\n	varying vec2 vSheenRoughnessMapUv;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n	uniform mat3 iridescenceMapTransform;\n	varying vec2 vIridescenceMapUv;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n	uniform mat3 iridescenceThicknessMapTransform;\n	varying vec2 vIridescenceThicknessMapUv;\n#endif\n#ifdef USE_SPECULARMAP\n	uniform mat3 specularMapTransform;\n	varying vec2 vSpecularMapUv;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n	uniform mat3 specularColorMapTransform;\n	varying vec2 vSpecularColorMapUv;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n	uniform mat3 specularIntensityMapTransform;\n	varying vec2 vSpecularIntensityMapUv;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n	uniform mat3 transmissionMapTransform;\n	varying vec2 vTransmissionMapUv;\n#endif\n#ifdef USE_THICKNESSMAP\n	uniform mat3 thicknessMapTransform;\n	varying vec2 vThicknessMapUv;\n#endif";
    uv_vertex = "#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n	vUv = vec3( uv, 1 ).xy;\n#endif\n#ifdef USE_MAP\n	vMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ALPHAMAP\n	vAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_LIGHTMAP\n	vLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_AOMAP\n	vAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_BUMPMAP\n	vBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_NORMALMAP\n	vNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_DISPLACEMENTMAP\n	vDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_EMISSIVEMAP\n	vEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_METALNESSMAP\n	vMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ROUGHNESSMAP\n	vRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ANISOTROPYMAP\n	vAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOATMAP\n	vClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n	vClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n	vClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n	vIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n	vIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n	vSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n	vSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULARMAP\n	vSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n	vSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n	vSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n	vTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_THICKNESSMAP\n	vThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;\n#endif";
    worldpos_vertex = "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0\n	vec4 worldPosition = vec4( transformed, 1.0 );\n	#ifdef USE_BATCHING\n		worldPosition = batchingMatrix * worldPosition;\n	#endif\n	#ifdef USE_INSTANCING\n		worldPosition = instanceMatrix * worldPosition;\n	#endif\n	worldPosition = modelMatrix * worldPosition;\n#endif";
    vertex$h = "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n	gl_Position = vec4( position.xy, 1.0, 1.0 );\n}";
    fragment$h = "uniform sampler2D t2D;\nuniform float backgroundIntensity;\nvarying vec2 vUv;\nvoid main() {\n	vec4 texColor = texture2D( t2D, vUv );\n	#ifdef DECODE_VIDEO_TEXTURE\n		texColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );\n	#endif\n	texColor.rgb *= backgroundIntensity;\n	gl_FragColor = texColor;\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n}";
    vertex$g = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vWorldDirection = transformDirection( position, modelMatrix );\n	#include <begin_vertex>\n	#include <project_vertex>\n	gl_Position.z = gl_Position.w;\n}";
    fragment$g = "#ifdef ENVMAP_TYPE_CUBE\n	uniform samplerCube envMap;\n#elif defined( ENVMAP_TYPE_CUBE_UV )\n	uniform sampler2D envMap;\n#endif\nuniform float flipEnvMap;\nuniform float backgroundBlurriness;\nuniform float backgroundIntensity;\nuniform mat3 backgroundRotation;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n	#ifdef ENVMAP_TYPE_CUBE\n		vec4 texColor = textureCube( envMap, backgroundRotation * vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );\n	#elif defined( ENVMAP_TYPE_CUBE_UV )\n		vec4 texColor = textureCubeUV( envMap, backgroundRotation * vWorldDirection, backgroundBlurriness );\n	#else\n		vec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n	#endif\n	texColor.rgb *= backgroundIntensity;\n	gl_FragColor = texColor;\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n}";
    vertex$f = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vWorldDirection = transformDirection( position, modelMatrix );\n	#include <begin_vertex>\n	#include <project_vertex>\n	gl_Position.z = gl_Position.w;\n}";
    fragment$f = "uniform samplerCube tCube;\nuniform float tFlip;\nuniform float opacity;\nvarying vec3 vWorldDirection;\nvoid main() {\n	vec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );\n	gl_FragColor = texColor;\n	gl_FragColor.a *= opacity;\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n}";
    vertex$e = "#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n	#include <uv_vertex>\n	#include <batching_vertex>\n	#include <skinbase_vertex>\n	#include <morphinstance_vertex>\n	#ifdef USE_DISPLACEMENTMAP\n		#include <beginnormal_vertex>\n		#include <morphnormal_vertex>\n		#include <skinnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vHighPrecisionZW = gl_Position.zw;\n}";
    fragment$e = "#if DEPTH_PACKING == 3200\n	uniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n	vec4 diffuseColor = vec4( 1.0 );\n	#include <clipping_planes_fragment>\n	#if DEPTH_PACKING == 3200\n		diffuseColor.a = opacity;\n	#endif\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <alphahash_fragment>\n	#include <logdepthbuf_fragment>\n	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n	#if DEPTH_PACKING == 3200\n		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n	#elif DEPTH_PACKING == 3201\n		gl_FragColor = packDepthToRGBA( fragCoordZ );\n	#elif DEPTH_PACKING == 3202\n		gl_FragColor = vec4( packDepthToRGB( fragCoordZ ), 1.0 );\n	#elif DEPTH_PACKING == 3203\n		gl_FragColor = vec4( packDepthToRG( fragCoordZ ), 0.0, 1.0 );\n	#endif\n}";
    vertex$d = "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <batching_vertex>\n	#include <skinbase_vertex>\n	#include <morphinstance_vertex>\n	#ifdef USE_DISPLACEMENTMAP\n		#include <beginnormal_vertex>\n		#include <morphnormal_vertex>\n		#include <skinnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <worldpos_vertex>\n	#include <clipping_planes_vertex>\n	vWorldPosition = worldPosition.xyz;\n}";
    fragment$d = "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n	vec4 diffuseColor = vec4( 1.0 );\n	#include <clipping_planes_fragment>\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <alphahash_fragment>\n	float dist = length( vWorldPosition - referencePosition );\n	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n	dist = saturate( dist );\n	gl_FragColor = packDepthToRGBA( dist );\n}";
    vertex$c = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vWorldDirection = transformDirection( position, modelMatrix );\n	#include <begin_vertex>\n	#include <project_vertex>\n}";
    fragment$c = "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vec3 direction = normalize( vWorldDirection );\n	vec2 sampleUV = equirectUv( direction );\n	gl_FragColor = texture2D( tEquirect, sampleUV );\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n}";
    vertex$b = "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	vLineDistance = scale * lineDistance;\n	#include <uv_vertex>\n	#include <color_vertex>\n	#include <morphinstance_vertex>\n	#include <morphcolor_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n}";
    fragment$b = "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <clipping_planes_fragment>\n	if ( mod( vLineDistance, totalSize ) > dashSize ) {\n		discard;\n	}\n	vec3 outgoingLight = vec3( 0.0 );\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	outgoingLight = diffuseColor.rgb;\n	#include <opaque_fragment>\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n}";
    vertex$a = "#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <color_vertex>\n	#include <morphinstance_vertex>\n	#include <morphcolor_vertex>\n	#include <batching_vertex>\n	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\n		#include <beginnormal_vertex>\n		#include <morphnormal_vertex>\n		#include <skinbase_vertex>\n		#include <skinnormal_vertex>\n		#include <defaultnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <fog_vertex>\n}";
    fragment$a = "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <clipping_planes_fragment>\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <alphahash_fragment>\n	#include <specularmap_fragment>\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	#ifdef USE_LIGHTMAP\n		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );\n		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;\n	#else\n		reflectedLight.indirectDiffuse += vec3( 1.0 );\n	#endif\n	#include <aomap_fragment>\n	reflectedLight.indirectDiffuse *= diffuseColor.rgb;\n	vec3 outgoingLight = reflectedLight.indirectDiffuse;\n	#include <envmap_fragment>\n	#include <opaque_fragment>\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
    vertex$9 = "#define LAMBERT\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <color_vertex>\n	#include <morphinstance_vertex>\n	#include <morphcolor_vertex>\n	#include <batching_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}";
    fragment$9 = "#define LAMBERT\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_lambert_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <clipping_planes_fragment>\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <alphahash_fragment>\n	#include <specularmap_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_lambert_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n	#include <envmap_fragment>\n	#include <opaque_fragment>\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
    vertex$8 = "#define MATCAP\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <color_vertex>\n	#include <morphinstance_vertex>\n	#include <morphcolor_vertex>\n	#include <batching_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n	vViewPosition = - mvPosition.xyz;\n}";
    fragment$8 = "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <clipping_planes_fragment>\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <alphahash_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	vec3 viewDir = normalize( vViewPosition );\n	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n	vec3 y = cross( viewDir, x );\n	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n	#ifdef USE_MATCAP\n		vec4 matcapColor = texture2D( matcap, uv );\n	#else\n		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );\n	#endif\n	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n	#include <opaque_fragment>\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
    vertex$7 = "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n	varying vec3 vViewPosition;\n#endif\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <batching_vertex>\n	#include <beginnormal_vertex>\n	#include <morphinstance_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n	vViewPosition = - mvPosition.xyz;\n#endif\n}";
    fragment$7 = "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n	varying vec3 vViewPosition;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	vec4 diffuseColor = vec4( 0.0, 0.0, 0.0, opacity );\n	#include <clipping_planes_fragment>\n	#include <logdepthbuf_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	gl_FragColor = vec4( packNormalToRGB( normal ), diffuseColor.a );\n	#ifdef OPAQUE\n		gl_FragColor.a = 1.0;\n	#endif\n}";
    vertex$6 = "#define PHONG\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <color_vertex>\n	#include <morphcolor_vertex>\n	#include <batching_vertex>\n	#include <beginnormal_vertex>\n	#include <morphinstance_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}";
    fragment$6 = "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <clipping_planes_fragment>\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <alphahash_fragment>\n	#include <specularmap_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_phong_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n	#include <envmap_fragment>\n	#include <opaque_fragment>\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
    vertex$5 = "#define STANDARD\nvarying vec3 vViewPosition;\n#ifdef USE_TRANSMISSION\n	varying vec3 vWorldPosition;\n#endif\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <color_vertex>\n	#include <morphinstance_vertex>\n	#include <morphcolor_vertex>\n	#include <batching_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n#ifdef USE_TRANSMISSION\n	vWorldPosition = worldPosition.xyz;\n#endif\n}";
    fragment$5 = "#define STANDARD\n#ifdef PHYSICAL\n	#define IOR\n	#define USE_SPECULAR\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef IOR\n	uniform float ior;\n#endif\n#ifdef USE_SPECULAR\n	uniform float specularIntensity;\n	uniform vec3 specularColor;\n	#ifdef USE_SPECULAR_COLORMAP\n		uniform sampler2D specularColorMap;\n	#endif\n	#ifdef USE_SPECULAR_INTENSITYMAP\n		uniform sampler2D specularIntensityMap;\n	#endif\n#endif\n#ifdef USE_CLEARCOAT\n	uniform float clearcoat;\n	uniform float clearcoatRoughness;\n#endif\n#ifdef USE_DISPERSION\n	uniform float dispersion;\n#endif\n#ifdef USE_IRIDESCENCE\n	uniform float iridescence;\n	uniform float iridescenceIOR;\n	uniform float iridescenceThicknessMinimum;\n	uniform float iridescenceThicknessMaximum;\n#endif\n#ifdef USE_SHEEN\n	uniform vec3 sheenColor;\n	uniform float sheenRoughness;\n	#ifdef USE_SHEEN_COLORMAP\n		uniform sampler2D sheenColorMap;\n	#endif\n	#ifdef USE_SHEEN_ROUGHNESSMAP\n		uniform sampler2D sheenRoughnessMap;\n	#endif\n#endif\n#ifdef USE_ANISOTROPY\n	uniform vec2 anisotropyVector;\n	#ifdef USE_ANISOTROPYMAP\n		uniform sampler2D anisotropyMap;\n	#endif\n#endif\nvarying vec3 vViewPosition;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <iridescence_fragment>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_physical_pars_fragment>\n#include <transmission_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <iridescence_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <clipping_planes_fragment>\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <alphahash_fragment>\n	#include <roughnessmap_fragment>\n	#include <metalnessmap_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <clearcoat_normal_fragment_begin>\n	#include <clearcoat_normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_physical_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\n	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n	#include <transmission_fragment>\n	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\n	#ifdef USE_SHEEN\n		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );\n		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecularDirect + sheenSpecularIndirect;\n	#endif\n	#ifdef USE_CLEARCOAT\n		float dotNVcc = saturate( dot( geometryClearcoatNormal, geometryViewDir ) );\n		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );\n		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + ( clearcoatSpecularDirect + clearcoatSpecularIndirect ) * material.clearcoat;\n	#endif\n	#include <opaque_fragment>\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
    vertex$4 = "#define TOON\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <color_vertex>\n	#include <morphinstance_vertex>\n	#include <morphcolor_vertex>\n	#include <batching_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}";
    fragment$4 = "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <clipping_planes_fragment>\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <alphahash_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_toon_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n	#include <opaque_fragment>\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
    vertex$3 = "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n#ifdef USE_POINTS_UV\n	varying vec2 vUv;\n	uniform mat3 uvTransform;\n#endif\nvoid main() {\n	#ifdef USE_POINTS_UV\n		vUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n	#endif\n	#include <color_vertex>\n	#include <morphinstance_vertex>\n	#include <morphcolor_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <project_vertex>\n	gl_PointSize = size;\n	#ifdef USE_SIZEATTENUATION\n		bool isPerspective = isPerspectiveMatrix( projectionMatrix );\n		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n	#endif\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <worldpos_vertex>\n	#include <fog_vertex>\n}";
    fragment$3 = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <clipping_planes_fragment>\n	vec3 outgoingLight = vec3( 0.0 );\n	#include <logdepthbuf_fragment>\n	#include <map_particle_fragment>\n	#include <color_fragment>\n	#include <alphatest_fragment>\n	#include <alphahash_fragment>\n	outgoingLight = diffuseColor.rgb;\n	#include <opaque_fragment>\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n}";
    vertex$2 = "#include <common>\n#include <batching_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n	#include <batching_vertex>\n	#include <beginnormal_vertex>\n	#include <morphinstance_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}";
    fragment$2 = "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <logdepthbuf_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n	#include <logdepthbuf_fragment>\n	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n	#include <fog_fragment>\n}";
    vertex$1 = "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	vec4 mvPosition = modelViewMatrix[ 3 ];\n	vec2 scale = vec2( length( modelMatrix[ 0 ].xyz ), length( modelMatrix[ 1 ].xyz ) );\n	#ifndef USE_SIZEATTENUATION\n		bool isPerspective = isPerspectiveMatrix( projectionMatrix );\n		if ( isPerspective ) scale *= - mvPosition.z;\n	#endif\n	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n	vec2 rotatedPosition;\n	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n	mvPosition.xy += rotatedPosition;\n	gl_Position = projectionMatrix * mvPosition;\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n}";
    fragment$1 = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <clipping_planes_fragment>\n	vec3 outgoingLight = vec3( 0.0 );\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <alphahash_fragment>\n	outgoingLight = diffuseColor.rgb;\n	#include <opaque_fragment>\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n	#include <fog_fragment>\n}";
    ShaderChunk = {
      alphahash_fragment,
      alphahash_pars_fragment,
      alphamap_fragment,
      alphamap_pars_fragment,
      alphatest_fragment,
      alphatest_pars_fragment,
      aomap_fragment,
      aomap_pars_fragment,
      batching_pars_vertex,
      batching_vertex,
      begin_vertex,
      beginnormal_vertex,
      bsdfs,
      iridescence_fragment,
      bumpmap_pars_fragment,
      clipping_planes_fragment,
      clipping_planes_pars_fragment,
      clipping_planes_pars_vertex,
      clipping_planes_vertex,
      color_fragment,
      color_pars_fragment,
      color_pars_vertex,
      color_vertex,
      common,
      cube_uv_reflection_fragment,
      defaultnormal_vertex,
      displacementmap_pars_vertex,
      displacementmap_vertex,
      emissivemap_fragment,
      emissivemap_pars_fragment,
      colorspace_fragment,
      colorspace_pars_fragment,
      envmap_fragment,
      envmap_common_pars_fragment,
      envmap_pars_fragment,
      envmap_pars_vertex,
      envmap_physical_pars_fragment,
      envmap_vertex,
      fog_vertex,
      fog_pars_vertex,
      fog_fragment,
      fog_pars_fragment,
      gradientmap_pars_fragment,
      lightmap_pars_fragment,
      lights_lambert_fragment,
      lights_lambert_pars_fragment,
      lights_pars_begin,
      lights_toon_fragment,
      lights_toon_pars_fragment,
      lights_phong_fragment,
      lights_phong_pars_fragment,
      lights_physical_fragment,
      lights_physical_pars_fragment,
      lights_fragment_begin,
      lights_fragment_maps,
      lights_fragment_end,
      logdepthbuf_fragment,
      logdepthbuf_pars_fragment,
      logdepthbuf_pars_vertex,
      logdepthbuf_vertex,
      map_fragment,
      map_pars_fragment,
      map_particle_fragment,
      map_particle_pars_fragment,
      metalnessmap_fragment,
      metalnessmap_pars_fragment,
      morphinstance_vertex,
      morphcolor_vertex,
      morphnormal_vertex,
      morphtarget_pars_vertex,
      morphtarget_vertex,
      normal_fragment_begin,
      normal_fragment_maps,
      normal_pars_fragment,
      normal_pars_vertex,
      normal_vertex,
      normalmap_pars_fragment,
      clearcoat_normal_fragment_begin,
      clearcoat_normal_fragment_maps,
      clearcoat_pars_fragment,
      iridescence_pars_fragment,
      opaque_fragment,
      packing,
      premultiplied_alpha_fragment,
      project_vertex,
      dithering_fragment,
      dithering_pars_fragment,
      roughnessmap_fragment,
      roughnessmap_pars_fragment,
      shadowmap_pars_fragment,
      shadowmap_pars_vertex,
      shadowmap_vertex,
      shadowmask_pars_fragment,
      skinbase_vertex,
      skinning_pars_vertex,
      skinning_vertex,
      skinnormal_vertex,
      specularmap_fragment,
      specularmap_pars_fragment,
      tonemapping_fragment,
      tonemapping_pars_fragment,
      transmission_fragment,
      transmission_pars_fragment,
      uv_pars_fragment,
      uv_pars_vertex,
      uv_vertex,
      worldpos_vertex,
      background_vert: vertex$h,
      background_frag: fragment$h,
      backgroundCube_vert: vertex$g,
      backgroundCube_frag: fragment$g,
      cube_vert: vertex$f,
      cube_frag: fragment$f,
      depth_vert: vertex$e,
      depth_frag: fragment$e,
      distanceRGBA_vert: vertex$d,
      distanceRGBA_frag: fragment$d,
      equirect_vert: vertex$c,
      equirect_frag: fragment$c,
      linedashed_vert: vertex$b,
      linedashed_frag: fragment$b,
      meshbasic_vert: vertex$a,
      meshbasic_frag: fragment$a,
      meshlambert_vert: vertex$9,
      meshlambert_frag: fragment$9,
      meshmatcap_vert: vertex$8,
      meshmatcap_frag: fragment$8,
      meshnormal_vert: vertex$7,
      meshnormal_frag: fragment$7,
      meshphong_vert: vertex$6,
      meshphong_frag: fragment$6,
      meshphysical_vert: vertex$5,
      meshphysical_frag: fragment$5,
      meshtoon_vert: vertex$4,
      meshtoon_frag: fragment$4,
      points_vert: vertex$3,
      points_frag: fragment$3,
      shadow_vert: vertex$2,
      shadow_frag: fragment$2,
      sprite_vert: vertex$1,
      sprite_frag: fragment$1
    };
    UniformsLib = {
      common: {
        diffuse: { value: /* @__PURE__ */ new Color(16777215) },
        opacity: { value: 1 },
        map: { value: null },
        mapTransform: { value: /* @__PURE__ */ new Matrix3() },
        alphaMap: { value: null },
        alphaMapTransform: { value: /* @__PURE__ */ new Matrix3() },
        alphaTest: { value: 0 }
      },
      specularmap: {
        specularMap: { value: null },
        specularMapTransform: { value: /* @__PURE__ */ new Matrix3() }
      },
      envmap: {
        envMap: { value: null },
        envMapRotation: { value: /* @__PURE__ */ new Matrix3() },
        flipEnvMap: { value: -1 },
        reflectivity: { value: 1 },
        // basic, lambert, phong
        ior: { value: 1.5 },
        // physical
        refractionRatio: { value: 0.98 }
        // basic, lambert, phong
      },
      aomap: {
        aoMap: { value: null },
        aoMapIntensity: { value: 1 },
        aoMapTransform: { value: /* @__PURE__ */ new Matrix3() }
      },
      lightmap: {
        lightMap: { value: null },
        lightMapIntensity: { value: 1 },
        lightMapTransform: { value: /* @__PURE__ */ new Matrix3() }
      },
      bumpmap: {
        bumpMap: { value: null },
        bumpMapTransform: { value: /* @__PURE__ */ new Matrix3() },
        bumpScale: { value: 1 }
      },
      normalmap: {
        normalMap: { value: null },
        normalMapTransform: { value: /* @__PURE__ */ new Matrix3() },
        normalScale: { value: /* @__PURE__ */ new Vector2(1, 1) }
      },
      displacementmap: {
        displacementMap: { value: null },
        displacementMapTransform: { value: /* @__PURE__ */ new Matrix3() },
        displacementScale: { value: 1 },
        displacementBias: { value: 0 }
      },
      emissivemap: {
        emissiveMap: { value: null },
        emissiveMapTransform: { value: /* @__PURE__ */ new Matrix3() }
      },
      metalnessmap: {
        metalnessMap: { value: null },
        metalnessMapTransform: { value: /* @__PURE__ */ new Matrix3() }
      },
      roughnessmap: {
        roughnessMap: { value: null },
        roughnessMapTransform: { value: /* @__PURE__ */ new Matrix3() }
      },
      gradientmap: {
        gradientMap: { value: null }
      },
      fog: {
        fogDensity: { value: 25e-5 },
        fogNear: { value: 1 },
        fogFar: { value: 2e3 },
        fogColor: { value: /* @__PURE__ */ new Color(16777215) }
      },
      lights: {
        ambientLightColor: { value: [] },
        lightProbe: { value: [] },
        directionalLights: { value: [], properties: {
          direction: {},
          color: {}
        } },
        directionalLightShadows: { value: [], properties: {
          shadowIntensity: 1,
          shadowBias: {},
          shadowNormalBias: {},
          shadowRadius: {},
          shadowMapSize: {}
        } },
        directionalShadowMap: { value: [] },
        directionalShadowMatrix: { value: [] },
        spotLights: { value: [], properties: {
          color: {},
          position: {},
          direction: {},
          distance: {},
          coneCos: {},
          penumbraCos: {},
          decay: {}
        } },
        spotLightShadows: { value: [], properties: {
          shadowIntensity: 1,
          shadowBias: {},
          shadowNormalBias: {},
          shadowRadius: {},
          shadowMapSize: {}
        } },
        spotLightMap: { value: [] },
        spotShadowMap: { value: [] },
        spotLightMatrix: { value: [] },
        pointLights: { value: [], properties: {
          color: {},
          position: {},
          decay: {},
          distance: {}
        } },
        pointLightShadows: { value: [], properties: {
          shadowIntensity: 1,
          shadowBias: {},
          shadowNormalBias: {},
          shadowRadius: {},
          shadowMapSize: {},
          shadowCameraNear: {},
          shadowCameraFar: {}
        } },
        pointShadowMap: { value: [] },
        pointShadowMatrix: { value: [] },
        hemisphereLights: { value: [], properties: {
          direction: {},
          skyColor: {},
          groundColor: {}
        } },
        // TODO (abelnation): RectAreaLight BRDF data needs to be moved from example to main src
        rectAreaLights: { value: [], properties: {
          color: {},
          position: {},
          width: {},
          height: {}
        } },
        ltc_1: { value: null },
        ltc_2: { value: null }
      },
      points: {
        diffuse: { value: /* @__PURE__ */ new Color(16777215) },
        opacity: { value: 1 },
        size: { value: 1 },
        scale: { value: 1 },
        map: { value: null },
        alphaMap: { value: null },
        alphaMapTransform: { value: /* @__PURE__ */ new Matrix3() },
        alphaTest: { value: 0 },
        uvTransform: { value: /* @__PURE__ */ new Matrix3() }
      },
      sprite: {
        diffuse: { value: /* @__PURE__ */ new Color(16777215) },
        opacity: { value: 1 },
        center: { value: /* @__PURE__ */ new Vector2(0.5, 0.5) },
        rotation: { value: 0 },
        map: { value: null },
        mapTransform: { value: /* @__PURE__ */ new Matrix3() },
        alphaMap: { value: null },
        alphaMapTransform: { value: /* @__PURE__ */ new Matrix3() },
        alphaTest: { value: 0 }
      }
    };
    ShaderLib = {
      basic: {
        uniforms: /* @__PURE__ */ mergeUniforms([
          UniformsLib.common,
          UniformsLib.specularmap,
          UniformsLib.envmap,
          UniformsLib.aomap,
          UniformsLib.lightmap,
          UniformsLib.fog
        ]),
        vertexShader: ShaderChunk.meshbasic_vert,
        fragmentShader: ShaderChunk.meshbasic_frag
      },
      lambert: {
        uniforms: /* @__PURE__ */ mergeUniforms([
          UniformsLib.common,
          UniformsLib.specularmap,
          UniformsLib.envmap,
          UniformsLib.aomap,
          UniformsLib.lightmap,
          UniformsLib.emissivemap,
          UniformsLib.bumpmap,
          UniformsLib.normalmap,
          UniformsLib.displacementmap,
          UniformsLib.fog,
          UniformsLib.lights,
          {
            emissive: { value: /* @__PURE__ */ new Color(0) }
          }
        ]),
        vertexShader: ShaderChunk.meshlambert_vert,
        fragmentShader: ShaderChunk.meshlambert_frag
      },
      phong: {
        uniforms: /* @__PURE__ */ mergeUniforms([
          UniformsLib.common,
          UniformsLib.specularmap,
          UniformsLib.envmap,
          UniformsLib.aomap,
          UniformsLib.lightmap,
          UniformsLib.emissivemap,
          UniformsLib.bumpmap,
          UniformsLib.normalmap,
          UniformsLib.displacementmap,
          UniformsLib.fog,
          UniformsLib.lights,
          {
            emissive: { value: /* @__PURE__ */ new Color(0) },
            specular: { value: /* @__PURE__ */ new Color(1118481) },
            shininess: { value: 30 }
          }
        ]),
        vertexShader: ShaderChunk.meshphong_vert,
        fragmentShader: ShaderChunk.meshphong_frag
      },
      standard: {
        uniforms: /* @__PURE__ */ mergeUniforms([
          UniformsLib.common,
          UniformsLib.envmap,
          UniformsLib.aomap,
          UniformsLib.lightmap,
          UniformsLib.emissivemap,
          UniformsLib.bumpmap,
          UniformsLib.normalmap,
          UniformsLib.displacementmap,
          UniformsLib.roughnessmap,
          UniformsLib.metalnessmap,
          UniformsLib.fog,
          UniformsLib.lights,
          {
            emissive: { value: /* @__PURE__ */ new Color(0) },
            roughness: { value: 1 },
            metalness: { value: 0 },
            envMapIntensity: { value: 1 }
          }
        ]),
        vertexShader: ShaderChunk.meshphysical_vert,
        fragmentShader: ShaderChunk.meshphysical_frag
      },
      toon: {
        uniforms: /* @__PURE__ */ mergeUniforms([
          UniformsLib.common,
          UniformsLib.aomap,
          UniformsLib.lightmap,
          UniformsLib.emissivemap,
          UniformsLib.bumpmap,
          UniformsLib.normalmap,
          UniformsLib.displacementmap,
          UniformsLib.gradientmap,
          UniformsLib.fog,
          UniformsLib.lights,
          {
            emissive: { value: /* @__PURE__ */ new Color(0) }
          }
        ]),
        vertexShader: ShaderChunk.meshtoon_vert,
        fragmentShader: ShaderChunk.meshtoon_frag
      },
      matcap: {
        uniforms: /* @__PURE__ */ mergeUniforms([
          UniformsLib.common,
          UniformsLib.bumpmap,
          UniformsLib.normalmap,
          UniformsLib.displacementmap,
          UniformsLib.fog,
          {
            matcap: { value: null }
          }
        ]),
        vertexShader: ShaderChunk.meshmatcap_vert,
        fragmentShader: ShaderChunk.meshmatcap_frag
      },
      points: {
        uniforms: /* @__PURE__ */ mergeUniforms([
          UniformsLib.points,
          UniformsLib.fog
        ]),
        vertexShader: ShaderChunk.points_vert,
        fragmentShader: ShaderChunk.points_frag
      },
      dashed: {
        uniforms: /* @__PURE__ */ mergeUniforms([
          UniformsLib.common,
          UniformsLib.fog,
          {
            scale: { value: 1 },
            dashSize: { value: 1 },
            totalSize: { value: 2 }
          }
        ]),
        vertexShader: ShaderChunk.linedashed_vert,
        fragmentShader: ShaderChunk.linedashed_frag
      },
      depth: {
        uniforms: /* @__PURE__ */ mergeUniforms([
          UniformsLib.common,
          UniformsLib.displacementmap
        ]),
        vertexShader: ShaderChunk.depth_vert,
        fragmentShader: ShaderChunk.depth_frag
      },
      normal: {
        uniforms: /* @__PURE__ */ mergeUniforms([
          UniformsLib.common,
          UniformsLib.bumpmap,
          UniformsLib.normalmap,
          UniformsLib.displacementmap,
          {
            opacity: { value: 1 }
          }
        ]),
        vertexShader: ShaderChunk.meshnormal_vert,
        fragmentShader: ShaderChunk.meshnormal_frag
      },
      sprite: {
        uniforms: /* @__PURE__ */ mergeUniforms([
          UniformsLib.sprite,
          UniformsLib.fog
        ]),
        vertexShader: ShaderChunk.sprite_vert,
        fragmentShader: ShaderChunk.sprite_frag
      },
      background: {
        uniforms: {
          uvTransform: { value: /* @__PURE__ */ new Matrix3() },
          t2D: { value: null },
          backgroundIntensity: { value: 1 }
        },
        vertexShader: ShaderChunk.background_vert,
        fragmentShader: ShaderChunk.background_frag
      },
      backgroundCube: {
        uniforms: {
          envMap: { value: null },
          flipEnvMap: { value: -1 },
          backgroundBlurriness: { value: 0 },
          backgroundIntensity: { value: 1 },
          backgroundRotation: { value: /* @__PURE__ */ new Matrix3() }
        },
        vertexShader: ShaderChunk.backgroundCube_vert,
        fragmentShader: ShaderChunk.backgroundCube_frag
      },
      cube: {
        uniforms: {
          tCube: { value: null },
          tFlip: { value: -1 },
          opacity: { value: 1 }
        },
        vertexShader: ShaderChunk.cube_vert,
        fragmentShader: ShaderChunk.cube_frag
      },
      equirect: {
        uniforms: {
          tEquirect: { value: null }
        },
        vertexShader: ShaderChunk.equirect_vert,
        fragmentShader: ShaderChunk.equirect_frag
      },
      distanceRGBA: {
        uniforms: /* @__PURE__ */ mergeUniforms([
          UniformsLib.common,
          UniformsLib.displacementmap,
          {
            referencePosition: { value: /* @__PURE__ */ new Vector3() },
            nearDistance: { value: 1 },
            farDistance: { value: 1e3 }
          }
        ]),
        vertexShader: ShaderChunk.distanceRGBA_vert,
        fragmentShader: ShaderChunk.distanceRGBA_frag
      },
      shadow: {
        uniforms: /* @__PURE__ */ mergeUniforms([
          UniformsLib.lights,
          UniformsLib.fog,
          {
            color: { value: /* @__PURE__ */ new Color(0) },
            opacity: { value: 1 }
          }
        ]),
        vertexShader: ShaderChunk.shadow_vert,
        fragmentShader: ShaderChunk.shadow_frag
      }
    };
    ShaderLib.physical = {
      uniforms: /* @__PURE__ */ mergeUniforms([
        ShaderLib.standard.uniforms,
        {
          clearcoat: { value: 0 },
          clearcoatMap: { value: null },
          clearcoatMapTransform: { value: /* @__PURE__ */ new Matrix3() },
          clearcoatNormalMap: { value: null },
          clearcoatNormalMapTransform: { value: /* @__PURE__ */ new Matrix3() },
          clearcoatNormalScale: { value: /* @__PURE__ */ new Vector2(1, 1) },
          clearcoatRoughness: { value: 0 },
          clearcoatRoughnessMap: { value: null },
          clearcoatRoughnessMapTransform: { value: /* @__PURE__ */ new Matrix3() },
          dispersion: { value: 0 },
          iridescence: { value: 0 },
          iridescenceMap: { value: null },
          iridescenceMapTransform: { value: /* @__PURE__ */ new Matrix3() },
          iridescenceIOR: { value: 1.3 },
          iridescenceThicknessMinimum: { value: 100 },
          iridescenceThicknessMaximum: { value: 400 },
          iridescenceThicknessMap: { value: null },
          iridescenceThicknessMapTransform: { value: /* @__PURE__ */ new Matrix3() },
          sheen: { value: 0 },
          sheenColor: { value: /* @__PURE__ */ new Color(0) },
          sheenColorMap: { value: null },
          sheenColorMapTransform: { value: /* @__PURE__ */ new Matrix3() },
          sheenRoughness: { value: 1 },
          sheenRoughnessMap: { value: null },
          sheenRoughnessMapTransform: { value: /* @__PURE__ */ new Matrix3() },
          transmission: { value: 0 },
          transmissionMap: { value: null },
          transmissionMapTransform: { value: /* @__PURE__ */ new Matrix3() },
          transmissionSamplerSize: { value: /* @__PURE__ */ new Vector2() },
          transmissionSamplerMap: { value: null },
          thickness: { value: 0 },
          thicknessMap: { value: null },
          thicknessMapTransform: { value: /* @__PURE__ */ new Matrix3() },
          attenuationDistance: { value: 0 },
          attenuationColor: { value: /* @__PURE__ */ new Color(0) },
          specularColor: { value: /* @__PURE__ */ new Color(1, 1, 1) },
          specularColorMap: { value: null },
          specularColorMapTransform: { value: /* @__PURE__ */ new Matrix3() },
          specularIntensity: { value: 1 },
          specularIntensityMap: { value: null },
          specularIntensityMapTransform: { value: /* @__PURE__ */ new Matrix3() },
          anisotropyVector: { value: /* @__PURE__ */ new Vector2() },
          anisotropyMap: { value: null },
          anisotropyMapTransform: { value: /* @__PURE__ */ new Matrix3() }
        }
      ]),
      vertexShader: ShaderChunk.meshphysical_vert,
      fragmentShader: ShaderChunk.meshphysical_frag
    };
    _rgb = { r: 0, b: 0, g: 0 };
    _e1$1 = /* @__PURE__ */ new Euler();
    _m1$1 = /* @__PURE__ */ new Matrix4();
    OrthographicCamera = class extends Camera {
      constructor(left = -1, right = 1, top = 1, bottom = -1, near = 0.1, far = 2e3) {
        super();
        this.isOrthographicCamera = true;
        this.type = "OrthographicCamera";
        this.zoom = 1;
        this.view = null;
        this.left = left;
        this.right = right;
        this.top = top;
        this.bottom = bottom;
        this.near = near;
        this.far = far;
        this.updateProjectionMatrix();
      }
      copy(source, recursive) {
        super.copy(source, recursive);
        this.left = source.left;
        this.right = source.right;
        this.top = source.top;
        this.bottom = source.bottom;
        this.near = source.near;
        this.far = source.far;
        this.zoom = source.zoom;
        this.view = source.view === null ? null : Object.assign({}, source.view);
        return this;
      }
      setViewOffset(fullWidth, fullHeight, x, y2, width, height) {
        if (this.view === null) {
          this.view = {
            enabled: true,
            fullWidth: 1,
            fullHeight: 1,
            offsetX: 0,
            offsetY: 0,
            width: 1,
            height: 1
          };
        }
        this.view.enabled = true;
        this.view.fullWidth = fullWidth;
        this.view.fullHeight = fullHeight;
        this.view.offsetX = x;
        this.view.offsetY = y2;
        this.view.width = width;
        this.view.height = height;
        this.updateProjectionMatrix();
      }
      clearViewOffset() {
        if (this.view !== null) {
          this.view.enabled = false;
        }
        this.updateProjectionMatrix();
      }
      updateProjectionMatrix() {
        const dx = (this.right - this.left) / (2 * this.zoom);
        const dy = (this.top - this.bottom) / (2 * this.zoom);
        const cx = (this.right + this.left) / 2;
        const cy = (this.top + this.bottom) / 2;
        let left = cx - dx;
        let right = cx + dx;
        let top = cy + dy;
        let bottom = cy - dy;
        if (this.view !== null && this.view.enabled) {
          const scaleW = (this.right - this.left) / this.view.fullWidth / this.zoom;
          const scaleH = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
          left += scaleW * this.view.offsetX;
          right = left + scaleW * this.view.width;
          top -= scaleH * this.view.offsetY;
          bottom = top - scaleH * this.view.height;
        }
        this.projectionMatrix.makeOrthographic(left, right, top, bottom, this.near, this.far, this.coordinateSystem);
        this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
      }
      toJSON(meta) {
        const data = super.toJSON(meta);
        data.object.zoom = this.zoom;
        data.object.left = this.left;
        data.object.right = this.right;
        data.object.top = this.top;
        data.object.bottom = this.bottom;
        data.object.near = this.near;
        data.object.far = this.far;
        if (this.view !== null) data.object.view = Object.assign({}, this.view);
        return data;
      }
    };
    LOD_MIN = 4;
    EXTRA_LOD_SIGMA = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582];
    MAX_SAMPLES = 20;
    _flatCamera = /* @__PURE__ */ new OrthographicCamera();
    _clearColor = /* @__PURE__ */ new Color();
    _oldTarget = null;
    _oldActiveCubeFace = 0;
    _oldActiveMipmapLevel = 0;
    _oldXrEnabled = false;
    PHI = (1 + Math.sqrt(5)) / 2;
    INV_PHI = 1 / PHI;
    _axisDirections = [
      /* @__PURE__ */ new Vector3(-PHI, INV_PHI, 0),
      /* @__PURE__ */ new Vector3(PHI, INV_PHI, 0),
      /* @__PURE__ */ new Vector3(-INV_PHI, 0, PHI),
      /* @__PURE__ */ new Vector3(INV_PHI, 0, PHI),
      /* @__PURE__ */ new Vector3(0, PHI, -INV_PHI),
      /* @__PURE__ */ new Vector3(0, PHI, INV_PHI),
      /* @__PURE__ */ new Vector3(-1, 1, -1),
      /* @__PURE__ */ new Vector3(1, 1, -1),
      /* @__PURE__ */ new Vector3(-1, 1, 1),
      /* @__PURE__ */ new Vector3(1, 1, 1)
    ];
    PMREMGenerator = class {
      constructor(renderer) {
        this._renderer = renderer;
        this._pingPongRenderTarget = null;
        this._lodMax = 0;
        this._cubeSize = 0;
        this._lodPlanes = [];
        this._sizeLods = [];
        this._sigmas = [];
        this._blurMaterial = null;
        this._cubemapMaterial = null;
        this._equirectMaterial = null;
        this._compileMaterial(this._blurMaterial);
      }
      /**
       * Generates a PMREM from a supplied Scene, which can be faster than using an
       * image if networking bandwidth is low. Optional sigma specifies a blur radius
       * in radians to be applied to the scene before PMREM generation. Optional near
       * and far planes ensure the scene is rendered in its entirety (the cubeCamera
       * is placed at the origin).
       */
      fromScene(scene, sigma = 0, near = 0.1, far = 100) {
        _oldTarget = this._renderer.getRenderTarget();
        _oldActiveCubeFace = this._renderer.getActiveCubeFace();
        _oldActiveMipmapLevel = this._renderer.getActiveMipmapLevel();
        _oldXrEnabled = this._renderer.xr.enabled;
        this._renderer.xr.enabled = false;
        this._setSize(256);
        const cubeUVRenderTarget = this._allocateTargets();
        cubeUVRenderTarget.depthBuffer = true;
        this._sceneToCubeUV(scene, near, far, cubeUVRenderTarget);
        if (sigma > 0) {
          this._blur(cubeUVRenderTarget, 0, 0, sigma);
        }
        this._applyPMREM(cubeUVRenderTarget);
        this._cleanup(cubeUVRenderTarget);
        return cubeUVRenderTarget;
      }
      /**
       * Generates a PMREM from an equirectangular texture, which can be either LDR
       * or HDR. The ideal input image size is 1k (1024 x 512),
       * as this matches best with the 256 x 256 cubemap output.
       * The smallest supported equirectangular image size is 64 x 32.
       */
      fromEquirectangular(equirectangular, renderTarget = null) {
        return this._fromTexture(equirectangular, renderTarget);
      }
      /**
       * Generates a PMREM from an cubemap texture, which can be either LDR
       * or HDR. The ideal input cube size is 256 x 256,
       * as this matches best with the 256 x 256 cubemap output.
       * The smallest supported cube size is 16 x 16.
       */
      fromCubemap(cubemap, renderTarget = null) {
        return this._fromTexture(cubemap, renderTarget);
      }
      /**
       * Pre-compiles the cubemap shader. You can get faster start-up by invoking this method during
       * your texture's network fetch for increased concurrency.
       */
      compileCubemapShader() {
        if (this._cubemapMaterial === null) {
          this._cubemapMaterial = _getCubemapMaterial();
          this._compileMaterial(this._cubemapMaterial);
        }
      }
      /**
       * Pre-compiles the equirectangular shader. You can get faster start-up by invoking this method during
       * your texture's network fetch for increased concurrency.
       */
      compileEquirectangularShader() {
        if (this._equirectMaterial === null) {
          this._equirectMaterial = _getEquirectMaterial();
          this._compileMaterial(this._equirectMaterial);
        }
      }
      /**
       * Disposes of the PMREMGenerator's internal memory. Note that PMREMGenerator is a static class,
       * so you should not need more than one PMREMGenerator object. If you do, calling dispose() on
       * one of them will cause any others to also become unusable.
       */
      dispose() {
        this._dispose();
        if (this._cubemapMaterial !== null) this._cubemapMaterial.dispose();
        if (this._equirectMaterial !== null) this._equirectMaterial.dispose();
      }
      // private interface
      _setSize(cubeSize) {
        this._lodMax = Math.floor(Math.log2(cubeSize));
        this._cubeSize = Math.pow(2, this._lodMax);
      }
      _dispose() {
        if (this._blurMaterial !== null) this._blurMaterial.dispose();
        if (this._pingPongRenderTarget !== null) this._pingPongRenderTarget.dispose();
        for (let i2 = 0; i2 < this._lodPlanes.length; i2++) {
          this._lodPlanes[i2].dispose();
        }
      }
      _cleanup(outputTarget) {
        this._renderer.setRenderTarget(_oldTarget, _oldActiveCubeFace, _oldActiveMipmapLevel);
        this._renderer.xr.enabled = _oldXrEnabled;
        outputTarget.scissorTest = false;
        _setViewport(outputTarget, 0, 0, outputTarget.width, outputTarget.height);
      }
      _fromTexture(texture, renderTarget) {
        if (texture.mapping === CubeReflectionMapping || texture.mapping === CubeRefractionMapping) {
          this._setSize(texture.image.length === 0 ? 16 : texture.image[0].width || texture.image[0].image.width);
        } else {
          this._setSize(texture.image.width / 4);
        }
        _oldTarget = this._renderer.getRenderTarget();
        _oldActiveCubeFace = this._renderer.getActiveCubeFace();
        _oldActiveMipmapLevel = this._renderer.getActiveMipmapLevel();
        _oldXrEnabled = this._renderer.xr.enabled;
        this._renderer.xr.enabled = false;
        const cubeUVRenderTarget = renderTarget || this._allocateTargets();
        this._textureToCubeUV(texture, cubeUVRenderTarget);
        this._applyPMREM(cubeUVRenderTarget);
        this._cleanup(cubeUVRenderTarget);
        return cubeUVRenderTarget;
      }
      _allocateTargets() {
        const width = 3 * Math.max(this._cubeSize, 16 * 7);
        const height = 4 * this._cubeSize;
        const params = {
          magFilter: LinearFilter,
          minFilter: LinearFilter,
          generateMipmaps: false,
          type: HalfFloatType,
          format: RGBAFormat,
          colorSpace: LinearSRGBColorSpace,
          depthBuffer: false
        };
        const cubeUVRenderTarget = _createRenderTarget(width, height, params);
        if (this._pingPongRenderTarget === null || this._pingPongRenderTarget.width !== width || this._pingPongRenderTarget.height !== height) {
          if (this._pingPongRenderTarget !== null) {
            this._dispose();
          }
          this._pingPongRenderTarget = _createRenderTarget(width, height, params);
          const { _lodMax } = this;
          ({ sizeLods: this._sizeLods, lodPlanes: this._lodPlanes, sigmas: this._sigmas } = _createPlanes(_lodMax));
          this._blurMaterial = _getBlurShader(_lodMax, width, height);
        }
        return cubeUVRenderTarget;
      }
      _compileMaterial(material) {
        const tmpMesh = new Mesh(this._lodPlanes[0], material);
        this._renderer.compile(tmpMesh, _flatCamera);
      }
      _sceneToCubeUV(scene, near, far, cubeUVRenderTarget) {
        const fov2 = 90;
        const aspect2 = 1;
        const cubeCamera = new PerspectiveCamera(fov2, aspect2, near, far);
        const upSign = [1, -1, 1, 1, 1, 1];
        const forwardSign = [1, 1, 1, -1, -1, -1];
        const renderer = this._renderer;
        const originalAutoClear = renderer.autoClear;
        const toneMapping = renderer.toneMapping;
        renderer.getClearColor(_clearColor);
        renderer.toneMapping = NoToneMapping;
        renderer.autoClear = false;
        const backgroundMaterial = new MeshBasicMaterial({
          name: "PMREM.Background",
          side: BackSide,
          depthWrite: false,
          depthTest: false
        });
        const backgroundBox = new Mesh(new BoxGeometry(), backgroundMaterial);
        let useSolidColor = false;
        const background = scene.background;
        if (background) {
          if (background.isColor) {
            backgroundMaterial.color.copy(background);
            scene.background = null;
            useSolidColor = true;
          }
        } else {
          backgroundMaterial.color.copy(_clearColor);
          useSolidColor = true;
        }
        for (let i2 = 0; i2 < 6; i2++) {
          const col = i2 % 3;
          if (col === 0) {
            cubeCamera.up.set(0, upSign[i2], 0);
            cubeCamera.lookAt(forwardSign[i2], 0, 0);
          } else if (col === 1) {
            cubeCamera.up.set(0, 0, upSign[i2]);
            cubeCamera.lookAt(0, forwardSign[i2], 0);
          } else {
            cubeCamera.up.set(0, upSign[i2], 0);
            cubeCamera.lookAt(0, 0, forwardSign[i2]);
          }
          const size = this._cubeSize;
          _setViewport(cubeUVRenderTarget, col * size, i2 > 2 ? size : 0, size, size);
          renderer.setRenderTarget(cubeUVRenderTarget);
          if (useSolidColor) {
            renderer.render(backgroundBox, cubeCamera);
          }
          renderer.render(scene, cubeCamera);
        }
        backgroundBox.geometry.dispose();
        backgroundBox.material.dispose();
        renderer.toneMapping = toneMapping;
        renderer.autoClear = originalAutoClear;
        scene.background = background;
      }
      _textureToCubeUV(texture, cubeUVRenderTarget) {
        const renderer = this._renderer;
        const isCubeTexture = texture.mapping === CubeReflectionMapping || texture.mapping === CubeRefractionMapping;
        if (isCubeTexture) {
          if (this._cubemapMaterial === null) {
            this._cubemapMaterial = _getCubemapMaterial();
          }
          this._cubemapMaterial.uniforms.flipEnvMap.value = texture.isRenderTargetTexture === false ? -1 : 1;
        } else {
          if (this._equirectMaterial === null) {
            this._equirectMaterial = _getEquirectMaterial();
          }
        }
        const material = isCubeTexture ? this._cubemapMaterial : this._equirectMaterial;
        const mesh = new Mesh(this._lodPlanes[0], material);
        const uniforms = material.uniforms;
        uniforms["envMap"].value = texture;
        const size = this._cubeSize;
        _setViewport(cubeUVRenderTarget, 0, 0, 3 * size, 2 * size);
        renderer.setRenderTarget(cubeUVRenderTarget);
        renderer.render(mesh, _flatCamera);
      }
      _applyPMREM(cubeUVRenderTarget) {
        const renderer = this._renderer;
        const autoClear = renderer.autoClear;
        renderer.autoClear = false;
        const n = this._lodPlanes.length;
        for (let i2 = 1; i2 < n; i2++) {
          const sigma = Math.sqrt(this._sigmas[i2] * this._sigmas[i2] - this._sigmas[i2 - 1] * this._sigmas[i2 - 1]);
          const poleAxis = _axisDirections[(n - i2 - 1) % _axisDirections.length];
          this._blur(cubeUVRenderTarget, i2 - 1, i2, sigma, poleAxis);
        }
        renderer.autoClear = autoClear;
      }
      /**
       * This is a two-pass Gaussian blur for a cubemap. Normally this is done
       * vertically and horizontally, but this breaks down on a cube. Here we apply
       * the blur latitudinally (around the poles), and then longitudinally (towards
       * the poles) to approximate the orthogonally-separable blur. It is least
       * accurate at the poles, but still does a decent job.
       */
      _blur(cubeUVRenderTarget, lodIn, lodOut, sigma, poleAxis) {
        const pingPongRenderTarget = this._pingPongRenderTarget;
        this._halfBlur(
          cubeUVRenderTarget,
          pingPongRenderTarget,
          lodIn,
          lodOut,
          sigma,
          "latitudinal",
          poleAxis
        );
        this._halfBlur(
          pingPongRenderTarget,
          cubeUVRenderTarget,
          lodOut,
          lodOut,
          sigma,
          "longitudinal",
          poleAxis
        );
      }
      _halfBlur(targetIn, targetOut, lodIn, lodOut, sigmaRadians, direction, poleAxis) {
        const renderer = this._renderer;
        const blurMaterial = this._blurMaterial;
        if (direction !== "latitudinal" && direction !== "longitudinal") {
          console.error(
            "blur direction must be either latitudinal or longitudinal!"
          );
        }
        const STANDARD_DEVIATIONS = 3;
        const blurMesh = new Mesh(this._lodPlanes[lodOut], blurMaterial);
        const blurUniforms = blurMaterial.uniforms;
        const pixels = this._sizeLods[lodIn] - 1;
        const radiansPerPixel = isFinite(sigmaRadians) ? Math.PI / (2 * pixels) : 2 * Math.PI / (2 * MAX_SAMPLES - 1);
        const sigmaPixels = sigmaRadians / radiansPerPixel;
        const samples = isFinite(sigmaRadians) ? 1 + Math.floor(STANDARD_DEVIATIONS * sigmaPixels) : MAX_SAMPLES;
        if (samples > MAX_SAMPLES) {
          console.warn(`sigmaRadians, ${sigmaRadians}, is too large and will clip, as it requested ${samples} samples when the maximum is set to ${MAX_SAMPLES}`);
        }
        const weights = [];
        let sum = 0;
        for (let i2 = 0; i2 < MAX_SAMPLES; ++i2) {
          const x2 = i2 / sigmaPixels;
          const weight = Math.exp(-x2 * x2 / 2);
          weights.push(weight);
          if (i2 === 0) {
            sum += weight;
          } else if (i2 < samples) {
            sum += 2 * weight;
          }
        }
        for (let i2 = 0; i2 < weights.length; i2++) {
          weights[i2] = weights[i2] / sum;
        }
        blurUniforms["envMap"].value = targetIn.texture;
        blurUniforms["samples"].value = samples;
        blurUniforms["weights"].value = weights;
        blurUniforms["latitudinal"].value = direction === "latitudinal";
        if (poleAxis) {
          blurUniforms["poleAxis"].value = poleAxis;
        }
        const { _lodMax } = this;
        blurUniforms["dTheta"].value = radiansPerPixel;
        blurUniforms["mipInt"].value = _lodMax - lodIn;
        const outputSize = this._sizeLods[lodOut];
        const x = 3 * outputSize * (lodOut > _lodMax - LOD_MIN ? lodOut - _lodMax + LOD_MIN : 0);
        const y2 = 4 * (this._cubeSize - outputSize);
        _setViewport(targetOut, x, y2, 3 * outputSize, 2 * outputSize);
        renderer.setRenderTarget(targetOut);
        renderer.render(blurMesh, _flatCamera);
      }
    };
    DepthTexture = class extends Texture {
      constructor(width, height, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, format = DepthFormat) {
        if (format !== DepthFormat && format !== DepthStencilFormat) {
          throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
        }
        if (type === void 0 && format === DepthFormat) type = UnsignedIntType;
        if (type === void 0 && format === DepthStencilFormat) type = UnsignedInt248Type;
        super(null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);
        this.isDepthTexture = true;
        this.image = { width, height };
        this.magFilter = magFilter !== void 0 ? magFilter : NearestFilter;
        this.minFilter = minFilter !== void 0 ? minFilter : NearestFilter;
        this.flipY = false;
        this.generateMipmaps = false;
        this.compareFunction = null;
      }
      copy(source) {
        super.copy(source);
        this.compareFunction = source.compareFunction;
        return this;
      }
      toJSON(meta) {
        const data = super.toJSON(meta);
        if (this.compareFunction !== null) data.compareFunction = this.compareFunction;
        return data;
      }
    };
    emptyTexture = /* @__PURE__ */ new Texture();
    emptyShadowTexture = /* @__PURE__ */ new DepthTexture(1, 1);
    emptyArrayTexture = /* @__PURE__ */ new DataArrayTexture();
    empty3dTexture = /* @__PURE__ */ new Data3DTexture();
    emptyCubeTexture = /* @__PURE__ */ new CubeTexture();
    arrayCacheF32 = [];
    arrayCacheI32 = [];
    mat4array = new Float32Array(16);
    mat3array = new Float32Array(9);
    mat2array = new Float32Array(4);
    SingleUniform = class {
      constructor(id, activeInfo, addr) {
        this.id = id;
        this.addr = addr;
        this.cache = [];
        this.type = activeInfo.type;
        this.setValue = getSingularSetter(activeInfo.type);
      }
    };
    PureArrayUniform = class {
      constructor(id, activeInfo, addr) {
        this.id = id;
        this.addr = addr;
        this.cache = [];
        this.type = activeInfo.type;
        this.size = activeInfo.size;
        this.setValue = getPureArraySetter(activeInfo.type);
      }
    };
    StructuredUniform = class {
      constructor(id) {
        this.id = id;
        this.seq = [];
        this.map = {};
      }
      setValue(gl, value, textures) {
        const seq = this.seq;
        for (let i2 = 0, n = seq.length; i2 !== n; ++i2) {
          const u3 = seq[i2];
          u3.setValue(gl, value[u3.id], textures);
        }
      }
    };
    RePathPart = /(\w+)(\])?(\[|\.)?/g;
    WebGLUniforms = class {
      constructor(gl, program) {
        this.seq = [];
        this.map = {};
        const n = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);
        for (let i2 = 0; i2 < n; ++i2) {
          const info = gl.getActiveUniform(program, i2), addr = gl.getUniformLocation(program, info.name);
          parseUniform(info, addr, this);
        }
      }
      setValue(gl, name, value, textures) {
        const u3 = this.map[name];
        if (u3 !== void 0) u3.setValue(gl, value, textures);
      }
      setOptional(gl, object, name) {
        const v2 = object[name];
        if (v2 !== void 0) this.setValue(gl, name, v2);
      }
      static upload(gl, seq, values, textures) {
        for (let i2 = 0, n = seq.length; i2 !== n; ++i2) {
          const u3 = seq[i2], v2 = values[u3.id];
          if (v2.needsUpdate !== false) {
            u3.setValue(gl, v2.value, textures);
          }
        }
      }
      static seqWithValue(seq, values) {
        const r2 = [];
        for (let i2 = 0, n = seq.length; i2 !== n; ++i2) {
          const u3 = seq[i2];
          if (u3.id in values) r2.push(u3);
        }
        return r2;
      }
    };
    COMPLETION_STATUS_KHR = 37297;
    programIdCount = 0;
    _v0$1 = /* @__PURE__ */ new Vector3();
    includePattern = /^[ \t]*#include +<([\w\d./]+)>/gm;
    shaderChunkMap = /* @__PURE__ */ new Map();
    unrollLoopPattern = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
    _id$1 = 0;
    WebGLShaderCache = class {
      constructor() {
        this.shaderCache = /* @__PURE__ */ new Map();
        this.materialCache = /* @__PURE__ */ new Map();
      }
      update(material) {
        const vertexShader = material.vertexShader;
        const fragmentShader = material.fragmentShader;
        const vertexShaderStage = this._getShaderStage(vertexShader);
        const fragmentShaderStage = this._getShaderStage(fragmentShader);
        const materialShaders = this._getShaderCacheForMaterial(material);
        if (materialShaders.has(vertexShaderStage) === false) {
          materialShaders.add(vertexShaderStage);
          vertexShaderStage.usedTimes++;
        }
        if (materialShaders.has(fragmentShaderStage) === false) {
          materialShaders.add(fragmentShaderStage);
          fragmentShaderStage.usedTimes++;
        }
        return this;
      }
      remove(material) {
        const materialShaders = this.materialCache.get(material);
        for (const shaderStage of materialShaders) {
          shaderStage.usedTimes--;
          if (shaderStage.usedTimes === 0) this.shaderCache.delete(shaderStage.code);
        }
        this.materialCache.delete(material);
        return this;
      }
      getVertexShaderID(material) {
        return this._getShaderStage(material.vertexShader).id;
      }
      getFragmentShaderID(material) {
        return this._getShaderStage(material.fragmentShader).id;
      }
      dispose() {
        this.shaderCache.clear();
        this.materialCache.clear();
      }
      _getShaderCacheForMaterial(material) {
        const cache = this.materialCache;
        let set = cache.get(material);
        if (set === void 0) {
          set = /* @__PURE__ */ new Set();
          cache.set(material, set);
        }
        return set;
      }
      _getShaderStage(code) {
        const cache = this.shaderCache;
        let stage = cache.get(code);
        if (stage === void 0) {
          stage = new WebGLShaderStage(code);
          cache.set(code, stage);
        }
        return stage;
      }
    };
    WebGLShaderStage = class {
      constructor(code) {
        this.id = _id$1++;
        this.code = code;
        this.usedTimes = 0;
      }
    };
    nextVersion = 0;
    MeshDepthMaterial = class extends Material {
      constructor(parameters) {
        super();
        this.isMeshDepthMaterial = true;
        this.type = "MeshDepthMaterial";
        this.depthPacking = BasicDepthPacking;
        this.map = null;
        this.alphaMap = null;
        this.displacementMap = null;
        this.displacementScale = 1;
        this.displacementBias = 0;
        this.wireframe = false;
        this.wireframeLinewidth = 1;
        this.setValues(parameters);
      }
      copy(source) {
        super.copy(source);
        this.depthPacking = source.depthPacking;
        this.map = source.map;
        this.alphaMap = source.alphaMap;
        this.displacementMap = source.displacementMap;
        this.displacementScale = source.displacementScale;
        this.displacementBias = source.displacementBias;
        this.wireframe = source.wireframe;
        this.wireframeLinewidth = source.wireframeLinewidth;
        return this;
      }
    };
    MeshDistanceMaterial = class extends Material {
      constructor(parameters) {
        super();
        this.isMeshDistanceMaterial = true;
        this.type = "MeshDistanceMaterial";
        this.map = null;
        this.alphaMap = null;
        this.displacementMap = null;
        this.displacementScale = 1;
        this.displacementBias = 0;
        this.setValues(parameters);
      }
      copy(source) {
        super.copy(source);
        this.map = source.map;
        this.alphaMap = source.alphaMap;
        this.displacementMap = source.displacementMap;
        this.displacementScale = source.displacementScale;
        this.displacementBias = source.displacementBias;
        return this;
      }
    };
    vertex = "void main() {\n	gl_Position = vec4( position, 1.0 );\n}";
    fragment = "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n	const float samples = float( VSM_SAMPLES );\n	float mean = 0.0;\n	float squared_mean = 0.0;\n	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );\n	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;\n	for ( float i = 0.0; i < samples; i ++ ) {\n		float uvOffset = uvStart + i * uvStride;\n		#ifdef HORIZONTAL_PASS\n			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );\n			mean += distribution.x;\n			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n		#else\n			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );\n			mean += depth;\n			squared_mean += depth * depth;\n		#endif\n	}\n	mean = mean / samples;\n	squared_mean = squared_mean / samples;\n	float std_dev = sqrt( squared_mean - mean * mean );\n	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}";
    reversedFuncs = {
      [NeverDepth]: AlwaysDepth,
      [LessDepth]: GreaterDepth,
      [EqualDepth]: NotEqualDepth,
      [LessEqualDepth]: GreaterEqualDepth,
      [AlwaysDepth]: NeverDepth,
      [GreaterDepth]: LessDepth,
      [NotEqualDepth]: EqualDepth,
      [GreaterEqualDepth]: LessEqualDepth
    };
    TextureUtils = {
      contain,
      cover,
      fill,
      getByteLength
    };
    ArrayCamera = class extends PerspectiveCamera {
      constructor(array = []) {
        super();
        this.isArrayCamera = true;
        this.cameras = array;
      }
    };
    Group = class extends Object3D {
      constructor() {
        super();
        this.isGroup = true;
        this.type = "Group";
      }
    };
    _moveEvent = { type: "move" };
    WebXRController = class {
      constructor() {
        this._targetRay = null;
        this._grip = null;
        this._hand = null;
      }
      getHandSpace() {
        if (this._hand === null) {
          this._hand = new Group();
          this._hand.matrixAutoUpdate = false;
          this._hand.visible = false;
          this._hand.joints = {};
          this._hand.inputState = { pinching: false };
        }
        return this._hand;
      }
      getTargetRaySpace() {
        if (this._targetRay === null) {
          this._targetRay = new Group();
          this._targetRay.matrixAutoUpdate = false;
          this._targetRay.visible = false;
          this._targetRay.hasLinearVelocity = false;
          this._targetRay.linearVelocity = new Vector3();
          this._targetRay.hasAngularVelocity = false;
          this._targetRay.angularVelocity = new Vector3();
        }
        return this._targetRay;
      }
      getGripSpace() {
        if (this._grip === null) {
          this._grip = new Group();
          this._grip.matrixAutoUpdate = false;
          this._grip.visible = false;
          this._grip.hasLinearVelocity = false;
          this._grip.linearVelocity = new Vector3();
          this._grip.hasAngularVelocity = false;
          this._grip.angularVelocity = new Vector3();
        }
        return this._grip;
      }
      dispatchEvent(event) {
        if (this._targetRay !== null) {
          this._targetRay.dispatchEvent(event);
        }
        if (this._grip !== null) {
          this._grip.dispatchEvent(event);
        }
        if (this._hand !== null) {
          this._hand.dispatchEvent(event);
        }
        return this;
      }
      connect(inputSource) {
        if (inputSource && inputSource.hand) {
          const hand = this._hand;
          if (hand) {
            for (const inputjoint of inputSource.hand.values()) {
              this._getHandJoint(hand, inputjoint);
            }
          }
        }
        this.dispatchEvent({ type: "connected", data: inputSource });
        return this;
      }
      disconnect(inputSource) {
        this.dispatchEvent({ type: "disconnected", data: inputSource });
        if (this._targetRay !== null) {
          this._targetRay.visible = false;
        }
        if (this._grip !== null) {
          this._grip.visible = false;
        }
        if (this._hand !== null) {
          this._hand.visible = false;
        }
        return this;
      }
      update(inputSource, frame, referenceSpace) {
        let inputPose = null;
        let gripPose = null;
        let handPose = null;
        const targetRay = this._targetRay;
        const grip = this._grip;
        const hand = this._hand;
        if (inputSource && frame.session.visibilityState !== "visible-blurred") {
          if (hand && inputSource.hand) {
            handPose = true;
            for (const inputjoint of inputSource.hand.values()) {
              const jointPose = frame.getJointPose(inputjoint, referenceSpace);
              const joint = this._getHandJoint(hand, inputjoint);
              if (jointPose !== null) {
                joint.matrix.fromArray(jointPose.transform.matrix);
                joint.matrix.decompose(joint.position, joint.rotation, joint.scale);
                joint.matrixWorldNeedsUpdate = true;
                joint.jointRadius = jointPose.radius;
              }
              joint.visible = jointPose !== null;
            }
            const indexTip = hand.joints["index-finger-tip"];
            const thumbTip = hand.joints["thumb-tip"];
            const distance = indexTip.position.distanceTo(thumbTip.position);
            const distanceToPinch = 0.02;
            const threshold = 5e-3;
            if (hand.inputState.pinching && distance > distanceToPinch + threshold) {
              hand.inputState.pinching = false;
              this.dispatchEvent({
                type: "pinchend",
                handedness: inputSource.handedness,
                target: this
              });
            } else if (!hand.inputState.pinching && distance <= distanceToPinch - threshold) {
              hand.inputState.pinching = true;
              this.dispatchEvent({
                type: "pinchstart",
                handedness: inputSource.handedness,
                target: this
              });
            }
          } else {
            if (grip !== null && inputSource.gripSpace) {
              gripPose = frame.getPose(inputSource.gripSpace, referenceSpace);
              if (gripPose !== null) {
                grip.matrix.fromArray(gripPose.transform.matrix);
                grip.matrix.decompose(grip.position, grip.rotation, grip.scale);
                grip.matrixWorldNeedsUpdate = true;
                if (gripPose.linearVelocity) {
                  grip.hasLinearVelocity = true;
                  grip.linearVelocity.copy(gripPose.linearVelocity);
                } else {
                  grip.hasLinearVelocity = false;
                }
                if (gripPose.angularVelocity) {
                  grip.hasAngularVelocity = true;
                  grip.angularVelocity.copy(gripPose.angularVelocity);
                } else {
                  grip.hasAngularVelocity = false;
                }
              }
            }
          }
          if (targetRay !== null) {
            inputPose = frame.getPose(inputSource.targetRaySpace, referenceSpace);
            if (inputPose === null && gripPose !== null) {
              inputPose = gripPose;
            }
            if (inputPose !== null) {
              targetRay.matrix.fromArray(inputPose.transform.matrix);
              targetRay.matrix.decompose(targetRay.position, targetRay.rotation, targetRay.scale);
              targetRay.matrixWorldNeedsUpdate = true;
              if (inputPose.linearVelocity) {
                targetRay.hasLinearVelocity = true;
                targetRay.linearVelocity.copy(inputPose.linearVelocity);
              } else {
                targetRay.hasLinearVelocity = false;
              }
              if (inputPose.angularVelocity) {
                targetRay.hasAngularVelocity = true;
                targetRay.angularVelocity.copy(inputPose.angularVelocity);
              } else {
                targetRay.hasAngularVelocity = false;
              }
              this.dispatchEvent(_moveEvent);
            }
          }
        }
        if (targetRay !== null) {
          targetRay.visible = inputPose !== null;
        }
        if (grip !== null) {
          grip.visible = gripPose !== null;
        }
        if (hand !== null) {
          hand.visible = handPose !== null;
        }
        return this;
      }
      // private method
      _getHandJoint(hand, inputjoint) {
        if (hand.joints[inputjoint.jointName] === void 0) {
          const joint = new Group();
          joint.matrixAutoUpdate = false;
          joint.visible = false;
          hand.joints[inputjoint.jointName] = joint;
          hand.add(joint);
        }
        return hand.joints[inputjoint.jointName];
      }
    };
    _occlusion_vertex = `
void main() {

	gl_Position = vec4( position, 1.0 );

}`;
    _occlusion_fragment = `
uniform sampler2DArray depthColor;
uniform float depthWidth;
uniform float depthHeight;

void main() {

	vec2 coord = vec2( gl_FragCoord.x / depthWidth, gl_FragCoord.y / depthHeight );

	if ( coord.x >= 1.0 ) {

		gl_FragDepth = texture( depthColor, vec3( coord.x - 1.0, coord.y, 1 ) ).r;

	} else {

		gl_FragDepth = texture( depthColor, vec3( coord.x, coord.y, 0 ) ).r;

	}

}`;
    WebXRDepthSensing = class {
      constructor() {
        this.texture = null;
        this.mesh = null;
        this.depthNear = 0;
        this.depthFar = 0;
      }
      init(renderer, depthData, renderState) {
        if (this.texture === null) {
          const texture = new Texture();
          const texProps = renderer.properties.get(texture);
          texProps.__webglTexture = depthData.texture;
          if (depthData.depthNear != renderState.depthNear || depthData.depthFar != renderState.depthFar) {
            this.depthNear = depthData.depthNear;
            this.depthFar = depthData.depthFar;
          }
          this.texture = texture;
        }
      }
      getMesh(cameraXR) {
        if (this.texture !== null) {
          if (this.mesh === null) {
            const viewport = cameraXR.cameras[0].viewport;
            const material = new ShaderMaterial({
              vertexShader: _occlusion_vertex,
              fragmentShader: _occlusion_fragment,
              uniforms: {
                depthColor: { value: this.texture },
                depthWidth: { value: viewport.z },
                depthHeight: { value: viewport.w }
              }
            });
            this.mesh = new Mesh(new PlaneGeometry(20, 20), material);
          }
        }
        return this.mesh;
      }
      reset() {
        this.texture = null;
        this.mesh = null;
      }
      getDepthTexture() {
        return this.texture;
      }
    };
    WebXRManager = class extends EventDispatcher {
      constructor(renderer, gl) {
        super();
        const scope = this;
        let session = null;
        let framebufferScaleFactor = 1;
        let referenceSpace = null;
        let referenceSpaceType = "local-floor";
        let foveation = 1;
        let customReferenceSpace = null;
        let pose = null;
        let glBinding = null;
        let glProjLayer = null;
        let glBaseLayer = null;
        let xrFrame = null;
        const depthSensing = new WebXRDepthSensing();
        const attributes = gl.getContextAttributes();
        let initialRenderTarget = null;
        let newRenderTarget = null;
        const controllers = [];
        const controllerInputSources = [];
        const currentSize = new Vector2();
        let currentPixelRatio = null;
        const cameraL = new PerspectiveCamera();
        cameraL.layers.enable(1);
        cameraL.viewport = new Vector4();
        const cameraR = new PerspectiveCamera();
        cameraR.layers.enable(2);
        cameraR.viewport = new Vector4();
        const cameras = [cameraL, cameraR];
        const cameraXR = new ArrayCamera();
        cameraXR.layers.enable(1);
        cameraXR.layers.enable(2);
        let _currentDepthNear = null;
        let _currentDepthFar = null;
        this.cameraAutoUpdate = true;
        this.enabled = false;
        this.isPresenting = false;
        this.getController = function(index) {
          let controller = controllers[index];
          if (controller === void 0) {
            controller = new WebXRController();
            controllers[index] = controller;
          }
          return controller.getTargetRaySpace();
        };
        this.getControllerGrip = function(index) {
          let controller = controllers[index];
          if (controller === void 0) {
            controller = new WebXRController();
            controllers[index] = controller;
          }
          return controller.getGripSpace();
        };
        this.getHand = function(index) {
          let controller = controllers[index];
          if (controller === void 0) {
            controller = new WebXRController();
            controllers[index] = controller;
          }
          return controller.getHandSpace();
        };
        function onSessionEvent(event) {
          const controllerIndex = controllerInputSources.indexOf(event.inputSource);
          if (controllerIndex === -1) {
            return;
          }
          const controller = controllers[controllerIndex];
          if (controller !== void 0) {
            controller.update(event.inputSource, event.frame, customReferenceSpace || referenceSpace);
            controller.dispatchEvent({ type: event.type, data: event.inputSource });
          }
        }
        function onSessionEnd() {
          session.removeEventListener("select", onSessionEvent);
          session.removeEventListener("selectstart", onSessionEvent);
          session.removeEventListener("selectend", onSessionEvent);
          session.removeEventListener("squeeze", onSessionEvent);
          session.removeEventListener("squeezestart", onSessionEvent);
          session.removeEventListener("squeezeend", onSessionEvent);
          session.removeEventListener("end", onSessionEnd);
          session.removeEventListener("inputsourceschange", onInputSourcesChange);
          for (let i2 = 0; i2 < controllers.length; i2++) {
            const inputSource = controllerInputSources[i2];
            if (inputSource === null) continue;
            controllerInputSources[i2] = null;
            controllers[i2].disconnect(inputSource);
          }
          _currentDepthNear = null;
          _currentDepthFar = null;
          depthSensing.reset();
          renderer.setRenderTarget(initialRenderTarget);
          glBaseLayer = null;
          glProjLayer = null;
          glBinding = null;
          session = null;
          newRenderTarget = null;
          animation.stop();
          scope.isPresenting = false;
          renderer.setPixelRatio(currentPixelRatio);
          renderer.setSize(currentSize.width, currentSize.height, false);
          scope.dispatchEvent({ type: "sessionend" });
        }
        this.setFramebufferScaleFactor = function(value) {
          framebufferScaleFactor = value;
          if (scope.isPresenting === true) {
            console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.");
          }
        };
        this.setReferenceSpaceType = function(value) {
          referenceSpaceType = value;
          if (scope.isPresenting === true) {
            console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.");
          }
        };
        this.getReferenceSpace = function() {
          return customReferenceSpace || referenceSpace;
        };
        this.setReferenceSpace = function(space) {
          customReferenceSpace = space;
        };
        this.getBaseLayer = function() {
          return glProjLayer !== null ? glProjLayer : glBaseLayer;
        };
        this.getBinding = function() {
          return glBinding;
        };
        this.getFrame = function() {
          return xrFrame;
        };
        this.getSession = function() {
          return session;
        };
        this.setSession = function(value) {
          return __async(this, null, function* () {
            session = value;
            if (session !== null) {
              initialRenderTarget = renderer.getRenderTarget();
              session.addEventListener("select", onSessionEvent);
              session.addEventListener("selectstart", onSessionEvent);
              session.addEventListener("selectend", onSessionEvent);
              session.addEventListener("squeeze", onSessionEvent);
              session.addEventListener("squeezestart", onSessionEvent);
              session.addEventListener("squeezeend", onSessionEvent);
              session.addEventListener("end", onSessionEnd);
              session.addEventListener("inputsourceschange", onInputSourcesChange);
              if (attributes.xrCompatible !== true) {
                yield gl.makeXRCompatible();
              }
              currentPixelRatio = renderer.getPixelRatio();
              renderer.getSize(currentSize);
              if (session.renderState.layers === void 0) {
                const layerInit = {
                  antialias: attributes.antialias,
                  alpha: true,
                  depth: attributes.depth,
                  stencil: attributes.stencil,
                  framebufferScaleFactor
                };
                glBaseLayer = new XRWebGLLayer(session, gl, layerInit);
                session.updateRenderState({ baseLayer: glBaseLayer });
                renderer.setPixelRatio(1);
                renderer.setSize(glBaseLayer.framebufferWidth, glBaseLayer.framebufferHeight, false);
                newRenderTarget = new WebGLRenderTarget(
                  glBaseLayer.framebufferWidth,
                  glBaseLayer.framebufferHeight,
                  {
                    format: RGBAFormat,
                    type: UnsignedByteType,
                    colorSpace: renderer.outputColorSpace,
                    stencilBuffer: attributes.stencil
                  }
                );
              } else {
                let depthFormat = null;
                let depthType = null;
                let glDepthFormat = null;
                if (attributes.depth) {
                  glDepthFormat = attributes.stencil ? gl.DEPTH24_STENCIL8 : gl.DEPTH_COMPONENT24;
                  depthFormat = attributes.stencil ? DepthStencilFormat : DepthFormat;
                  depthType = attributes.stencil ? UnsignedInt248Type : UnsignedIntType;
                }
                const projectionlayerInit = {
                  colorFormat: gl.RGBA8,
                  depthFormat: glDepthFormat,
                  scaleFactor: framebufferScaleFactor
                };
                glBinding = new XRWebGLBinding(session, gl);
                glProjLayer = glBinding.createProjectionLayer(projectionlayerInit);
                session.updateRenderState({ layers: [glProjLayer] });
                renderer.setPixelRatio(1);
                renderer.setSize(glProjLayer.textureWidth, glProjLayer.textureHeight, false);
                newRenderTarget = new WebGLRenderTarget(
                  glProjLayer.textureWidth,
                  glProjLayer.textureHeight,
                  {
                    format: RGBAFormat,
                    type: UnsignedByteType,
                    depthTexture: new DepthTexture(glProjLayer.textureWidth, glProjLayer.textureHeight, depthType, void 0, void 0, void 0, void 0, void 0, void 0, depthFormat),
                    stencilBuffer: attributes.stencil,
                    colorSpace: renderer.outputColorSpace,
                    samples: attributes.antialias ? 4 : 0,
                    resolveDepthBuffer: glProjLayer.ignoreDepthValues === false
                  }
                );
              }
              newRenderTarget.isXRRenderTarget = true;
              this.setFoveation(foveation);
              customReferenceSpace = null;
              referenceSpace = yield session.requestReferenceSpace(referenceSpaceType);
              animation.setContext(session);
              animation.start();
              scope.isPresenting = true;
              scope.dispatchEvent({ type: "sessionstart" });
            }
          });
        };
        this.getEnvironmentBlendMode = function() {
          if (session !== null) {
            return session.environmentBlendMode;
          }
        };
        this.getDepthTexture = function() {
          return depthSensing.getDepthTexture();
        };
        function onInputSourcesChange(event) {
          for (let i2 = 0; i2 < event.removed.length; i2++) {
            const inputSource = event.removed[i2];
            const index = controllerInputSources.indexOf(inputSource);
            if (index >= 0) {
              controllerInputSources[index] = null;
              controllers[index].disconnect(inputSource);
            }
          }
          for (let i2 = 0; i2 < event.added.length; i2++) {
            const inputSource = event.added[i2];
            let controllerIndex = controllerInputSources.indexOf(inputSource);
            if (controllerIndex === -1) {
              for (let i22 = 0; i22 < controllers.length; i22++) {
                if (i22 >= controllerInputSources.length) {
                  controllerInputSources.push(inputSource);
                  controllerIndex = i22;
                  break;
                } else if (controllerInputSources[i22] === null) {
                  controllerInputSources[i22] = inputSource;
                  controllerIndex = i22;
                  break;
                }
              }
              if (controllerIndex === -1) break;
            }
            const controller = controllers[controllerIndex];
            if (controller) {
              controller.connect(inputSource);
            }
          }
        }
        const cameraLPos = new Vector3();
        const cameraRPos = new Vector3();
        function setProjectionFromUnion(camera, cameraL2, cameraR2) {
          cameraLPos.setFromMatrixPosition(cameraL2.matrixWorld);
          cameraRPos.setFromMatrixPosition(cameraR2.matrixWorld);
          const ipd = cameraLPos.distanceTo(cameraRPos);
          const projL = cameraL2.projectionMatrix.elements;
          const projR = cameraR2.projectionMatrix.elements;
          const near = projL[14] / (projL[10] - 1);
          const far = projL[14] / (projL[10] + 1);
          const topFov = (projL[9] + 1) / projL[5];
          const bottomFov = (projL[9] - 1) / projL[5];
          const leftFov = (projL[8] - 1) / projL[0];
          const rightFov = (projR[8] + 1) / projR[0];
          const left = near * leftFov;
          const right = near * rightFov;
          const zOffset = ipd / (-leftFov + rightFov);
          const xOffset = zOffset * -leftFov;
          cameraL2.matrixWorld.decompose(camera.position, camera.quaternion, camera.scale);
          camera.translateX(xOffset);
          camera.translateZ(zOffset);
          camera.matrixWorld.compose(camera.position, camera.quaternion, camera.scale);
          camera.matrixWorldInverse.copy(camera.matrixWorld).invert();
          if (projL[10] === -1) {
            camera.projectionMatrix.copy(cameraL2.projectionMatrix);
            camera.projectionMatrixInverse.copy(cameraL2.projectionMatrixInverse);
          } else {
            const near2 = near + zOffset;
            const far2 = far + zOffset;
            const left2 = left - xOffset;
            const right2 = right + (ipd - xOffset);
            const top2 = topFov * far / far2 * near2;
            const bottom2 = bottomFov * far / far2 * near2;
            camera.projectionMatrix.makePerspective(left2, right2, top2, bottom2, near2, far2);
            camera.projectionMatrixInverse.copy(camera.projectionMatrix).invert();
          }
        }
        function updateCamera2(camera, parent) {
          if (parent === null) {
            camera.matrixWorld.copy(camera.matrix);
          } else {
            camera.matrixWorld.multiplyMatrices(parent.matrixWorld, camera.matrix);
          }
          camera.matrixWorldInverse.copy(camera.matrixWorld).invert();
        }
        this.updateCamera = function(camera) {
          if (session === null) return;
          let depthNear = camera.near;
          let depthFar = camera.far;
          if (depthSensing.texture !== null) {
            if (depthSensing.depthNear > 0) depthNear = depthSensing.depthNear;
            if (depthSensing.depthFar > 0) depthFar = depthSensing.depthFar;
          }
          cameraXR.near = cameraR.near = cameraL.near = depthNear;
          cameraXR.far = cameraR.far = cameraL.far = depthFar;
          if (_currentDepthNear !== cameraXR.near || _currentDepthFar !== cameraXR.far) {
            session.updateRenderState({
              depthNear: cameraXR.near,
              depthFar: cameraXR.far
            });
            _currentDepthNear = cameraXR.near;
            _currentDepthFar = cameraXR.far;
          }
          const parent = camera.parent;
          const cameras2 = cameraXR.cameras;
          updateCamera2(cameraXR, parent);
          for (let i2 = 0; i2 < cameras2.length; i2++) {
            updateCamera2(cameras2[i2], parent);
          }
          if (cameras2.length === 2) {
            setProjectionFromUnion(cameraXR, cameraL, cameraR);
          } else {
            cameraXR.projectionMatrix.copy(cameraL.projectionMatrix);
          }
          updateUserCamera(camera, cameraXR, parent);
        };
        function updateUserCamera(camera, cameraXR2, parent) {
          if (parent === null) {
            camera.matrix.copy(cameraXR2.matrixWorld);
          } else {
            camera.matrix.copy(parent.matrixWorld);
            camera.matrix.invert();
            camera.matrix.multiply(cameraXR2.matrixWorld);
          }
          camera.matrix.decompose(camera.position, camera.quaternion, camera.scale);
          camera.updateMatrixWorld(true);
          camera.projectionMatrix.copy(cameraXR2.projectionMatrix);
          camera.projectionMatrixInverse.copy(cameraXR2.projectionMatrixInverse);
          if (camera.isPerspectiveCamera) {
            camera.fov = RAD2DEG * 2 * Math.atan(1 / camera.projectionMatrix.elements[5]);
            camera.zoom = 1;
          }
        }
        this.getCamera = function() {
          return cameraXR;
        };
        this.getFoveation = function() {
          if (glProjLayer === null && glBaseLayer === null) {
            return void 0;
          }
          return foveation;
        };
        this.setFoveation = function(value) {
          foveation = value;
          if (glProjLayer !== null) {
            glProjLayer.fixedFoveation = value;
          }
          if (glBaseLayer !== null && glBaseLayer.fixedFoveation !== void 0) {
            glBaseLayer.fixedFoveation = value;
          }
        };
        this.hasDepthSensing = function() {
          return depthSensing.texture !== null;
        };
        this.getDepthSensingMesh = function() {
          return depthSensing.getMesh(cameraXR);
        };
        let onAnimationFrameCallback = null;
        function onAnimationFrame(time, frame) {
          pose = frame.getViewerPose(customReferenceSpace || referenceSpace);
          xrFrame = frame;
          if (pose !== null) {
            const views = pose.views;
            if (glBaseLayer !== null) {
              renderer.setRenderTargetFramebuffer(newRenderTarget, glBaseLayer.framebuffer);
              renderer.setRenderTarget(newRenderTarget);
            }
            let cameraXRNeedsUpdate = false;
            if (views.length !== cameraXR.cameras.length) {
              cameraXR.cameras.length = 0;
              cameraXRNeedsUpdate = true;
            }
            for (let i2 = 0; i2 < views.length; i2++) {
              const view = views[i2];
              let viewport = null;
              if (glBaseLayer !== null) {
                viewport = glBaseLayer.getViewport(view);
              } else {
                const glSubImage = glBinding.getViewSubImage(glProjLayer, view);
                viewport = glSubImage.viewport;
                if (i2 === 0) {
                  renderer.setRenderTargetTextures(
                    newRenderTarget,
                    glSubImage.colorTexture,
                    glProjLayer.ignoreDepthValues ? void 0 : glSubImage.depthStencilTexture
                  );
                  renderer.setRenderTarget(newRenderTarget);
                }
              }
              let camera = cameras[i2];
              if (camera === void 0) {
                camera = new PerspectiveCamera();
                camera.layers.enable(i2);
                camera.viewport = new Vector4();
                cameras[i2] = camera;
              }
              camera.matrix.fromArray(view.transform.matrix);
              camera.matrix.decompose(camera.position, camera.quaternion, camera.scale);
              camera.projectionMatrix.fromArray(view.projectionMatrix);
              camera.projectionMatrixInverse.copy(camera.projectionMatrix).invert();
              camera.viewport.set(viewport.x, viewport.y, viewport.width, viewport.height);
              if (i2 === 0) {
                cameraXR.matrix.copy(camera.matrix);
                cameraXR.matrix.decompose(cameraXR.position, cameraXR.quaternion, cameraXR.scale);
              }
              if (cameraXRNeedsUpdate === true) {
                cameraXR.cameras.push(camera);
              }
            }
            const enabledFeatures = session.enabledFeatures;
            if (enabledFeatures && enabledFeatures.includes("depth-sensing")) {
              const depthData = glBinding.getDepthInformation(views[0]);
              if (depthData && depthData.isValid && depthData.texture) {
                depthSensing.init(renderer, depthData, session.renderState);
              }
            }
          }
          for (let i2 = 0; i2 < controllers.length; i2++) {
            const inputSource = controllerInputSources[i2];
            const controller = controllers[i2];
            if (inputSource !== null && controller !== void 0) {
              controller.update(inputSource, frame, customReferenceSpace || referenceSpace);
            }
          }
          if (onAnimationFrameCallback) onAnimationFrameCallback(time, frame);
          if (frame.detectedPlanes) {
            scope.dispatchEvent({ type: "planesdetected", data: frame });
          }
          xrFrame = null;
        }
        const animation = new WebGLAnimation();
        animation.setAnimationLoop(onAnimationFrame);
        this.setAnimationLoop = function(callback) {
          onAnimationFrameCallback = callback;
        };
        this.dispose = function() {
        };
      }
    };
    _e1 = /* @__PURE__ */ new Euler();
    _m1 = /* @__PURE__ */ new Matrix4();
    WebGLRenderer = class {
      constructor(parameters = {}) {
        const {
          canvas = createCanvasElement(),
          context: context2 = null,
          depth = true,
          stencil = false,
          alpha = false,
          antialias = false,
          premultipliedAlpha = true,
          preserveDrawingBuffer = false,
          powerPreference = "default",
          failIfMajorPerformanceCaveat = false
        } = parameters;
        this.isWebGLRenderer = true;
        let _alpha;
        if (context2 !== null) {
          if (typeof WebGLRenderingContext !== "undefined" && context2 instanceof WebGLRenderingContext) {
            throw new Error("THREE.WebGLRenderer: WebGL 1 is not supported since r163.");
          }
          _alpha = context2.getContextAttributes().alpha;
        } else {
          _alpha = alpha;
        }
        const uintClearColor = new Uint32Array(4);
        const intClearColor = new Int32Array(4);
        let currentRenderList = null;
        let currentRenderState = null;
        const renderListStack = [];
        const renderStateStack = [];
        this.domElement = canvas;
        this.debug = {
          /**
           * Enables error checking and reporting when shader programs are being compiled
           * @type {boolean}
           */
          checkShaderErrors: true,
          /**
           * Callback for custom error reporting.
           * @type {?Function}
           */
          onShaderError: null
        };
        this.autoClear = true;
        this.autoClearColor = true;
        this.autoClearDepth = true;
        this.autoClearStencil = true;
        this.sortObjects = true;
        this.clippingPlanes = [];
        this.localClippingEnabled = false;
        this._outputColorSpace = SRGBColorSpace;
        this.toneMapping = NoToneMapping;
        this.toneMappingExposure = 1;
        const _this = this;
        let _isContextLost = false;
        let _currentActiveCubeFace = 0;
        let _currentActiveMipmapLevel = 0;
        let _currentRenderTarget = null;
        let _currentMaterialId = -1;
        let _currentCamera = null;
        const _currentViewport = new Vector4();
        const _currentScissor = new Vector4();
        let _currentScissorTest = null;
        const _currentClearColor = new Color(0);
        let _currentClearAlpha = 0;
        let _width = canvas.width;
        let _height = canvas.height;
        let _pixelRatio = 1;
        let _opaqueSort = null;
        let _transparentSort = null;
        const _viewport = new Vector4(0, 0, _width, _height);
        const _scissor = new Vector4(0, 0, _width, _height);
        let _scissorTest = false;
        const _frustum2 = new Frustum();
        let _clippingEnabled = false;
        let _localClippingEnabled = false;
        const _currentProjectionMatrix = new Matrix4();
        const _projScreenMatrix2 = new Matrix4();
        const _vector32 = new Vector3();
        const _vector4 = new Vector4();
        const _emptyScene = { background: null, fog: null, environment: null, overrideMaterial: null, isScene: true };
        let _renderBackground = false;
        function getTargetPixelRatio() {
          return _currentRenderTarget === null ? _pixelRatio : 1;
        }
        let _gl = context2;
        function getContext(contextName, contextAttributes) {
          return canvas.getContext(contextName, contextAttributes);
        }
        try {
          const contextAttributes = {
            alpha: true,
            depth,
            stencil,
            antialias,
            premultipliedAlpha,
            preserveDrawingBuffer,
            powerPreference,
            failIfMajorPerformanceCaveat
          };
          if ("setAttribute" in canvas) canvas.setAttribute("data-engine", `three.js r${REVISION}`);
          canvas.addEventListener("webglcontextlost", onContextLost, false);
          canvas.addEventListener("webglcontextrestored", onContextRestore, false);
          canvas.addEventListener("webglcontextcreationerror", onContextCreationError, false);
          if (_gl === null) {
            const contextName = "webgl2";
            _gl = getContext(contextName, contextAttributes);
            if (_gl === null) {
              if (getContext(contextName)) {
                throw new Error("Error creating WebGL context with your selected attributes.");
              } else {
                throw new Error("Error creating WebGL context.");
              }
            }
          }
        } catch (error2) {
          console.error("THREE.WebGLRenderer: " + error2.message);
          throw error2;
        }
        let extensions, capabilities, state, info;
        let properties, textures, cubemaps, cubeuvmaps, attributes, geometries, objects;
        let programCache, materials, renderLists, renderStates, clipping, shadowMap;
        let background, morphtargets, bufferRenderer, indexedBufferRenderer;
        let utils, bindingStates, uniformsGroups;
        function initGLContext() {
          extensions = new WebGLExtensions(_gl);
          extensions.init();
          utils = new WebGLUtils(_gl, extensions);
          capabilities = new WebGLCapabilities(_gl, extensions, parameters, utils);
          state = new WebGLState(_gl);
          if (capabilities.reverseDepthBuffer) state.buffers.depth.setReversed(true);
          info = new WebGLInfo(_gl);
          properties = new WebGLProperties();
          textures = new WebGLTextures(_gl, extensions, state, properties, capabilities, utils, info);
          cubemaps = new WebGLCubeMaps(_this);
          cubeuvmaps = new WebGLCubeUVMaps(_this);
          attributes = new WebGLAttributes(_gl);
          bindingStates = new WebGLBindingStates(_gl, attributes);
          geometries = new WebGLGeometries(_gl, attributes, info, bindingStates);
          objects = new WebGLObjects(_gl, geometries, attributes, info);
          morphtargets = new WebGLMorphtargets(_gl, capabilities, textures);
          clipping = new WebGLClipping(properties);
          programCache = new WebGLPrograms(_this, cubemaps, cubeuvmaps, extensions, capabilities, bindingStates, clipping);
          materials = new WebGLMaterials(_this, properties);
          renderLists = new WebGLRenderLists();
          renderStates = new WebGLRenderStates(extensions);
          background = new WebGLBackground(_this, cubemaps, cubeuvmaps, state, objects, _alpha, premultipliedAlpha);
          shadowMap = new WebGLShadowMap(_this, objects, capabilities);
          uniformsGroups = new WebGLUniformsGroups(_gl, info, capabilities, state);
          bufferRenderer = new WebGLBufferRenderer(_gl, extensions, info);
          indexedBufferRenderer = new WebGLIndexedBufferRenderer(_gl, extensions, info);
          info.programs = programCache.programs;
          _this.capabilities = capabilities;
          _this.extensions = extensions;
          _this.properties = properties;
          _this.renderLists = renderLists;
          _this.shadowMap = shadowMap;
          _this.state = state;
          _this.info = info;
        }
        initGLContext();
        const xr = new WebXRManager(_this, _gl);
        this.xr = xr;
        this.getContext = function() {
          return _gl;
        };
        this.getContextAttributes = function() {
          return _gl.getContextAttributes();
        };
        this.forceContextLoss = function() {
          const extension = extensions.get("WEBGL_lose_context");
          if (extension) extension.loseContext();
        };
        this.forceContextRestore = function() {
          const extension = extensions.get("WEBGL_lose_context");
          if (extension) extension.restoreContext();
        };
        this.getPixelRatio = function() {
          return _pixelRatio;
        };
        this.setPixelRatio = function(value) {
          if (value === void 0) return;
          _pixelRatio = value;
          this.setSize(_width, _height, false);
        };
        this.getSize = function(target2) {
          return target2.set(_width, _height);
        };
        this.setSize = function(width, height, updateStyle = true) {
          if (xr.isPresenting) {
            console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.");
            return;
          }
          _width = width;
          _height = height;
          canvas.width = Math.floor(width * _pixelRatio);
          canvas.height = Math.floor(height * _pixelRatio);
          if (updateStyle === true) {
            canvas.style.width = width + "px";
            canvas.style.height = height + "px";
          }
          this.setViewport(0, 0, width, height);
        };
        this.getDrawingBufferSize = function(target2) {
          return target2.set(_width * _pixelRatio, _height * _pixelRatio).floor();
        };
        this.setDrawingBufferSize = function(width, height, pixelRatio) {
          _width = width;
          _height = height;
          _pixelRatio = pixelRatio;
          canvas.width = Math.floor(width * pixelRatio);
          canvas.height = Math.floor(height * pixelRatio);
          this.setViewport(0, 0, width, height);
        };
        this.getCurrentViewport = function(target2) {
          return target2.copy(_currentViewport);
        };
        this.getViewport = function(target2) {
          return target2.copy(_viewport);
        };
        this.setViewport = function(x, y2, width, height) {
          if (x.isVector4) {
            _viewport.set(x.x, x.y, x.z, x.w);
          } else {
            _viewport.set(x, y2, width, height);
          }
          state.viewport(_currentViewport.copy(_viewport).multiplyScalar(_pixelRatio).round());
        };
        this.getScissor = function(target2) {
          return target2.copy(_scissor);
        };
        this.setScissor = function(x, y2, width, height) {
          if (x.isVector4) {
            _scissor.set(x.x, x.y, x.z, x.w);
          } else {
            _scissor.set(x, y2, width, height);
          }
          state.scissor(_currentScissor.copy(_scissor).multiplyScalar(_pixelRatio).round());
        };
        this.getScissorTest = function() {
          return _scissorTest;
        };
        this.setScissorTest = function(boolean) {
          state.setScissorTest(_scissorTest = boolean);
        };
        this.setOpaqueSort = function(method) {
          _opaqueSort = method;
        };
        this.setTransparentSort = function(method) {
          _transparentSort = method;
        };
        this.getClearColor = function(target2) {
          return target2.copy(background.getClearColor());
        };
        this.setClearColor = function() {
          background.setClearColor.apply(background, arguments);
        };
        this.getClearAlpha = function() {
          return background.getClearAlpha();
        };
        this.setClearAlpha = function() {
          background.setClearAlpha.apply(background, arguments);
        };
        this.clear = function(color = true, depth2 = true, stencil2 = true) {
          let bits = 0;
          if (color) {
            let isIntegerFormat = false;
            if (_currentRenderTarget !== null) {
              const targetFormat = _currentRenderTarget.texture.format;
              isIntegerFormat = targetFormat === RGBAIntegerFormat || targetFormat === RGIntegerFormat || targetFormat === RedIntegerFormat;
            }
            if (isIntegerFormat) {
              const targetType = _currentRenderTarget.texture.type;
              const isUnsignedType = targetType === UnsignedByteType || targetType === UnsignedIntType || targetType === UnsignedShortType || targetType === UnsignedInt248Type || targetType === UnsignedShort4444Type || targetType === UnsignedShort5551Type;
              const clearColor = background.getClearColor();
              const a = background.getClearAlpha();
              const r2 = clearColor.r;
              const g3 = clearColor.g;
              const b = clearColor.b;
              if (isUnsignedType) {
                uintClearColor[0] = r2;
                uintClearColor[1] = g3;
                uintClearColor[2] = b;
                uintClearColor[3] = a;
                _gl.clearBufferuiv(_gl.COLOR, 0, uintClearColor);
              } else {
                intClearColor[0] = r2;
                intClearColor[1] = g3;
                intClearColor[2] = b;
                intClearColor[3] = a;
                _gl.clearBufferiv(_gl.COLOR, 0, intClearColor);
              }
            } else {
              bits |= _gl.COLOR_BUFFER_BIT;
            }
          }
          if (depth2) {
            bits |= _gl.DEPTH_BUFFER_BIT;
            _gl.clearDepth(this.capabilities.reverseDepthBuffer ? 0 : 1);
          }
          if (stencil2) {
            bits |= _gl.STENCIL_BUFFER_BIT;
            this.state.buffers.stencil.setMask(4294967295);
          }
          _gl.clear(bits);
        };
        this.clearColor = function() {
          this.clear(true, false, false);
        };
        this.clearDepth = function() {
          this.clear(false, true, false);
        };
        this.clearStencil = function() {
          this.clear(false, false, true);
        };
        this.dispose = function() {
          canvas.removeEventListener("webglcontextlost", onContextLost, false);
          canvas.removeEventListener("webglcontextrestored", onContextRestore, false);
          canvas.removeEventListener("webglcontextcreationerror", onContextCreationError, false);
          renderLists.dispose();
          renderStates.dispose();
          properties.dispose();
          cubemaps.dispose();
          cubeuvmaps.dispose();
          objects.dispose();
          bindingStates.dispose();
          uniformsGroups.dispose();
          programCache.dispose();
          xr.dispose();
          xr.removeEventListener("sessionstart", onXRSessionStart);
          xr.removeEventListener("sessionend", onXRSessionEnd);
          animation.stop();
        };
        function onContextLost(event) {
          event.preventDefault();
          console.log("THREE.WebGLRenderer: Context Lost.");
          _isContextLost = true;
        }
        function onContextRestore() {
          console.log("THREE.WebGLRenderer: Context Restored.");
          _isContextLost = false;
          const infoAutoReset = info.autoReset;
          const shadowMapEnabled = shadowMap.enabled;
          const shadowMapAutoUpdate = shadowMap.autoUpdate;
          const shadowMapNeedsUpdate = shadowMap.needsUpdate;
          const shadowMapType = shadowMap.type;
          initGLContext();
          info.autoReset = infoAutoReset;
          shadowMap.enabled = shadowMapEnabled;
          shadowMap.autoUpdate = shadowMapAutoUpdate;
          shadowMap.needsUpdate = shadowMapNeedsUpdate;
          shadowMap.type = shadowMapType;
        }
        function onContextCreationError(event) {
          console.error("THREE.WebGLRenderer: A WebGL context could not be created. Reason: ", event.statusMessage);
        }
        function onMaterialDispose(event) {
          const material = event.target;
          material.removeEventListener("dispose", onMaterialDispose);
          deallocateMaterial(material);
        }
        function deallocateMaterial(material) {
          releaseMaterialProgramReferences(material);
          properties.remove(material);
        }
        function releaseMaterialProgramReferences(material) {
          const programs = properties.get(material).programs;
          if (programs !== void 0) {
            programs.forEach(function(program) {
              programCache.releaseProgram(program);
            });
            if (material.isShaderMaterial) {
              programCache.releaseShaderCache(material);
            }
          }
        }
        this.renderBufferDirect = function(camera, scene, geometry, material, object, group) {
          if (scene === null) scene = _emptyScene;
          const frontFaceCW = object.isMesh && object.matrixWorld.determinant() < 0;
          const program = setProgram(camera, scene, geometry, material, object);
          state.setMaterial(material, frontFaceCW);
          let index = geometry.index;
          let rangeFactor = 1;
          if (material.wireframe === true) {
            index = geometries.getWireframeAttribute(geometry);
            if (index === void 0) return;
            rangeFactor = 2;
          }
          const drawRange = geometry.drawRange;
          const position = geometry.attributes.position;
          let drawStart = drawRange.start * rangeFactor;
          let drawEnd = (drawRange.start + drawRange.count) * rangeFactor;
          if (group !== null) {
            drawStart = Math.max(drawStart, group.start * rangeFactor);
            drawEnd = Math.min(drawEnd, (group.start + group.count) * rangeFactor);
          }
          if (index !== null) {
            drawStart = Math.max(drawStart, 0);
            drawEnd = Math.min(drawEnd, index.count);
          } else if (position !== void 0 && position !== null) {
            drawStart = Math.max(drawStart, 0);
            drawEnd = Math.min(drawEnd, position.count);
          }
          const drawCount = drawEnd - drawStart;
          if (drawCount < 0 || drawCount === Infinity) return;
          bindingStates.setup(object, material, program, geometry, index);
          let attribute;
          let renderer = bufferRenderer;
          if (index !== null) {
            attribute = attributes.get(index);
            renderer = indexedBufferRenderer;
            renderer.setIndex(attribute);
          }
          if (object.isMesh) {
            if (material.wireframe === true) {
              state.setLineWidth(material.wireframeLinewidth * getTargetPixelRatio());
              renderer.setMode(_gl.LINES);
            } else {
              renderer.setMode(_gl.TRIANGLES);
            }
          } else if (object.isLine) {
            let lineWidth = material.linewidth;
            if (lineWidth === void 0) lineWidth = 1;
            state.setLineWidth(lineWidth * getTargetPixelRatio());
            if (object.isLineSegments) {
              renderer.setMode(_gl.LINES);
            } else if (object.isLineLoop) {
              renderer.setMode(_gl.LINE_LOOP);
            } else {
              renderer.setMode(_gl.LINE_STRIP);
            }
          } else if (object.isPoints) {
            renderer.setMode(_gl.POINTS);
          } else if (object.isSprite) {
            renderer.setMode(_gl.TRIANGLES);
          }
          if (object.isBatchedMesh) {
            if (object._multiDrawInstances !== null) {
              renderer.renderMultiDrawInstances(object._multiDrawStarts, object._multiDrawCounts, object._multiDrawCount, object._multiDrawInstances);
            } else {
              if (!extensions.get("WEBGL_multi_draw")) {
                const starts = object._multiDrawStarts;
                const counts = object._multiDrawCounts;
                const drawCount2 = object._multiDrawCount;
                const bytesPerElement = index ? attributes.get(index).bytesPerElement : 1;
                const uniforms = properties.get(material).currentProgram.getUniforms();
                for (let i2 = 0; i2 < drawCount2; i2++) {
                  uniforms.setValue(_gl, "_gl_DrawID", i2);
                  renderer.render(starts[i2] / bytesPerElement, counts[i2]);
                }
              } else {
                renderer.renderMultiDraw(object._multiDrawStarts, object._multiDrawCounts, object._multiDrawCount);
              }
            }
          } else if (object.isInstancedMesh) {
            renderer.renderInstances(drawStart, drawCount, object.count);
          } else if (geometry.isInstancedBufferGeometry) {
            const maxInstanceCount = geometry._maxInstanceCount !== void 0 ? geometry._maxInstanceCount : Infinity;
            const instanceCount = Math.min(geometry.instanceCount, maxInstanceCount);
            renderer.renderInstances(drawStart, drawCount, instanceCount);
          } else {
            renderer.render(drawStart, drawCount);
          }
        };
        function prepareMaterial(material, scene, object) {
          if (material.transparent === true && material.side === DoubleSide && material.forceSinglePass === false) {
            material.side = BackSide;
            material.needsUpdate = true;
            getProgram(material, scene, object);
            material.side = FrontSide;
            material.needsUpdate = true;
            getProgram(material, scene, object);
            material.side = DoubleSide;
          } else {
            getProgram(material, scene, object);
          }
        }
        this.compile = function(scene, camera, targetScene = null) {
          if (targetScene === null) targetScene = scene;
          currentRenderState = renderStates.get(targetScene);
          currentRenderState.init(camera);
          renderStateStack.push(currentRenderState);
          targetScene.traverseVisible(function(object) {
            if (object.isLight && object.layers.test(camera.layers)) {
              currentRenderState.pushLight(object);
              if (object.castShadow) {
                currentRenderState.pushShadow(object);
              }
            }
          });
          if (scene !== targetScene) {
            scene.traverseVisible(function(object) {
              if (object.isLight && object.layers.test(camera.layers)) {
                currentRenderState.pushLight(object);
                if (object.castShadow) {
                  currentRenderState.pushShadow(object);
                }
              }
            });
          }
          currentRenderState.setupLights();
          const materials2 = /* @__PURE__ */ new Set();
          scene.traverse(function(object) {
            if (!(object.isMesh || object.isPoints || object.isLine || object.isSprite)) {
              return;
            }
            const material = object.material;
            if (material) {
              if (Array.isArray(material)) {
                for (let i2 = 0; i2 < material.length; i2++) {
                  const material2 = material[i2];
                  prepareMaterial(material2, targetScene, object);
                  materials2.add(material2);
                }
              } else {
                prepareMaterial(material, targetScene, object);
                materials2.add(material);
              }
            }
          });
          renderStateStack.pop();
          currentRenderState = null;
          return materials2;
        };
        this.compileAsync = function(scene, camera, targetScene = null) {
          const materials2 = this.compile(scene, camera, targetScene);
          return new Promise((resolve2) => {
            function checkMaterialsReady() {
              materials2.forEach(function(material) {
                const materialProperties = properties.get(material);
                const program = materialProperties.currentProgram;
                if (program.isReady()) {
                  materials2.delete(material);
                }
              });
              if (materials2.size === 0) {
                resolve2(scene);
                return;
              }
              setTimeout(checkMaterialsReady, 10);
            }
            if (extensions.get("KHR_parallel_shader_compile") !== null) {
              checkMaterialsReady();
            } else {
              setTimeout(checkMaterialsReady, 10);
            }
          });
        };
        let onAnimationFrameCallback = null;
        function onAnimationFrame(time) {
          if (onAnimationFrameCallback) onAnimationFrameCallback(time);
        }
        function onXRSessionStart() {
          animation.stop();
        }
        function onXRSessionEnd() {
          animation.start();
        }
        const animation = new WebGLAnimation();
        animation.setAnimationLoop(onAnimationFrame);
        if (typeof self !== "undefined") animation.setContext(self);
        this.setAnimationLoop = function(callback) {
          onAnimationFrameCallback = callback;
          xr.setAnimationLoop(callback);
          callback === null ? animation.stop() : animation.start();
        };
        xr.addEventListener("sessionstart", onXRSessionStart);
        xr.addEventListener("sessionend", onXRSessionEnd);
        this.render = function(scene, camera) {
          if (camera !== void 0 && camera.isCamera !== true) {
            console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
            return;
          }
          if (_isContextLost === true) return;
          if (scene.matrixWorldAutoUpdate === true) scene.updateMatrixWorld();
          if (camera.parent === null && camera.matrixWorldAutoUpdate === true) camera.updateMatrixWorld();
          if (xr.enabled === true && xr.isPresenting === true) {
            if (xr.cameraAutoUpdate === true) xr.updateCamera(camera);
            camera = xr.getCamera();
          }
          if (scene.isScene === true) scene.onBeforeRender(_this, scene, camera, _currentRenderTarget);
          currentRenderState = renderStates.get(scene, renderStateStack.length);
          currentRenderState.init(camera);
          renderStateStack.push(currentRenderState);
          _projScreenMatrix2.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);
          _frustum2.setFromProjectionMatrix(_projScreenMatrix2);
          _localClippingEnabled = this.localClippingEnabled;
          _clippingEnabled = clipping.init(this.clippingPlanes, _localClippingEnabled);
          currentRenderList = renderLists.get(scene, renderListStack.length);
          currentRenderList.init();
          renderListStack.push(currentRenderList);
          if (xr.enabled === true && xr.isPresenting === true) {
            const depthSensingMesh = _this.xr.getDepthSensingMesh();
            if (depthSensingMesh !== null) {
              projectObject(depthSensingMesh, camera, -Infinity, _this.sortObjects);
            }
          }
          projectObject(scene, camera, 0, _this.sortObjects);
          currentRenderList.finish();
          if (_this.sortObjects === true) {
            currentRenderList.sort(_opaqueSort, _transparentSort);
          }
          _renderBackground = xr.enabled === false || xr.isPresenting === false || xr.hasDepthSensing() === false;
          if (_renderBackground) {
            background.addToRenderList(currentRenderList, scene);
          }
          this.info.render.frame++;
          if (_clippingEnabled === true) clipping.beginShadows();
          const shadowsArray = currentRenderState.state.shadowsArray;
          shadowMap.render(shadowsArray, scene, camera);
          if (_clippingEnabled === true) clipping.endShadows();
          if (this.info.autoReset === true) this.info.reset();
          const opaqueObjects = currentRenderList.opaque;
          const transmissiveObjects = currentRenderList.transmissive;
          currentRenderState.setupLights();
          if (camera.isArrayCamera) {
            const cameras = camera.cameras;
            if (transmissiveObjects.length > 0) {
              for (let i2 = 0, l2 = cameras.length; i2 < l2; i2++) {
                const camera2 = cameras[i2];
                renderTransmissionPass(opaqueObjects, transmissiveObjects, scene, camera2);
              }
            }
            if (_renderBackground) background.render(scene);
            for (let i2 = 0, l2 = cameras.length; i2 < l2; i2++) {
              const camera2 = cameras[i2];
              renderScene(currentRenderList, scene, camera2, camera2.viewport);
            }
          } else {
            if (transmissiveObjects.length > 0) renderTransmissionPass(opaqueObjects, transmissiveObjects, scene, camera);
            if (_renderBackground) background.render(scene);
            renderScene(currentRenderList, scene, camera);
          }
          if (_currentRenderTarget !== null) {
            textures.updateMultisampleRenderTarget(_currentRenderTarget);
            textures.updateRenderTargetMipmap(_currentRenderTarget);
          }
          if (scene.isScene === true) scene.onAfterRender(_this, scene, camera);
          bindingStates.resetDefaultState();
          _currentMaterialId = -1;
          _currentCamera = null;
          renderStateStack.pop();
          if (renderStateStack.length > 0) {
            currentRenderState = renderStateStack[renderStateStack.length - 1];
            if (_clippingEnabled === true) clipping.setGlobalState(_this.clippingPlanes, currentRenderState.state.camera);
          } else {
            currentRenderState = null;
          }
          renderListStack.pop();
          if (renderListStack.length > 0) {
            currentRenderList = renderListStack[renderListStack.length - 1];
          } else {
            currentRenderList = null;
          }
        };
        function projectObject(object, camera, groupOrder, sortObjects) {
          if (object.visible === false) return;
          const visible = object.layers.test(camera.layers);
          if (visible) {
            if (object.isGroup) {
              groupOrder = object.renderOrder;
            } else if (object.isLOD) {
              if (object.autoUpdate === true) object.update(camera);
            } else if (object.isLight) {
              currentRenderState.pushLight(object);
              if (object.castShadow) {
                currentRenderState.pushShadow(object);
              }
            } else if (object.isSprite) {
              if (!object.frustumCulled || _frustum2.intersectsSprite(object)) {
                if (sortObjects) {
                  _vector4.setFromMatrixPosition(object.matrixWorld).applyMatrix4(_projScreenMatrix2);
                }
                const geometry = objects.update(object);
                const material = object.material;
                if (material.visible) {
                  currentRenderList.push(object, geometry, material, groupOrder, _vector4.z, null);
                }
              }
            } else if (object.isMesh || object.isLine || object.isPoints) {
              if (!object.frustumCulled || _frustum2.intersectsObject(object)) {
                const geometry = objects.update(object);
                const material = object.material;
                if (sortObjects) {
                  if (object.boundingSphere !== void 0) {
                    if (object.boundingSphere === null) object.computeBoundingSphere();
                    _vector4.copy(object.boundingSphere.center);
                  } else {
                    if (geometry.boundingSphere === null) geometry.computeBoundingSphere();
                    _vector4.copy(geometry.boundingSphere.center);
                  }
                  _vector4.applyMatrix4(object.matrixWorld).applyMatrix4(_projScreenMatrix2);
                }
                if (Array.isArray(material)) {
                  const groups = geometry.groups;
                  for (let i2 = 0, l2 = groups.length; i2 < l2; i2++) {
                    const group = groups[i2];
                    const groupMaterial = material[group.materialIndex];
                    if (groupMaterial && groupMaterial.visible) {
                      currentRenderList.push(object, geometry, groupMaterial, groupOrder, _vector4.z, group);
                    }
                  }
                } else if (material.visible) {
                  currentRenderList.push(object, geometry, material, groupOrder, _vector4.z, null);
                }
              }
            }
          }
          const children = object.children;
          for (let i2 = 0, l2 = children.length; i2 < l2; i2++) {
            projectObject(children[i2], camera, groupOrder, sortObjects);
          }
        }
        function renderScene(currentRenderList2, scene, camera, viewport) {
          const opaqueObjects = currentRenderList2.opaque;
          const transmissiveObjects = currentRenderList2.transmissive;
          const transparentObjects = currentRenderList2.transparent;
          currentRenderState.setupLightsView(camera);
          if (_clippingEnabled === true) clipping.setGlobalState(_this.clippingPlanes, camera);
          if (viewport) state.viewport(_currentViewport.copy(viewport));
          if (opaqueObjects.length > 0) renderObjects(opaqueObjects, scene, camera);
          if (transmissiveObjects.length > 0) renderObjects(transmissiveObjects, scene, camera);
          if (transparentObjects.length > 0) renderObjects(transparentObjects, scene, camera);
          state.buffers.depth.setTest(true);
          state.buffers.depth.setMask(true);
          state.buffers.color.setMask(true);
          state.setPolygonOffset(false);
        }
        function renderTransmissionPass(opaqueObjects, transmissiveObjects, scene, camera) {
          const overrideMaterial = scene.isScene === true ? scene.overrideMaterial : null;
          if (overrideMaterial !== null) {
            return;
          }
          if (currentRenderState.state.transmissionRenderTarget[camera.id] === void 0) {
            currentRenderState.state.transmissionRenderTarget[camera.id] = new WebGLRenderTarget(1, 1, {
              generateMipmaps: true,
              type: extensions.has("EXT_color_buffer_half_float") || extensions.has("EXT_color_buffer_float") ? HalfFloatType : UnsignedByteType,
              minFilter: LinearMipmapLinearFilter,
              samples: 4,
              stencilBuffer: stencil,
              resolveDepthBuffer: false,
              resolveStencilBuffer: false,
              colorSpace: ColorManagement.workingColorSpace
            });
          }
          const transmissionRenderTarget = currentRenderState.state.transmissionRenderTarget[camera.id];
          const activeViewport = camera.viewport || _currentViewport;
          transmissionRenderTarget.setSize(activeViewport.z, activeViewport.w);
          const currentRenderTarget = _this.getRenderTarget();
          _this.setRenderTarget(transmissionRenderTarget);
          _this.getClearColor(_currentClearColor);
          _currentClearAlpha = _this.getClearAlpha();
          if (_currentClearAlpha < 1) _this.setClearColor(16777215, 0.5);
          _this.clear();
          if (_renderBackground) background.render(scene);
          const currentToneMapping = _this.toneMapping;
          _this.toneMapping = NoToneMapping;
          const currentCameraViewport = camera.viewport;
          if (camera.viewport !== void 0) camera.viewport = void 0;
          currentRenderState.setupLightsView(camera);
          if (_clippingEnabled === true) clipping.setGlobalState(_this.clippingPlanes, camera);
          renderObjects(opaqueObjects, scene, camera);
          textures.updateMultisampleRenderTarget(transmissionRenderTarget);
          textures.updateRenderTargetMipmap(transmissionRenderTarget);
          if (extensions.has("WEBGL_multisampled_render_to_texture") === false) {
            let renderTargetNeedsUpdate = false;
            for (let i2 = 0, l2 = transmissiveObjects.length; i2 < l2; i2++) {
              const renderItem = transmissiveObjects[i2];
              const object = renderItem.object;
              const geometry = renderItem.geometry;
              const material = renderItem.material;
              const group = renderItem.group;
              if (material.side === DoubleSide && object.layers.test(camera.layers)) {
                const currentSide = material.side;
                material.side = BackSide;
                material.needsUpdate = true;
                renderObject(object, scene, camera, geometry, material, group);
                material.side = currentSide;
                material.needsUpdate = true;
                renderTargetNeedsUpdate = true;
              }
            }
            if (renderTargetNeedsUpdate === true) {
              textures.updateMultisampleRenderTarget(transmissionRenderTarget);
              textures.updateRenderTargetMipmap(transmissionRenderTarget);
            }
          }
          _this.setRenderTarget(currentRenderTarget);
          _this.setClearColor(_currentClearColor, _currentClearAlpha);
          if (currentCameraViewport !== void 0) camera.viewport = currentCameraViewport;
          _this.toneMapping = currentToneMapping;
        }
        function renderObjects(renderList, scene, camera) {
          const overrideMaterial = scene.isScene === true ? scene.overrideMaterial : null;
          for (let i2 = 0, l2 = renderList.length; i2 < l2; i2++) {
            const renderItem = renderList[i2];
            const object = renderItem.object;
            const geometry = renderItem.geometry;
            const material = overrideMaterial === null ? renderItem.material : overrideMaterial;
            const group = renderItem.group;
            if (object.layers.test(camera.layers)) {
              renderObject(object, scene, camera, geometry, material, group);
            }
          }
        }
        function renderObject(object, scene, camera, geometry, material, group) {
          object.onBeforeRender(_this, scene, camera, geometry, material, group);
          object.modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse, object.matrixWorld);
          object.normalMatrix.getNormalMatrix(object.modelViewMatrix);
          material.onBeforeRender(_this, scene, camera, geometry, object, group);
          if (material.transparent === true && material.side === DoubleSide && material.forceSinglePass === false) {
            material.side = BackSide;
            material.needsUpdate = true;
            _this.renderBufferDirect(camera, scene, geometry, material, object, group);
            material.side = FrontSide;
            material.needsUpdate = true;
            _this.renderBufferDirect(camera, scene, geometry, material, object, group);
            material.side = DoubleSide;
          } else {
            _this.renderBufferDirect(camera, scene, geometry, material, object, group);
          }
          object.onAfterRender(_this, scene, camera, geometry, material, group);
        }
        function getProgram(material, scene, object) {
          if (scene.isScene !== true) scene = _emptyScene;
          const materialProperties = properties.get(material);
          const lights = currentRenderState.state.lights;
          const shadowsArray = currentRenderState.state.shadowsArray;
          const lightsStateVersion = lights.state.version;
          const parameters2 = programCache.getParameters(material, lights.state, shadowsArray, scene, object);
          const programCacheKey = programCache.getProgramCacheKey(parameters2);
          let programs = materialProperties.programs;
          materialProperties.environment = material.isMeshStandardMaterial ? scene.environment : null;
          materialProperties.fog = scene.fog;
          materialProperties.envMap = (material.isMeshStandardMaterial ? cubeuvmaps : cubemaps).get(material.envMap || materialProperties.environment);
          materialProperties.envMapRotation = materialProperties.environment !== null && material.envMap === null ? scene.environmentRotation : material.envMapRotation;
          if (programs === void 0) {
            material.addEventListener("dispose", onMaterialDispose);
            programs = /* @__PURE__ */ new Map();
            materialProperties.programs = programs;
          }
          let program = programs.get(programCacheKey);
          if (program !== void 0) {
            if (materialProperties.currentProgram === program && materialProperties.lightsStateVersion === lightsStateVersion) {
              updateCommonMaterialProperties(material, parameters2);
              return program;
            }
          } else {
            parameters2.uniforms = programCache.getUniforms(material);
            material.onBeforeCompile(parameters2, _this);
            program = programCache.acquireProgram(parameters2, programCacheKey);
            programs.set(programCacheKey, program);
            materialProperties.uniforms = parameters2.uniforms;
          }
          const uniforms = materialProperties.uniforms;
          if (!material.isShaderMaterial && !material.isRawShaderMaterial || material.clipping === true) {
            uniforms.clippingPlanes = clipping.uniform;
          }
          updateCommonMaterialProperties(material, parameters2);
          materialProperties.needsLights = materialNeedsLights(material);
          materialProperties.lightsStateVersion = lightsStateVersion;
          if (materialProperties.needsLights) {
            uniforms.ambientLightColor.value = lights.state.ambient;
            uniforms.lightProbe.value = lights.state.probe;
            uniforms.directionalLights.value = lights.state.directional;
            uniforms.directionalLightShadows.value = lights.state.directionalShadow;
            uniforms.spotLights.value = lights.state.spot;
            uniforms.spotLightShadows.value = lights.state.spotShadow;
            uniforms.rectAreaLights.value = lights.state.rectArea;
            uniforms.ltc_1.value = lights.state.rectAreaLTC1;
            uniforms.ltc_2.value = lights.state.rectAreaLTC2;
            uniforms.pointLights.value = lights.state.point;
            uniforms.pointLightShadows.value = lights.state.pointShadow;
            uniforms.hemisphereLights.value = lights.state.hemi;
            uniforms.directionalShadowMap.value = lights.state.directionalShadowMap;
            uniforms.directionalShadowMatrix.value = lights.state.directionalShadowMatrix;
            uniforms.spotShadowMap.value = lights.state.spotShadowMap;
            uniforms.spotLightMatrix.value = lights.state.spotLightMatrix;
            uniforms.spotLightMap.value = lights.state.spotLightMap;
            uniforms.pointShadowMap.value = lights.state.pointShadowMap;
            uniforms.pointShadowMatrix.value = lights.state.pointShadowMatrix;
          }
          materialProperties.currentProgram = program;
          materialProperties.uniformsList = null;
          return program;
        }
        function getUniformList(materialProperties) {
          if (materialProperties.uniformsList === null) {
            const progUniforms = materialProperties.currentProgram.getUniforms();
            materialProperties.uniformsList = WebGLUniforms.seqWithValue(progUniforms.seq, materialProperties.uniforms);
          }
          return materialProperties.uniformsList;
        }
        function updateCommonMaterialProperties(material, parameters2) {
          const materialProperties = properties.get(material);
          materialProperties.outputColorSpace = parameters2.outputColorSpace;
          materialProperties.batching = parameters2.batching;
          materialProperties.batchingColor = parameters2.batchingColor;
          materialProperties.instancing = parameters2.instancing;
          materialProperties.instancingColor = parameters2.instancingColor;
          materialProperties.instancingMorph = parameters2.instancingMorph;
          materialProperties.skinning = parameters2.skinning;
          materialProperties.morphTargets = parameters2.morphTargets;
          materialProperties.morphNormals = parameters2.morphNormals;
          materialProperties.morphColors = parameters2.morphColors;
          materialProperties.morphTargetsCount = parameters2.morphTargetsCount;
          materialProperties.numClippingPlanes = parameters2.numClippingPlanes;
          materialProperties.numIntersection = parameters2.numClipIntersection;
          materialProperties.vertexAlphas = parameters2.vertexAlphas;
          materialProperties.vertexTangents = parameters2.vertexTangents;
          materialProperties.toneMapping = parameters2.toneMapping;
        }
        function setProgram(camera, scene, geometry, material, object) {
          if (scene.isScene !== true) scene = _emptyScene;
          textures.resetTextureUnits();
          const fog = scene.fog;
          const environment = material.isMeshStandardMaterial ? scene.environment : null;
          const colorSpace = _currentRenderTarget === null ? _this.outputColorSpace : _currentRenderTarget.isXRRenderTarget === true ? _currentRenderTarget.texture.colorSpace : LinearSRGBColorSpace;
          const envMap = (material.isMeshStandardMaterial ? cubeuvmaps : cubemaps).get(material.envMap || environment);
          const vertexAlphas = material.vertexColors === true && !!geometry.attributes.color && geometry.attributes.color.itemSize === 4;
          const vertexTangents = !!geometry.attributes.tangent && (!!material.normalMap || material.anisotropy > 0);
          const morphTargets = !!geometry.morphAttributes.position;
          const morphNormals = !!geometry.morphAttributes.normal;
          const morphColors = !!geometry.morphAttributes.color;
          let toneMapping = NoToneMapping;
          if (material.toneMapped) {
            if (_currentRenderTarget === null || _currentRenderTarget.isXRRenderTarget === true) {
              toneMapping = _this.toneMapping;
            }
          }
          const morphAttribute = geometry.morphAttributes.position || geometry.morphAttributes.normal || geometry.morphAttributes.color;
          const morphTargetsCount = morphAttribute !== void 0 ? morphAttribute.length : 0;
          const materialProperties = properties.get(material);
          const lights = currentRenderState.state.lights;
          if (_clippingEnabled === true) {
            if (_localClippingEnabled === true || camera !== _currentCamera) {
              const useCache = camera === _currentCamera && material.id === _currentMaterialId;
              clipping.setState(material, camera, useCache);
            }
          }
          let needsProgramChange = false;
          if (material.version === materialProperties.__version) {
            if (materialProperties.needsLights && materialProperties.lightsStateVersion !== lights.state.version) {
              needsProgramChange = true;
            } else if (materialProperties.outputColorSpace !== colorSpace) {
              needsProgramChange = true;
            } else if (object.isBatchedMesh && materialProperties.batching === false) {
              needsProgramChange = true;
            } else if (!object.isBatchedMesh && materialProperties.batching === true) {
              needsProgramChange = true;
            } else if (object.isBatchedMesh && materialProperties.batchingColor === true && object.colorTexture === null) {
              needsProgramChange = true;
            } else if (object.isBatchedMesh && materialProperties.batchingColor === false && object.colorTexture !== null) {
              needsProgramChange = true;
            } else if (object.isInstancedMesh && materialProperties.instancing === false) {
              needsProgramChange = true;
            } else if (!object.isInstancedMesh && materialProperties.instancing === true) {
              needsProgramChange = true;
            } else if (object.isSkinnedMesh && materialProperties.skinning === false) {
              needsProgramChange = true;
            } else if (!object.isSkinnedMesh && materialProperties.skinning === true) {
              needsProgramChange = true;
            } else if (object.isInstancedMesh && materialProperties.instancingColor === true && object.instanceColor === null) {
              needsProgramChange = true;
            } else if (object.isInstancedMesh && materialProperties.instancingColor === false && object.instanceColor !== null) {
              needsProgramChange = true;
            } else if (object.isInstancedMesh && materialProperties.instancingMorph === true && object.morphTexture === null) {
              needsProgramChange = true;
            } else if (object.isInstancedMesh && materialProperties.instancingMorph === false && object.morphTexture !== null) {
              needsProgramChange = true;
            } else if (materialProperties.envMap !== envMap) {
              needsProgramChange = true;
            } else if (material.fog === true && materialProperties.fog !== fog) {
              needsProgramChange = true;
            } else if (materialProperties.numClippingPlanes !== void 0 && (materialProperties.numClippingPlanes !== clipping.numPlanes || materialProperties.numIntersection !== clipping.numIntersection)) {
              needsProgramChange = true;
            } else if (materialProperties.vertexAlphas !== vertexAlphas) {
              needsProgramChange = true;
            } else if (materialProperties.vertexTangents !== vertexTangents) {
              needsProgramChange = true;
            } else if (materialProperties.morphTargets !== morphTargets) {
              needsProgramChange = true;
            } else if (materialProperties.morphNormals !== morphNormals) {
              needsProgramChange = true;
            } else if (materialProperties.morphColors !== morphColors) {
              needsProgramChange = true;
            } else if (materialProperties.toneMapping !== toneMapping) {
              needsProgramChange = true;
            } else if (materialProperties.morphTargetsCount !== morphTargetsCount) {
              needsProgramChange = true;
            }
          } else {
            needsProgramChange = true;
            materialProperties.__version = material.version;
          }
          let program = materialProperties.currentProgram;
          if (needsProgramChange === true) {
            program = getProgram(material, scene, object);
          }
          let refreshProgram = false;
          let refreshMaterial = false;
          let refreshLights = false;
          const p_uniforms = program.getUniforms(), m_uniforms = materialProperties.uniforms;
          if (state.useProgram(program.program)) {
            refreshProgram = true;
            refreshMaterial = true;
            refreshLights = true;
          }
          if (material.id !== _currentMaterialId) {
            _currentMaterialId = material.id;
            refreshMaterial = true;
          }
          if (refreshProgram || _currentCamera !== camera) {
            if (capabilities.reverseDepthBuffer) {
              _currentProjectionMatrix.copy(camera.projectionMatrix);
              toNormalizedProjectionMatrix(_currentProjectionMatrix);
              toReversedProjectionMatrix(_currentProjectionMatrix);
              p_uniforms.setValue(_gl, "projectionMatrix", _currentProjectionMatrix);
            } else {
              p_uniforms.setValue(_gl, "projectionMatrix", camera.projectionMatrix);
            }
            p_uniforms.setValue(_gl, "viewMatrix", camera.matrixWorldInverse);
            const uCamPos = p_uniforms.map.cameraPosition;
            if (uCamPos !== void 0) {
              uCamPos.setValue(_gl, _vector32.setFromMatrixPosition(camera.matrixWorld));
            }
            if (capabilities.logarithmicDepthBuffer) {
              p_uniforms.setValue(
                _gl,
                "logDepthBufFC",
                2 / (Math.log(camera.far + 1) / Math.LN2)
              );
            }
            if (material.isMeshPhongMaterial || material.isMeshToonMaterial || material.isMeshLambertMaterial || material.isMeshBasicMaterial || material.isMeshStandardMaterial || material.isShaderMaterial) {
              p_uniforms.setValue(_gl, "isOrthographic", camera.isOrthographicCamera === true);
            }
            if (_currentCamera !== camera) {
              _currentCamera = camera;
              refreshMaterial = true;
              refreshLights = true;
            }
          }
          if (object.isSkinnedMesh) {
            p_uniforms.setOptional(_gl, object, "bindMatrix");
            p_uniforms.setOptional(_gl, object, "bindMatrixInverse");
            const skeleton = object.skeleton;
            if (skeleton) {
              if (skeleton.boneTexture === null) skeleton.computeBoneTexture();
              p_uniforms.setValue(_gl, "boneTexture", skeleton.boneTexture, textures);
            }
          }
          if (object.isBatchedMesh) {
            p_uniforms.setOptional(_gl, object, "batchingTexture");
            p_uniforms.setValue(_gl, "batchingTexture", object._matricesTexture, textures);
            p_uniforms.setOptional(_gl, object, "batchingIdTexture");
            p_uniforms.setValue(_gl, "batchingIdTexture", object._indirectTexture, textures);
            p_uniforms.setOptional(_gl, object, "batchingColorTexture");
            if (object._colorsTexture !== null) {
              p_uniforms.setValue(_gl, "batchingColorTexture", object._colorsTexture, textures);
            }
          }
          const morphAttributes = geometry.morphAttributes;
          if (morphAttributes.position !== void 0 || morphAttributes.normal !== void 0 || morphAttributes.color !== void 0) {
            morphtargets.update(object, geometry, program);
          }
          if (refreshMaterial || materialProperties.receiveShadow !== object.receiveShadow) {
            materialProperties.receiveShadow = object.receiveShadow;
            p_uniforms.setValue(_gl, "receiveShadow", object.receiveShadow);
          }
          if (material.isMeshGouraudMaterial && material.envMap !== null) {
            m_uniforms.envMap.value = envMap;
            m_uniforms.flipEnvMap.value = envMap.isCubeTexture && envMap.isRenderTargetTexture === false ? -1 : 1;
          }
          if (material.isMeshStandardMaterial && material.envMap === null && scene.environment !== null) {
            m_uniforms.envMapIntensity.value = scene.environmentIntensity;
          }
          if (refreshMaterial) {
            p_uniforms.setValue(_gl, "toneMappingExposure", _this.toneMappingExposure);
            if (materialProperties.needsLights) {
              markUniformsLightsNeedsUpdate(m_uniforms, refreshLights);
            }
            if (fog && material.fog === true) {
              materials.refreshFogUniforms(m_uniforms, fog);
            }
            materials.refreshMaterialUniforms(m_uniforms, material, _pixelRatio, _height, currentRenderState.state.transmissionRenderTarget[camera.id]);
            WebGLUniforms.upload(_gl, getUniformList(materialProperties), m_uniforms, textures);
          }
          if (material.isShaderMaterial && material.uniformsNeedUpdate === true) {
            WebGLUniforms.upload(_gl, getUniformList(materialProperties), m_uniforms, textures);
            material.uniformsNeedUpdate = false;
          }
          if (material.isSpriteMaterial) {
            p_uniforms.setValue(_gl, "center", object.center);
          }
          p_uniforms.setValue(_gl, "modelViewMatrix", object.modelViewMatrix);
          p_uniforms.setValue(_gl, "normalMatrix", object.normalMatrix);
          p_uniforms.setValue(_gl, "modelMatrix", object.matrixWorld);
          if (material.isShaderMaterial || material.isRawShaderMaterial) {
            const groups = material.uniformsGroups;
            for (let i2 = 0, l2 = groups.length; i2 < l2; i2++) {
              const group = groups[i2];
              uniformsGroups.update(group, program);
              uniformsGroups.bind(group, program);
            }
          }
          return program;
        }
        function markUniformsLightsNeedsUpdate(uniforms, value) {
          uniforms.ambientLightColor.needsUpdate = value;
          uniforms.lightProbe.needsUpdate = value;
          uniforms.directionalLights.needsUpdate = value;
          uniforms.directionalLightShadows.needsUpdate = value;
          uniforms.pointLights.needsUpdate = value;
          uniforms.pointLightShadows.needsUpdate = value;
          uniforms.spotLights.needsUpdate = value;
          uniforms.spotLightShadows.needsUpdate = value;
          uniforms.rectAreaLights.needsUpdate = value;
          uniforms.hemisphereLights.needsUpdate = value;
        }
        function materialNeedsLights(material) {
          return material.isMeshLambertMaterial || material.isMeshToonMaterial || material.isMeshPhongMaterial || material.isMeshStandardMaterial || material.isShadowMaterial || material.isShaderMaterial && material.lights === true;
        }
        this.getActiveCubeFace = function() {
          return _currentActiveCubeFace;
        };
        this.getActiveMipmapLevel = function() {
          return _currentActiveMipmapLevel;
        };
        this.getRenderTarget = function() {
          return _currentRenderTarget;
        };
        this.setRenderTargetTextures = function(renderTarget, colorTexture, depthTexture) {
          properties.get(renderTarget.texture).__webglTexture = colorTexture;
          properties.get(renderTarget.depthTexture).__webglTexture = depthTexture;
          const renderTargetProperties = properties.get(renderTarget);
          renderTargetProperties.__hasExternalTextures = true;
          renderTargetProperties.__autoAllocateDepthBuffer = depthTexture === void 0;
          if (!renderTargetProperties.__autoAllocateDepthBuffer) {
            if (extensions.has("WEBGL_multisampled_render_to_texture") === true) {
              console.warn("THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided");
              renderTargetProperties.__useRenderToTexture = false;
            }
          }
        };
        this.setRenderTargetFramebuffer = function(renderTarget, defaultFramebuffer) {
          const renderTargetProperties = properties.get(renderTarget);
          renderTargetProperties.__webglFramebuffer = defaultFramebuffer;
          renderTargetProperties.__useDefaultFramebuffer = defaultFramebuffer === void 0;
        };
        this.setRenderTarget = function(renderTarget, activeCubeFace = 0, activeMipmapLevel = 0) {
          _currentRenderTarget = renderTarget;
          _currentActiveCubeFace = activeCubeFace;
          _currentActiveMipmapLevel = activeMipmapLevel;
          let useDefaultFramebuffer = true;
          let framebuffer = null;
          let isCube = false;
          let isRenderTarget3D = false;
          if (renderTarget) {
            const renderTargetProperties = properties.get(renderTarget);
            if (renderTargetProperties.__useDefaultFramebuffer !== void 0) {
              state.bindFramebuffer(_gl.FRAMEBUFFER, null);
              useDefaultFramebuffer = false;
            } else if (renderTargetProperties.__webglFramebuffer === void 0) {
              textures.setupRenderTarget(renderTarget);
            } else if (renderTargetProperties.__hasExternalTextures) {
              textures.rebindTextures(renderTarget, properties.get(renderTarget.texture).__webglTexture, properties.get(renderTarget.depthTexture).__webglTexture);
            } else if (renderTarget.depthBuffer) {
              const depthTexture = renderTarget.depthTexture;
              if (renderTargetProperties.__boundDepthTexture !== depthTexture) {
                if (depthTexture !== null && properties.has(depthTexture) && (renderTarget.width !== depthTexture.image.width || renderTarget.height !== depthTexture.image.height)) {
                  throw new Error("WebGLRenderTarget: Attached DepthTexture is initialized to the incorrect size.");
                }
                textures.setupDepthRenderbuffer(renderTarget);
              }
            }
            const texture = renderTarget.texture;
            if (texture.isData3DTexture || texture.isDataArrayTexture || texture.isCompressedArrayTexture) {
              isRenderTarget3D = true;
            }
            const __webglFramebuffer = properties.get(renderTarget).__webglFramebuffer;
            if (renderTarget.isWebGLCubeRenderTarget) {
              if (Array.isArray(__webglFramebuffer[activeCubeFace])) {
                framebuffer = __webglFramebuffer[activeCubeFace][activeMipmapLevel];
              } else {
                framebuffer = __webglFramebuffer[activeCubeFace];
              }
              isCube = true;
            } else if (renderTarget.samples > 0 && textures.useMultisampledRTT(renderTarget) === false) {
              framebuffer = properties.get(renderTarget).__webglMultisampledFramebuffer;
            } else {
              if (Array.isArray(__webglFramebuffer)) {
                framebuffer = __webglFramebuffer[activeMipmapLevel];
              } else {
                framebuffer = __webglFramebuffer;
              }
            }
            _currentViewport.copy(renderTarget.viewport);
            _currentScissor.copy(renderTarget.scissor);
            _currentScissorTest = renderTarget.scissorTest;
          } else {
            _currentViewport.copy(_viewport).multiplyScalar(_pixelRatio).floor();
            _currentScissor.copy(_scissor).multiplyScalar(_pixelRatio).floor();
            _currentScissorTest = _scissorTest;
          }
          const framebufferBound = state.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);
          if (framebufferBound && useDefaultFramebuffer) {
            state.drawBuffers(renderTarget, framebuffer);
          }
          state.viewport(_currentViewport);
          state.scissor(_currentScissor);
          state.setScissorTest(_currentScissorTest);
          if (isCube) {
            const textureProperties = properties.get(renderTarget.texture);
            _gl.framebufferTexture2D(_gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + activeCubeFace, textureProperties.__webglTexture, activeMipmapLevel);
          } else if (isRenderTarget3D) {
            const textureProperties = properties.get(renderTarget.texture);
            const layer = activeCubeFace || 0;
            _gl.framebufferTextureLayer(_gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, textureProperties.__webglTexture, activeMipmapLevel || 0, layer);
          }
          _currentMaterialId = -1;
        };
        this.readRenderTargetPixels = function(renderTarget, x, y2, width, height, buffer, activeCubeFaceIndex) {
          if (!(renderTarget && renderTarget.isWebGLRenderTarget)) {
            console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
            return;
          }
          let framebuffer = properties.get(renderTarget).__webglFramebuffer;
          if (renderTarget.isWebGLCubeRenderTarget && activeCubeFaceIndex !== void 0) {
            framebuffer = framebuffer[activeCubeFaceIndex];
          }
          if (framebuffer) {
            state.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);
            try {
              const texture = renderTarget.texture;
              const textureFormat = texture.format;
              const textureType = texture.type;
              if (!capabilities.textureFormatReadable(textureFormat)) {
                console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
                return;
              }
              if (!capabilities.textureTypeReadable(textureType)) {
                console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
                return;
              }
              if (x >= 0 && x <= renderTarget.width - width && (y2 >= 0 && y2 <= renderTarget.height - height)) {
                _gl.readPixels(x, y2, width, height, utils.convert(textureFormat), utils.convert(textureType), buffer);
              }
            } finally {
              const framebuffer2 = _currentRenderTarget !== null ? properties.get(_currentRenderTarget).__webglFramebuffer : null;
              state.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer2);
            }
          }
        };
        this.readRenderTargetPixelsAsync = function(renderTarget, x, y2, width, height, buffer, activeCubeFaceIndex) {
          return __async(this, null, function* () {
            if (!(renderTarget && renderTarget.isWebGLRenderTarget)) {
              throw new Error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
            }
            let framebuffer = properties.get(renderTarget).__webglFramebuffer;
            if (renderTarget.isWebGLCubeRenderTarget && activeCubeFaceIndex !== void 0) {
              framebuffer = framebuffer[activeCubeFaceIndex];
            }
            if (framebuffer) {
              const texture = renderTarget.texture;
              const textureFormat = texture.format;
              const textureType = texture.type;
              if (!capabilities.textureFormatReadable(textureFormat)) {
                throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in RGBA or implementation defined format.");
              }
              if (!capabilities.textureTypeReadable(textureType)) {
                throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in UnsignedByteType or implementation defined type.");
              }
              if (x >= 0 && x <= renderTarget.width - width && (y2 >= 0 && y2 <= renderTarget.height - height)) {
                state.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);
                const glBuffer = _gl.createBuffer();
                _gl.bindBuffer(_gl.PIXEL_PACK_BUFFER, glBuffer);
                _gl.bufferData(_gl.PIXEL_PACK_BUFFER, buffer.byteLength, _gl.STREAM_READ);
                _gl.readPixels(x, y2, width, height, utils.convert(textureFormat), utils.convert(textureType), 0);
                const currFramebuffer = _currentRenderTarget !== null ? properties.get(_currentRenderTarget).__webglFramebuffer : null;
                state.bindFramebuffer(_gl.FRAMEBUFFER, currFramebuffer);
                const sync = _gl.fenceSync(_gl.SYNC_GPU_COMMANDS_COMPLETE, 0);
                _gl.flush();
                yield probeAsync(_gl, sync, 4);
                _gl.bindBuffer(_gl.PIXEL_PACK_BUFFER, glBuffer);
                _gl.getBufferSubData(_gl.PIXEL_PACK_BUFFER, 0, buffer);
                _gl.deleteBuffer(glBuffer);
                _gl.deleteSync(sync);
                return buffer;
              } else {
                throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: requested read bounds are out of range.");
              }
            }
          });
        };
        this.copyFramebufferToTexture = function(texture, position = null, level = 0) {
          if (texture.isTexture !== true) {
            warnOnce("WebGLRenderer: copyFramebufferToTexture function signature has changed.");
            position = arguments[0] || null;
            texture = arguments[1];
          }
          const levelScale = Math.pow(2, -level);
          const width = Math.floor(texture.image.width * levelScale);
          const height = Math.floor(texture.image.height * levelScale);
          const x = position !== null ? position.x : 0;
          const y2 = position !== null ? position.y : 0;
          textures.setTexture2D(texture, 0);
          _gl.copyTexSubImage2D(_gl.TEXTURE_2D, level, 0, 0, x, y2, width, height);
          state.unbindTexture();
        };
        this.copyTextureToTexture = function(srcTexture, dstTexture, srcRegion = null, dstPosition = null, level = 0) {
          if (srcTexture.isTexture !== true) {
            warnOnce("WebGLRenderer: copyTextureToTexture function signature has changed.");
            dstPosition = arguments[0] || null;
            srcTexture = arguments[1];
            dstTexture = arguments[2];
            level = arguments[3] || 0;
            srcRegion = null;
          }
          let width, height, minX, minY;
          let dstX, dstY;
          if (srcRegion !== null) {
            width = srcRegion.max.x - srcRegion.min.x;
            height = srcRegion.max.y - srcRegion.min.y;
            minX = srcRegion.min.x;
            minY = srcRegion.min.y;
          } else {
            width = srcTexture.image.width;
            height = srcTexture.image.height;
            minX = 0;
            minY = 0;
          }
          if (dstPosition !== null) {
            dstX = dstPosition.x;
            dstY = dstPosition.y;
          } else {
            dstX = 0;
            dstY = 0;
          }
          const glFormat = utils.convert(dstTexture.format);
          const glType = utils.convert(dstTexture.type);
          textures.setTexture2D(dstTexture, 0);
          _gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, dstTexture.flipY);
          _gl.pixelStorei(_gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, dstTexture.premultiplyAlpha);
          _gl.pixelStorei(_gl.UNPACK_ALIGNMENT, dstTexture.unpackAlignment);
          const currentUnpackRowLen = _gl.getParameter(_gl.UNPACK_ROW_LENGTH);
          const currentUnpackImageHeight = _gl.getParameter(_gl.UNPACK_IMAGE_HEIGHT);
          const currentUnpackSkipPixels = _gl.getParameter(_gl.UNPACK_SKIP_PIXELS);
          const currentUnpackSkipRows = _gl.getParameter(_gl.UNPACK_SKIP_ROWS);
          const currentUnpackSkipImages = _gl.getParameter(_gl.UNPACK_SKIP_IMAGES);
          const image = srcTexture.isCompressedTexture ? srcTexture.mipmaps[level] : srcTexture.image;
          _gl.pixelStorei(_gl.UNPACK_ROW_LENGTH, image.width);
          _gl.pixelStorei(_gl.UNPACK_IMAGE_HEIGHT, image.height);
          _gl.pixelStorei(_gl.UNPACK_SKIP_PIXELS, minX);
          _gl.pixelStorei(_gl.UNPACK_SKIP_ROWS, minY);
          if (srcTexture.isDataTexture) {
            _gl.texSubImage2D(_gl.TEXTURE_2D, level, dstX, dstY, width, height, glFormat, glType, image.data);
          } else {
            if (srcTexture.isCompressedTexture) {
              _gl.compressedTexSubImage2D(_gl.TEXTURE_2D, level, dstX, dstY, image.width, image.height, glFormat, image.data);
            } else {
              _gl.texSubImage2D(_gl.TEXTURE_2D, level, dstX, dstY, width, height, glFormat, glType, image);
            }
          }
          _gl.pixelStorei(_gl.UNPACK_ROW_LENGTH, currentUnpackRowLen);
          _gl.pixelStorei(_gl.UNPACK_IMAGE_HEIGHT, currentUnpackImageHeight);
          _gl.pixelStorei(_gl.UNPACK_SKIP_PIXELS, currentUnpackSkipPixels);
          _gl.pixelStorei(_gl.UNPACK_SKIP_ROWS, currentUnpackSkipRows);
          _gl.pixelStorei(_gl.UNPACK_SKIP_IMAGES, currentUnpackSkipImages);
          if (level === 0 && dstTexture.generateMipmaps) _gl.generateMipmap(_gl.TEXTURE_2D);
          state.unbindTexture();
        };
        this.copyTextureToTexture3D = function(srcTexture, dstTexture, srcRegion = null, dstPosition = null, level = 0) {
          if (srcTexture.isTexture !== true) {
            warnOnce("WebGLRenderer: copyTextureToTexture3D function signature has changed.");
            srcRegion = arguments[0] || null;
            dstPosition = arguments[1] || null;
            srcTexture = arguments[2];
            dstTexture = arguments[3];
            level = arguments[4] || 0;
          }
          let width, height, depth2, minX, minY, minZ;
          let dstX, dstY, dstZ;
          const image = srcTexture.isCompressedTexture ? srcTexture.mipmaps[level] : srcTexture.image;
          if (srcRegion !== null) {
            width = srcRegion.max.x - srcRegion.min.x;
            height = srcRegion.max.y - srcRegion.min.y;
            depth2 = srcRegion.max.z - srcRegion.min.z;
            minX = srcRegion.min.x;
            minY = srcRegion.min.y;
            minZ = srcRegion.min.z;
          } else {
            width = image.width;
            height = image.height;
            depth2 = image.depth;
            minX = 0;
            minY = 0;
            minZ = 0;
          }
          if (dstPosition !== null) {
            dstX = dstPosition.x;
            dstY = dstPosition.y;
            dstZ = dstPosition.z;
          } else {
            dstX = 0;
            dstY = 0;
            dstZ = 0;
          }
          const glFormat = utils.convert(dstTexture.format);
          const glType = utils.convert(dstTexture.type);
          let glTarget;
          if (dstTexture.isData3DTexture) {
            textures.setTexture3D(dstTexture, 0);
            glTarget = _gl.TEXTURE_3D;
          } else if (dstTexture.isDataArrayTexture || dstTexture.isCompressedArrayTexture) {
            textures.setTexture2DArray(dstTexture, 0);
            glTarget = _gl.TEXTURE_2D_ARRAY;
          } else {
            console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");
            return;
          }
          _gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, dstTexture.flipY);
          _gl.pixelStorei(_gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, dstTexture.premultiplyAlpha);
          _gl.pixelStorei(_gl.UNPACK_ALIGNMENT, dstTexture.unpackAlignment);
          const currentUnpackRowLen = _gl.getParameter(_gl.UNPACK_ROW_LENGTH);
          const currentUnpackImageHeight = _gl.getParameter(_gl.UNPACK_IMAGE_HEIGHT);
          const currentUnpackSkipPixels = _gl.getParameter(_gl.UNPACK_SKIP_PIXELS);
          const currentUnpackSkipRows = _gl.getParameter(_gl.UNPACK_SKIP_ROWS);
          const currentUnpackSkipImages = _gl.getParameter(_gl.UNPACK_SKIP_IMAGES);
          _gl.pixelStorei(_gl.UNPACK_ROW_LENGTH, image.width);
          _gl.pixelStorei(_gl.UNPACK_IMAGE_HEIGHT, image.height);
          _gl.pixelStorei(_gl.UNPACK_SKIP_PIXELS, minX);
          _gl.pixelStorei(_gl.UNPACK_SKIP_ROWS, minY);
          _gl.pixelStorei(_gl.UNPACK_SKIP_IMAGES, minZ);
          if (srcTexture.isDataTexture || srcTexture.isData3DTexture) {
            _gl.texSubImage3D(glTarget, level, dstX, dstY, dstZ, width, height, depth2, glFormat, glType, image.data);
          } else {
            if (dstTexture.isCompressedArrayTexture) {
              _gl.compressedTexSubImage3D(glTarget, level, dstX, dstY, dstZ, width, height, depth2, glFormat, image.data);
            } else {
              _gl.texSubImage3D(glTarget, level, dstX, dstY, dstZ, width, height, depth2, glFormat, glType, image);
            }
          }
          _gl.pixelStorei(_gl.UNPACK_ROW_LENGTH, currentUnpackRowLen);
          _gl.pixelStorei(_gl.UNPACK_IMAGE_HEIGHT, currentUnpackImageHeight);
          _gl.pixelStorei(_gl.UNPACK_SKIP_PIXELS, currentUnpackSkipPixels);
          _gl.pixelStorei(_gl.UNPACK_SKIP_ROWS, currentUnpackSkipRows);
          _gl.pixelStorei(_gl.UNPACK_SKIP_IMAGES, currentUnpackSkipImages);
          if (level === 0 && dstTexture.generateMipmaps) _gl.generateMipmap(glTarget);
          state.unbindTexture();
        };
        this.initRenderTarget = function(target2) {
          if (properties.get(target2).__webglFramebuffer === void 0) {
            textures.setupRenderTarget(target2);
          }
        };
        this.initTexture = function(texture) {
          if (texture.isCubeTexture) {
            textures.setTextureCube(texture, 0);
          } else if (texture.isData3DTexture) {
            textures.setTexture3D(texture, 0);
          } else if (texture.isDataArrayTexture || texture.isCompressedArrayTexture) {
            textures.setTexture2DArray(texture, 0);
          } else {
            textures.setTexture2D(texture, 0);
          }
          state.unbindTexture();
        };
        this.resetState = function() {
          _currentActiveCubeFace = 0;
          _currentActiveMipmapLevel = 0;
          _currentRenderTarget = null;
          state.reset();
          bindingStates.reset();
        };
        if (typeof __THREE_DEVTOOLS__ !== "undefined") {
          __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this }));
        }
      }
      get coordinateSystem() {
        return WebGLCoordinateSystem;
      }
      get outputColorSpace() {
        return this._outputColorSpace;
      }
      set outputColorSpace(colorSpace) {
        this._outputColorSpace = colorSpace;
        const gl = this.getContext();
        gl.drawingBufferColorSpace = colorSpace === DisplayP3ColorSpace ? "display-p3" : "srgb";
        gl.unpackColorSpace = ColorManagement.workingColorSpace === LinearDisplayP3ColorSpace ? "display-p3" : "srgb";
      }
    };
    FogExp2 = class _FogExp2 {
      constructor(color, density = 25e-5) {
        this.isFogExp2 = true;
        this.name = "";
        this.color = new Color(color);
        this.density = density;
      }
      clone() {
        return new _FogExp2(this.color, this.density);
      }
      toJSON() {
        return {
          type: "FogExp2",
          name: this.name,
          color: this.color.getHex(),
          density: this.density
        };
      }
    };
    Fog = class _Fog {
      constructor(color, near = 1, far = 1e3) {
        this.isFog = true;
        this.name = "";
        this.color = new Color(color);
        this.near = near;
        this.far = far;
      }
      clone() {
        return new _Fog(this.color, this.near, this.far);
      }
      toJSON() {
        return {
          type: "Fog",
          name: this.name,
          color: this.color.getHex(),
          near: this.near,
          far: this.far
        };
      }
    };
    Scene = class extends Object3D {
      constructor() {
        super();
        this.isScene = true;
        this.type = "Scene";
        this.background = null;
        this.environment = null;
        this.fog = null;
        this.backgroundBlurriness = 0;
        this.backgroundIntensity = 1;
        this.backgroundRotation = new Euler();
        this.environmentIntensity = 1;
        this.environmentRotation = new Euler();
        this.overrideMaterial = null;
        if (typeof __THREE_DEVTOOLS__ !== "undefined") {
          __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this }));
        }
      }
      copy(source, recursive) {
        super.copy(source, recursive);
        if (source.background !== null) this.background = source.background.clone();
        if (source.environment !== null) this.environment = source.environment.clone();
        if (source.fog !== null) this.fog = source.fog.clone();
        this.backgroundBlurriness = source.backgroundBlurriness;
        this.backgroundIntensity = source.backgroundIntensity;
        this.backgroundRotation.copy(source.backgroundRotation);
        this.environmentIntensity = source.environmentIntensity;
        this.environmentRotation.copy(source.environmentRotation);
        if (source.overrideMaterial !== null) this.overrideMaterial = source.overrideMaterial.clone();
        this.matrixAutoUpdate = source.matrixAutoUpdate;
        return this;
      }
      toJSON(meta) {
        const data = super.toJSON(meta);
        if (this.fog !== null) data.object.fog = this.fog.toJSON();
        if (this.backgroundBlurriness > 0) data.object.backgroundBlurriness = this.backgroundBlurriness;
        if (this.backgroundIntensity !== 1) data.object.backgroundIntensity = this.backgroundIntensity;
        data.object.backgroundRotation = this.backgroundRotation.toArray();
        if (this.environmentIntensity !== 1) data.object.environmentIntensity = this.environmentIntensity;
        data.object.environmentRotation = this.environmentRotation.toArray();
        return data;
      }
    };
    InterleavedBuffer = class {
      constructor(array, stride) {
        this.isInterleavedBuffer = true;
        this.array = array;
        this.stride = stride;
        this.count = array !== void 0 ? array.length / stride : 0;
        this.usage = StaticDrawUsage;
        this.updateRanges = [];
        this.version = 0;
        this.uuid = generateUUID();
      }
      onUploadCallback() {
      }
      set needsUpdate(value) {
        if (value === true) this.version++;
      }
      setUsage(value) {
        this.usage = value;
        return this;
      }
      addUpdateRange(start, count) {
        this.updateRanges.push({ start, count });
      }
      clearUpdateRanges() {
        this.updateRanges.length = 0;
      }
      copy(source) {
        this.array = new source.array.constructor(source.array);
        this.count = source.count;
        this.stride = source.stride;
        this.usage = source.usage;
        return this;
      }
      copyAt(index1, attribute, index2) {
        index1 *= this.stride;
        index2 *= attribute.stride;
        for (let i2 = 0, l2 = this.stride; i2 < l2; i2++) {
          this.array[index1 + i2] = attribute.array[index2 + i2];
        }
        return this;
      }
      set(value, offset = 0) {
        this.array.set(value, offset);
        return this;
      }
      clone(data) {
        if (data.arrayBuffers === void 0) {
          data.arrayBuffers = {};
        }
        if (this.array.buffer._uuid === void 0) {
          this.array.buffer._uuid = generateUUID();
        }
        if (data.arrayBuffers[this.array.buffer._uuid] === void 0) {
          data.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer;
        }
        const array = new this.array.constructor(data.arrayBuffers[this.array.buffer._uuid]);
        const ib = new this.constructor(array, this.stride);
        ib.setUsage(this.usage);
        return ib;
      }
      onUpload(callback) {
        this.onUploadCallback = callback;
        return this;
      }
      toJSON(data) {
        if (data.arrayBuffers === void 0) {
          data.arrayBuffers = {};
        }
        if (this.array.buffer._uuid === void 0) {
          this.array.buffer._uuid = generateUUID();
        }
        if (data.arrayBuffers[this.array.buffer._uuid] === void 0) {
          data.arrayBuffers[this.array.buffer._uuid] = Array.from(new Uint32Array(this.array.buffer));
        }
        return {
          uuid: this.uuid,
          buffer: this.array.buffer._uuid,
          type: this.array.constructor.name,
          stride: this.stride
        };
      }
    };
    _vector$6 = /* @__PURE__ */ new Vector3();
    InterleavedBufferAttribute = class _InterleavedBufferAttribute {
      constructor(interleavedBuffer, itemSize, offset, normalized = false) {
        this.isInterleavedBufferAttribute = true;
        this.name = "";
        this.data = interleavedBuffer;
        this.itemSize = itemSize;
        this.offset = offset;
        this.normalized = normalized;
      }
      get count() {
        return this.data.count;
      }
      get array() {
        return this.data.array;
      }
      set needsUpdate(value) {
        this.data.needsUpdate = value;
      }
      applyMatrix4(m) {
        for (let i2 = 0, l2 = this.data.count; i2 < l2; i2++) {
          _vector$6.fromBufferAttribute(this, i2);
          _vector$6.applyMatrix4(m);
          this.setXYZ(i2, _vector$6.x, _vector$6.y, _vector$6.z);
        }
        return this;
      }
      applyNormalMatrix(m) {
        for (let i2 = 0, l2 = this.count; i2 < l2; i2++) {
          _vector$6.fromBufferAttribute(this, i2);
          _vector$6.applyNormalMatrix(m);
          this.setXYZ(i2, _vector$6.x, _vector$6.y, _vector$6.z);
        }
        return this;
      }
      transformDirection(m) {
        for (let i2 = 0, l2 = this.count; i2 < l2; i2++) {
          _vector$6.fromBufferAttribute(this, i2);
          _vector$6.transformDirection(m);
          this.setXYZ(i2, _vector$6.x, _vector$6.y, _vector$6.z);
        }
        return this;
      }
      getComponent(index, component) {
        let value = this.array[index * this.data.stride + this.offset + component];
        if (this.normalized) value = denormalize(value, this.array);
        return value;
      }
      setComponent(index, component, value) {
        if (this.normalized) value = normalize(value, this.array);
        this.data.array[index * this.data.stride + this.offset + component] = value;
        return this;
      }
      setX(index, x) {
        if (this.normalized) x = normalize(x, this.array);
        this.data.array[index * this.data.stride + this.offset] = x;
        return this;
      }
      setY(index, y2) {
        if (this.normalized) y2 = normalize(y2, this.array);
        this.data.array[index * this.data.stride + this.offset + 1] = y2;
        return this;
      }
      setZ(index, z2) {
        if (this.normalized) z2 = normalize(z2, this.array);
        this.data.array[index * this.data.stride + this.offset + 2] = z2;
        return this;
      }
      setW(index, w) {
        if (this.normalized) w = normalize(w, this.array);
        this.data.array[index * this.data.stride + this.offset + 3] = w;
        return this;
      }
      getX(index) {
        let x = this.data.array[index * this.data.stride + this.offset];
        if (this.normalized) x = denormalize(x, this.array);
        return x;
      }
      getY(index) {
        let y2 = this.data.array[index * this.data.stride + this.offset + 1];
        if (this.normalized) y2 = denormalize(y2, this.array);
        return y2;
      }
      getZ(index) {
        let z2 = this.data.array[index * this.data.stride + this.offset + 2];
        if (this.normalized) z2 = denormalize(z2, this.array);
        return z2;
      }
      getW(index) {
        let w = this.data.array[index * this.data.stride + this.offset + 3];
        if (this.normalized) w = denormalize(w, this.array);
        return w;
      }
      setXY(index, x, y2) {
        index = index * this.data.stride + this.offset;
        if (this.normalized) {
          x = normalize(x, this.array);
          y2 = normalize(y2, this.array);
        }
        this.data.array[index + 0] = x;
        this.data.array[index + 1] = y2;
        return this;
      }
      setXYZ(index, x, y2, z2) {
        index = index * this.data.stride + this.offset;
        if (this.normalized) {
          x = normalize(x, this.array);
          y2 = normalize(y2, this.array);
          z2 = normalize(z2, this.array);
        }
        this.data.array[index + 0] = x;
        this.data.array[index + 1] = y2;
        this.data.array[index + 2] = z2;
        return this;
      }
      setXYZW(index, x, y2, z2, w) {
        index = index * this.data.stride + this.offset;
        if (this.normalized) {
          x = normalize(x, this.array);
          y2 = normalize(y2, this.array);
          z2 = normalize(z2, this.array);
          w = normalize(w, this.array);
        }
        this.data.array[index + 0] = x;
        this.data.array[index + 1] = y2;
        this.data.array[index + 2] = z2;
        this.data.array[index + 3] = w;
        return this;
      }
      clone(data) {
        if (data === void 0) {
          console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data.");
          const array = [];
          for (let i2 = 0; i2 < this.count; i2++) {
            const index = i2 * this.data.stride + this.offset;
            for (let j2 = 0; j2 < this.itemSize; j2++) {
              array.push(this.data.array[index + j2]);
            }
          }
          return new BufferAttribute(new this.array.constructor(array), this.itemSize, this.normalized);
        } else {
          if (data.interleavedBuffers === void 0) {
            data.interleavedBuffers = {};
          }
          if (data.interleavedBuffers[this.data.uuid] === void 0) {
            data.interleavedBuffers[this.data.uuid] = this.data.clone(data);
          }
          return new _InterleavedBufferAttribute(data.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized);
        }
      }
      toJSON(data) {
        if (data === void 0) {
          console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data.");
          const array = [];
          for (let i2 = 0; i2 < this.count; i2++) {
            const index = i2 * this.data.stride + this.offset;
            for (let j2 = 0; j2 < this.itemSize; j2++) {
              array.push(this.data.array[index + j2]);
            }
          }
          return {
            itemSize: this.itemSize,
            type: this.array.constructor.name,
            array,
            normalized: this.normalized
          };
        } else {
          if (data.interleavedBuffers === void 0) {
            data.interleavedBuffers = {};
          }
          if (data.interleavedBuffers[this.data.uuid] === void 0) {
            data.interleavedBuffers[this.data.uuid] = this.data.toJSON(data);
          }
          return {
            isInterleavedBufferAttribute: true,
            itemSize: this.itemSize,
            data: this.data.uuid,
            offset: this.offset,
            normalized: this.normalized
          };
        }
      }
    };
    SpriteMaterial = class extends Material {
      constructor(parameters) {
        super();
        this.isSpriteMaterial = true;
        this.type = "SpriteMaterial";
        this.color = new Color(16777215);
        this.map = null;
        this.alphaMap = null;
        this.rotation = 0;
        this.sizeAttenuation = true;
        this.transparent = true;
        this.fog = true;
        this.setValues(parameters);
      }
      copy(source) {
        super.copy(source);
        this.color.copy(source.color);
        this.map = source.map;
        this.alphaMap = source.alphaMap;
        this.rotation = source.rotation;
        this.sizeAttenuation = source.sizeAttenuation;
        this.fog = source.fog;
        return this;
      }
    };
    _intersectPoint = /* @__PURE__ */ new Vector3();
    _worldScale = /* @__PURE__ */ new Vector3();
    _mvPosition = /* @__PURE__ */ new Vector3();
    _alignedPosition = /* @__PURE__ */ new Vector2();
    _rotatedPosition = /* @__PURE__ */ new Vector2();
    _viewWorldMatrix = /* @__PURE__ */ new Matrix4();
    _vA = /* @__PURE__ */ new Vector3();
    _vB = /* @__PURE__ */ new Vector3();
    _vC = /* @__PURE__ */ new Vector3();
    _uvA = /* @__PURE__ */ new Vector2();
    _uvB = /* @__PURE__ */ new Vector2();
    _uvC = /* @__PURE__ */ new Vector2();
    Sprite = class extends Object3D {
      constructor(material = new SpriteMaterial()) {
        super();
        this.isSprite = true;
        this.type = "Sprite";
        if (_geometry === void 0) {
          _geometry = new BufferGeometry();
          const float32Array = new Float32Array([
            -0.5,
            -0.5,
            0,
            0,
            0,
            0.5,
            -0.5,
            0,
            1,
            0,
            0.5,
            0.5,
            0,
            1,
            1,
            -0.5,
            0.5,
            0,
            0,
            1
          ]);
          const interleavedBuffer = new InterleavedBuffer(float32Array, 5);
          _geometry.setIndex([0, 1, 2, 0, 2, 3]);
          _geometry.setAttribute("position", new InterleavedBufferAttribute(interleavedBuffer, 3, 0, false));
          _geometry.setAttribute("uv", new InterleavedBufferAttribute(interleavedBuffer, 2, 3, false));
        }
        this.geometry = _geometry;
        this.material = material;
        this.center = new Vector2(0.5, 0.5);
      }
      raycast(raycaster, intersects2) {
        if (raycaster.camera === null) {
          console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.');
        }
        _worldScale.setFromMatrixScale(this.matrixWorld);
        _viewWorldMatrix.copy(raycaster.camera.matrixWorld);
        this.modelViewMatrix.multiplyMatrices(raycaster.camera.matrixWorldInverse, this.matrixWorld);
        _mvPosition.setFromMatrixPosition(this.modelViewMatrix);
        if (raycaster.camera.isPerspectiveCamera && this.material.sizeAttenuation === false) {
          _worldScale.multiplyScalar(-_mvPosition.z);
        }
        const rotation = this.material.rotation;
        let sin, cos;
        if (rotation !== 0) {
          cos = Math.cos(rotation);
          sin = Math.sin(rotation);
        }
        const center = this.center;
        transformVertex(_vA.set(-0.5, -0.5, 0), _mvPosition, center, _worldScale, sin, cos);
        transformVertex(_vB.set(0.5, -0.5, 0), _mvPosition, center, _worldScale, sin, cos);
        transformVertex(_vC.set(0.5, 0.5, 0), _mvPosition, center, _worldScale, sin, cos);
        _uvA.set(0, 0);
        _uvB.set(1, 0);
        _uvC.set(1, 1);
        let intersect2 = raycaster.ray.intersectTriangle(_vA, _vB, _vC, false, _intersectPoint);
        if (intersect2 === null) {
          transformVertex(_vB.set(-0.5, 0.5, 0), _mvPosition, center, _worldScale, sin, cos);
          _uvB.set(0, 1);
          intersect2 = raycaster.ray.intersectTriangle(_vA, _vC, _vB, false, _intersectPoint);
          if (intersect2 === null) {
            return;
          }
        }
        const distance = raycaster.ray.origin.distanceTo(_intersectPoint);
        if (distance < raycaster.near || distance > raycaster.far) return;
        intersects2.push({
          distance,
          point: _intersectPoint.clone(),
          uv: Triangle.getInterpolation(_intersectPoint, _vA, _vB, _vC, _uvA, _uvB, _uvC, new Vector2()),
          face: null,
          object: this
        });
      }
      copy(source, recursive) {
        super.copy(source, recursive);
        if (source.center !== void 0) this.center.copy(source.center);
        this.material = source.material;
        return this;
      }
    };
    _v1$2 = /* @__PURE__ */ new Vector3();
    _v2$1 = /* @__PURE__ */ new Vector3();
    LOD = class extends Object3D {
      constructor() {
        super();
        this._currentLevel = 0;
        this.type = "LOD";
        Object.defineProperties(this, {
          levels: {
            enumerable: true,
            value: []
          },
          isLOD: {
            value: true
          }
        });
        this.autoUpdate = true;
      }
      copy(source) {
        super.copy(source, false);
        const levels = source.levels;
        for (let i2 = 0, l2 = levels.length; i2 < l2; i2++) {
          const level = levels[i2];
          this.addLevel(level.object.clone(), level.distance, level.hysteresis);
        }
        this.autoUpdate = source.autoUpdate;
        return this;
      }
      addLevel(object, distance = 0, hysteresis = 0) {
        distance = Math.abs(distance);
        const levels = this.levels;
        let l2;
        for (l2 = 0; l2 < levels.length; l2++) {
          if (distance < levels[l2].distance) {
            break;
          }
        }
        levels.splice(l2, 0, { distance, hysteresis, object });
        this.add(object);
        return this;
      }
      removeLevel(distance) {
        const levels = this.levels;
        for (let i2 = 0; i2 < levels.length; i2++) {
          if (levels[i2].distance === distance) {
            const removedElements = levels.splice(i2, 1);
            this.remove(removedElements[0].object);
            return true;
          }
        }
        return false;
      }
      getCurrentLevel() {
        return this._currentLevel;
      }
      getObjectForDistance(distance) {
        const levels = this.levels;
        if (levels.length > 0) {
          let i2, l2;
          for (i2 = 1, l2 = levels.length; i2 < l2; i2++) {
            let levelDistance = levels[i2].distance;
            if (levels[i2].object.visible) {
              levelDistance -= levelDistance * levels[i2].hysteresis;
            }
            if (distance < levelDistance) {
              break;
            }
          }
          return levels[i2 - 1].object;
        }
        return null;
      }
      raycast(raycaster, intersects2) {
        const levels = this.levels;
        if (levels.length > 0) {
          _v1$2.setFromMatrixPosition(this.matrixWorld);
          const distance = raycaster.ray.origin.distanceTo(_v1$2);
          this.getObjectForDistance(distance).raycast(raycaster, intersects2);
        }
      }
      update(camera) {
        const levels = this.levels;
        if (levels.length > 1) {
          _v1$2.setFromMatrixPosition(camera.matrixWorld);
          _v2$1.setFromMatrixPosition(this.matrixWorld);
          const distance = _v1$2.distanceTo(_v2$1) / camera.zoom;
          levels[0].object.visible = true;
          let i2, l2;
          for (i2 = 1, l2 = levels.length; i2 < l2; i2++) {
            let levelDistance = levels[i2].distance;
            if (levels[i2].object.visible) {
              levelDistance -= levelDistance * levels[i2].hysteresis;
            }
            if (distance >= levelDistance) {
              levels[i2 - 1].object.visible = false;
              levels[i2].object.visible = true;
            } else {
              break;
            }
          }
          this._currentLevel = i2 - 1;
          for (; i2 < l2; i2++) {
            levels[i2].object.visible = false;
          }
        }
      }
      toJSON(meta) {
        const data = super.toJSON(meta);
        if (this.autoUpdate === false) data.object.autoUpdate = false;
        data.object.levels = [];
        const levels = this.levels;
        for (let i2 = 0, l2 = levels.length; i2 < l2; i2++) {
          const level = levels[i2];
          data.object.levels.push({
            object: level.object.uuid,
            distance: level.distance,
            hysteresis: level.hysteresis
          });
        }
        return data;
      }
    };
    _basePosition = /* @__PURE__ */ new Vector3();
    _skinIndex = /* @__PURE__ */ new Vector4();
    _skinWeight = /* @__PURE__ */ new Vector4();
    _vector3 = /* @__PURE__ */ new Vector3();
    _matrix4 = /* @__PURE__ */ new Matrix4();
    _vertex = /* @__PURE__ */ new Vector3();
    _sphere$4 = /* @__PURE__ */ new Sphere();
    _inverseMatrix$2 = /* @__PURE__ */ new Matrix4();
    _ray$2 = /* @__PURE__ */ new Ray();
    SkinnedMesh = class extends Mesh {
      constructor(geometry, material) {
        super(geometry, material);
        this.isSkinnedMesh = true;
        this.type = "SkinnedMesh";
        this.bindMode = AttachedBindMode;
        this.bindMatrix = new Matrix4();
        this.bindMatrixInverse = new Matrix4();
        this.boundingBox = null;
        this.boundingSphere = null;
      }
      computeBoundingBox() {
        const geometry = this.geometry;
        if (this.boundingBox === null) {
          this.boundingBox = new Box3();
        }
        this.boundingBox.makeEmpty();
        const positionAttribute = geometry.getAttribute("position");
        for (let i2 = 0; i2 < positionAttribute.count; i2++) {
          this.getVertexPosition(i2, _vertex);
          this.boundingBox.expandByPoint(_vertex);
        }
      }
      computeBoundingSphere() {
        const geometry = this.geometry;
        if (this.boundingSphere === null) {
          this.boundingSphere = new Sphere();
        }
        this.boundingSphere.makeEmpty();
        const positionAttribute = geometry.getAttribute("position");
        for (let i2 = 0; i2 < positionAttribute.count; i2++) {
          this.getVertexPosition(i2, _vertex);
          this.boundingSphere.expandByPoint(_vertex);
        }
      }
      copy(source, recursive) {
        super.copy(source, recursive);
        this.bindMode = source.bindMode;
        this.bindMatrix.copy(source.bindMatrix);
        this.bindMatrixInverse.copy(source.bindMatrixInverse);
        this.skeleton = source.skeleton;
        if (source.boundingBox !== null) this.boundingBox = source.boundingBox.clone();
        if (source.boundingSphere !== null) this.boundingSphere = source.boundingSphere.clone();
        return this;
      }
      raycast(raycaster, intersects2) {
        const material = this.material;
        const matrixWorld = this.matrixWorld;
        if (material === void 0) return;
        if (this.boundingSphere === null) this.computeBoundingSphere();
        _sphere$4.copy(this.boundingSphere);
        _sphere$4.applyMatrix4(matrixWorld);
        if (raycaster.ray.intersectsSphere(_sphere$4) === false) return;
        _inverseMatrix$2.copy(matrixWorld).invert();
        _ray$2.copy(raycaster.ray).applyMatrix4(_inverseMatrix$2);
        if (this.boundingBox !== null) {
          if (_ray$2.intersectsBox(this.boundingBox) === false) return;
        }
        this._computeIntersections(raycaster, intersects2, _ray$2);
      }
      getVertexPosition(index, target2) {
        super.getVertexPosition(index, target2);
        this.applyBoneTransform(index, target2);
        return target2;
      }
      bind(skeleton, bindMatrix) {
        this.skeleton = skeleton;
        if (bindMatrix === void 0) {
          this.updateMatrixWorld(true);
          this.skeleton.calculateInverses();
          bindMatrix = this.matrixWorld;
        }
        this.bindMatrix.copy(bindMatrix);
        this.bindMatrixInverse.copy(bindMatrix).invert();
      }
      pose() {
        this.skeleton.pose();
      }
      normalizeSkinWeights() {
        const vector = new Vector4();
        const skinWeight = this.geometry.attributes.skinWeight;
        for (let i2 = 0, l2 = skinWeight.count; i2 < l2; i2++) {
          vector.fromBufferAttribute(skinWeight, i2);
          const scale = 1 / vector.manhattanLength();
          if (scale !== Infinity) {
            vector.multiplyScalar(scale);
          } else {
            vector.set(1, 0, 0, 0);
          }
          skinWeight.setXYZW(i2, vector.x, vector.y, vector.z, vector.w);
        }
      }
      updateMatrixWorld(force) {
        super.updateMatrixWorld(force);
        if (this.bindMode === AttachedBindMode) {
          this.bindMatrixInverse.copy(this.matrixWorld).invert();
        } else if (this.bindMode === DetachedBindMode) {
          this.bindMatrixInverse.copy(this.bindMatrix).invert();
        } else {
          console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode);
        }
      }
      applyBoneTransform(index, vector) {
        const skeleton = this.skeleton;
        const geometry = this.geometry;
        _skinIndex.fromBufferAttribute(geometry.attributes.skinIndex, index);
        _skinWeight.fromBufferAttribute(geometry.attributes.skinWeight, index);
        _basePosition.copy(vector).applyMatrix4(this.bindMatrix);
        vector.set(0, 0, 0);
        for (let i2 = 0; i2 < 4; i2++) {
          const weight = _skinWeight.getComponent(i2);
          if (weight !== 0) {
            const boneIndex = _skinIndex.getComponent(i2);
            _matrix4.multiplyMatrices(skeleton.bones[boneIndex].matrixWorld, skeleton.boneInverses[boneIndex]);
            vector.addScaledVector(_vector3.copy(_basePosition).applyMatrix4(_matrix4), weight);
          }
        }
        return vector.applyMatrix4(this.bindMatrixInverse);
      }
    };
    Bone = class extends Object3D {
      constructor() {
        super();
        this.isBone = true;
        this.type = "Bone";
      }
    };
    DataTexture = class extends Texture {
      constructor(data = null, width = 1, height = 1, format, type, mapping, wrapS, wrapT, magFilter = NearestFilter, minFilter = NearestFilter, anisotropy, colorSpace) {
        super(null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, colorSpace);
        this.isDataTexture = true;
        this.image = { data, width, height };
        this.generateMipmaps = false;
        this.flipY = false;
        this.unpackAlignment = 1;
      }
    };
    _offsetMatrix = /* @__PURE__ */ new Matrix4();
    _identityMatrix$1 = /* @__PURE__ */ new Matrix4();
    Skeleton = class _Skeleton {
      constructor(bones = [], boneInverses = []) {
        this.uuid = generateUUID();
        this.bones = bones.slice(0);
        this.boneInverses = boneInverses;
        this.boneMatrices = null;
        this.boneTexture = null;
        this.init();
      }
      init() {
        const bones = this.bones;
        const boneInverses = this.boneInverses;
        this.boneMatrices = new Float32Array(bones.length * 16);
        if (boneInverses.length === 0) {
          this.calculateInverses();
        } else {
          if (bones.length !== boneInverses.length) {
            console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones.");
            this.boneInverses = [];
            for (let i2 = 0, il = this.bones.length; i2 < il; i2++) {
              this.boneInverses.push(new Matrix4());
            }
          }
        }
      }
      calculateInverses() {
        this.boneInverses.length = 0;
        for (let i2 = 0, il = this.bones.length; i2 < il; i2++) {
          const inverse = new Matrix4();
          if (this.bones[i2]) {
            inverse.copy(this.bones[i2].matrixWorld).invert();
          }
          this.boneInverses.push(inverse);
        }
      }
      pose() {
        for (let i2 = 0, il = this.bones.length; i2 < il; i2++) {
          const bone = this.bones[i2];
          if (bone) {
            bone.matrixWorld.copy(this.boneInverses[i2]).invert();
          }
        }
        for (let i2 = 0, il = this.bones.length; i2 < il; i2++) {
          const bone = this.bones[i2];
          if (bone) {
            if (bone.parent && bone.parent.isBone) {
              bone.matrix.copy(bone.parent.matrixWorld).invert();
              bone.matrix.multiply(bone.matrixWorld);
            } else {
              bone.matrix.copy(bone.matrixWorld);
            }
            bone.matrix.decompose(bone.position, bone.quaternion, bone.scale);
          }
        }
      }
      update() {
        const bones = this.bones;
        const boneInverses = this.boneInverses;
        const boneMatrices = this.boneMatrices;
        const boneTexture = this.boneTexture;
        for (let i2 = 0, il = bones.length; i2 < il; i2++) {
          const matrix2 = bones[i2] ? bones[i2].matrixWorld : _identityMatrix$1;
          _offsetMatrix.multiplyMatrices(matrix2, boneInverses[i2]);
          _offsetMatrix.toArray(boneMatrices, i2 * 16);
        }
        if (boneTexture !== null) {
          boneTexture.needsUpdate = true;
        }
      }
      clone() {
        return new _Skeleton(this.bones, this.boneInverses);
      }
      computeBoneTexture() {
        let size = Math.sqrt(this.bones.length * 4);
        size = Math.ceil(size / 4) * 4;
        size = Math.max(size, 4);
        const boneMatrices = new Float32Array(size * size * 4);
        boneMatrices.set(this.boneMatrices);
        const boneTexture = new DataTexture(boneMatrices, size, size, RGBAFormat, FloatType);
        boneTexture.needsUpdate = true;
        this.boneMatrices = boneMatrices;
        this.boneTexture = boneTexture;
        return this;
      }
      getBoneByName(name) {
        for (let i2 = 0, il = this.bones.length; i2 < il; i2++) {
          const bone = this.bones[i2];
          if (bone.name === name) {
            return bone;
          }
        }
        return void 0;
      }
      dispose() {
        if (this.boneTexture !== null) {
          this.boneTexture.dispose();
          this.boneTexture = null;
        }
      }
      fromJSON(json, bones) {
        this.uuid = json.uuid;
        for (let i2 = 0, l2 = json.bones.length; i2 < l2; i2++) {
          const uuid = json.bones[i2];
          let bone = bones[uuid];
          if (bone === void 0) {
            console.warn("THREE.Skeleton: No bone found with UUID:", uuid);
            bone = new Bone();
          }
          this.bones.push(bone);
          this.boneInverses.push(new Matrix4().fromArray(json.boneInverses[i2]));
        }
        this.init();
        return this;
      }
      toJSON() {
        const data = {
          metadata: {
            version: 4.6,
            type: "Skeleton",
            generator: "Skeleton.toJSON"
          },
          bones: [],
          boneInverses: []
        };
        data.uuid = this.uuid;
        const bones = this.bones;
        const boneInverses = this.boneInverses;
        for (let i2 = 0, l2 = bones.length; i2 < l2; i2++) {
          const bone = bones[i2];
          data.bones.push(bone.uuid);
          const boneInverse = boneInverses[i2];
          data.boneInverses.push(boneInverse.toArray());
        }
        return data;
      }
    };
    InstancedBufferAttribute = class extends BufferAttribute {
      constructor(array, itemSize, normalized, meshPerAttribute = 1) {
        super(array, itemSize, normalized);
        this.isInstancedBufferAttribute = true;
        this.meshPerAttribute = meshPerAttribute;
      }
      copy(source) {
        super.copy(source);
        this.meshPerAttribute = source.meshPerAttribute;
        return this;
      }
      toJSON() {
        const data = super.toJSON();
        data.meshPerAttribute = this.meshPerAttribute;
        data.isInstancedBufferAttribute = true;
        return data;
      }
    };
    _instanceLocalMatrix = /* @__PURE__ */ new Matrix4();
    _instanceWorldMatrix = /* @__PURE__ */ new Matrix4();
    _instanceIntersects = [];
    _box3 = /* @__PURE__ */ new Box3();
    _identity = /* @__PURE__ */ new Matrix4();
    _mesh$1 = /* @__PURE__ */ new Mesh();
    _sphere$3 = /* @__PURE__ */ new Sphere();
    InstancedMesh = class extends Mesh {
      constructor(geometry, material, count) {
        super(geometry, material);
        this.isInstancedMesh = true;
        this.instanceMatrix = new InstancedBufferAttribute(new Float32Array(count * 16), 16);
        this.instanceColor = null;
        this.morphTexture = null;
        this.count = count;
        this.boundingBox = null;
        this.boundingSphere = null;
        for (let i2 = 0; i2 < count; i2++) {
          this.setMatrixAt(i2, _identity);
        }
      }
      computeBoundingBox() {
        const geometry = this.geometry;
        const count = this.count;
        if (this.boundingBox === null) {
          this.boundingBox = new Box3();
        }
        if (geometry.boundingBox === null) {
          geometry.computeBoundingBox();
        }
        this.boundingBox.makeEmpty();
        for (let i2 = 0; i2 < count; i2++) {
          this.getMatrixAt(i2, _instanceLocalMatrix);
          _box3.copy(geometry.boundingBox).applyMatrix4(_instanceLocalMatrix);
          this.boundingBox.union(_box3);
        }
      }
      computeBoundingSphere() {
        const geometry = this.geometry;
        const count = this.count;
        if (this.boundingSphere === null) {
          this.boundingSphere = new Sphere();
        }
        if (geometry.boundingSphere === null) {
          geometry.computeBoundingSphere();
        }
        this.boundingSphere.makeEmpty();
        for (let i2 = 0; i2 < count; i2++) {
          this.getMatrixAt(i2, _instanceLocalMatrix);
          _sphere$3.copy(geometry.boundingSphere).applyMatrix4(_instanceLocalMatrix);
          this.boundingSphere.union(_sphere$3);
        }
      }
      copy(source, recursive) {
        super.copy(source, recursive);
        this.instanceMatrix.copy(source.instanceMatrix);
        if (source.morphTexture !== null) this.morphTexture = source.morphTexture.clone();
        if (source.instanceColor !== null) this.instanceColor = source.instanceColor.clone();
        this.count = source.count;
        if (source.boundingBox !== null) this.boundingBox = source.boundingBox.clone();
        if (source.boundingSphere !== null) this.boundingSphere = source.boundingSphere.clone();
        return this;
      }
      getColorAt(index, color) {
        color.fromArray(this.instanceColor.array, index * 3);
      }
      getMatrixAt(index, matrix2) {
        matrix2.fromArray(this.instanceMatrix.array, index * 16);
      }
      getMorphAt(index, object) {
        const objectInfluences = object.morphTargetInfluences;
        const array = this.morphTexture.source.data.data;
        const len = objectInfluences.length + 1;
        const dataIndex = index * len + 1;
        for (let i2 = 0; i2 < objectInfluences.length; i2++) {
          objectInfluences[i2] = array[dataIndex + i2];
        }
      }
      raycast(raycaster, intersects2) {
        const matrixWorld = this.matrixWorld;
        const raycastTimes = this.count;
        _mesh$1.geometry = this.geometry;
        _mesh$1.material = this.material;
        if (_mesh$1.material === void 0) return;
        if (this.boundingSphere === null) this.computeBoundingSphere();
        _sphere$3.copy(this.boundingSphere);
        _sphere$3.applyMatrix4(matrixWorld);
        if (raycaster.ray.intersectsSphere(_sphere$3) === false) return;
        for (let instanceId = 0; instanceId < raycastTimes; instanceId++) {
          this.getMatrixAt(instanceId, _instanceLocalMatrix);
          _instanceWorldMatrix.multiplyMatrices(matrixWorld, _instanceLocalMatrix);
          _mesh$1.matrixWorld = _instanceWorldMatrix;
          _mesh$1.raycast(raycaster, _instanceIntersects);
          for (let i2 = 0, l2 = _instanceIntersects.length; i2 < l2; i2++) {
            const intersect2 = _instanceIntersects[i2];
            intersect2.instanceId = instanceId;
            intersect2.object = this;
            intersects2.push(intersect2);
          }
          _instanceIntersects.length = 0;
        }
      }
      setColorAt(index, color) {
        if (this.instanceColor === null) {
          this.instanceColor = new InstancedBufferAttribute(new Float32Array(this.instanceMatrix.count * 3).fill(1), 3);
        }
        color.toArray(this.instanceColor.array, index * 3);
      }
      setMatrixAt(index, matrix2) {
        matrix2.toArray(this.instanceMatrix.array, index * 16);
      }
      setMorphAt(index, object) {
        const objectInfluences = object.morphTargetInfluences;
        const len = objectInfluences.length + 1;
        if (this.morphTexture === null) {
          this.morphTexture = new DataTexture(new Float32Array(len * this.count), len, this.count, RedFormat, FloatType);
        }
        const array = this.morphTexture.source.data.data;
        let morphInfluencesSum = 0;
        for (let i2 = 0; i2 < objectInfluences.length; i2++) {
          morphInfluencesSum += objectInfluences[i2];
        }
        const morphBaseInfluence = this.geometry.morphTargetsRelative ? 1 : 1 - morphInfluencesSum;
        const dataIndex = len * index;
        array[dataIndex] = morphBaseInfluence;
        array.set(objectInfluences, dataIndex + 1);
      }
      updateMorphTargets() {
      }
      dispose() {
        this.dispatchEvent({ type: "dispose" });
        if (this.morphTexture !== null) {
          this.morphTexture.dispose();
          this.morphTexture = null;
        }
        return this;
      }
    };
    MultiDrawRenderList = class {
      constructor() {
        this.index = 0;
        this.pool = [];
        this.list = [];
      }
      push(drawRange, z2, index) {
        const pool = this.pool;
        const list = this.list;
        if (this.index >= pool.length) {
          pool.push({
            start: -1,
            count: -1,
            z: -1,
            index: -1
          });
        }
        const item = pool[this.index];
        list.push(item);
        this.index++;
        item.start = drawRange.start;
        item.count = drawRange.count;
        item.z = z2;
        item.index = index;
      }
      reset() {
        this.list.length = 0;
        this.index = 0;
      }
    };
    _matrix$1 = /* @__PURE__ */ new Matrix4();
    _invMatrixWorld = /* @__PURE__ */ new Matrix4();
    _identityMatrix = /* @__PURE__ */ new Matrix4();
    _whiteColor = /* @__PURE__ */ new Color(1, 1, 1);
    _projScreenMatrix$2 = /* @__PURE__ */ new Matrix4();
    _frustum = /* @__PURE__ */ new Frustum();
    _box$1 = /* @__PURE__ */ new Box3();
    _sphere$2 = /* @__PURE__ */ new Sphere();
    _vector$5 = /* @__PURE__ */ new Vector3();
    _forward = /* @__PURE__ */ new Vector3();
    _temp = /* @__PURE__ */ new Vector3();
    _renderList = /* @__PURE__ */ new MultiDrawRenderList();
    _mesh = /* @__PURE__ */ new Mesh();
    _batchIntersects = [];
    BatchedMesh = class extends Mesh {
      get maxInstanceCount() {
        return this._maxInstanceCount;
      }
      constructor(maxInstanceCount, maxVertexCount, maxIndexCount = maxVertexCount * 2, material) {
        super(new BufferGeometry(), material);
        this.isBatchedMesh = true;
        this.perObjectFrustumCulled = true;
        this.sortObjects = true;
        this.boundingBox = null;
        this.boundingSphere = null;
        this.customSort = null;
        this._drawInfo = [];
        this._availableInstanceIds = [];
        this._drawRanges = [];
        this._reservedRanges = [];
        this._bounds = [];
        this._maxInstanceCount = maxInstanceCount;
        this._maxVertexCount = maxVertexCount;
        this._maxIndexCount = maxIndexCount;
        this._geometryInitialized = false;
        this._geometryCount = 0;
        this._multiDrawCounts = new Int32Array(maxInstanceCount);
        this._multiDrawStarts = new Int32Array(maxInstanceCount);
        this._multiDrawCount = 0;
        this._multiDrawInstances = null;
        this._visibilityChanged = true;
        this._matricesTexture = null;
        this._indirectTexture = null;
        this._colorsTexture = null;
        this._initMatricesTexture();
        this._initIndirectTexture();
      }
      _initMatricesTexture() {
        let size = Math.sqrt(this._maxInstanceCount * 4);
        size = Math.ceil(size / 4) * 4;
        size = Math.max(size, 4);
        const matricesArray = new Float32Array(size * size * 4);
        const matricesTexture = new DataTexture(matricesArray, size, size, RGBAFormat, FloatType);
        this._matricesTexture = matricesTexture;
      }
      _initIndirectTexture() {
        let size = Math.sqrt(this._maxInstanceCount);
        size = Math.ceil(size);
        const indirectArray = new Uint32Array(size * size);
        const indirectTexture = new DataTexture(indirectArray, size, size, RedIntegerFormat, UnsignedIntType);
        this._indirectTexture = indirectTexture;
      }
      _initColorsTexture() {
        let size = Math.sqrt(this._maxInstanceCount);
        size = Math.ceil(size);
        const colorsArray = new Float32Array(size * size * 4).fill(1);
        const colorsTexture = new DataTexture(colorsArray, size, size, RGBAFormat, FloatType);
        colorsTexture.colorSpace = ColorManagement.workingColorSpace;
        this._colorsTexture = colorsTexture;
      }
      _initializeGeometry(reference) {
        const geometry = this.geometry;
        const maxVertexCount = this._maxVertexCount;
        const maxIndexCount = this._maxIndexCount;
        if (this._geometryInitialized === false) {
          for (const attributeName in reference.attributes) {
            const srcAttribute = reference.getAttribute(attributeName);
            const { array, itemSize, normalized } = srcAttribute;
            const dstArray = new array.constructor(maxVertexCount * itemSize);
            const dstAttribute = new BufferAttribute(dstArray, itemSize, normalized);
            geometry.setAttribute(attributeName, dstAttribute);
          }
          if (reference.getIndex() !== null) {
            const indexArray = maxVertexCount > 65535 ? new Uint32Array(maxIndexCount) : new Uint16Array(maxIndexCount);
            geometry.setIndex(new BufferAttribute(indexArray, 1));
          }
          this._geometryInitialized = true;
        }
      }
      // Make sure the geometry is compatible with the existing combined geometry attributes
      _validateGeometry(geometry) {
        const batchGeometry = this.geometry;
        if (Boolean(geometry.getIndex()) !== Boolean(batchGeometry.getIndex())) {
          throw new Error('BatchedMesh: All geometries must consistently have "index".');
        }
        for (const attributeName in batchGeometry.attributes) {
          if (!geometry.hasAttribute(attributeName)) {
            throw new Error(`BatchedMesh: Added geometry missing "${attributeName}". All geometries must have consistent attributes.`);
          }
          const srcAttribute = geometry.getAttribute(attributeName);
          const dstAttribute = batchGeometry.getAttribute(attributeName);
          if (srcAttribute.itemSize !== dstAttribute.itemSize || srcAttribute.normalized !== dstAttribute.normalized) {
            throw new Error("BatchedMesh: All attributes must have a consistent itemSize and normalized value.");
          }
        }
      }
      setCustomSort(func) {
        this.customSort = func;
        return this;
      }
      computeBoundingBox() {
        if (this.boundingBox === null) {
          this.boundingBox = new Box3();
        }
        const boundingBox = this.boundingBox;
        const drawInfo = this._drawInfo;
        boundingBox.makeEmpty();
        for (let i2 = 0, l2 = drawInfo.length; i2 < l2; i2++) {
          if (drawInfo[i2].active === false) continue;
          const geometryId = drawInfo[i2].geometryIndex;
          this.getMatrixAt(i2, _matrix$1);
          this.getBoundingBoxAt(geometryId, _box$1).applyMatrix4(_matrix$1);
          boundingBox.union(_box$1);
        }
      }
      computeBoundingSphere() {
        if (this.boundingSphere === null) {
          this.boundingSphere = new Sphere();
        }
        const boundingSphere = this.boundingSphere;
        const drawInfo = this._drawInfo;
        boundingSphere.makeEmpty();
        for (let i2 = 0, l2 = drawInfo.length; i2 < l2; i2++) {
          if (drawInfo[i2].active === false) continue;
          const geometryId = drawInfo[i2].geometryIndex;
          this.getMatrixAt(i2, _matrix$1);
          this.getBoundingSphereAt(geometryId, _sphere$2).applyMatrix4(_matrix$1);
          boundingSphere.union(_sphere$2);
        }
      }
      addInstance(geometryId) {
        const atCapacity = this._drawInfo.length >= this.maxInstanceCount;
        if (atCapacity && this._availableInstanceIds.length === 0) {
          throw new Error("BatchedMesh: Maximum item count reached.");
        }
        const instanceDrawInfo = {
          visible: true,
          active: true,
          geometryIndex: geometryId
        };
        let drawId = null;
        if (this._availableInstanceIds.length > 0) {
          drawId = this._availableInstanceIds.pop();
          this._drawInfo[drawId] = instanceDrawInfo;
        } else {
          drawId = this._drawInfo.length;
          this._drawInfo.push(instanceDrawInfo);
        }
        const matricesTexture = this._matricesTexture;
        const matricesArray = matricesTexture.image.data;
        _identityMatrix.toArray(matricesArray, drawId * 16);
        matricesTexture.needsUpdate = true;
        const colorsTexture = this._colorsTexture;
        if (colorsTexture) {
          _whiteColor.toArray(colorsTexture.image.data, drawId * 4);
          colorsTexture.needsUpdate = true;
        }
        return drawId;
      }
      addGeometry(geometry, vertexCount = -1, indexCount = -1) {
        this._initializeGeometry(geometry);
        this._validateGeometry(geometry);
        if (this._drawInfo.length >= this._maxInstanceCount) {
          throw new Error("BatchedMesh: Maximum item count reached.");
        }
        const reservedRange = {
          vertexStart: -1,
          vertexCount: -1,
          indexStart: -1,
          indexCount: -1
        };
        let lastRange = null;
        const reservedRanges = this._reservedRanges;
        const drawRanges = this._drawRanges;
        const bounds = this._bounds;
        if (this._geometryCount !== 0) {
          lastRange = reservedRanges[reservedRanges.length - 1];
        }
        if (vertexCount === -1) {
          reservedRange.vertexCount = geometry.getAttribute("position").count;
        } else {
          reservedRange.vertexCount = vertexCount;
        }
        if (lastRange === null) {
          reservedRange.vertexStart = 0;
        } else {
          reservedRange.vertexStart = lastRange.vertexStart + lastRange.vertexCount;
        }
        const index = geometry.getIndex();
        const hasIndex = index !== null;
        if (hasIndex) {
          if (indexCount === -1) {
            reservedRange.indexCount = index.count;
          } else {
            reservedRange.indexCount = indexCount;
          }
          if (lastRange === null) {
            reservedRange.indexStart = 0;
          } else {
            reservedRange.indexStart = lastRange.indexStart + lastRange.indexCount;
          }
        }
        if (reservedRange.indexStart !== -1 && reservedRange.indexStart + reservedRange.indexCount > this._maxIndexCount || reservedRange.vertexStart + reservedRange.vertexCount > this._maxVertexCount) {
          throw new Error("BatchedMesh: Reserved space request exceeds the maximum buffer size.");
        }
        const geometryId = this._geometryCount;
        this._geometryCount++;
        reservedRanges.push(reservedRange);
        drawRanges.push({
          start: hasIndex ? reservedRange.indexStart : reservedRange.vertexStart,
          count: -1
        });
        bounds.push({
          boxInitialized: false,
          box: new Box3(),
          sphereInitialized: false,
          sphere: new Sphere()
        });
        this.setGeometryAt(geometryId, geometry);
        return geometryId;
      }
      setGeometryAt(geometryId, geometry) {
        if (geometryId >= this._geometryCount) {
          throw new Error("BatchedMesh: Maximum geometry count reached.");
        }
        this._validateGeometry(geometry);
        const batchGeometry = this.geometry;
        const hasIndex = batchGeometry.getIndex() !== null;
        const dstIndex = batchGeometry.getIndex();
        const srcIndex = geometry.getIndex();
        const reservedRange = this._reservedRanges[geometryId];
        if (hasIndex && srcIndex.count > reservedRange.indexCount || geometry.attributes.position.count > reservedRange.vertexCount) {
          throw new Error("BatchedMesh: Reserved space not large enough for provided geometry.");
        }
        const vertexStart = reservedRange.vertexStart;
        const vertexCount = reservedRange.vertexCount;
        for (const attributeName in batchGeometry.attributes) {
          const srcAttribute = geometry.getAttribute(attributeName);
          const dstAttribute = batchGeometry.getAttribute(attributeName);
          copyAttributeData(srcAttribute, dstAttribute, vertexStart);
          const itemSize = srcAttribute.itemSize;
          for (let i2 = srcAttribute.count, l2 = vertexCount; i2 < l2; i2++) {
            const index = vertexStart + i2;
            for (let c = 0; c < itemSize; c++) {
              dstAttribute.setComponent(index, c, 0);
            }
          }
          dstAttribute.needsUpdate = true;
          dstAttribute.addUpdateRange(vertexStart * itemSize, vertexCount * itemSize);
        }
        if (hasIndex) {
          const indexStart = reservedRange.indexStart;
          for (let i2 = 0; i2 < srcIndex.count; i2++) {
            dstIndex.setX(indexStart + i2, vertexStart + srcIndex.getX(i2));
          }
          for (let i2 = srcIndex.count, l2 = reservedRange.indexCount; i2 < l2; i2++) {
            dstIndex.setX(indexStart + i2, vertexStart);
          }
          dstIndex.needsUpdate = true;
          dstIndex.addUpdateRange(indexStart, reservedRange.indexCount);
        }
        const bound = this._bounds[geometryId];
        if (geometry.boundingBox !== null) {
          bound.box.copy(geometry.boundingBox);
          bound.boxInitialized = true;
        } else {
          bound.boxInitialized = false;
        }
        if (geometry.boundingSphere !== null) {
          bound.sphere.copy(geometry.boundingSphere);
          bound.sphereInitialized = true;
        } else {
          bound.sphereInitialized = false;
        }
        const drawRange = this._drawRanges[geometryId];
        const posAttr = geometry.getAttribute("position");
        drawRange.count = hasIndex ? srcIndex.count : posAttr.count;
        this._visibilityChanged = true;
        return geometryId;
      }
      /*
      	deleteGeometry( geometryId ) {
      
      		// TODO: delete geometry and associated instances
      
      	}
      	*/
      deleteInstance(instanceId) {
        const drawInfo = this._drawInfo;
        if (instanceId >= drawInfo.length || drawInfo[instanceId].active === false) {
          return this;
        }
        drawInfo[instanceId].active = false;
        this._availableInstanceIds.push(instanceId);
        this._visibilityChanged = true;
        return this;
      }
      // get bounding box and compute it if it doesn't exist
      getBoundingBoxAt(geometryId, target2) {
        if (geometryId >= this._geometryCount) {
          return null;
        }
        const bound = this._bounds[geometryId];
        const box = bound.box;
        const geometry = this.geometry;
        if (bound.boxInitialized === false) {
          box.makeEmpty();
          const index = geometry.index;
          const position = geometry.attributes.position;
          const drawRange = this._drawRanges[geometryId];
          for (let i2 = drawRange.start, l2 = drawRange.start + drawRange.count; i2 < l2; i2++) {
            let iv = i2;
            if (index) {
              iv = index.getX(iv);
            }
            box.expandByPoint(_vector$5.fromBufferAttribute(position, iv));
          }
          bound.boxInitialized = true;
        }
        target2.copy(box);
        return target2;
      }
      // get bounding sphere and compute it if it doesn't exist
      getBoundingSphereAt(geometryId, target2) {
        if (geometryId >= this._geometryCount) {
          return null;
        }
        const bound = this._bounds[geometryId];
        const sphere = bound.sphere;
        const geometry = this.geometry;
        if (bound.sphereInitialized === false) {
          sphere.makeEmpty();
          this.getBoundingBoxAt(geometryId, _box$1);
          _box$1.getCenter(sphere.center);
          const index = geometry.index;
          const position = geometry.attributes.position;
          const drawRange = this._drawRanges[geometryId];
          let maxRadiusSq = 0;
          for (let i2 = drawRange.start, l2 = drawRange.start + drawRange.count; i2 < l2; i2++) {
            let iv = i2;
            if (index) {
              iv = index.getX(iv);
            }
            _vector$5.fromBufferAttribute(position, iv);
            maxRadiusSq = Math.max(maxRadiusSq, sphere.center.distanceToSquared(_vector$5));
          }
          sphere.radius = Math.sqrt(maxRadiusSq);
          bound.sphereInitialized = true;
        }
        target2.copy(sphere);
        return target2;
      }
      setMatrixAt(instanceId, matrix2) {
        const drawInfo = this._drawInfo;
        const matricesTexture = this._matricesTexture;
        const matricesArray = this._matricesTexture.image.data;
        if (instanceId >= drawInfo.length || drawInfo[instanceId].active === false) {
          return this;
        }
        matrix2.toArray(matricesArray, instanceId * 16);
        matricesTexture.needsUpdate = true;
        return this;
      }
      getMatrixAt(instanceId, matrix2) {
        const drawInfo = this._drawInfo;
        const matricesArray = this._matricesTexture.image.data;
        if (instanceId >= drawInfo.length || drawInfo[instanceId].active === false) {
          return null;
        }
        return matrix2.fromArray(matricesArray, instanceId * 16);
      }
      setColorAt(instanceId, color) {
        if (this._colorsTexture === null) {
          this._initColorsTexture();
        }
        const colorsTexture = this._colorsTexture;
        const colorsArray = this._colorsTexture.image.data;
        const drawInfo = this._drawInfo;
        if (instanceId >= drawInfo.length || drawInfo[instanceId].active === false) {
          return this;
        }
        color.toArray(colorsArray, instanceId * 4);
        colorsTexture.needsUpdate = true;
        return this;
      }
      getColorAt(instanceId, color) {
        const colorsArray = this._colorsTexture.image.data;
        const drawInfo = this._drawInfo;
        if (instanceId >= drawInfo.length || drawInfo[instanceId].active === false) {
          return null;
        }
        return color.fromArray(colorsArray, instanceId * 4);
      }
      setVisibleAt(instanceId, value) {
        const drawInfo = this._drawInfo;
        if (instanceId >= drawInfo.length || drawInfo[instanceId].active === false || drawInfo[instanceId].visible === value) {
          return this;
        }
        drawInfo[instanceId].visible = value;
        this._visibilityChanged = true;
        return this;
      }
      getVisibleAt(instanceId) {
        const drawInfo = this._drawInfo;
        if (instanceId >= drawInfo.length || drawInfo[instanceId].active === false) {
          return false;
        }
        return drawInfo[instanceId].visible;
      }
      setGeometryIdAt(instanceId, geometryId) {
        const drawInfo = this._drawInfo;
        if (instanceId >= drawInfo.length || drawInfo[instanceId].active === false) {
          return null;
        }
        if (geometryId < 0 || geometryId >= this._geometryCount) {
          return null;
        }
        drawInfo[instanceId].geometryIndex = geometryId;
        return this;
      }
      getGeometryIdAt(instanceId) {
        const drawInfo = this._drawInfo;
        if (instanceId >= drawInfo.length || drawInfo[instanceId].active === false) {
          return -1;
        }
        return drawInfo[instanceId].geometryIndex;
      }
      getGeometryRangeAt(geometryId, target2 = {}) {
        if (geometryId < 0 || geometryId >= this._geometryCount) {
          return null;
        }
        const drawRange = this._drawRanges[geometryId];
        target2.start = drawRange.start;
        target2.count = drawRange.count;
        return target2;
      }
      raycast(raycaster, intersects2) {
        const drawInfo = this._drawInfo;
        const drawRanges = this._drawRanges;
        const matrixWorld = this.matrixWorld;
        const batchGeometry = this.geometry;
        _mesh.material = this.material;
        _mesh.geometry.index = batchGeometry.index;
        _mesh.geometry.attributes = batchGeometry.attributes;
        if (_mesh.geometry.boundingBox === null) {
          _mesh.geometry.boundingBox = new Box3();
        }
        if (_mesh.geometry.boundingSphere === null) {
          _mesh.geometry.boundingSphere = new Sphere();
        }
        for (let i2 = 0, l2 = drawInfo.length; i2 < l2; i2++) {
          if (!drawInfo[i2].visible || !drawInfo[i2].active) {
            continue;
          }
          const geometryId = drawInfo[i2].geometryIndex;
          const drawRange = drawRanges[geometryId];
          _mesh.geometry.setDrawRange(drawRange.start, drawRange.count);
          this.getMatrixAt(i2, _mesh.matrixWorld).premultiply(matrixWorld);
          this.getBoundingBoxAt(geometryId, _mesh.geometry.boundingBox);
          this.getBoundingSphereAt(geometryId, _mesh.geometry.boundingSphere);
          _mesh.raycast(raycaster, _batchIntersects);
          for (let j2 = 0, l22 = _batchIntersects.length; j2 < l22; j2++) {
            const intersect2 = _batchIntersects[j2];
            intersect2.object = this;
            intersect2.batchId = i2;
            intersects2.push(intersect2);
          }
          _batchIntersects.length = 0;
        }
        _mesh.material = null;
        _mesh.geometry.index = null;
        _mesh.geometry.attributes = {};
        _mesh.geometry.setDrawRange(0, Infinity);
      }
      copy(source) {
        super.copy(source);
        this.geometry = source.geometry.clone();
        this.perObjectFrustumCulled = source.perObjectFrustumCulled;
        this.sortObjects = source.sortObjects;
        this.boundingBox = source.boundingBox !== null ? source.boundingBox.clone() : null;
        this.boundingSphere = source.boundingSphere !== null ? source.boundingSphere.clone() : null;
        this._drawRanges = source._drawRanges.map((range) => __spreadValues({}, range));
        this._reservedRanges = source._reservedRanges.map((range) => __spreadValues({}, range));
        this._drawInfo = source._drawInfo.map((inf) => __spreadValues({}, inf));
        this._bounds = source._bounds.map((bound) => ({
          boxInitialized: bound.boxInitialized,
          box: bound.box.clone(),
          sphereInitialized: bound.sphereInitialized,
          sphere: bound.sphere.clone()
        }));
        this._maxInstanceCount = source._maxInstanceCount;
        this._maxVertexCount = source._maxVertexCount;
        this._maxIndexCount = source._maxIndexCount;
        this._geometryInitialized = source._geometryInitialized;
        this._geometryCount = source._geometryCount;
        this._multiDrawCounts = source._multiDrawCounts.slice();
        this._multiDrawStarts = source._multiDrawStarts.slice();
        this._matricesTexture = source._matricesTexture.clone();
        this._matricesTexture.image.data = this._matricesTexture.image.data.slice();
        if (this._colorsTexture !== null) {
          this._colorsTexture = source._colorsTexture.clone();
          this._colorsTexture.image.data = this._colorsTexture.image.data.slice();
        }
        return this;
      }
      dispose() {
        this.geometry.dispose();
        this._matricesTexture.dispose();
        this._matricesTexture = null;
        this._indirectTexture.dispose();
        this._indirectTexture = null;
        if (this._colorsTexture !== null) {
          this._colorsTexture.dispose();
          this._colorsTexture = null;
        }
        return this;
      }
      onBeforeRender(renderer, scene, camera, geometry, material) {
        if (!this._visibilityChanged && !this.perObjectFrustumCulled && !this.sortObjects) {
          return;
        }
        const index = geometry.getIndex();
        const bytesPerElement = index === null ? 1 : index.array.BYTES_PER_ELEMENT;
        const drawInfo = this._drawInfo;
        const multiDrawStarts = this._multiDrawStarts;
        const multiDrawCounts = this._multiDrawCounts;
        const drawRanges = this._drawRanges;
        const perObjectFrustumCulled = this.perObjectFrustumCulled;
        const indirectTexture = this._indirectTexture;
        const indirectArray = indirectTexture.image.data;
        if (perObjectFrustumCulled) {
          _projScreenMatrix$2.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse).multiply(this.matrixWorld);
          _frustum.setFromProjectionMatrix(
            _projScreenMatrix$2,
            renderer.coordinateSystem
          );
        }
        let count = 0;
        if (this.sortObjects) {
          _invMatrixWorld.copy(this.matrixWorld).invert();
          _vector$5.setFromMatrixPosition(camera.matrixWorld).applyMatrix4(_invMatrixWorld);
          _forward.set(0, 0, -1).transformDirection(camera.matrixWorld).transformDirection(_invMatrixWorld);
          for (let i2 = 0, l2 = drawInfo.length; i2 < l2; i2++) {
            if (drawInfo[i2].visible && drawInfo[i2].active) {
              const geometryId = drawInfo[i2].geometryIndex;
              this.getMatrixAt(i2, _matrix$1);
              this.getBoundingSphereAt(geometryId, _sphere$2).applyMatrix4(_matrix$1);
              let culled = false;
              if (perObjectFrustumCulled) {
                culled = !_frustum.intersectsSphere(_sphere$2);
              }
              if (!culled) {
                const z2 = _temp.subVectors(_sphere$2.center, _vector$5).dot(_forward);
                _renderList.push(drawRanges[geometryId], z2, i2);
              }
            }
          }
          const list = _renderList.list;
          const customSort = this.customSort;
          if (customSort === null) {
            list.sort(material.transparent ? sortTransparent : sortOpaque);
          } else {
            customSort.call(this, list, camera);
          }
          for (let i2 = 0, l2 = list.length; i2 < l2; i2++) {
            const item = list[i2];
            multiDrawStarts[count] = item.start * bytesPerElement;
            multiDrawCounts[count] = item.count;
            indirectArray[count] = item.index;
            count++;
          }
          _renderList.reset();
        } else {
          for (let i2 = 0, l2 = drawInfo.length; i2 < l2; i2++) {
            if (drawInfo[i2].visible && drawInfo[i2].active) {
              const geometryId = drawInfo[i2].geometryIndex;
              let culled = false;
              if (perObjectFrustumCulled) {
                this.getMatrixAt(i2, _matrix$1);
                this.getBoundingSphereAt(geometryId, _sphere$2).applyMatrix4(_matrix$1);
                culled = !_frustum.intersectsSphere(_sphere$2);
              }
              if (!culled) {
                const range = drawRanges[geometryId];
                multiDrawStarts[count] = range.start * bytesPerElement;
                multiDrawCounts[count] = range.count;
                indirectArray[count] = i2;
                count++;
              }
            }
          }
        }
        indirectTexture.needsUpdate = true;
        this._multiDrawCount = count;
        this._visibilityChanged = false;
      }
      onBeforeShadow(renderer, object, camera, shadowCamera, geometry, depthMaterial) {
        this.onBeforeRender(renderer, null, shadowCamera, geometry, depthMaterial);
      }
    };
    LineBasicMaterial = class extends Material {
      constructor(parameters) {
        super();
        this.isLineBasicMaterial = true;
        this.type = "LineBasicMaterial";
        this.color = new Color(16777215);
        this.map = null;
        this.linewidth = 1;
        this.linecap = "round";
        this.linejoin = "round";
        this.fog = true;
        this.setValues(parameters);
      }
      copy(source) {
        super.copy(source);
        this.color.copy(source.color);
        this.map = source.map;
        this.linewidth = source.linewidth;
        this.linecap = source.linecap;
        this.linejoin = source.linejoin;
        this.fog = source.fog;
        return this;
      }
    };
    _vStart = /* @__PURE__ */ new Vector3();
    _vEnd = /* @__PURE__ */ new Vector3();
    _inverseMatrix$1 = /* @__PURE__ */ new Matrix4();
    _ray$1 = /* @__PURE__ */ new Ray();
    _sphere$1 = /* @__PURE__ */ new Sphere();
    _intersectPointOnRay = /* @__PURE__ */ new Vector3();
    _intersectPointOnSegment = /* @__PURE__ */ new Vector3();
    Line = class extends Object3D {
      constructor(geometry = new BufferGeometry(), material = new LineBasicMaterial()) {
        super();
        this.isLine = true;
        this.type = "Line";
        this.geometry = geometry;
        this.material = material;
        this.updateMorphTargets();
      }
      copy(source, recursive) {
        super.copy(source, recursive);
        this.material = Array.isArray(source.material) ? source.material.slice() : source.material;
        this.geometry = source.geometry;
        return this;
      }
      computeLineDistances() {
        const geometry = this.geometry;
        if (geometry.index === null) {
          const positionAttribute = geometry.attributes.position;
          const lineDistances = [0];
          for (let i2 = 1, l2 = positionAttribute.count; i2 < l2; i2++) {
            _vStart.fromBufferAttribute(positionAttribute, i2 - 1);
            _vEnd.fromBufferAttribute(positionAttribute, i2);
            lineDistances[i2] = lineDistances[i2 - 1];
            lineDistances[i2] += _vStart.distanceTo(_vEnd);
          }
          geometry.setAttribute("lineDistance", new Float32BufferAttribute(lineDistances, 1));
        } else {
          console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
        }
        return this;
      }
      raycast(raycaster, intersects2) {
        const geometry = this.geometry;
        const matrixWorld = this.matrixWorld;
        const threshold = raycaster.params.Line.threshold;
        const drawRange = geometry.drawRange;
        if (geometry.boundingSphere === null) geometry.computeBoundingSphere();
        _sphere$1.copy(geometry.boundingSphere);
        _sphere$1.applyMatrix4(matrixWorld);
        _sphere$1.radius += threshold;
        if (raycaster.ray.intersectsSphere(_sphere$1) === false) return;
        _inverseMatrix$1.copy(matrixWorld).invert();
        _ray$1.copy(raycaster.ray).applyMatrix4(_inverseMatrix$1);
        const localThreshold = threshold / ((this.scale.x + this.scale.y + this.scale.z) / 3);
        const localThresholdSq = localThreshold * localThreshold;
        const step = this.isLineSegments ? 2 : 1;
        const index = geometry.index;
        const attributes = geometry.attributes;
        const positionAttribute = attributes.position;
        if (index !== null) {
          const start = Math.max(0, drawRange.start);
          const end = Math.min(index.count, drawRange.start + drawRange.count);
          for (let i2 = start, l2 = end - 1; i2 < l2; i2 += step) {
            const a = index.getX(i2);
            const b = index.getX(i2 + 1);
            const intersect2 = checkIntersection(this, raycaster, _ray$1, localThresholdSq, a, b);
            if (intersect2) {
              intersects2.push(intersect2);
            }
          }
          if (this.isLineLoop) {
            const a = index.getX(end - 1);
            const b = index.getX(start);
            const intersect2 = checkIntersection(this, raycaster, _ray$1, localThresholdSq, a, b);
            if (intersect2) {
              intersects2.push(intersect2);
            }
          }
        } else {
          const start = Math.max(0, drawRange.start);
          const end = Math.min(positionAttribute.count, drawRange.start + drawRange.count);
          for (let i2 = start, l2 = end - 1; i2 < l2; i2 += step) {
            const intersect2 = checkIntersection(this, raycaster, _ray$1, localThresholdSq, i2, i2 + 1);
            if (intersect2) {
              intersects2.push(intersect2);
            }
          }
          if (this.isLineLoop) {
            const intersect2 = checkIntersection(this, raycaster, _ray$1, localThresholdSq, end - 1, start);
            if (intersect2) {
              intersects2.push(intersect2);
            }
          }
        }
      }
      updateMorphTargets() {
        const geometry = this.geometry;
        const morphAttributes = geometry.morphAttributes;
        const keys = Object.keys(morphAttributes);
        if (keys.length > 0) {
          const morphAttribute = morphAttributes[keys[0]];
          if (morphAttribute !== void 0) {
            this.morphTargetInfluences = [];
            this.morphTargetDictionary = {};
            for (let m = 0, ml = morphAttribute.length; m < ml; m++) {
              const name = morphAttribute[m].name || String(m);
              this.morphTargetInfluences.push(0);
              this.morphTargetDictionary[name] = m;
            }
          }
        }
      }
    };
    _start = /* @__PURE__ */ new Vector3();
    _end = /* @__PURE__ */ new Vector3();
    LineSegments = class extends Line {
      constructor(geometry, material) {
        super(geometry, material);
        this.isLineSegments = true;
        this.type = "LineSegments";
      }
      computeLineDistances() {
        const geometry = this.geometry;
        if (geometry.index === null) {
          const positionAttribute = geometry.attributes.position;
          const lineDistances = [];
          for (let i2 = 0, l2 = positionAttribute.count; i2 < l2; i2 += 2) {
            _start.fromBufferAttribute(positionAttribute, i2);
            _end.fromBufferAttribute(positionAttribute, i2 + 1);
            lineDistances[i2] = i2 === 0 ? 0 : lineDistances[i2 - 1];
            lineDistances[i2 + 1] = lineDistances[i2] + _start.distanceTo(_end);
          }
          geometry.setAttribute("lineDistance", new Float32BufferAttribute(lineDistances, 1));
        } else {
          console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
        }
        return this;
      }
    };
    LineLoop = class extends Line {
      constructor(geometry, material) {
        super(geometry, material);
        this.isLineLoop = true;
        this.type = "LineLoop";
      }
    };
    PointsMaterial = class extends Material {
      constructor(parameters) {
        super();
        this.isPointsMaterial = true;
        this.type = "PointsMaterial";
        this.color = new Color(16777215);
        this.map = null;
        this.alphaMap = null;
        this.size = 1;
        this.sizeAttenuation = true;
        this.fog = true;
        this.setValues(parameters);
      }
      copy(source) {
        super.copy(source);
        this.color.copy(source.color);
        this.map = source.map;
        this.alphaMap = source.alphaMap;
        this.size = source.size;
        this.sizeAttenuation = source.sizeAttenuation;
        this.fog = source.fog;
        return this;
      }
    };
    _inverseMatrix = /* @__PURE__ */ new Matrix4();
    _ray = /* @__PURE__ */ new Ray();
    _sphere = /* @__PURE__ */ new Sphere();
    _position$2 = /* @__PURE__ */ new Vector3();
    Points = class extends Object3D {
      constructor(geometry = new BufferGeometry(), material = new PointsMaterial()) {
        super();
        this.isPoints = true;
        this.type = "Points";
        this.geometry = geometry;
        this.material = material;
        this.updateMorphTargets();
      }
      copy(source, recursive) {
        super.copy(source, recursive);
        this.material = Array.isArray(source.material) ? source.material.slice() : source.material;
        this.geometry = source.geometry;
        return this;
      }
      raycast(raycaster, intersects2) {
        const geometry = this.geometry;
        const matrixWorld = this.matrixWorld;
        const threshold = raycaster.params.Points.threshold;
        const drawRange = geometry.drawRange;
        if (geometry.boundingSphere === null) geometry.computeBoundingSphere();
        _sphere.copy(geometry.boundingSphere);
        _sphere.applyMatrix4(matrixWorld);
        _sphere.radius += threshold;
        if (raycaster.ray.intersectsSphere(_sphere) === false) return;
        _inverseMatrix.copy(matrixWorld).invert();
        _ray.copy(raycaster.ray).applyMatrix4(_inverseMatrix);
        const localThreshold = threshold / ((this.scale.x + this.scale.y + this.scale.z) / 3);
        const localThresholdSq = localThreshold * localThreshold;
        const index = geometry.index;
        const attributes = geometry.attributes;
        const positionAttribute = attributes.position;
        if (index !== null) {
          const start = Math.max(0, drawRange.start);
          const end = Math.min(index.count, drawRange.start + drawRange.count);
          for (let i2 = start, il = end; i2 < il; i2++) {
            const a = index.getX(i2);
            _position$2.fromBufferAttribute(positionAttribute, a);
            testPoint(_position$2, a, localThresholdSq, matrixWorld, raycaster, intersects2, this);
          }
        } else {
          const start = Math.max(0, drawRange.start);
          const end = Math.min(positionAttribute.count, drawRange.start + drawRange.count);
          for (let i2 = start, l2 = end; i2 < l2; i2++) {
            _position$2.fromBufferAttribute(positionAttribute, i2);
            testPoint(_position$2, i2, localThresholdSq, matrixWorld, raycaster, intersects2, this);
          }
        }
      }
      updateMorphTargets() {
        const geometry = this.geometry;
        const morphAttributes = geometry.morphAttributes;
        const keys = Object.keys(morphAttributes);
        if (keys.length > 0) {
          const morphAttribute = morphAttributes[keys[0]];
          if (morphAttribute !== void 0) {
            this.morphTargetInfluences = [];
            this.morphTargetDictionary = {};
            for (let m = 0, ml = morphAttribute.length; m < ml; m++) {
              const name = morphAttribute[m].name || String(m);
              this.morphTargetInfluences.push(0);
              this.morphTargetDictionary[name] = m;
            }
          }
        }
      }
    };
    VideoTexture = class extends Texture {
      constructor(video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy) {
        super(video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);
        this.isVideoTexture = true;
        this.minFilter = minFilter !== void 0 ? minFilter : LinearFilter;
        this.magFilter = magFilter !== void 0 ? magFilter : LinearFilter;
        this.generateMipmaps = false;
        const scope = this;
        function updateVideo() {
          scope.needsUpdate = true;
          video.requestVideoFrameCallback(updateVideo);
        }
        if ("requestVideoFrameCallback" in video) {
          video.requestVideoFrameCallback(updateVideo);
        }
      }
      clone() {
        return new this.constructor(this.image).copy(this);
      }
      update() {
        const video = this.image;
        const hasVideoFrameCallback = "requestVideoFrameCallback" in video;
        if (hasVideoFrameCallback === false && video.readyState >= video.HAVE_CURRENT_DATA) {
          this.needsUpdate = true;
        }
      }
    };
    FramebufferTexture = class extends Texture {
      constructor(width, height) {
        super({ width, height });
        this.isFramebufferTexture = true;
        this.magFilter = NearestFilter;
        this.minFilter = NearestFilter;
        this.generateMipmaps = false;
        this.needsUpdate = true;
      }
    };
    CompressedTexture = class extends Texture {
      constructor(mipmaps, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, colorSpace) {
        super(null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, colorSpace);
        this.isCompressedTexture = true;
        this.image = { width, height };
        this.mipmaps = mipmaps;
        this.flipY = false;
        this.generateMipmaps = false;
      }
    };
    CompressedArrayTexture = class extends CompressedTexture {
      constructor(mipmaps, width, height, depth, format, type) {
        super(mipmaps, width, height, format, type);
        this.isCompressedArrayTexture = true;
        this.image.depth = depth;
        this.wrapR = ClampToEdgeWrapping;
        this.layerUpdates = /* @__PURE__ */ new Set();
      }
      addLayerUpdate(layerIndex) {
        this.layerUpdates.add(layerIndex);
      }
      clearLayerUpdates() {
        this.layerUpdates.clear();
      }
    };
    CompressedCubeTexture = class extends CompressedTexture {
      constructor(images, format, type) {
        super(void 0, images[0].width, images[0].height, format, type, CubeReflectionMapping);
        this.isCompressedCubeTexture = true;
        this.isCubeTexture = true;
        this.image = images;
      }
    };
    CanvasTexture = class extends Texture {
      constructor(canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy) {
        super(canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);
        this.isCanvasTexture = true;
        this.needsUpdate = true;
      }
    };
    Curve = class {
      constructor() {
        this.type = "Curve";
        this.arcLengthDivisions = 200;
      }
      // Virtual base class method to overwrite and implement in subclasses
      //	- t [0 .. 1]
      getPoint() {
        console.warn("THREE.Curve: .getPoint() not implemented.");
        return null;
      }
      // Get point at relative position in curve according to arc length
      // - u [0 .. 1]
      getPointAt(u3, optionalTarget) {
        const t2 = this.getUtoTmapping(u3);
        return this.getPoint(t2, optionalTarget);
      }
      // Get sequence of points using getPoint( t )
      getPoints(divisions = 5) {
        const points = [];
        for (let d = 0; d <= divisions; d++) {
          points.push(this.getPoint(d / divisions));
        }
        return points;
      }
      // Get sequence of points using getPointAt( u )
      getSpacedPoints(divisions = 5) {
        const points = [];
        for (let d = 0; d <= divisions; d++) {
          points.push(this.getPointAt(d / divisions));
        }
        return points;
      }
      // Get total curve arc length
      getLength() {
        const lengths = this.getLengths();
        return lengths[lengths.length - 1];
      }
      // Get list of cumulative segment lengths
      getLengths(divisions = this.arcLengthDivisions) {
        if (this.cacheArcLengths && this.cacheArcLengths.length === divisions + 1 && !this.needsUpdate) {
          return this.cacheArcLengths;
        }
        this.needsUpdate = false;
        const cache = [];
        let current, last = this.getPoint(0);
        let sum = 0;
        cache.push(0);
        for (let p3 = 1; p3 <= divisions; p3++) {
          current = this.getPoint(p3 / divisions);
          sum += current.distanceTo(last);
          cache.push(sum);
          last = current;
        }
        this.cacheArcLengths = cache;
        return cache;
      }
      updateArcLengths() {
        this.needsUpdate = true;
        this.getLengths();
      }
      // Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equidistant
      getUtoTmapping(u3, distance) {
        const arcLengths = this.getLengths();
        let i2 = 0;
        const il = arcLengths.length;
        let targetArcLength;
        if (distance) {
          targetArcLength = distance;
        } else {
          targetArcLength = u3 * arcLengths[il - 1];
        }
        let low = 0, high = il - 1, comparison;
        while (low <= high) {
          i2 = Math.floor(low + (high - low) / 2);
          comparison = arcLengths[i2] - targetArcLength;
          if (comparison < 0) {
            low = i2 + 1;
          } else if (comparison > 0) {
            high = i2 - 1;
          } else {
            high = i2;
            break;
          }
        }
        i2 = high;
        if (arcLengths[i2] === targetArcLength) {
          return i2 / (il - 1);
        }
        const lengthBefore = arcLengths[i2];
        const lengthAfter = arcLengths[i2 + 1];
        const segmentLength = lengthAfter - lengthBefore;
        const segmentFraction = (targetArcLength - lengthBefore) / segmentLength;
        const t2 = (i2 + segmentFraction) / (il - 1);
        return t2;
      }
      // Returns a unit vector tangent at t
      // In case any sub curve does not implement its tangent derivation,
      // 2 points a small delta apart will be used to find its gradient
      // which seems to give a reasonable approximation
      getTangent(t2, optionalTarget) {
        const delta = 1e-4;
        let t1 = t2 - delta;
        let t22 = t2 + delta;
        if (t1 < 0) t1 = 0;
        if (t22 > 1) t22 = 1;
        const pt1 = this.getPoint(t1);
        const pt2 = this.getPoint(t22);
        const tangent = optionalTarget || (pt1.isVector2 ? new Vector2() : new Vector3());
        tangent.copy(pt2).sub(pt1).normalize();
        return tangent;
      }
      getTangentAt(u3, optionalTarget) {
        const t2 = this.getUtoTmapping(u3);
        return this.getTangent(t2, optionalTarget);
      }
      computeFrenetFrames(segments, closed) {
        const normal = new Vector3();
        const tangents = [];
        const normals = [];
        const binormals = [];
        const vec = new Vector3();
        const mat = new Matrix4();
        for (let i2 = 0; i2 <= segments; i2++) {
          const u3 = i2 / segments;
          tangents[i2] = this.getTangentAt(u3, new Vector3());
        }
        normals[0] = new Vector3();
        binormals[0] = new Vector3();
        let min = Number.MAX_VALUE;
        const tx = Math.abs(tangents[0].x);
        const ty = Math.abs(tangents[0].y);
        const tz = Math.abs(tangents[0].z);
        if (tx <= min) {
          min = tx;
          normal.set(1, 0, 0);
        }
        if (ty <= min) {
          min = ty;
          normal.set(0, 1, 0);
        }
        if (tz <= min) {
          normal.set(0, 0, 1);
        }
        vec.crossVectors(tangents[0], normal).normalize();
        normals[0].crossVectors(tangents[0], vec);
        binormals[0].crossVectors(tangents[0], normals[0]);
        for (let i2 = 1; i2 <= segments; i2++) {
          normals[i2] = normals[i2 - 1].clone();
          binormals[i2] = binormals[i2 - 1].clone();
          vec.crossVectors(tangents[i2 - 1], tangents[i2]);
          if (vec.length() > Number.EPSILON) {
            vec.normalize();
            const theta = Math.acos(clamp(tangents[i2 - 1].dot(tangents[i2]), -1, 1));
            normals[i2].applyMatrix4(mat.makeRotationAxis(vec, theta));
          }
          binormals[i2].crossVectors(tangents[i2], normals[i2]);
        }
        if (closed === true) {
          let theta = Math.acos(clamp(normals[0].dot(normals[segments]), -1, 1));
          theta /= segments;
          if (tangents[0].dot(vec.crossVectors(normals[0], normals[segments])) > 0) {
            theta = -theta;
          }
          for (let i2 = 1; i2 <= segments; i2++) {
            normals[i2].applyMatrix4(mat.makeRotationAxis(tangents[i2], theta * i2));
            binormals[i2].crossVectors(tangents[i2], normals[i2]);
          }
        }
        return {
          tangents,
          normals,
          binormals
        };
      }
      clone() {
        return new this.constructor().copy(this);
      }
      copy(source) {
        this.arcLengthDivisions = source.arcLengthDivisions;
        return this;
      }
      toJSON() {
        const data = {
          metadata: {
            version: 4.6,
            type: "Curve",
            generator: "Curve.toJSON"
          }
        };
        data.arcLengthDivisions = this.arcLengthDivisions;
        data.type = this.type;
        return data;
      }
      fromJSON(json) {
        this.arcLengthDivisions = json.arcLengthDivisions;
        return this;
      }
    };
    EllipseCurve = class extends Curve {
      constructor(aX = 0, aY = 0, xRadius = 1, yRadius = 1, aStartAngle = 0, aEndAngle = Math.PI * 2, aClockwise = false, aRotation = 0) {
        super();
        this.isEllipseCurve = true;
        this.type = "EllipseCurve";
        this.aX = aX;
        this.aY = aY;
        this.xRadius = xRadius;
        this.yRadius = yRadius;
        this.aStartAngle = aStartAngle;
        this.aEndAngle = aEndAngle;
        this.aClockwise = aClockwise;
        this.aRotation = aRotation;
      }
      getPoint(t2, optionalTarget = new Vector2()) {
        const point = optionalTarget;
        const twoPi = Math.PI * 2;
        let deltaAngle = this.aEndAngle - this.aStartAngle;
        const samePoints = Math.abs(deltaAngle) < Number.EPSILON;
        while (deltaAngle < 0) deltaAngle += twoPi;
        while (deltaAngle > twoPi) deltaAngle -= twoPi;
        if (deltaAngle < Number.EPSILON) {
          if (samePoints) {
            deltaAngle = 0;
          } else {
            deltaAngle = twoPi;
          }
        }
        if (this.aClockwise === true && !samePoints) {
          if (deltaAngle === twoPi) {
            deltaAngle = -twoPi;
          } else {
            deltaAngle = deltaAngle - twoPi;
          }
        }
        const angle = this.aStartAngle + t2 * deltaAngle;
        let x = this.aX + this.xRadius * Math.cos(angle);
        let y2 = this.aY + this.yRadius * Math.sin(angle);
        if (this.aRotation !== 0) {
          const cos = Math.cos(this.aRotation);
          const sin = Math.sin(this.aRotation);
          const tx = x - this.aX;
          const ty = y2 - this.aY;
          x = tx * cos - ty * sin + this.aX;
          y2 = tx * sin + ty * cos + this.aY;
        }
        return point.set(x, y2);
      }
      copy(source) {
        super.copy(source);
        this.aX = source.aX;
        this.aY = source.aY;
        this.xRadius = source.xRadius;
        this.yRadius = source.yRadius;
        this.aStartAngle = source.aStartAngle;
        this.aEndAngle = source.aEndAngle;
        this.aClockwise = source.aClockwise;
        this.aRotation = source.aRotation;
        return this;
      }
      toJSON() {
        const data = super.toJSON();
        data.aX = this.aX;
        data.aY = this.aY;
        data.xRadius = this.xRadius;
        data.yRadius = this.yRadius;
        data.aStartAngle = this.aStartAngle;
        data.aEndAngle = this.aEndAngle;
        data.aClockwise = this.aClockwise;
        data.aRotation = this.aRotation;
        return data;
      }
      fromJSON(json) {
        super.fromJSON(json);
        this.aX = json.aX;
        this.aY = json.aY;
        this.xRadius = json.xRadius;
        this.yRadius = json.yRadius;
        this.aStartAngle = json.aStartAngle;
        this.aEndAngle = json.aEndAngle;
        this.aClockwise = json.aClockwise;
        this.aRotation = json.aRotation;
        return this;
      }
    };
    ArcCurve = class extends EllipseCurve {
      constructor(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
        super(aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise);
        this.isArcCurve = true;
        this.type = "ArcCurve";
      }
    };
    tmp = /* @__PURE__ */ new Vector3();
    px = /* @__PURE__ */ new CubicPoly();
    py = /* @__PURE__ */ new CubicPoly();
    pz = /* @__PURE__ */ new CubicPoly();
    CatmullRomCurve3 = class extends Curve {
      constructor(points = [], closed = false, curveType = "centripetal", tension = 0.5) {
        super();
        this.isCatmullRomCurve3 = true;
        this.type = "CatmullRomCurve3";
        this.points = points;
        this.closed = closed;
        this.curveType = curveType;
        this.tension = tension;
      }
      getPoint(t2, optionalTarget = new Vector3()) {
        const point = optionalTarget;
        const points = this.points;
        const l2 = points.length;
        const p3 = (l2 - (this.closed ? 0 : 1)) * t2;
        let intPoint = Math.floor(p3);
        let weight = p3 - intPoint;
        if (this.closed) {
          intPoint += intPoint > 0 ? 0 : (Math.floor(Math.abs(intPoint) / l2) + 1) * l2;
        } else if (weight === 0 && intPoint === l2 - 1) {
          intPoint = l2 - 2;
          weight = 1;
        }
        let p0, p32;
        if (this.closed || intPoint > 0) {
          p0 = points[(intPoint - 1) % l2];
        } else {
          tmp.subVectors(points[0], points[1]).add(points[0]);
          p0 = tmp;
        }
        const p1 = points[intPoint % l2];
        const p22 = points[(intPoint + 1) % l2];
        if (this.closed || intPoint + 2 < l2) {
          p32 = points[(intPoint + 2) % l2];
        } else {
          tmp.subVectors(points[l2 - 1], points[l2 - 2]).add(points[l2 - 1]);
          p32 = tmp;
        }
        if (this.curveType === "centripetal" || this.curveType === "chordal") {
          const pow = this.curveType === "chordal" ? 0.5 : 0.25;
          let dt0 = Math.pow(p0.distanceToSquared(p1), pow);
          let dt1 = Math.pow(p1.distanceToSquared(p22), pow);
          let dt2 = Math.pow(p22.distanceToSquared(p32), pow);
          if (dt1 < 1e-4) dt1 = 1;
          if (dt0 < 1e-4) dt0 = dt1;
          if (dt2 < 1e-4) dt2 = dt1;
          px.initNonuniformCatmullRom(p0.x, p1.x, p22.x, p32.x, dt0, dt1, dt2);
          py.initNonuniformCatmullRom(p0.y, p1.y, p22.y, p32.y, dt0, dt1, dt2);
          pz.initNonuniformCatmullRom(p0.z, p1.z, p22.z, p32.z, dt0, dt1, dt2);
        } else if (this.curveType === "catmullrom") {
          px.initCatmullRom(p0.x, p1.x, p22.x, p32.x, this.tension);
          py.initCatmullRom(p0.y, p1.y, p22.y, p32.y, this.tension);
          pz.initCatmullRom(p0.z, p1.z, p22.z, p32.z, this.tension);
        }
        point.set(
          px.calc(weight),
          py.calc(weight),
          pz.calc(weight)
        );
        return point;
      }
      copy(source) {
        super.copy(source);
        this.points = [];
        for (let i2 = 0, l2 = source.points.length; i2 < l2; i2++) {
          const point = source.points[i2];
          this.points.push(point.clone());
        }
        this.closed = source.closed;
        this.curveType = source.curveType;
        this.tension = source.tension;
        return this;
      }
      toJSON() {
        const data = super.toJSON();
        data.points = [];
        for (let i2 = 0, l2 = this.points.length; i2 < l2; i2++) {
          const point = this.points[i2];
          data.points.push(point.toArray());
        }
        data.closed = this.closed;
        data.curveType = this.curveType;
        data.tension = this.tension;
        return data;
      }
      fromJSON(json) {
        super.fromJSON(json);
        this.points = [];
        for (let i2 = 0, l2 = json.points.length; i2 < l2; i2++) {
          const point = json.points[i2];
          this.points.push(new Vector3().fromArray(point));
        }
        this.closed = json.closed;
        this.curveType = json.curveType;
        this.tension = json.tension;
        return this;
      }
    };
    CubicBezierCurve = class extends Curve {
      constructor(v0 = new Vector2(), v1 = new Vector2(), v2 = new Vector2(), v3 = new Vector2()) {
        super();
        this.isCubicBezierCurve = true;
        this.type = "CubicBezierCurve";
        this.v0 = v0;
        this.v1 = v1;
        this.v2 = v2;
        this.v3 = v3;
      }
      getPoint(t2, optionalTarget = new Vector2()) {
        const point = optionalTarget;
        const v0 = this.v0, v1 = this.v1, v2 = this.v2, v3 = this.v3;
        point.set(
          CubicBezier(t2, v0.x, v1.x, v2.x, v3.x),
          CubicBezier(t2, v0.y, v1.y, v2.y, v3.y)
        );
        return point;
      }
      copy(source) {
        super.copy(source);
        this.v0.copy(source.v0);
        this.v1.copy(source.v1);
        this.v2.copy(source.v2);
        this.v3.copy(source.v3);
        return this;
      }
      toJSON() {
        const data = super.toJSON();
        data.v0 = this.v0.toArray();
        data.v1 = this.v1.toArray();
        data.v2 = this.v2.toArray();
        data.v3 = this.v3.toArray();
        return data;
      }
      fromJSON(json) {
        super.fromJSON(json);
        this.v0.fromArray(json.v0);
        this.v1.fromArray(json.v1);
        this.v2.fromArray(json.v2);
        this.v3.fromArray(json.v3);
        return this;
      }
    };
    CubicBezierCurve3 = class extends Curve {
      constructor(v0 = new Vector3(), v1 = new Vector3(), v2 = new Vector3(), v3 = new Vector3()) {
        super();
        this.isCubicBezierCurve3 = true;
        this.type = "CubicBezierCurve3";
        this.v0 = v0;
        this.v1 = v1;
        this.v2 = v2;
        this.v3 = v3;
      }
      getPoint(t2, optionalTarget = new Vector3()) {
        const point = optionalTarget;
        const v0 = this.v0, v1 = this.v1, v2 = this.v2, v3 = this.v3;
        point.set(
          CubicBezier(t2, v0.x, v1.x, v2.x, v3.x),
          CubicBezier(t2, v0.y, v1.y, v2.y, v3.y),
          CubicBezier(t2, v0.z, v1.z, v2.z, v3.z)
        );
        return point;
      }
      copy(source) {
        super.copy(source);
        this.v0.copy(source.v0);
        this.v1.copy(source.v1);
        this.v2.copy(source.v2);
        this.v3.copy(source.v3);
        return this;
      }
      toJSON() {
        const data = super.toJSON();
        data.v0 = this.v0.toArray();
        data.v1 = this.v1.toArray();
        data.v2 = this.v2.toArray();
        data.v3 = this.v3.toArray();
        return data;
      }
      fromJSON(json) {
        super.fromJSON(json);
        this.v0.fromArray(json.v0);
        this.v1.fromArray(json.v1);
        this.v2.fromArray(json.v2);
        this.v3.fromArray(json.v3);
        return this;
      }
    };
    LineCurve = class extends Curve {
      constructor(v1 = new Vector2(), v2 = new Vector2()) {
        super();
        this.isLineCurve = true;
        this.type = "LineCurve";
        this.v1 = v1;
        this.v2 = v2;
      }
      getPoint(t2, optionalTarget = new Vector2()) {
        const point = optionalTarget;
        if (t2 === 1) {
          point.copy(this.v2);
        } else {
          point.copy(this.v2).sub(this.v1);
          point.multiplyScalar(t2).add(this.v1);
        }
        return point;
      }
      // Line curve is linear, so we can overwrite default getPointAt
      getPointAt(u3, optionalTarget) {
        return this.getPoint(u3, optionalTarget);
      }
      getTangent(t2, optionalTarget = new Vector2()) {
        return optionalTarget.subVectors(this.v2, this.v1).normalize();
      }
      getTangentAt(u3, optionalTarget) {
        return this.getTangent(u3, optionalTarget);
      }
      copy(source) {
        super.copy(source);
        this.v1.copy(source.v1);
        this.v2.copy(source.v2);
        return this;
      }
      toJSON() {
        const data = super.toJSON();
        data.v1 = this.v1.toArray();
        data.v2 = this.v2.toArray();
        return data;
      }
      fromJSON(json) {
        super.fromJSON(json);
        this.v1.fromArray(json.v1);
        this.v2.fromArray(json.v2);
        return this;
      }
    };
    LineCurve3 = class extends Curve {
      constructor(v1 = new Vector3(), v2 = new Vector3()) {
        super();
        this.isLineCurve3 = true;
        this.type = "LineCurve3";
        this.v1 = v1;
        this.v2 = v2;
      }
      getPoint(t2, optionalTarget = new Vector3()) {
        const point = optionalTarget;
        if (t2 === 1) {
          point.copy(this.v2);
        } else {
          point.copy(this.v2).sub(this.v1);
          point.multiplyScalar(t2).add(this.v1);
        }
        return point;
      }
      // Line curve is linear, so we can overwrite default getPointAt
      getPointAt(u3, optionalTarget) {
        return this.getPoint(u3, optionalTarget);
      }
      getTangent(t2, optionalTarget = new Vector3()) {
        return optionalTarget.subVectors(this.v2, this.v1).normalize();
      }
      getTangentAt(u3, optionalTarget) {
        return this.getTangent(u3, optionalTarget);
      }
      copy(source) {
        super.copy(source);
        this.v1.copy(source.v1);
        this.v2.copy(source.v2);
        return this;
      }
      toJSON() {
        const data = super.toJSON();
        data.v1 = this.v1.toArray();
        data.v2 = this.v2.toArray();
        return data;
      }
      fromJSON(json) {
        super.fromJSON(json);
        this.v1.fromArray(json.v1);
        this.v2.fromArray(json.v2);
        return this;
      }
    };
    QuadraticBezierCurve = class extends Curve {
      constructor(v0 = new Vector2(), v1 = new Vector2(), v2 = new Vector2()) {
        super();
        this.isQuadraticBezierCurve = true;
        this.type = "QuadraticBezierCurve";
        this.v0 = v0;
        this.v1 = v1;
        this.v2 = v2;
      }
      getPoint(t2, optionalTarget = new Vector2()) {
        const point = optionalTarget;
        const v0 = this.v0, v1 = this.v1, v2 = this.v2;
        point.set(
          QuadraticBezier(t2, v0.x, v1.x, v2.x),
          QuadraticBezier(t2, v0.y, v1.y, v2.y)
        );
        return point;
      }
      copy(source) {
        super.copy(source);
        this.v0.copy(source.v0);
        this.v1.copy(source.v1);
        this.v2.copy(source.v2);
        return this;
      }
      toJSON() {
        const data = super.toJSON();
        data.v0 = this.v0.toArray();
        data.v1 = this.v1.toArray();
        data.v2 = this.v2.toArray();
        return data;
      }
      fromJSON(json) {
        super.fromJSON(json);
        this.v0.fromArray(json.v0);
        this.v1.fromArray(json.v1);
        this.v2.fromArray(json.v2);
        return this;
      }
    };
    QuadraticBezierCurve3 = class extends Curve {
      constructor(v0 = new Vector3(), v1 = new Vector3(), v2 = new Vector3()) {
        super();
        this.isQuadraticBezierCurve3 = true;
        this.type = "QuadraticBezierCurve3";
        this.v0 = v0;
        this.v1 = v1;
        this.v2 = v2;
      }
      getPoint(t2, optionalTarget = new Vector3()) {
        const point = optionalTarget;
        const v0 = this.v0, v1 = this.v1, v2 = this.v2;
        point.set(
          QuadraticBezier(t2, v0.x, v1.x, v2.x),
          QuadraticBezier(t2, v0.y, v1.y, v2.y),
          QuadraticBezier(t2, v0.z, v1.z, v2.z)
        );
        return point;
      }
      copy(source) {
        super.copy(source);
        this.v0.copy(source.v0);
        this.v1.copy(source.v1);
        this.v2.copy(source.v2);
        return this;
      }
      toJSON() {
        const data = super.toJSON();
        data.v0 = this.v0.toArray();
        data.v1 = this.v1.toArray();
        data.v2 = this.v2.toArray();
        return data;
      }
      fromJSON(json) {
        super.fromJSON(json);
        this.v0.fromArray(json.v0);
        this.v1.fromArray(json.v1);
        this.v2.fromArray(json.v2);
        return this;
      }
    };
    SplineCurve = class extends Curve {
      constructor(points = []) {
        super();
        this.isSplineCurve = true;
        this.type = "SplineCurve";
        this.points = points;
      }
      getPoint(t2, optionalTarget = new Vector2()) {
        const point = optionalTarget;
        const points = this.points;
        const p3 = (points.length - 1) * t2;
        const intPoint = Math.floor(p3);
        const weight = p3 - intPoint;
        const p0 = points[intPoint === 0 ? intPoint : intPoint - 1];
        const p1 = points[intPoint];
        const p22 = points[intPoint > points.length - 2 ? points.length - 1 : intPoint + 1];
        const p32 = points[intPoint > points.length - 3 ? points.length - 1 : intPoint + 2];
        point.set(
          CatmullRom(weight, p0.x, p1.x, p22.x, p32.x),
          CatmullRom(weight, p0.y, p1.y, p22.y, p32.y)
        );
        return point;
      }
      copy(source) {
        super.copy(source);
        this.points = [];
        for (let i2 = 0, l2 = source.points.length; i2 < l2; i2++) {
          const point = source.points[i2];
          this.points.push(point.clone());
        }
        return this;
      }
      toJSON() {
        const data = super.toJSON();
        data.points = [];
        for (let i2 = 0, l2 = this.points.length; i2 < l2; i2++) {
          const point = this.points[i2];
          data.points.push(point.toArray());
        }
        return data;
      }
      fromJSON(json) {
        super.fromJSON(json);
        this.points = [];
        for (let i2 = 0, l2 = json.points.length; i2 < l2; i2++) {
          const point = json.points[i2];
          this.points.push(new Vector2().fromArray(point));
        }
        return this;
      }
    };
    Curves = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      ArcCurve,
      CatmullRomCurve3,
      CubicBezierCurve,
      CubicBezierCurve3,
      EllipseCurve,
      LineCurve,
      LineCurve3,
      QuadraticBezierCurve,
      QuadraticBezierCurve3,
      SplineCurve
    });
    CurvePath = class extends Curve {
      constructor() {
        super();
        this.type = "CurvePath";
        this.curves = [];
        this.autoClose = false;
      }
      add(curve) {
        this.curves.push(curve);
      }
      closePath() {
        const startPoint = this.curves[0].getPoint(0);
        const endPoint = this.curves[this.curves.length - 1].getPoint(1);
        if (!startPoint.equals(endPoint)) {
          const lineType = startPoint.isVector2 === true ? "LineCurve" : "LineCurve3";
          this.curves.push(new Curves[lineType](endPoint, startPoint));
        }
        return this;
      }
      // To get accurate point with reference to
      // entire path distance at time t,
      // following has to be done:
      // 1. Length of each sub path have to be known
      // 2. Locate and identify type of curve
      // 3. Get t for the curve
      // 4. Return curve.getPointAt(t')
      getPoint(t2, optionalTarget) {
        const d = t2 * this.getLength();
        const curveLengths = this.getCurveLengths();
        let i2 = 0;
        while (i2 < curveLengths.length) {
          if (curveLengths[i2] >= d) {
            const diff = curveLengths[i2] - d;
            const curve = this.curves[i2];
            const segmentLength = curve.getLength();
            const u3 = segmentLength === 0 ? 0 : 1 - diff / segmentLength;
            return curve.getPointAt(u3, optionalTarget);
          }
          i2++;
        }
        return null;
      }
      // We cannot use the default THREE.Curve getPoint() with getLength() because in
      // THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath
      // getPoint() depends on getLength
      getLength() {
        const lens = this.getCurveLengths();
        return lens[lens.length - 1];
      }
      // cacheLengths must be recalculated.
      updateArcLengths() {
        this.needsUpdate = true;
        this.cacheLengths = null;
        this.getCurveLengths();
      }
      // Compute lengths and cache them
      // We cannot overwrite getLengths() because UtoT mapping uses it.
      getCurveLengths() {
        if (this.cacheLengths && this.cacheLengths.length === this.curves.length) {
          return this.cacheLengths;
        }
        const lengths = [];
        let sums = 0;
        for (let i2 = 0, l2 = this.curves.length; i2 < l2; i2++) {
          sums += this.curves[i2].getLength();
          lengths.push(sums);
        }
        this.cacheLengths = lengths;
        return lengths;
      }
      getSpacedPoints(divisions = 40) {
        const points = [];
        for (let i2 = 0; i2 <= divisions; i2++) {
          points.push(this.getPoint(i2 / divisions));
        }
        if (this.autoClose) {
          points.push(points[0]);
        }
        return points;
      }
      getPoints(divisions = 12) {
        const points = [];
        let last;
        for (let i2 = 0, curves = this.curves; i2 < curves.length; i2++) {
          const curve = curves[i2];
          const resolution = curve.isEllipseCurve ? divisions * 2 : curve.isLineCurve || curve.isLineCurve3 ? 1 : curve.isSplineCurve ? divisions * curve.points.length : divisions;
          const pts = curve.getPoints(resolution);
          for (let j2 = 0; j2 < pts.length; j2++) {
            const point = pts[j2];
            if (last && last.equals(point)) continue;
            points.push(point);
            last = point;
          }
        }
        if (this.autoClose && points.length > 1 && !points[points.length - 1].equals(points[0])) {
          points.push(points[0]);
        }
        return points;
      }
      copy(source) {
        super.copy(source);
        this.curves = [];
        for (let i2 = 0, l2 = source.curves.length; i2 < l2; i2++) {
          const curve = source.curves[i2];
          this.curves.push(curve.clone());
        }
        this.autoClose = source.autoClose;
        return this;
      }
      toJSON() {
        const data = super.toJSON();
        data.autoClose = this.autoClose;
        data.curves = [];
        for (let i2 = 0, l2 = this.curves.length; i2 < l2; i2++) {
          const curve = this.curves[i2];
          data.curves.push(curve.toJSON());
        }
        return data;
      }
      fromJSON(json) {
        super.fromJSON(json);
        this.autoClose = json.autoClose;
        this.curves = [];
        for (let i2 = 0, l2 = json.curves.length; i2 < l2; i2++) {
          const curve = json.curves[i2];
          this.curves.push(new Curves[curve.type]().fromJSON(curve));
        }
        return this;
      }
    };
    Path = class extends CurvePath {
      constructor(points) {
        super();
        this.type = "Path";
        this.currentPoint = new Vector2();
        if (points) {
          this.setFromPoints(points);
        }
      }
      setFromPoints(points) {
        this.moveTo(points[0].x, points[0].y);
        for (let i2 = 1, l2 = points.length; i2 < l2; i2++) {
          this.lineTo(points[i2].x, points[i2].y);
        }
        return this;
      }
      moveTo(x, y2) {
        this.currentPoint.set(x, y2);
        return this;
      }
      lineTo(x, y2) {
        const curve = new LineCurve(this.currentPoint.clone(), new Vector2(x, y2));
        this.curves.push(curve);
        this.currentPoint.set(x, y2);
        return this;
      }
      quadraticCurveTo(aCPx, aCPy, aX, aY) {
        const curve = new QuadraticBezierCurve(
          this.currentPoint.clone(),
          new Vector2(aCPx, aCPy),
          new Vector2(aX, aY)
        );
        this.curves.push(curve);
        this.currentPoint.set(aX, aY);
        return this;
      }
      bezierCurveTo(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY) {
        const curve = new CubicBezierCurve(
          this.currentPoint.clone(),
          new Vector2(aCP1x, aCP1y),
          new Vector2(aCP2x, aCP2y),
          new Vector2(aX, aY)
        );
        this.curves.push(curve);
        this.currentPoint.set(aX, aY);
        return this;
      }
      splineThru(pts) {
        const npts = [this.currentPoint.clone()].concat(pts);
        const curve = new SplineCurve(npts);
        this.curves.push(curve);
        this.currentPoint.copy(pts[pts.length - 1]);
        return this;
      }
      arc(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
        const x0 = this.currentPoint.x;
        const y0 = this.currentPoint.y;
        this.absarc(
          aX + x0,
          aY + y0,
          aRadius,
          aStartAngle,
          aEndAngle,
          aClockwise
        );
        return this;
      }
      absarc(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
        this.absellipse(aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise);
        return this;
      }
      ellipse(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {
        const x0 = this.currentPoint.x;
        const y0 = this.currentPoint.y;
        this.absellipse(aX + x0, aY + y0, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation);
        return this;
      }
      absellipse(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {
        const curve = new EllipseCurve(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation);
        if (this.curves.length > 0) {
          const firstPoint = curve.getPoint(0);
          if (!firstPoint.equals(this.currentPoint)) {
            this.lineTo(firstPoint.x, firstPoint.y);
          }
        }
        this.curves.push(curve);
        const lastPoint = curve.getPoint(1);
        this.currentPoint.copy(lastPoint);
        return this;
      }
      copy(source) {
        super.copy(source);
        this.currentPoint.copy(source.currentPoint);
        return this;
      }
      toJSON() {
        const data = super.toJSON();
        data.currentPoint = this.currentPoint.toArray();
        return data;
      }
      fromJSON(json) {
        super.fromJSON(json);
        this.currentPoint.fromArray(json.currentPoint);
        return this;
      }
    };
    LatheGeometry = class _LatheGeometry extends BufferGeometry {
      constructor(points = [new Vector2(0, -0.5), new Vector2(0.5, 0), new Vector2(0, 0.5)], segments = 12, phiStart = 0, phiLength = Math.PI * 2) {
        super();
        this.type = "LatheGeometry";
        this.parameters = {
          points,
          segments,
          phiStart,
          phiLength
        };
        segments = Math.floor(segments);
        phiLength = clamp(phiLength, 0, Math.PI * 2);
        const indices = [];
        const vertices = [];
        const uvs = [];
        const initNormals = [];
        const normals = [];
        const inverseSegments = 1 / segments;
        const vertex2 = new Vector3();
        const uv = new Vector2();
        const normal = new Vector3();
        const curNormal = new Vector3();
        const prevNormal = new Vector3();
        let dx = 0;
        let dy = 0;
        for (let j2 = 0; j2 <= points.length - 1; j2++) {
          switch (j2) {
            case 0:
              dx = points[j2 + 1].x - points[j2].x;
              dy = points[j2 + 1].y - points[j2].y;
              normal.x = dy * 1;
              normal.y = -dx;
              normal.z = dy * 0;
              prevNormal.copy(normal);
              normal.normalize();
              initNormals.push(normal.x, normal.y, normal.z);
              break;
            case points.length - 1:
              initNormals.push(prevNormal.x, prevNormal.y, prevNormal.z);
              break;
            default:
              dx = points[j2 + 1].x - points[j2].x;
              dy = points[j2 + 1].y - points[j2].y;
              normal.x = dy * 1;
              normal.y = -dx;
              normal.z = dy * 0;
              curNormal.copy(normal);
              normal.x += prevNormal.x;
              normal.y += prevNormal.y;
              normal.z += prevNormal.z;
              normal.normalize();
              initNormals.push(normal.x, normal.y, normal.z);
              prevNormal.copy(curNormal);
          }
        }
        for (let i2 = 0; i2 <= segments; i2++) {
          const phi = phiStart + i2 * inverseSegments * phiLength;
          const sin = Math.sin(phi);
          const cos = Math.cos(phi);
          for (let j2 = 0; j2 <= points.length - 1; j2++) {
            vertex2.x = points[j2].x * sin;
            vertex2.y = points[j2].y;
            vertex2.z = points[j2].x * cos;
            vertices.push(vertex2.x, vertex2.y, vertex2.z);
            uv.x = i2 / segments;
            uv.y = j2 / (points.length - 1);
            uvs.push(uv.x, uv.y);
            const x = initNormals[3 * j2 + 0] * sin;
            const y2 = initNormals[3 * j2 + 1];
            const z2 = initNormals[3 * j2 + 0] * cos;
            normals.push(x, y2, z2);
          }
        }
        for (let i2 = 0; i2 < segments; i2++) {
          for (let j2 = 0; j2 < points.length - 1; j2++) {
            const base = j2 + i2 * points.length;
            const a = base;
            const b = base + points.length;
            const c = base + points.length + 1;
            const d = base + 1;
            indices.push(a, b, d);
            indices.push(c, d, b);
          }
        }
        this.setIndex(indices);
        this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
        this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
        this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
      }
      copy(source) {
        super.copy(source);
        this.parameters = Object.assign({}, source.parameters);
        return this;
      }
      static fromJSON(data) {
        return new _LatheGeometry(data.points, data.segments, data.phiStart, data.phiLength);
      }
    };
    CapsuleGeometry = class _CapsuleGeometry extends LatheGeometry {
      constructor(radius = 1, length = 1, capSegments = 4, radialSegments = 8) {
        const path = new Path();
        path.absarc(0, -length / 2, radius, Math.PI * 1.5, 0);
        path.absarc(0, length / 2, radius, 0, Math.PI * 0.5);
        super(path.getPoints(capSegments), radialSegments);
        this.type = "CapsuleGeometry";
        this.parameters = {
          radius,
          length,
          capSegments,
          radialSegments
        };
      }
      static fromJSON(data) {
        return new _CapsuleGeometry(data.radius, data.length, data.capSegments, data.radialSegments);
      }
    };
    CircleGeometry = class _CircleGeometry extends BufferGeometry {
      constructor(radius = 1, segments = 32, thetaStart = 0, thetaLength = Math.PI * 2) {
        super();
        this.type = "CircleGeometry";
        this.parameters = {
          radius,
          segments,
          thetaStart,
          thetaLength
        };
        segments = Math.max(3, segments);
        const indices = [];
        const vertices = [];
        const normals = [];
        const uvs = [];
        const vertex2 = new Vector3();
        const uv = new Vector2();
        vertices.push(0, 0, 0);
        normals.push(0, 0, 1);
        uvs.push(0.5, 0.5);
        for (let s = 0, i2 = 3; s <= segments; s++, i2 += 3) {
          const segment = thetaStart + s / segments * thetaLength;
          vertex2.x = radius * Math.cos(segment);
          vertex2.y = radius * Math.sin(segment);
          vertices.push(vertex2.x, vertex2.y, vertex2.z);
          normals.push(0, 0, 1);
          uv.x = (vertices[i2] / radius + 1) / 2;
          uv.y = (vertices[i2 + 1] / radius + 1) / 2;
          uvs.push(uv.x, uv.y);
        }
        for (let i2 = 1; i2 <= segments; i2++) {
          indices.push(i2, i2 + 1, 0);
        }
        this.setIndex(indices);
        this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
        this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
        this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
      }
      copy(source) {
        super.copy(source);
        this.parameters = Object.assign({}, source.parameters);
        return this;
      }
      static fromJSON(data) {
        return new _CircleGeometry(data.radius, data.segments, data.thetaStart, data.thetaLength);
      }
    };
    CylinderGeometry = class _CylinderGeometry extends BufferGeometry {
      constructor(radiusTop = 1, radiusBottom = 1, height = 1, radialSegments = 32, heightSegments = 1, openEnded = false, thetaStart = 0, thetaLength = Math.PI * 2) {
        super();
        this.type = "CylinderGeometry";
        this.parameters = {
          radiusTop,
          radiusBottom,
          height,
          radialSegments,
          heightSegments,
          openEnded,
          thetaStart,
          thetaLength
        };
        const scope = this;
        radialSegments = Math.floor(radialSegments);
        heightSegments = Math.floor(heightSegments);
        const indices = [];
        const vertices = [];
        const normals = [];
        const uvs = [];
        let index = 0;
        const indexArray = [];
        const halfHeight = height / 2;
        let groupStart = 0;
        generateTorso();
        if (openEnded === false) {
          if (radiusTop > 0) generateCap(true);
          if (radiusBottom > 0) generateCap(false);
        }
        this.setIndex(indices);
        this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
        this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
        this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
        function generateTorso() {
          const normal = new Vector3();
          const vertex2 = new Vector3();
          let groupCount = 0;
          const slope = (radiusBottom - radiusTop) / height;
          for (let y2 = 0; y2 <= heightSegments; y2++) {
            const indexRow = [];
            const v2 = y2 / heightSegments;
            const radius = v2 * (radiusBottom - radiusTop) + radiusTop;
            for (let x = 0; x <= radialSegments; x++) {
              const u3 = x / radialSegments;
              const theta = u3 * thetaLength + thetaStart;
              const sinTheta = Math.sin(theta);
              const cosTheta = Math.cos(theta);
              vertex2.x = radius * sinTheta;
              vertex2.y = -v2 * height + halfHeight;
              vertex2.z = radius * cosTheta;
              vertices.push(vertex2.x, vertex2.y, vertex2.z);
              normal.set(sinTheta, slope, cosTheta).normalize();
              normals.push(normal.x, normal.y, normal.z);
              uvs.push(u3, 1 - v2);
              indexRow.push(index++);
            }
            indexArray.push(indexRow);
          }
          for (let x = 0; x < radialSegments; x++) {
            for (let y2 = 0; y2 < heightSegments; y2++) {
              const a = indexArray[y2][x];
              const b = indexArray[y2 + 1][x];
              const c = indexArray[y2 + 1][x + 1];
              const d = indexArray[y2][x + 1];
              if (radiusTop > 0) {
                indices.push(a, b, d);
                groupCount += 3;
              }
              if (radiusBottom > 0) {
                indices.push(b, c, d);
                groupCount += 3;
              }
            }
          }
          scope.addGroup(groupStart, groupCount, 0);
          groupStart += groupCount;
        }
        function generateCap(top) {
          const centerIndexStart = index;
          const uv = new Vector2();
          const vertex2 = new Vector3();
          let groupCount = 0;
          const radius = top === true ? radiusTop : radiusBottom;
          const sign2 = top === true ? 1 : -1;
          for (let x = 1; x <= radialSegments; x++) {
            vertices.push(0, halfHeight * sign2, 0);
            normals.push(0, sign2, 0);
            uvs.push(0.5, 0.5);
            index++;
          }
          const centerIndexEnd = index;
          for (let x = 0; x <= radialSegments; x++) {
            const u3 = x / radialSegments;
            const theta = u3 * thetaLength + thetaStart;
            const cosTheta = Math.cos(theta);
            const sinTheta = Math.sin(theta);
            vertex2.x = radius * sinTheta;
            vertex2.y = halfHeight * sign2;
            vertex2.z = radius * cosTheta;
            vertices.push(vertex2.x, vertex2.y, vertex2.z);
            normals.push(0, sign2, 0);
            uv.x = cosTheta * 0.5 + 0.5;
            uv.y = sinTheta * 0.5 * sign2 + 0.5;
            uvs.push(uv.x, uv.y);
            index++;
          }
          for (let x = 0; x < radialSegments; x++) {
            const c = centerIndexStart + x;
            const i2 = centerIndexEnd + x;
            if (top === true) {
              indices.push(i2, i2 + 1, c);
            } else {
              indices.push(i2 + 1, i2, c);
            }
            groupCount += 3;
          }
          scope.addGroup(groupStart, groupCount, top === true ? 1 : 2);
          groupStart += groupCount;
        }
      }
      copy(source) {
        super.copy(source);
        this.parameters = Object.assign({}, source.parameters);
        return this;
      }
      static fromJSON(data) {
        return new _CylinderGeometry(data.radiusTop, data.radiusBottom, data.height, data.radialSegments, data.heightSegments, data.openEnded, data.thetaStart, data.thetaLength);
      }
    };
    ConeGeometry = class _ConeGeometry extends CylinderGeometry {
      constructor(radius = 1, height = 1, radialSegments = 32, heightSegments = 1, openEnded = false, thetaStart = 0, thetaLength = Math.PI * 2) {
        super(0, radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength);
        this.type = "ConeGeometry";
        this.parameters = {
          radius,
          height,
          radialSegments,
          heightSegments,
          openEnded,
          thetaStart,
          thetaLength
        };
      }
      static fromJSON(data) {
        return new _ConeGeometry(data.radius, data.height, data.radialSegments, data.heightSegments, data.openEnded, data.thetaStart, data.thetaLength);
      }
    };
    PolyhedronGeometry = class _PolyhedronGeometry extends BufferGeometry {
      constructor(vertices = [], indices = [], radius = 1, detail = 0) {
        super();
        this.type = "PolyhedronGeometry";
        this.parameters = {
          vertices,
          indices,
          radius,
          detail
        };
        const vertexBuffer = [];
        const uvBuffer = [];
        subdivide(detail);
        applyRadius(radius);
        generateUVs();
        this.setAttribute("position", new Float32BufferAttribute(vertexBuffer, 3));
        this.setAttribute("normal", new Float32BufferAttribute(vertexBuffer.slice(), 3));
        this.setAttribute("uv", new Float32BufferAttribute(uvBuffer, 2));
        if (detail === 0) {
          this.computeVertexNormals();
        } else {
          this.normalizeNormals();
        }
        function subdivide(detail2) {
          const a = new Vector3();
          const b = new Vector3();
          const c = new Vector3();
          for (let i2 = 0; i2 < indices.length; i2 += 3) {
            getVertexByIndex(indices[i2 + 0], a);
            getVertexByIndex(indices[i2 + 1], b);
            getVertexByIndex(indices[i2 + 2], c);
            subdivideFace(a, b, c, detail2);
          }
        }
        function subdivideFace(a, b, c, detail2) {
          const cols = detail2 + 1;
          const v2 = [];
          for (let i2 = 0; i2 <= cols; i2++) {
            v2[i2] = [];
            const aj = a.clone().lerp(c, i2 / cols);
            const bj = b.clone().lerp(c, i2 / cols);
            const rows = cols - i2;
            for (let j2 = 0; j2 <= rows; j2++) {
              if (j2 === 0 && i2 === cols) {
                v2[i2][j2] = aj;
              } else {
                v2[i2][j2] = aj.clone().lerp(bj, j2 / rows);
              }
            }
          }
          for (let i2 = 0; i2 < cols; i2++) {
            for (let j2 = 0; j2 < 2 * (cols - i2) - 1; j2++) {
              const k3 = Math.floor(j2 / 2);
              if (j2 % 2 === 0) {
                pushVertex(v2[i2][k3 + 1]);
                pushVertex(v2[i2 + 1][k3]);
                pushVertex(v2[i2][k3]);
              } else {
                pushVertex(v2[i2][k3 + 1]);
                pushVertex(v2[i2 + 1][k3 + 1]);
                pushVertex(v2[i2 + 1][k3]);
              }
            }
          }
        }
        function applyRadius(radius2) {
          const vertex2 = new Vector3();
          for (let i2 = 0; i2 < vertexBuffer.length; i2 += 3) {
            vertex2.x = vertexBuffer[i2 + 0];
            vertex2.y = vertexBuffer[i2 + 1];
            vertex2.z = vertexBuffer[i2 + 2];
            vertex2.normalize().multiplyScalar(radius2);
            vertexBuffer[i2 + 0] = vertex2.x;
            vertexBuffer[i2 + 1] = vertex2.y;
            vertexBuffer[i2 + 2] = vertex2.z;
          }
        }
        function generateUVs() {
          const vertex2 = new Vector3();
          for (let i2 = 0; i2 < vertexBuffer.length; i2 += 3) {
            vertex2.x = vertexBuffer[i2 + 0];
            vertex2.y = vertexBuffer[i2 + 1];
            vertex2.z = vertexBuffer[i2 + 2];
            const u3 = azimuth(vertex2) / 2 / Math.PI + 0.5;
            const v2 = inclination(vertex2) / Math.PI + 0.5;
            uvBuffer.push(u3, 1 - v2);
          }
          correctUVs();
          correctSeam();
        }
        function correctSeam() {
          for (let i2 = 0; i2 < uvBuffer.length; i2 += 6) {
            const x0 = uvBuffer[i2 + 0];
            const x1 = uvBuffer[i2 + 2];
            const x2 = uvBuffer[i2 + 4];
            const max = Math.max(x0, x1, x2);
            const min = Math.min(x0, x1, x2);
            if (max > 0.9 && min < 0.1) {
              if (x0 < 0.2) uvBuffer[i2 + 0] += 1;
              if (x1 < 0.2) uvBuffer[i2 + 2] += 1;
              if (x2 < 0.2) uvBuffer[i2 + 4] += 1;
            }
          }
        }
        function pushVertex(vertex2) {
          vertexBuffer.push(vertex2.x, vertex2.y, vertex2.z);
        }
        function getVertexByIndex(index, vertex2) {
          const stride = index * 3;
          vertex2.x = vertices[stride + 0];
          vertex2.y = vertices[stride + 1];
          vertex2.z = vertices[stride + 2];
        }
        function correctUVs() {
          const a = new Vector3();
          const b = new Vector3();
          const c = new Vector3();
          const centroid = new Vector3();
          const uvA = new Vector2();
          const uvB = new Vector2();
          const uvC = new Vector2();
          for (let i2 = 0, j2 = 0; i2 < vertexBuffer.length; i2 += 9, j2 += 6) {
            a.set(vertexBuffer[i2 + 0], vertexBuffer[i2 + 1], vertexBuffer[i2 + 2]);
            b.set(vertexBuffer[i2 + 3], vertexBuffer[i2 + 4], vertexBuffer[i2 + 5]);
            c.set(vertexBuffer[i2 + 6], vertexBuffer[i2 + 7], vertexBuffer[i2 + 8]);
            uvA.set(uvBuffer[j2 + 0], uvBuffer[j2 + 1]);
            uvB.set(uvBuffer[j2 + 2], uvBuffer[j2 + 3]);
            uvC.set(uvBuffer[j2 + 4], uvBuffer[j2 + 5]);
            centroid.copy(a).add(b).add(c).divideScalar(3);
            const azi = azimuth(centroid);
            correctUV(uvA, j2 + 0, a, azi);
            correctUV(uvB, j2 + 2, b, azi);
            correctUV(uvC, j2 + 4, c, azi);
          }
        }
        function correctUV(uv, stride, vector, azimuth2) {
          if (azimuth2 < 0 && uv.x === 1) {
            uvBuffer[stride] = uv.x - 1;
          }
          if (vector.x === 0 && vector.z === 0) {
            uvBuffer[stride] = azimuth2 / 2 / Math.PI + 0.5;
          }
        }
        function azimuth(vector) {
          return Math.atan2(vector.z, -vector.x);
        }
        function inclination(vector) {
          return Math.atan2(-vector.y, Math.sqrt(vector.x * vector.x + vector.z * vector.z));
        }
      }
      copy(source) {
        super.copy(source);
        this.parameters = Object.assign({}, source.parameters);
        return this;
      }
      static fromJSON(data) {
        return new _PolyhedronGeometry(data.vertices, data.indices, data.radius, data.details);
      }
    };
    DodecahedronGeometry = class _DodecahedronGeometry extends PolyhedronGeometry {
      constructor(radius = 1, detail = 0) {
        const t2 = (1 + Math.sqrt(5)) / 2;
        const r2 = 1 / t2;
        const vertices = [
          // (±1, ±1, ±1)
          -1,
          -1,
          -1,
          -1,
          -1,
          1,
          -1,
          1,
          -1,
          -1,
          1,
          1,
          1,
          -1,
          -1,
          1,
          -1,
          1,
          1,
          1,
          -1,
          1,
          1,
          1,
          // (0, ±1/φ, ±φ)
          0,
          -r2,
          -t2,
          0,
          -r2,
          t2,
          0,
          r2,
          -t2,
          0,
          r2,
          t2,
          // (±1/φ, ±φ, 0)
          -r2,
          -t2,
          0,
          -r2,
          t2,
          0,
          r2,
          -t2,
          0,
          r2,
          t2,
          0,
          // (±φ, 0, ±1/φ)
          -t2,
          0,
          -r2,
          t2,
          0,
          -r2,
          -t2,
          0,
          r2,
          t2,
          0,
          r2
        ];
        const indices = [
          3,
          11,
          7,
          3,
          7,
          15,
          3,
          15,
          13,
          7,
          19,
          17,
          7,
          17,
          6,
          7,
          6,
          15,
          17,
          4,
          8,
          17,
          8,
          10,
          17,
          10,
          6,
          8,
          0,
          16,
          8,
          16,
          2,
          8,
          2,
          10,
          0,
          12,
          1,
          0,
          1,
          18,
          0,
          18,
          16,
          6,
          10,
          2,
          6,
          2,
          13,
          6,
          13,
          15,
          2,
          16,
          18,
          2,
          18,
          3,
          2,
          3,
          13,
          18,
          1,
          9,
          18,
          9,
          11,
          18,
          11,
          3,
          4,
          14,
          12,
          4,
          12,
          0,
          4,
          0,
          8,
          11,
          9,
          5,
          11,
          5,
          19,
          11,
          19,
          7,
          19,
          5,
          14,
          19,
          14,
          4,
          19,
          4,
          17,
          1,
          12,
          14,
          1,
          14,
          5,
          1,
          5,
          9
        ];
        super(vertices, indices, radius, detail);
        this.type = "DodecahedronGeometry";
        this.parameters = {
          radius,
          detail
        };
      }
      static fromJSON(data) {
        return new _DodecahedronGeometry(data.radius, data.detail);
      }
    };
    _v0 = /* @__PURE__ */ new Vector3();
    _v1$1 = /* @__PURE__ */ new Vector3();
    _normal = /* @__PURE__ */ new Vector3();
    _triangle = /* @__PURE__ */ new Triangle();
    EdgesGeometry = class extends BufferGeometry {
      constructor(geometry = null, thresholdAngle = 1) {
        super();
        this.type = "EdgesGeometry";
        this.parameters = {
          geometry,
          thresholdAngle
        };
        if (geometry !== null) {
          const precisionPoints = 4;
          const precision = Math.pow(10, precisionPoints);
          const thresholdDot = Math.cos(DEG2RAD * thresholdAngle);
          const indexAttr = geometry.getIndex();
          const positionAttr = geometry.getAttribute("position");
          const indexCount = indexAttr ? indexAttr.count : positionAttr.count;
          const indexArr = [0, 0, 0];
          const vertKeys = ["a", "b", "c"];
          const hashes = new Array(3);
          const edgeData = {};
          const vertices = [];
          for (let i2 = 0; i2 < indexCount; i2 += 3) {
            if (indexAttr) {
              indexArr[0] = indexAttr.getX(i2);
              indexArr[1] = indexAttr.getX(i2 + 1);
              indexArr[2] = indexAttr.getX(i2 + 2);
            } else {
              indexArr[0] = i2;
              indexArr[1] = i2 + 1;
              indexArr[2] = i2 + 2;
            }
            const { a, b, c } = _triangle;
            a.fromBufferAttribute(positionAttr, indexArr[0]);
            b.fromBufferAttribute(positionAttr, indexArr[1]);
            c.fromBufferAttribute(positionAttr, indexArr[2]);
            _triangle.getNormal(_normal);
            hashes[0] = `${Math.round(a.x * precision)},${Math.round(a.y * precision)},${Math.round(a.z * precision)}`;
            hashes[1] = `${Math.round(b.x * precision)},${Math.round(b.y * precision)},${Math.round(b.z * precision)}`;
            hashes[2] = `${Math.round(c.x * precision)},${Math.round(c.y * precision)},${Math.round(c.z * precision)}`;
            if (hashes[0] === hashes[1] || hashes[1] === hashes[2] || hashes[2] === hashes[0]) {
              continue;
            }
            for (let j2 = 0; j2 < 3; j2++) {
              const jNext = (j2 + 1) % 3;
              const vecHash0 = hashes[j2];
              const vecHash1 = hashes[jNext];
              const v0 = _triangle[vertKeys[j2]];
              const v1 = _triangle[vertKeys[jNext]];
              const hash = `${vecHash0}_${vecHash1}`;
              const reverseHash = `${vecHash1}_${vecHash0}`;
              if (reverseHash in edgeData && edgeData[reverseHash]) {
                if (_normal.dot(edgeData[reverseHash].normal) <= thresholdDot) {
                  vertices.push(v0.x, v0.y, v0.z);
                  vertices.push(v1.x, v1.y, v1.z);
                }
                edgeData[reverseHash] = null;
              } else if (!(hash in edgeData)) {
                edgeData[hash] = {
                  index0: indexArr[j2],
                  index1: indexArr[jNext],
                  normal: _normal.clone()
                };
              }
            }
          }
          for (const key in edgeData) {
            if (edgeData[key]) {
              const { index0, index1 } = edgeData[key];
              _v0.fromBufferAttribute(positionAttr, index0);
              _v1$1.fromBufferAttribute(positionAttr, index1);
              vertices.push(_v0.x, _v0.y, _v0.z);
              vertices.push(_v1$1.x, _v1$1.y, _v1$1.z);
            }
          }
          this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
        }
      }
      copy(source) {
        super.copy(source);
        this.parameters = Object.assign({}, source.parameters);
        return this;
      }
    };
    Shape = class extends Path {
      constructor(points) {
        super(points);
        this.uuid = generateUUID();
        this.type = "Shape";
        this.holes = [];
      }
      getPointsHoles(divisions) {
        const holesPts = [];
        for (let i2 = 0, l2 = this.holes.length; i2 < l2; i2++) {
          holesPts[i2] = this.holes[i2].getPoints(divisions);
        }
        return holesPts;
      }
      // get points of shape and holes (keypoints based on segments parameter)
      extractPoints(divisions) {
        return {
          shape: this.getPoints(divisions),
          holes: this.getPointsHoles(divisions)
        };
      }
      copy(source) {
        super.copy(source);
        this.holes = [];
        for (let i2 = 0, l2 = source.holes.length; i2 < l2; i2++) {
          const hole = source.holes[i2];
          this.holes.push(hole.clone());
        }
        return this;
      }
      toJSON() {
        const data = super.toJSON();
        data.uuid = this.uuid;
        data.holes = [];
        for (let i2 = 0, l2 = this.holes.length; i2 < l2; i2++) {
          const hole = this.holes[i2];
          data.holes.push(hole.toJSON());
        }
        return data;
      }
      fromJSON(json) {
        super.fromJSON(json);
        this.uuid = json.uuid;
        this.holes = [];
        for (let i2 = 0, l2 = json.holes.length; i2 < l2; i2++) {
          const hole = json.holes[i2];
          this.holes.push(new Path().fromJSON(hole));
        }
        return this;
      }
    };
    Earcut = {
      triangulate: function(data, holeIndices, dim = 2) {
        const hasHoles = holeIndices && holeIndices.length;
        const outerLen = hasHoles ? holeIndices[0] * dim : data.length;
        let outerNode = linkedList(data, 0, outerLen, dim, true);
        const triangles = [];
        if (!outerNode || outerNode.next === outerNode.prev) return triangles;
        let minX, minY, maxX, maxY, x, y2, invSize;
        if (hasHoles) outerNode = eliminateHoles(data, holeIndices, outerNode, dim);
        if (data.length > 80 * dim) {
          minX = maxX = data[0];
          minY = maxY = data[1];
          for (let i2 = dim; i2 < outerLen; i2 += dim) {
            x = data[i2];
            y2 = data[i2 + 1];
            if (x < minX) minX = x;
            if (y2 < minY) minY = y2;
            if (x > maxX) maxX = x;
            if (y2 > maxY) maxY = y2;
          }
          invSize = Math.max(maxX - minX, maxY - minY);
          invSize = invSize !== 0 ? 32767 / invSize : 0;
        }
        earcutLinked(outerNode, triangles, dim, minX, minY, invSize, 0);
        return triangles;
      }
    };
    ShapeUtils = class _ShapeUtils {
      // calculate area of the contour polygon
      static area(contour) {
        const n = contour.length;
        let a = 0;
        for (let p3 = n - 1, q3 = 0; q3 < n; p3 = q3++) {
          a += contour[p3].x * contour[q3].y - contour[q3].x * contour[p3].y;
        }
        return a * 0.5;
      }
      static isClockWise(pts) {
        return _ShapeUtils.area(pts) < 0;
      }
      static triangulateShape(contour, holes) {
        const vertices = [];
        const holeIndices = [];
        const faces = [];
        removeDupEndPts(contour);
        addContour(vertices, contour);
        let holeIndex = contour.length;
        holes.forEach(removeDupEndPts);
        for (let i2 = 0; i2 < holes.length; i2++) {
          holeIndices.push(holeIndex);
          holeIndex += holes[i2].length;
          addContour(vertices, holes[i2]);
        }
        const triangles = Earcut.triangulate(vertices, holeIndices);
        for (let i2 = 0; i2 < triangles.length; i2 += 3) {
          faces.push(triangles.slice(i2, i2 + 3));
        }
        return faces;
      }
    };
    ExtrudeGeometry = class _ExtrudeGeometry extends BufferGeometry {
      constructor(shapes = new Shape([new Vector2(0.5, 0.5), new Vector2(-0.5, 0.5), new Vector2(-0.5, -0.5), new Vector2(0.5, -0.5)]), options = {}) {
        super();
        this.type = "ExtrudeGeometry";
        this.parameters = {
          shapes,
          options
        };
        shapes = Array.isArray(shapes) ? shapes : [shapes];
        const scope = this;
        const verticesArray = [];
        const uvArray = [];
        for (let i2 = 0, l2 = shapes.length; i2 < l2; i2++) {
          const shape = shapes[i2];
          addShape(shape);
        }
        this.setAttribute("position", new Float32BufferAttribute(verticesArray, 3));
        this.setAttribute("uv", new Float32BufferAttribute(uvArray, 2));
        this.computeVertexNormals();
        function addShape(shape) {
          const placeholder = [];
          const curveSegments = options.curveSegments !== void 0 ? options.curveSegments : 12;
          const steps = options.steps !== void 0 ? options.steps : 1;
          const depth = options.depth !== void 0 ? options.depth : 1;
          let bevelEnabled = options.bevelEnabled !== void 0 ? options.bevelEnabled : true;
          let bevelThickness = options.bevelThickness !== void 0 ? options.bevelThickness : 0.2;
          let bevelSize = options.bevelSize !== void 0 ? options.bevelSize : bevelThickness - 0.1;
          let bevelOffset = options.bevelOffset !== void 0 ? options.bevelOffset : 0;
          let bevelSegments = options.bevelSegments !== void 0 ? options.bevelSegments : 3;
          const extrudePath = options.extrudePath;
          const uvgen = options.UVGenerator !== void 0 ? options.UVGenerator : WorldUVGenerator;
          let extrudePts, extrudeByPath = false;
          let splineTube, binormal, normal, position2;
          if (extrudePath) {
            extrudePts = extrudePath.getSpacedPoints(steps);
            extrudeByPath = true;
            bevelEnabled = false;
            splineTube = extrudePath.computeFrenetFrames(steps, false);
            binormal = new Vector3();
            normal = new Vector3();
            position2 = new Vector3();
          }
          if (!bevelEnabled) {
            bevelSegments = 0;
            bevelThickness = 0;
            bevelSize = 0;
            bevelOffset = 0;
          }
          const shapePoints = shape.extractPoints(curveSegments);
          let vertices = shapePoints.shape;
          const holes = shapePoints.holes;
          const reverse = !ShapeUtils.isClockWise(vertices);
          if (reverse) {
            vertices = vertices.reverse();
            for (let h2 = 0, hl = holes.length; h2 < hl; h2++) {
              const ahole = holes[h2];
              if (ShapeUtils.isClockWise(ahole)) {
                holes[h2] = ahole.reverse();
              }
            }
          }
          const faces = ShapeUtils.triangulateShape(vertices, holes);
          const contour = vertices;
          for (let h2 = 0, hl = holes.length; h2 < hl; h2++) {
            const ahole = holes[h2];
            vertices = vertices.concat(ahole);
          }
          function scalePt2(pt, vec, size) {
            if (!vec) console.error("THREE.ExtrudeGeometry: vec does not exist");
            return pt.clone().addScaledVector(vec, size);
          }
          const vlen = vertices.length, flen = faces.length;
          function getBevelVec(inPt, inPrev, inNext) {
            let v_trans_x, v_trans_y, shrink_by;
            const v_prev_x = inPt.x - inPrev.x, v_prev_y = inPt.y - inPrev.y;
            const v_next_x = inNext.x - inPt.x, v_next_y = inNext.y - inPt.y;
            const v_prev_lensq = v_prev_x * v_prev_x + v_prev_y * v_prev_y;
            const collinear0 = v_prev_x * v_next_y - v_prev_y * v_next_x;
            if (Math.abs(collinear0) > Number.EPSILON) {
              const v_prev_len = Math.sqrt(v_prev_lensq);
              const v_next_len = Math.sqrt(v_next_x * v_next_x + v_next_y * v_next_y);
              const ptPrevShift_x = inPrev.x - v_prev_y / v_prev_len;
              const ptPrevShift_y = inPrev.y + v_prev_x / v_prev_len;
              const ptNextShift_x = inNext.x - v_next_y / v_next_len;
              const ptNextShift_y = inNext.y + v_next_x / v_next_len;
              const sf = ((ptNextShift_x - ptPrevShift_x) * v_next_y - (ptNextShift_y - ptPrevShift_y) * v_next_x) / (v_prev_x * v_next_y - v_prev_y * v_next_x);
              v_trans_x = ptPrevShift_x + v_prev_x * sf - inPt.x;
              v_trans_y = ptPrevShift_y + v_prev_y * sf - inPt.y;
              const v_trans_lensq = v_trans_x * v_trans_x + v_trans_y * v_trans_y;
              if (v_trans_lensq <= 2) {
                return new Vector2(v_trans_x, v_trans_y);
              } else {
                shrink_by = Math.sqrt(v_trans_lensq / 2);
              }
            } else {
              let direction_eq = false;
              if (v_prev_x > Number.EPSILON) {
                if (v_next_x > Number.EPSILON) {
                  direction_eq = true;
                }
              } else {
                if (v_prev_x < -Number.EPSILON) {
                  if (v_next_x < -Number.EPSILON) {
                    direction_eq = true;
                  }
                } else {
                  if (Math.sign(v_prev_y) === Math.sign(v_next_y)) {
                    direction_eq = true;
                  }
                }
              }
              if (direction_eq) {
                v_trans_x = -v_prev_y;
                v_trans_y = v_prev_x;
                shrink_by = Math.sqrt(v_prev_lensq);
              } else {
                v_trans_x = v_prev_x;
                v_trans_y = v_prev_y;
                shrink_by = Math.sqrt(v_prev_lensq / 2);
              }
            }
            return new Vector2(v_trans_x / shrink_by, v_trans_y / shrink_by);
          }
          const contourMovements = [];
          for (let i2 = 0, il = contour.length, j2 = il - 1, k3 = i2 + 1; i2 < il; i2++, j2++, k3++) {
            if (j2 === il) j2 = 0;
            if (k3 === il) k3 = 0;
            contourMovements[i2] = getBevelVec(contour[i2], contour[j2], contour[k3]);
          }
          const holesMovements = [];
          let oneHoleMovements, verticesMovements = contourMovements.concat();
          for (let h2 = 0, hl = holes.length; h2 < hl; h2++) {
            const ahole = holes[h2];
            oneHoleMovements = [];
            for (let i2 = 0, il = ahole.length, j2 = il - 1, k3 = i2 + 1; i2 < il; i2++, j2++, k3++) {
              if (j2 === il) j2 = 0;
              if (k3 === il) k3 = 0;
              oneHoleMovements[i2] = getBevelVec(ahole[i2], ahole[j2], ahole[k3]);
            }
            holesMovements.push(oneHoleMovements);
            verticesMovements = verticesMovements.concat(oneHoleMovements);
          }
          for (let b = 0; b < bevelSegments; b++) {
            const t2 = b / bevelSegments;
            const z2 = bevelThickness * Math.cos(t2 * Math.PI / 2);
            const bs2 = bevelSize * Math.sin(t2 * Math.PI / 2) + bevelOffset;
            for (let i2 = 0, il = contour.length; i2 < il; i2++) {
              const vert = scalePt2(contour[i2], contourMovements[i2], bs2);
              v2(vert.x, vert.y, -z2);
            }
            for (let h2 = 0, hl = holes.length; h2 < hl; h2++) {
              const ahole = holes[h2];
              oneHoleMovements = holesMovements[h2];
              for (let i2 = 0, il = ahole.length; i2 < il; i2++) {
                const vert = scalePt2(ahole[i2], oneHoleMovements[i2], bs2);
                v2(vert.x, vert.y, -z2);
              }
            }
          }
          const bs = bevelSize + bevelOffset;
          for (let i2 = 0; i2 < vlen; i2++) {
            const vert = bevelEnabled ? scalePt2(vertices[i2], verticesMovements[i2], bs) : vertices[i2];
            if (!extrudeByPath) {
              v2(vert.x, vert.y, 0);
            } else {
              normal.copy(splineTube.normals[0]).multiplyScalar(vert.x);
              binormal.copy(splineTube.binormals[0]).multiplyScalar(vert.y);
              position2.copy(extrudePts[0]).add(normal).add(binormal);
              v2(position2.x, position2.y, position2.z);
            }
          }
          for (let s = 1; s <= steps; s++) {
            for (let i2 = 0; i2 < vlen; i2++) {
              const vert = bevelEnabled ? scalePt2(vertices[i2], verticesMovements[i2], bs) : vertices[i2];
              if (!extrudeByPath) {
                v2(vert.x, vert.y, depth / steps * s);
              } else {
                normal.copy(splineTube.normals[s]).multiplyScalar(vert.x);
                binormal.copy(splineTube.binormals[s]).multiplyScalar(vert.y);
                position2.copy(extrudePts[s]).add(normal).add(binormal);
                v2(position2.x, position2.y, position2.z);
              }
            }
          }
          for (let b = bevelSegments - 1; b >= 0; b--) {
            const t2 = b / bevelSegments;
            const z2 = bevelThickness * Math.cos(t2 * Math.PI / 2);
            const bs2 = bevelSize * Math.sin(t2 * Math.PI / 2) + bevelOffset;
            for (let i2 = 0, il = contour.length; i2 < il; i2++) {
              const vert = scalePt2(contour[i2], contourMovements[i2], bs2);
              v2(vert.x, vert.y, depth + z2);
            }
            for (let h2 = 0, hl = holes.length; h2 < hl; h2++) {
              const ahole = holes[h2];
              oneHoleMovements = holesMovements[h2];
              for (let i2 = 0, il = ahole.length; i2 < il; i2++) {
                const vert = scalePt2(ahole[i2], oneHoleMovements[i2], bs2);
                if (!extrudeByPath) {
                  v2(vert.x, vert.y, depth + z2);
                } else {
                  v2(vert.x, vert.y + extrudePts[steps - 1].y, extrudePts[steps - 1].x + z2);
                }
              }
            }
          }
          buildLidFaces();
          buildSideFaces();
          function buildLidFaces() {
            const start = verticesArray.length / 3;
            if (bevelEnabled) {
              let layer = 0;
              let offset = vlen * layer;
              for (let i2 = 0; i2 < flen; i2++) {
                const face = faces[i2];
                f3(face[2] + offset, face[1] + offset, face[0] + offset);
              }
              layer = steps + bevelSegments * 2;
              offset = vlen * layer;
              for (let i2 = 0; i2 < flen; i2++) {
                const face = faces[i2];
                f3(face[0] + offset, face[1] + offset, face[2] + offset);
              }
            } else {
              for (let i2 = 0; i2 < flen; i2++) {
                const face = faces[i2];
                f3(face[2], face[1], face[0]);
              }
              for (let i2 = 0; i2 < flen; i2++) {
                const face = faces[i2];
                f3(face[0] + vlen * steps, face[1] + vlen * steps, face[2] + vlen * steps);
              }
            }
            scope.addGroup(start, verticesArray.length / 3 - start, 0);
          }
          function buildSideFaces() {
            const start = verticesArray.length / 3;
            let layeroffset = 0;
            sidewalls(contour, layeroffset);
            layeroffset += contour.length;
            for (let h2 = 0, hl = holes.length; h2 < hl; h2++) {
              const ahole = holes[h2];
              sidewalls(ahole, layeroffset);
              layeroffset += ahole.length;
            }
            scope.addGroup(start, verticesArray.length / 3 - start, 1);
          }
          function sidewalls(contour2, layeroffset) {
            let i2 = contour2.length;
            while (--i2 >= 0) {
              const j2 = i2;
              let k3 = i2 - 1;
              if (k3 < 0) k3 = contour2.length - 1;
              for (let s = 0, sl = steps + bevelSegments * 2; s < sl; s++) {
                const slen1 = vlen * s;
                const slen2 = vlen * (s + 1);
                const a = layeroffset + j2 + slen1, b = layeroffset + k3 + slen1, c = layeroffset + k3 + slen2, d = layeroffset + j2 + slen2;
                f4(a, b, c, d);
              }
            }
          }
          function v2(x, y2, z2) {
            placeholder.push(x);
            placeholder.push(y2);
            placeholder.push(z2);
          }
          function f3(a, b, c) {
            addVertex(a);
            addVertex(b);
            addVertex(c);
            const nextIndex = verticesArray.length / 3;
            const uvs = uvgen.generateTopUV(scope, verticesArray, nextIndex - 3, nextIndex - 2, nextIndex - 1);
            addUV(uvs[0]);
            addUV(uvs[1]);
            addUV(uvs[2]);
          }
          function f4(a, b, c, d) {
            addVertex(a);
            addVertex(b);
            addVertex(d);
            addVertex(b);
            addVertex(c);
            addVertex(d);
            const nextIndex = verticesArray.length / 3;
            const uvs = uvgen.generateSideWallUV(scope, verticesArray, nextIndex - 6, nextIndex - 3, nextIndex - 2, nextIndex - 1);
            addUV(uvs[0]);
            addUV(uvs[1]);
            addUV(uvs[3]);
            addUV(uvs[1]);
            addUV(uvs[2]);
            addUV(uvs[3]);
          }
          function addVertex(index) {
            verticesArray.push(placeholder[index * 3 + 0]);
            verticesArray.push(placeholder[index * 3 + 1]);
            verticesArray.push(placeholder[index * 3 + 2]);
          }
          function addUV(vector2) {
            uvArray.push(vector2.x);
            uvArray.push(vector2.y);
          }
        }
      }
      copy(source) {
        super.copy(source);
        this.parameters = Object.assign({}, source.parameters);
        return this;
      }
      toJSON() {
        const data = super.toJSON();
        const shapes = this.parameters.shapes;
        const options = this.parameters.options;
        return toJSON$1(shapes, options, data);
      }
      static fromJSON(data, shapes) {
        const geometryShapes = [];
        for (let j2 = 0, jl = data.shapes.length; j2 < jl; j2++) {
          const shape = shapes[data.shapes[j2]];
          geometryShapes.push(shape);
        }
        const extrudePath = data.options.extrudePath;
        if (extrudePath !== void 0) {
          data.options.extrudePath = new Curves[extrudePath.type]().fromJSON(extrudePath);
        }
        return new _ExtrudeGeometry(geometryShapes, data.options);
      }
    };
    WorldUVGenerator = {
      generateTopUV: function(geometry, vertices, indexA, indexB, indexC) {
        const a_x = vertices[indexA * 3];
        const a_y = vertices[indexA * 3 + 1];
        const b_x = vertices[indexB * 3];
        const b_y = vertices[indexB * 3 + 1];
        const c_x = vertices[indexC * 3];
        const c_y = vertices[indexC * 3 + 1];
        return [
          new Vector2(a_x, a_y),
          new Vector2(b_x, b_y),
          new Vector2(c_x, c_y)
        ];
      },
      generateSideWallUV: function(geometry, vertices, indexA, indexB, indexC, indexD) {
        const a_x = vertices[indexA * 3];
        const a_y = vertices[indexA * 3 + 1];
        const a_z = vertices[indexA * 3 + 2];
        const b_x = vertices[indexB * 3];
        const b_y = vertices[indexB * 3 + 1];
        const b_z = vertices[indexB * 3 + 2];
        const c_x = vertices[indexC * 3];
        const c_y = vertices[indexC * 3 + 1];
        const c_z = vertices[indexC * 3 + 2];
        const d_x = vertices[indexD * 3];
        const d_y = vertices[indexD * 3 + 1];
        const d_z = vertices[indexD * 3 + 2];
        if (Math.abs(a_y - b_y) < Math.abs(a_x - b_x)) {
          return [
            new Vector2(a_x, 1 - a_z),
            new Vector2(b_x, 1 - b_z),
            new Vector2(c_x, 1 - c_z),
            new Vector2(d_x, 1 - d_z)
          ];
        } else {
          return [
            new Vector2(a_y, 1 - a_z),
            new Vector2(b_y, 1 - b_z),
            new Vector2(c_y, 1 - c_z),
            new Vector2(d_y, 1 - d_z)
          ];
        }
      }
    };
    IcosahedronGeometry = class _IcosahedronGeometry extends PolyhedronGeometry {
      constructor(radius = 1, detail = 0) {
        const t2 = (1 + Math.sqrt(5)) / 2;
        const vertices = [
          -1,
          t2,
          0,
          1,
          t2,
          0,
          -1,
          -t2,
          0,
          1,
          -t2,
          0,
          0,
          -1,
          t2,
          0,
          1,
          t2,
          0,
          -1,
          -t2,
          0,
          1,
          -t2,
          t2,
          0,
          -1,
          t2,
          0,
          1,
          -t2,
          0,
          -1,
          -t2,
          0,
          1
        ];
        const indices = [
          0,
          11,
          5,
          0,
          5,
          1,
          0,
          1,
          7,
          0,
          7,
          10,
          0,
          10,
          11,
          1,
          5,
          9,
          5,
          11,
          4,
          11,
          10,
          2,
          10,
          7,
          6,
          7,
          1,
          8,
          3,
          9,
          4,
          3,
          4,
          2,
          3,
          2,
          6,
          3,
          6,
          8,
          3,
          8,
          9,
          4,
          9,
          5,
          2,
          4,
          11,
          6,
          2,
          10,
          8,
          6,
          7,
          9,
          8,
          1
        ];
        super(vertices, indices, radius, detail);
        this.type = "IcosahedronGeometry";
        this.parameters = {
          radius,
          detail
        };
      }
      static fromJSON(data) {
        return new _IcosahedronGeometry(data.radius, data.detail);
      }
    };
    OctahedronGeometry = class _OctahedronGeometry extends PolyhedronGeometry {
      constructor(radius = 1, detail = 0) {
        const vertices = [
          1,
          0,
          0,
          -1,
          0,
          0,
          0,
          1,
          0,
          0,
          -1,
          0,
          0,
          0,
          1,
          0,
          0,
          -1
        ];
        const indices = [
          0,
          2,
          4,
          0,
          4,
          3,
          0,
          3,
          5,
          0,
          5,
          2,
          1,
          2,
          5,
          1,
          5,
          3,
          1,
          3,
          4,
          1,
          4,
          2
        ];
        super(vertices, indices, radius, detail);
        this.type = "OctahedronGeometry";
        this.parameters = {
          radius,
          detail
        };
      }
      static fromJSON(data) {
        return new _OctahedronGeometry(data.radius, data.detail);
      }
    };
    RingGeometry = class _RingGeometry extends BufferGeometry {
      constructor(innerRadius = 0.5, outerRadius = 1, thetaSegments = 32, phiSegments = 1, thetaStart = 0, thetaLength = Math.PI * 2) {
        super();
        this.type = "RingGeometry";
        this.parameters = {
          innerRadius,
          outerRadius,
          thetaSegments,
          phiSegments,
          thetaStart,
          thetaLength
        };
        thetaSegments = Math.max(3, thetaSegments);
        phiSegments = Math.max(1, phiSegments);
        const indices = [];
        const vertices = [];
        const normals = [];
        const uvs = [];
        let radius = innerRadius;
        const radiusStep = (outerRadius - innerRadius) / phiSegments;
        const vertex2 = new Vector3();
        const uv = new Vector2();
        for (let j2 = 0; j2 <= phiSegments; j2++) {
          for (let i2 = 0; i2 <= thetaSegments; i2++) {
            const segment = thetaStart + i2 / thetaSegments * thetaLength;
            vertex2.x = radius * Math.cos(segment);
            vertex2.y = radius * Math.sin(segment);
            vertices.push(vertex2.x, vertex2.y, vertex2.z);
            normals.push(0, 0, 1);
            uv.x = (vertex2.x / outerRadius + 1) / 2;
            uv.y = (vertex2.y / outerRadius + 1) / 2;
            uvs.push(uv.x, uv.y);
          }
          radius += radiusStep;
        }
        for (let j2 = 0; j2 < phiSegments; j2++) {
          const thetaSegmentLevel = j2 * (thetaSegments + 1);
          for (let i2 = 0; i2 < thetaSegments; i2++) {
            const segment = i2 + thetaSegmentLevel;
            const a = segment;
            const b = segment + thetaSegments + 1;
            const c = segment + thetaSegments + 2;
            const d = segment + 1;
            indices.push(a, b, d);
            indices.push(b, c, d);
          }
        }
        this.setIndex(indices);
        this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
        this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
        this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
      }
      copy(source) {
        super.copy(source);
        this.parameters = Object.assign({}, source.parameters);
        return this;
      }
      static fromJSON(data) {
        return new _RingGeometry(data.innerRadius, data.outerRadius, data.thetaSegments, data.phiSegments, data.thetaStart, data.thetaLength);
      }
    };
    ShapeGeometry = class _ShapeGeometry extends BufferGeometry {
      constructor(shapes = new Shape([new Vector2(0, 0.5), new Vector2(-0.5, -0.5), new Vector2(0.5, -0.5)]), curveSegments = 12) {
        super();
        this.type = "ShapeGeometry";
        this.parameters = {
          shapes,
          curveSegments
        };
        const indices = [];
        const vertices = [];
        const normals = [];
        const uvs = [];
        let groupStart = 0;
        let groupCount = 0;
        if (Array.isArray(shapes) === false) {
          addShape(shapes);
        } else {
          for (let i2 = 0; i2 < shapes.length; i2++) {
            addShape(shapes[i2]);
            this.addGroup(groupStart, groupCount, i2);
            groupStart += groupCount;
            groupCount = 0;
          }
        }
        this.setIndex(indices);
        this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
        this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
        this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
        function addShape(shape) {
          const indexOffset = vertices.length / 3;
          const points = shape.extractPoints(curveSegments);
          let shapeVertices = points.shape;
          const shapeHoles = points.holes;
          if (ShapeUtils.isClockWise(shapeVertices) === false) {
            shapeVertices = shapeVertices.reverse();
          }
          for (let i2 = 0, l2 = shapeHoles.length; i2 < l2; i2++) {
            const shapeHole = shapeHoles[i2];
            if (ShapeUtils.isClockWise(shapeHole) === true) {
              shapeHoles[i2] = shapeHole.reverse();
            }
          }
          const faces = ShapeUtils.triangulateShape(shapeVertices, shapeHoles);
          for (let i2 = 0, l2 = shapeHoles.length; i2 < l2; i2++) {
            const shapeHole = shapeHoles[i2];
            shapeVertices = shapeVertices.concat(shapeHole);
          }
          for (let i2 = 0, l2 = shapeVertices.length; i2 < l2; i2++) {
            const vertex2 = shapeVertices[i2];
            vertices.push(vertex2.x, vertex2.y, 0);
            normals.push(0, 0, 1);
            uvs.push(vertex2.x, vertex2.y);
          }
          for (let i2 = 0, l2 = faces.length; i2 < l2; i2++) {
            const face = faces[i2];
            const a = face[0] + indexOffset;
            const b = face[1] + indexOffset;
            const c = face[2] + indexOffset;
            indices.push(a, b, c);
            groupCount += 3;
          }
        }
      }
      copy(source) {
        super.copy(source);
        this.parameters = Object.assign({}, source.parameters);
        return this;
      }
      toJSON() {
        const data = super.toJSON();
        const shapes = this.parameters.shapes;
        return toJSON(shapes, data);
      }
      static fromJSON(data, shapes) {
        const geometryShapes = [];
        for (let j2 = 0, jl = data.shapes.length; j2 < jl; j2++) {
          const shape = shapes[data.shapes[j2]];
          geometryShapes.push(shape);
        }
        return new _ShapeGeometry(geometryShapes, data.curveSegments);
      }
    };
    SphereGeometry = class _SphereGeometry extends BufferGeometry {
      constructor(radius = 1, widthSegments = 32, heightSegments = 16, phiStart = 0, phiLength = Math.PI * 2, thetaStart = 0, thetaLength = Math.PI) {
        super();
        this.type = "SphereGeometry";
        this.parameters = {
          radius,
          widthSegments,
          heightSegments,
          phiStart,
          phiLength,
          thetaStart,
          thetaLength
        };
        widthSegments = Math.max(3, Math.floor(widthSegments));
        heightSegments = Math.max(2, Math.floor(heightSegments));
        const thetaEnd = Math.min(thetaStart + thetaLength, Math.PI);
        let index = 0;
        const grid = [];
        const vertex2 = new Vector3();
        const normal = new Vector3();
        const indices = [];
        const vertices = [];
        const normals = [];
        const uvs = [];
        for (let iy = 0; iy <= heightSegments; iy++) {
          const verticesRow = [];
          const v2 = iy / heightSegments;
          let uOffset = 0;
          if (iy === 0 && thetaStart === 0) {
            uOffset = 0.5 / widthSegments;
          } else if (iy === heightSegments && thetaEnd === Math.PI) {
            uOffset = -0.5 / widthSegments;
          }
          for (let ix = 0; ix <= widthSegments; ix++) {
            const u3 = ix / widthSegments;
            vertex2.x = -radius * Math.cos(phiStart + u3 * phiLength) * Math.sin(thetaStart + v2 * thetaLength);
            vertex2.y = radius * Math.cos(thetaStart + v2 * thetaLength);
            vertex2.z = radius * Math.sin(phiStart + u3 * phiLength) * Math.sin(thetaStart + v2 * thetaLength);
            vertices.push(vertex2.x, vertex2.y, vertex2.z);
            normal.copy(vertex2).normalize();
            normals.push(normal.x, normal.y, normal.z);
            uvs.push(u3 + uOffset, 1 - v2);
            verticesRow.push(index++);
          }
          grid.push(verticesRow);
        }
        for (let iy = 0; iy < heightSegments; iy++) {
          for (let ix = 0; ix < widthSegments; ix++) {
            const a = grid[iy][ix + 1];
            const b = grid[iy][ix];
            const c = grid[iy + 1][ix];
            const d = grid[iy + 1][ix + 1];
            if (iy !== 0 || thetaStart > 0) indices.push(a, b, d);
            if (iy !== heightSegments - 1 || thetaEnd < Math.PI) indices.push(b, c, d);
          }
        }
        this.setIndex(indices);
        this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
        this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
        this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
      }
      copy(source) {
        super.copy(source);
        this.parameters = Object.assign({}, source.parameters);
        return this;
      }
      static fromJSON(data) {
        return new _SphereGeometry(data.radius, data.widthSegments, data.heightSegments, data.phiStart, data.phiLength, data.thetaStart, data.thetaLength);
      }
    };
    TetrahedronGeometry = class _TetrahedronGeometry extends PolyhedronGeometry {
      constructor(radius = 1, detail = 0) {
        const vertices = [
          1,
          1,
          1,
          -1,
          -1,
          1,
          -1,
          1,
          -1,
          1,
          -1,
          -1
        ];
        const indices = [
          2,
          1,
          0,
          0,
          3,
          2,
          1,
          3,
          0,
          2,
          3,
          1
        ];
        super(vertices, indices, radius, detail);
        this.type = "TetrahedronGeometry";
        this.parameters = {
          radius,
          detail
        };
      }
      static fromJSON(data) {
        return new _TetrahedronGeometry(data.radius, data.detail);
      }
    };
    TorusGeometry = class _TorusGeometry extends BufferGeometry {
      constructor(radius = 1, tube = 0.4, radialSegments = 12, tubularSegments = 48, arc = Math.PI * 2) {
        super();
        this.type = "TorusGeometry";
        this.parameters = {
          radius,
          tube,
          radialSegments,
          tubularSegments,
          arc
        };
        radialSegments = Math.floor(radialSegments);
        tubularSegments = Math.floor(tubularSegments);
        const indices = [];
        const vertices = [];
        const normals = [];
        const uvs = [];
        const center = new Vector3();
        const vertex2 = new Vector3();
        const normal = new Vector3();
        for (let j2 = 0; j2 <= radialSegments; j2++) {
          for (let i2 = 0; i2 <= tubularSegments; i2++) {
            const u3 = i2 / tubularSegments * arc;
            const v2 = j2 / radialSegments * Math.PI * 2;
            vertex2.x = (radius + tube * Math.cos(v2)) * Math.cos(u3);
            vertex2.y = (radius + tube * Math.cos(v2)) * Math.sin(u3);
            vertex2.z = tube * Math.sin(v2);
            vertices.push(vertex2.x, vertex2.y, vertex2.z);
            center.x = radius * Math.cos(u3);
            center.y = radius * Math.sin(u3);
            normal.subVectors(vertex2, center).normalize();
            normals.push(normal.x, normal.y, normal.z);
            uvs.push(i2 / tubularSegments);
            uvs.push(j2 / radialSegments);
          }
        }
        for (let j2 = 1; j2 <= radialSegments; j2++) {
          for (let i2 = 1; i2 <= tubularSegments; i2++) {
            const a = (tubularSegments + 1) * j2 + i2 - 1;
            const b = (tubularSegments + 1) * (j2 - 1) + i2 - 1;
            const c = (tubularSegments + 1) * (j2 - 1) + i2;
            const d = (tubularSegments + 1) * j2 + i2;
            indices.push(a, b, d);
            indices.push(b, c, d);
          }
        }
        this.setIndex(indices);
        this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
        this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
        this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
      }
      copy(source) {
        super.copy(source);
        this.parameters = Object.assign({}, source.parameters);
        return this;
      }
      static fromJSON(data) {
        return new _TorusGeometry(data.radius, data.tube, data.radialSegments, data.tubularSegments, data.arc);
      }
    };
    TorusKnotGeometry = class _TorusKnotGeometry extends BufferGeometry {
      constructor(radius = 1, tube = 0.4, tubularSegments = 64, radialSegments = 8, p3 = 2, q3 = 3) {
        super();
        this.type = "TorusKnotGeometry";
        this.parameters = {
          radius,
          tube,
          tubularSegments,
          radialSegments,
          p: p3,
          q: q3
        };
        tubularSegments = Math.floor(tubularSegments);
        radialSegments = Math.floor(radialSegments);
        const indices = [];
        const vertices = [];
        const normals = [];
        const uvs = [];
        const vertex2 = new Vector3();
        const normal = new Vector3();
        const P1 = new Vector3();
        const P2 = new Vector3();
        const B2 = new Vector3();
        const T3 = new Vector3();
        const N2 = new Vector3();
        for (let i2 = 0; i2 <= tubularSegments; ++i2) {
          const u3 = i2 / tubularSegments * p3 * Math.PI * 2;
          calculatePositionOnCurve(u3, p3, q3, radius, P1);
          calculatePositionOnCurve(u3 + 0.01, p3, q3, radius, P2);
          T3.subVectors(P2, P1);
          N2.addVectors(P2, P1);
          B2.crossVectors(T3, N2);
          N2.crossVectors(B2, T3);
          B2.normalize();
          N2.normalize();
          for (let j2 = 0; j2 <= radialSegments; ++j2) {
            const v2 = j2 / radialSegments * Math.PI * 2;
            const cx = -tube * Math.cos(v2);
            const cy = tube * Math.sin(v2);
            vertex2.x = P1.x + (cx * N2.x + cy * B2.x);
            vertex2.y = P1.y + (cx * N2.y + cy * B2.y);
            vertex2.z = P1.z + (cx * N2.z + cy * B2.z);
            vertices.push(vertex2.x, vertex2.y, vertex2.z);
            normal.subVectors(vertex2, P1).normalize();
            normals.push(normal.x, normal.y, normal.z);
            uvs.push(i2 / tubularSegments);
            uvs.push(j2 / radialSegments);
          }
        }
        for (let j2 = 1; j2 <= tubularSegments; j2++) {
          for (let i2 = 1; i2 <= radialSegments; i2++) {
            const a = (radialSegments + 1) * (j2 - 1) + (i2 - 1);
            const b = (radialSegments + 1) * j2 + (i2 - 1);
            const c = (radialSegments + 1) * j2 + i2;
            const d = (radialSegments + 1) * (j2 - 1) + i2;
            indices.push(a, b, d);
            indices.push(b, c, d);
          }
        }
        this.setIndex(indices);
        this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
        this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
        this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
        function calculatePositionOnCurve(u3, p22, q22, radius2, position) {
          const cu = Math.cos(u3);
          const su = Math.sin(u3);
          const quOverP = q22 / p22 * u3;
          const cs = Math.cos(quOverP);
          position.x = radius2 * (2 + cs) * 0.5 * cu;
          position.y = radius2 * (2 + cs) * su * 0.5;
          position.z = radius2 * Math.sin(quOverP) * 0.5;
        }
      }
      copy(source) {
        super.copy(source);
        this.parameters = Object.assign({}, source.parameters);
        return this;
      }
      static fromJSON(data) {
        return new _TorusKnotGeometry(data.radius, data.tube, data.tubularSegments, data.radialSegments, data.p, data.q);
      }
    };
    TubeGeometry = class _TubeGeometry extends BufferGeometry {
      constructor(path = new QuadraticBezierCurve3(new Vector3(-1, -1, 0), new Vector3(-1, 1, 0), new Vector3(1, 1, 0)), tubularSegments = 64, radius = 1, radialSegments = 8, closed = false) {
        super();
        this.type = "TubeGeometry";
        this.parameters = {
          path,
          tubularSegments,
          radius,
          radialSegments,
          closed
        };
        const frames = path.computeFrenetFrames(tubularSegments, closed);
        this.tangents = frames.tangents;
        this.normals = frames.normals;
        this.binormals = frames.binormals;
        const vertex2 = new Vector3();
        const normal = new Vector3();
        const uv = new Vector2();
        let P2 = new Vector3();
        const vertices = [];
        const normals = [];
        const uvs = [];
        const indices = [];
        generateBufferData();
        this.setIndex(indices);
        this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
        this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
        this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
        function generateBufferData() {
          for (let i2 = 0; i2 < tubularSegments; i2++) {
            generateSegment(i2);
          }
          generateSegment(closed === false ? tubularSegments : 0);
          generateUVs();
          generateIndices();
        }
        function generateSegment(i2) {
          P2 = path.getPointAt(i2 / tubularSegments, P2);
          const N2 = frames.normals[i2];
          const B2 = frames.binormals[i2];
          for (let j2 = 0; j2 <= radialSegments; j2++) {
            const v2 = j2 / radialSegments * Math.PI * 2;
            const sin = Math.sin(v2);
            const cos = -Math.cos(v2);
            normal.x = cos * N2.x + sin * B2.x;
            normal.y = cos * N2.y + sin * B2.y;
            normal.z = cos * N2.z + sin * B2.z;
            normal.normalize();
            normals.push(normal.x, normal.y, normal.z);
            vertex2.x = P2.x + radius * normal.x;
            vertex2.y = P2.y + radius * normal.y;
            vertex2.z = P2.z + radius * normal.z;
            vertices.push(vertex2.x, vertex2.y, vertex2.z);
          }
        }
        function generateIndices() {
          for (let j2 = 1; j2 <= tubularSegments; j2++) {
            for (let i2 = 1; i2 <= radialSegments; i2++) {
              const a = (radialSegments + 1) * (j2 - 1) + (i2 - 1);
              const b = (radialSegments + 1) * j2 + (i2 - 1);
              const c = (radialSegments + 1) * j2 + i2;
              const d = (radialSegments + 1) * (j2 - 1) + i2;
              indices.push(a, b, d);
              indices.push(b, c, d);
            }
          }
        }
        function generateUVs() {
          for (let i2 = 0; i2 <= tubularSegments; i2++) {
            for (let j2 = 0; j2 <= radialSegments; j2++) {
              uv.x = i2 / tubularSegments;
              uv.y = j2 / radialSegments;
              uvs.push(uv.x, uv.y);
            }
          }
        }
      }
      copy(source) {
        super.copy(source);
        this.parameters = Object.assign({}, source.parameters);
        return this;
      }
      toJSON() {
        const data = super.toJSON();
        data.path = this.parameters.path.toJSON();
        return data;
      }
      static fromJSON(data) {
        return new _TubeGeometry(
          new Curves[data.path.type]().fromJSON(data.path),
          data.tubularSegments,
          data.radius,
          data.radialSegments,
          data.closed
        );
      }
    };
    WireframeGeometry = class extends BufferGeometry {
      constructor(geometry = null) {
        super();
        this.type = "WireframeGeometry";
        this.parameters = {
          geometry
        };
        if (geometry !== null) {
          const vertices = [];
          const edges = /* @__PURE__ */ new Set();
          const start = new Vector3();
          const end = new Vector3();
          if (geometry.index !== null) {
            const position = geometry.attributes.position;
            const indices = geometry.index;
            let groups = geometry.groups;
            if (groups.length === 0) {
              groups = [{ start: 0, count: indices.count, materialIndex: 0 }];
            }
            for (let o = 0, ol = groups.length; o < ol; ++o) {
              const group = groups[o];
              const groupStart = group.start;
              const groupCount = group.count;
              for (let i2 = groupStart, l2 = groupStart + groupCount; i2 < l2; i2 += 3) {
                for (let j2 = 0; j2 < 3; j2++) {
                  const index1 = indices.getX(i2 + j2);
                  const index2 = indices.getX(i2 + (j2 + 1) % 3);
                  start.fromBufferAttribute(position, index1);
                  end.fromBufferAttribute(position, index2);
                  if (isUniqueEdge(start, end, edges) === true) {
                    vertices.push(start.x, start.y, start.z);
                    vertices.push(end.x, end.y, end.z);
                  }
                }
              }
            }
          } else {
            const position = geometry.attributes.position;
            for (let i2 = 0, l2 = position.count / 3; i2 < l2; i2++) {
              for (let j2 = 0; j2 < 3; j2++) {
                const index1 = 3 * i2 + j2;
                const index2 = 3 * i2 + (j2 + 1) % 3;
                start.fromBufferAttribute(position, index1);
                end.fromBufferAttribute(position, index2);
                if (isUniqueEdge(start, end, edges) === true) {
                  vertices.push(start.x, start.y, start.z);
                  vertices.push(end.x, end.y, end.z);
                }
              }
            }
          }
          this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
        }
      }
      copy(source) {
        super.copy(source);
        this.parameters = Object.assign({}, source.parameters);
        return this;
      }
    };
    Geometries = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      BoxGeometry,
      CapsuleGeometry,
      CircleGeometry,
      ConeGeometry,
      CylinderGeometry,
      DodecahedronGeometry,
      EdgesGeometry,
      ExtrudeGeometry,
      IcosahedronGeometry,
      LatheGeometry,
      OctahedronGeometry,
      PlaneGeometry,
      PolyhedronGeometry,
      RingGeometry,
      ShapeGeometry,
      SphereGeometry,
      TetrahedronGeometry,
      TorusGeometry,
      TorusKnotGeometry,
      TubeGeometry,
      WireframeGeometry
    });
    ShadowMaterial = class extends Material {
      constructor(parameters) {
        super();
        this.isShadowMaterial = true;
        this.type = "ShadowMaterial";
        this.color = new Color(0);
        this.transparent = true;
        this.fog = true;
        this.setValues(parameters);
      }
      copy(source) {
        super.copy(source);
        this.color.copy(source.color);
        this.fog = source.fog;
        return this;
      }
    };
    RawShaderMaterial = class extends ShaderMaterial {
      constructor(parameters) {
        super(parameters);
        this.isRawShaderMaterial = true;
        this.type = "RawShaderMaterial";
      }
    };
    MeshStandardMaterial = class extends Material {
      constructor(parameters) {
        super();
        this.isMeshStandardMaterial = true;
        this.defines = { "STANDARD": "" };
        this.type = "MeshStandardMaterial";
        this.color = new Color(16777215);
        this.roughness = 1;
        this.metalness = 0;
        this.map = null;
        this.lightMap = null;
        this.lightMapIntensity = 1;
        this.aoMap = null;
        this.aoMapIntensity = 1;
        this.emissive = new Color(0);
        this.emissiveIntensity = 1;
        this.emissiveMap = null;
        this.bumpMap = null;
        this.bumpScale = 1;
        this.normalMap = null;
        this.normalMapType = TangentSpaceNormalMap;
        this.normalScale = new Vector2(1, 1);
        this.displacementMap = null;
        this.displacementScale = 1;
        this.displacementBias = 0;
        this.roughnessMap = null;
        this.metalnessMap = null;
        this.alphaMap = null;
        this.envMap = null;
        this.envMapRotation = new Euler();
        this.envMapIntensity = 1;
        this.wireframe = false;
        this.wireframeLinewidth = 1;
        this.wireframeLinecap = "round";
        this.wireframeLinejoin = "round";
        this.flatShading = false;
        this.fog = true;
        this.setValues(parameters);
      }
      copy(source) {
        super.copy(source);
        this.defines = { "STANDARD": "" };
        this.color.copy(source.color);
        this.roughness = source.roughness;
        this.metalness = source.metalness;
        this.map = source.map;
        this.lightMap = source.lightMap;
        this.lightMapIntensity = source.lightMapIntensity;
        this.aoMap = source.aoMap;
        this.aoMapIntensity = source.aoMapIntensity;
        this.emissive.copy(source.emissive);
        this.emissiveMap = source.emissiveMap;
        this.emissiveIntensity = source.emissiveIntensity;
        this.bumpMap = source.bumpMap;
        this.bumpScale = source.bumpScale;
        this.normalMap = source.normalMap;
        this.normalMapType = source.normalMapType;
        this.normalScale.copy(source.normalScale);
        this.displacementMap = source.displacementMap;
        this.displacementScale = source.displacementScale;
        this.displacementBias = source.displacementBias;
        this.roughnessMap = source.roughnessMap;
        this.metalnessMap = source.metalnessMap;
        this.alphaMap = source.alphaMap;
        this.envMap = source.envMap;
        this.envMapRotation.copy(source.envMapRotation);
        this.envMapIntensity = source.envMapIntensity;
        this.wireframe = source.wireframe;
        this.wireframeLinewidth = source.wireframeLinewidth;
        this.wireframeLinecap = source.wireframeLinecap;
        this.wireframeLinejoin = source.wireframeLinejoin;
        this.flatShading = source.flatShading;
        this.fog = source.fog;
        return this;
      }
    };
    MeshPhysicalMaterial = class extends MeshStandardMaterial {
      constructor(parameters) {
        super();
        this.isMeshPhysicalMaterial = true;
        this.defines = {
          "STANDARD": "",
          "PHYSICAL": ""
        };
        this.type = "MeshPhysicalMaterial";
        this.anisotropyRotation = 0;
        this.anisotropyMap = null;
        this.clearcoatMap = null;
        this.clearcoatRoughness = 0;
        this.clearcoatRoughnessMap = null;
        this.clearcoatNormalScale = new Vector2(1, 1);
        this.clearcoatNormalMap = null;
        this.ior = 1.5;
        Object.defineProperty(this, "reflectivity", {
          get: function() {
            return clamp(2.5 * (this.ior - 1) / (this.ior + 1), 0, 1);
          },
          set: function(reflectivity) {
            this.ior = (1 + 0.4 * reflectivity) / (1 - 0.4 * reflectivity);
          }
        });
        this.iridescenceMap = null;
        this.iridescenceIOR = 1.3;
        this.iridescenceThicknessRange = [100, 400];
        this.iridescenceThicknessMap = null;
        this.sheenColor = new Color(0);
        this.sheenColorMap = null;
        this.sheenRoughness = 1;
        this.sheenRoughnessMap = null;
        this.transmissionMap = null;
        this.thickness = 0;
        this.thicknessMap = null;
        this.attenuationDistance = Infinity;
        this.attenuationColor = new Color(1, 1, 1);
        this.specularIntensity = 1;
        this.specularIntensityMap = null;
        this.specularColor = new Color(1, 1, 1);
        this.specularColorMap = null;
        this._anisotropy = 0;
        this._clearcoat = 0;
        this._dispersion = 0;
        this._iridescence = 0;
        this._sheen = 0;
        this._transmission = 0;
        this.setValues(parameters);
      }
      get anisotropy() {
        return this._anisotropy;
      }
      set anisotropy(value) {
        if (this._anisotropy > 0 !== value > 0) {
          this.version++;
        }
        this._anisotropy = value;
      }
      get clearcoat() {
        return this._clearcoat;
      }
      set clearcoat(value) {
        if (this._clearcoat > 0 !== value > 0) {
          this.version++;
        }
        this._clearcoat = value;
      }
      get iridescence() {
        return this._iridescence;
      }
      set iridescence(value) {
        if (this._iridescence > 0 !== value > 0) {
          this.version++;
        }
        this._iridescence = value;
      }
      get dispersion() {
        return this._dispersion;
      }
      set dispersion(value) {
        if (this._dispersion > 0 !== value > 0) {
          this.version++;
        }
        this._dispersion = value;
      }
      get sheen() {
        return this._sheen;
      }
      set sheen(value) {
        if (this._sheen > 0 !== value > 0) {
          this.version++;
        }
        this._sheen = value;
      }
      get transmission() {
        return this._transmission;
      }
      set transmission(value) {
        if (this._transmission > 0 !== value > 0) {
          this.version++;
        }
        this._transmission = value;
      }
      copy(source) {
        super.copy(source);
        this.defines = {
          "STANDARD": "",
          "PHYSICAL": ""
        };
        this.anisotropy = source.anisotropy;
        this.anisotropyRotation = source.anisotropyRotation;
        this.anisotropyMap = source.anisotropyMap;
        this.clearcoat = source.clearcoat;
        this.clearcoatMap = source.clearcoatMap;
        this.clearcoatRoughness = source.clearcoatRoughness;
        this.clearcoatRoughnessMap = source.clearcoatRoughnessMap;
        this.clearcoatNormalMap = source.clearcoatNormalMap;
        this.clearcoatNormalScale.copy(source.clearcoatNormalScale);
        this.dispersion = source.dispersion;
        this.ior = source.ior;
        this.iridescence = source.iridescence;
        this.iridescenceMap = source.iridescenceMap;
        this.iridescenceIOR = source.iridescenceIOR;
        this.iridescenceThicknessRange = [...source.iridescenceThicknessRange];
        this.iridescenceThicknessMap = source.iridescenceThicknessMap;
        this.sheen = source.sheen;
        this.sheenColor.copy(source.sheenColor);
        this.sheenColorMap = source.sheenColorMap;
        this.sheenRoughness = source.sheenRoughness;
        this.sheenRoughnessMap = source.sheenRoughnessMap;
        this.transmission = source.transmission;
        this.transmissionMap = source.transmissionMap;
        this.thickness = source.thickness;
        this.thicknessMap = source.thicknessMap;
        this.attenuationDistance = source.attenuationDistance;
        this.attenuationColor.copy(source.attenuationColor);
        this.specularIntensity = source.specularIntensity;
        this.specularIntensityMap = source.specularIntensityMap;
        this.specularColor.copy(source.specularColor);
        this.specularColorMap = source.specularColorMap;
        return this;
      }
    };
    MeshPhongMaterial = class extends Material {
      constructor(parameters) {
        super();
        this.isMeshPhongMaterial = true;
        this.type = "MeshPhongMaterial";
        this.color = new Color(16777215);
        this.specular = new Color(1118481);
        this.shininess = 30;
        this.map = null;
        this.lightMap = null;
        this.lightMapIntensity = 1;
        this.aoMap = null;
        this.aoMapIntensity = 1;
        this.emissive = new Color(0);
        this.emissiveIntensity = 1;
        this.emissiveMap = null;
        this.bumpMap = null;
        this.bumpScale = 1;
        this.normalMap = null;
        this.normalMapType = TangentSpaceNormalMap;
        this.normalScale = new Vector2(1, 1);
        this.displacementMap = null;
        this.displacementScale = 1;
        this.displacementBias = 0;
        this.specularMap = null;
        this.alphaMap = null;
        this.envMap = null;
        this.envMapRotation = new Euler();
        this.combine = MultiplyOperation;
        this.reflectivity = 1;
        this.refractionRatio = 0.98;
        this.wireframe = false;
        this.wireframeLinewidth = 1;
        this.wireframeLinecap = "round";
        this.wireframeLinejoin = "round";
        this.flatShading = false;
        this.fog = true;
        this.setValues(parameters);
      }
      copy(source) {
        super.copy(source);
        this.color.copy(source.color);
        this.specular.copy(source.specular);
        this.shininess = source.shininess;
        this.map = source.map;
        this.lightMap = source.lightMap;
        this.lightMapIntensity = source.lightMapIntensity;
        this.aoMap = source.aoMap;
        this.aoMapIntensity = source.aoMapIntensity;
        this.emissive.copy(source.emissive);
        this.emissiveMap = source.emissiveMap;
        this.emissiveIntensity = source.emissiveIntensity;
        this.bumpMap = source.bumpMap;
        this.bumpScale = source.bumpScale;
        this.normalMap = source.normalMap;
        this.normalMapType = source.normalMapType;
        this.normalScale.copy(source.normalScale);
        this.displacementMap = source.displacementMap;
        this.displacementScale = source.displacementScale;
        this.displacementBias = source.displacementBias;
        this.specularMap = source.specularMap;
        this.alphaMap = source.alphaMap;
        this.envMap = source.envMap;
        this.envMapRotation.copy(source.envMapRotation);
        this.combine = source.combine;
        this.reflectivity = source.reflectivity;
        this.refractionRatio = source.refractionRatio;
        this.wireframe = source.wireframe;
        this.wireframeLinewidth = source.wireframeLinewidth;
        this.wireframeLinecap = source.wireframeLinecap;
        this.wireframeLinejoin = source.wireframeLinejoin;
        this.flatShading = source.flatShading;
        this.fog = source.fog;
        return this;
      }
    };
    MeshToonMaterial = class extends Material {
      constructor(parameters) {
        super();
        this.isMeshToonMaterial = true;
        this.defines = { "TOON": "" };
        this.type = "MeshToonMaterial";
        this.color = new Color(16777215);
        this.map = null;
        this.gradientMap = null;
        this.lightMap = null;
        this.lightMapIntensity = 1;
        this.aoMap = null;
        this.aoMapIntensity = 1;
        this.emissive = new Color(0);
        this.emissiveIntensity = 1;
        this.emissiveMap = null;
        this.bumpMap = null;
        this.bumpScale = 1;
        this.normalMap = null;
        this.normalMapType = TangentSpaceNormalMap;
        this.normalScale = new Vector2(1, 1);
        this.displacementMap = null;
        this.displacementScale = 1;
        this.displacementBias = 0;
        this.alphaMap = null;
        this.wireframe = false;
        this.wireframeLinewidth = 1;
        this.wireframeLinecap = "round";
        this.wireframeLinejoin = "round";
        this.fog = true;
        this.setValues(parameters);
      }
      copy(source) {
        super.copy(source);
        this.color.copy(source.color);
        this.map = source.map;
        this.gradientMap = source.gradientMap;
        this.lightMap = source.lightMap;
        this.lightMapIntensity = source.lightMapIntensity;
        this.aoMap = source.aoMap;
        this.aoMapIntensity = source.aoMapIntensity;
        this.emissive.copy(source.emissive);
        this.emissiveMap = source.emissiveMap;
        this.emissiveIntensity = source.emissiveIntensity;
        this.bumpMap = source.bumpMap;
        this.bumpScale = source.bumpScale;
        this.normalMap = source.normalMap;
        this.normalMapType = source.normalMapType;
        this.normalScale.copy(source.normalScale);
        this.displacementMap = source.displacementMap;
        this.displacementScale = source.displacementScale;
        this.displacementBias = source.displacementBias;
        this.alphaMap = source.alphaMap;
        this.wireframe = source.wireframe;
        this.wireframeLinewidth = source.wireframeLinewidth;
        this.wireframeLinecap = source.wireframeLinecap;
        this.wireframeLinejoin = source.wireframeLinejoin;
        this.fog = source.fog;
        return this;
      }
    };
    MeshNormalMaterial = class extends Material {
      constructor(parameters) {
        super();
        this.isMeshNormalMaterial = true;
        this.type = "MeshNormalMaterial";
        this.bumpMap = null;
        this.bumpScale = 1;
        this.normalMap = null;
        this.normalMapType = TangentSpaceNormalMap;
        this.normalScale = new Vector2(1, 1);
        this.displacementMap = null;
        this.displacementScale = 1;
        this.displacementBias = 0;
        this.wireframe = false;
        this.wireframeLinewidth = 1;
        this.flatShading = false;
        this.setValues(parameters);
      }
      copy(source) {
        super.copy(source);
        this.bumpMap = source.bumpMap;
        this.bumpScale = source.bumpScale;
        this.normalMap = source.normalMap;
        this.normalMapType = source.normalMapType;
        this.normalScale.copy(source.normalScale);
        this.displacementMap = source.displacementMap;
        this.displacementScale = source.displacementScale;
        this.displacementBias = source.displacementBias;
        this.wireframe = source.wireframe;
        this.wireframeLinewidth = source.wireframeLinewidth;
        this.flatShading = source.flatShading;
        return this;
      }
    };
    MeshLambertMaterial = class extends Material {
      constructor(parameters) {
        super();
        this.isMeshLambertMaterial = true;
        this.type = "MeshLambertMaterial";
        this.color = new Color(16777215);
        this.map = null;
        this.lightMap = null;
        this.lightMapIntensity = 1;
        this.aoMap = null;
        this.aoMapIntensity = 1;
        this.emissive = new Color(0);
        this.emissiveIntensity = 1;
        this.emissiveMap = null;
        this.bumpMap = null;
        this.bumpScale = 1;
        this.normalMap = null;
        this.normalMapType = TangentSpaceNormalMap;
        this.normalScale = new Vector2(1, 1);
        this.displacementMap = null;
        this.displacementScale = 1;
        this.displacementBias = 0;
        this.specularMap = null;
        this.alphaMap = null;
        this.envMap = null;
        this.envMapRotation = new Euler();
        this.combine = MultiplyOperation;
        this.reflectivity = 1;
        this.refractionRatio = 0.98;
        this.wireframe = false;
        this.wireframeLinewidth = 1;
        this.wireframeLinecap = "round";
        this.wireframeLinejoin = "round";
        this.flatShading = false;
        this.fog = true;
        this.setValues(parameters);
      }
      copy(source) {
        super.copy(source);
        this.color.copy(source.color);
        this.map = source.map;
        this.lightMap = source.lightMap;
        this.lightMapIntensity = source.lightMapIntensity;
        this.aoMap = source.aoMap;
        this.aoMapIntensity = source.aoMapIntensity;
        this.emissive.copy(source.emissive);
        this.emissiveMap = source.emissiveMap;
        this.emissiveIntensity = source.emissiveIntensity;
        this.bumpMap = source.bumpMap;
        this.bumpScale = source.bumpScale;
        this.normalMap = source.normalMap;
        this.normalMapType = source.normalMapType;
        this.normalScale.copy(source.normalScale);
        this.displacementMap = source.displacementMap;
        this.displacementScale = source.displacementScale;
        this.displacementBias = source.displacementBias;
        this.specularMap = source.specularMap;
        this.alphaMap = source.alphaMap;
        this.envMap = source.envMap;
        this.envMapRotation.copy(source.envMapRotation);
        this.combine = source.combine;
        this.reflectivity = source.reflectivity;
        this.refractionRatio = source.refractionRatio;
        this.wireframe = source.wireframe;
        this.wireframeLinewidth = source.wireframeLinewidth;
        this.wireframeLinecap = source.wireframeLinecap;
        this.wireframeLinejoin = source.wireframeLinejoin;
        this.flatShading = source.flatShading;
        this.fog = source.fog;
        return this;
      }
    };
    MeshMatcapMaterial = class extends Material {
      constructor(parameters) {
        super();
        this.isMeshMatcapMaterial = true;
        this.defines = { "MATCAP": "" };
        this.type = "MeshMatcapMaterial";
        this.color = new Color(16777215);
        this.matcap = null;
        this.map = null;
        this.bumpMap = null;
        this.bumpScale = 1;
        this.normalMap = null;
        this.normalMapType = TangentSpaceNormalMap;
        this.normalScale = new Vector2(1, 1);
        this.displacementMap = null;
        this.displacementScale = 1;
        this.displacementBias = 0;
        this.alphaMap = null;
        this.flatShading = false;
        this.fog = true;
        this.setValues(parameters);
      }
      copy(source) {
        super.copy(source);
        this.defines = { "MATCAP": "" };
        this.color.copy(source.color);
        this.matcap = source.matcap;
        this.map = source.map;
        this.bumpMap = source.bumpMap;
        this.bumpScale = source.bumpScale;
        this.normalMap = source.normalMap;
        this.normalMapType = source.normalMapType;
        this.normalScale.copy(source.normalScale);
        this.displacementMap = source.displacementMap;
        this.displacementScale = source.displacementScale;
        this.displacementBias = source.displacementBias;
        this.alphaMap = source.alphaMap;
        this.flatShading = source.flatShading;
        this.fog = source.fog;
        return this;
      }
    };
    LineDashedMaterial = class extends LineBasicMaterial {
      constructor(parameters) {
        super();
        this.isLineDashedMaterial = true;
        this.type = "LineDashedMaterial";
        this.scale = 1;
        this.dashSize = 3;
        this.gapSize = 1;
        this.setValues(parameters);
      }
      copy(source) {
        super.copy(source);
        this.scale = source.scale;
        this.dashSize = source.dashSize;
        this.gapSize = source.gapSize;
        return this;
      }
    };
    AnimationUtils = {
      convertArray,
      isTypedArray,
      getKeyframeOrder,
      sortedArray,
      flattenJSON,
      subclip,
      makeClipAdditive
    };
    Interpolant = class {
      constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
        this.parameterPositions = parameterPositions;
        this._cachedIndex = 0;
        this.resultBuffer = resultBuffer !== void 0 ? resultBuffer : new sampleValues.constructor(sampleSize);
        this.sampleValues = sampleValues;
        this.valueSize = sampleSize;
        this.settings = null;
        this.DefaultSettings_ = {};
      }
      evaluate(t2) {
        const pp = this.parameterPositions;
        let i1 = this._cachedIndex, t1 = pp[i1], t0 = pp[i1 - 1];
        validate_interval: {
          seek: {
            let right;
            linear_scan: {
              forward_scan: if (!(t2 < t1)) {
                for (let giveUpAt = i1 + 2; ; ) {
                  if (t1 === void 0) {
                    if (t2 < t0) break forward_scan;
                    i1 = pp.length;
                    this._cachedIndex = i1;
                    return this.copySampleValue_(i1 - 1);
                  }
                  if (i1 === giveUpAt) break;
                  t0 = t1;
                  t1 = pp[++i1];
                  if (t2 < t1) {
                    break seek;
                  }
                }
                right = pp.length;
                break linear_scan;
              }
              if (!(t2 >= t0)) {
                const t1global = pp[1];
                if (t2 < t1global) {
                  i1 = 2;
                  t0 = t1global;
                }
                for (let giveUpAt = i1 - 2; ; ) {
                  if (t0 === void 0) {
                    this._cachedIndex = 0;
                    return this.copySampleValue_(0);
                  }
                  if (i1 === giveUpAt) break;
                  t1 = t0;
                  t0 = pp[--i1 - 1];
                  if (t2 >= t0) {
                    break seek;
                  }
                }
                right = i1;
                i1 = 0;
                break linear_scan;
              }
              break validate_interval;
            }
            while (i1 < right) {
              const mid = i1 + right >>> 1;
              if (t2 < pp[mid]) {
                right = mid;
              } else {
                i1 = mid + 1;
              }
            }
            t1 = pp[i1];
            t0 = pp[i1 - 1];
            if (t0 === void 0) {
              this._cachedIndex = 0;
              return this.copySampleValue_(0);
            }
            if (t1 === void 0) {
              i1 = pp.length;
              this._cachedIndex = i1;
              return this.copySampleValue_(i1 - 1);
            }
          }
          this._cachedIndex = i1;
          this.intervalChanged_(i1, t0, t1);
        }
        return this.interpolate_(i1, t0, t2, t1);
      }
      getSettings_() {
        return this.settings || this.DefaultSettings_;
      }
      copySampleValue_(index) {
        const result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, offset = index * stride;
        for (let i2 = 0; i2 !== stride; ++i2) {
          result[i2] = values[offset + i2];
        }
        return result;
      }
      // Template methods for derived classes:
      interpolate_() {
        throw new Error("call to abstract method");
      }
      intervalChanged_() {
      }
    };
    CubicInterpolant = class extends Interpolant {
      constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
        super(parameterPositions, sampleValues, sampleSize, resultBuffer);
        this._weightPrev = -0;
        this._offsetPrev = -0;
        this._weightNext = -0;
        this._offsetNext = -0;
        this.DefaultSettings_ = {
          endingStart: ZeroCurvatureEnding,
          endingEnd: ZeroCurvatureEnding
        };
      }
      intervalChanged_(i1, t0, t1) {
        const pp = this.parameterPositions;
        let iPrev = i1 - 2, iNext = i1 + 1, tPrev = pp[iPrev], tNext = pp[iNext];
        if (tPrev === void 0) {
          switch (this.getSettings_().endingStart) {
            case ZeroSlopeEnding:
              iPrev = i1;
              tPrev = 2 * t0 - t1;
              break;
            case WrapAroundEnding:
              iPrev = pp.length - 2;
              tPrev = t0 + pp[iPrev] - pp[iPrev + 1];
              break;
            default:
              iPrev = i1;
              tPrev = t1;
          }
        }
        if (tNext === void 0) {
          switch (this.getSettings_().endingEnd) {
            case ZeroSlopeEnding:
              iNext = i1;
              tNext = 2 * t1 - t0;
              break;
            case WrapAroundEnding:
              iNext = 1;
              tNext = t1 + pp[1] - pp[0];
              break;
            default:
              iNext = i1 - 1;
              tNext = t0;
          }
        }
        const halfDt = (t1 - t0) * 0.5, stride = this.valueSize;
        this._weightPrev = halfDt / (t0 - tPrev);
        this._weightNext = halfDt / (tNext - t1);
        this._offsetPrev = iPrev * stride;
        this._offsetNext = iNext * stride;
      }
      interpolate_(i1, t0, t2, t1) {
        const result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, o1 = i1 * stride, o0 = o1 - stride, oP = this._offsetPrev, oN = this._offsetNext, wP = this._weightPrev, wN = this._weightNext, p3 = (t2 - t0) / (t1 - t0), pp = p3 * p3, ppp = pp * p3;
        const sP = -wP * ppp + 2 * wP * pp - wP * p3;
        const s0 = (1 + wP) * ppp + (-1.5 - 2 * wP) * pp + (-0.5 + wP) * p3 + 1;
        const s1 = (-1 - wN) * ppp + (1.5 + wN) * pp + 0.5 * p3;
        const sN = wN * ppp - wN * pp;
        for (let i2 = 0; i2 !== stride; ++i2) {
          result[i2] = sP * values[oP + i2] + s0 * values[o0 + i2] + s1 * values[o1 + i2] + sN * values[oN + i2];
        }
        return result;
      }
    };
    LinearInterpolant = class extends Interpolant {
      constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
        super(parameterPositions, sampleValues, sampleSize, resultBuffer);
      }
      interpolate_(i1, t0, t2, t1) {
        const result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, offset1 = i1 * stride, offset0 = offset1 - stride, weight1 = (t2 - t0) / (t1 - t0), weight0 = 1 - weight1;
        for (let i2 = 0; i2 !== stride; ++i2) {
          result[i2] = values[offset0 + i2] * weight0 + values[offset1 + i2] * weight1;
        }
        return result;
      }
    };
    DiscreteInterpolant = class extends Interpolant {
      constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
        super(parameterPositions, sampleValues, sampleSize, resultBuffer);
      }
      interpolate_(i1) {
        return this.copySampleValue_(i1 - 1);
      }
    };
    KeyframeTrack = class {
      constructor(name, times, values, interpolation) {
        if (name === void 0) throw new Error("THREE.KeyframeTrack: track name is undefined");
        if (times === void 0 || times.length === 0) throw new Error("THREE.KeyframeTrack: no keyframes in track named " + name);
        this.name = name;
        this.times = convertArray(times, this.TimeBufferType);
        this.values = convertArray(values, this.ValueBufferType);
        this.setInterpolation(interpolation || this.DefaultInterpolation);
      }
      // Serialization (in static context, because of constructor invocation
      // and automatic invocation of .toJSON):
      static toJSON(track) {
        const trackType = track.constructor;
        let json;
        if (trackType.toJSON !== this.toJSON) {
          json = trackType.toJSON(track);
        } else {
          json = {
            "name": track.name,
            "times": convertArray(track.times, Array),
            "values": convertArray(track.values, Array)
          };
          const interpolation = track.getInterpolation();
          if (interpolation !== track.DefaultInterpolation) {
            json.interpolation = interpolation;
          }
        }
        json.type = track.ValueTypeName;
        return json;
      }
      InterpolantFactoryMethodDiscrete(result) {
        return new DiscreteInterpolant(this.times, this.values, this.getValueSize(), result);
      }
      InterpolantFactoryMethodLinear(result) {
        return new LinearInterpolant(this.times, this.values, this.getValueSize(), result);
      }
      InterpolantFactoryMethodSmooth(result) {
        return new CubicInterpolant(this.times, this.values, this.getValueSize(), result);
      }
      setInterpolation(interpolation) {
        let factoryMethod;
        switch (interpolation) {
          case InterpolateDiscrete:
            factoryMethod = this.InterpolantFactoryMethodDiscrete;
            break;
          case InterpolateLinear:
            factoryMethod = this.InterpolantFactoryMethodLinear;
            break;
          case InterpolateSmooth:
            factoryMethod = this.InterpolantFactoryMethodSmooth;
            break;
        }
        if (factoryMethod === void 0) {
          const message = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
          if (this.createInterpolant === void 0) {
            if (interpolation !== this.DefaultInterpolation) {
              this.setInterpolation(this.DefaultInterpolation);
            } else {
              throw new Error(message);
            }
          }
          console.warn("THREE.KeyframeTrack:", message);
          return this;
        }
        this.createInterpolant = factoryMethod;
        return this;
      }
      getInterpolation() {
        switch (this.createInterpolant) {
          case this.InterpolantFactoryMethodDiscrete:
            return InterpolateDiscrete;
          case this.InterpolantFactoryMethodLinear:
            return InterpolateLinear;
          case this.InterpolantFactoryMethodSmooth:
            return InterpolateSmooth;
        }
      }
      getValueSize() {
        return this.values.length / this.times.length;
      }
      // move all keyframes either forwards or backwards in time
      shift(timeOffset) {
        if (timeOffset !== 0) {
          const times = this.times;
          for (let i2 = 0, n = times.length; i2 !== n; ++i2) {
            times[i2] += timeOffset;
          }
        }
        return this;
      }
      // scale all keyframe times by a factor (useful for frame <-> seconds conversions)
      scale(timeScale) {
        if (timeScale !== 1) {
          const times = this.times;
          for (let i2 = 0, n = times.length; i2 !== n; ++i2) {
            times[i2] *= timeScale;
          }
        }
        return this;
      }
      // removes keyframes before and after animation without changing any values within the range [startTime, endTime].
      // IMPORTANT: We do not shift around keys to the start of the track time, because for interpolated keys this will change their values
      trim(startTime, endTime) {
        const times = this.times, nKeys = times.length;
        let from = 0, to = nKeys - 1;
        while (from !== nKeys && times[from] < startTime) {
          ++from;
        }
        while (to !== -1 && times[to] > endTime) {
          --to;
        }
        ++to;
        if (from !== 0 || to !== nKeys) {
          if (from >= to) {
            to = Math.max(to, 1);
            from = to - 1;
          }
          const stride = this.getValueSize();
          this.times = times.slice(from, to);
          this.values = this.values.slice(from * stride, to * stride);
        }
        return this;
      }
      // ensure we do not get a GarbageInGarbageOut situation, make sure tracks are at least minimally viable
      validate() {
        let valid = true;
        const valueSize = this.getValueSize();
        if (valueSize - Math.floor(valueSize) !== 0) {
          console.error("THREE.KeyframeTrack: Invalid value size in track.", this);
          valid = false;
        }
        const times = this.times, values = this.values, nKeys = times.length;
        if (nKeys === 0) {
          console.error("THREE.KeyframeTrack: Track is empty.", this);
          valid = false;
        }
        let prevTime = null;
        for (let i2 = 0; i2 !== nKeys; i2++) {
          const currTime = times[i2];
          if (typeof currTime === "number" && isNaN(currTime)) {
            console.error("THREE.KeyframeTrack: Time is not a valid number.", this, i2, currTime);
            valid = false;
            break;
          }
          if (prevTime !== null && prevTime > currTime) {
            console.error("THREE.KeyframeTrack: Out of order keys.", this, i2, currTime, prevTime);
            valid = false;
            break;
          }
          prevTime = currTime;
        }
        if (values !== void 0) {
          if (isTypedArray(values)) {
            for (let i2 = 0, n = values.length; i2 !== n; ++i2) {
              const value = values[i2];
              if (isNaN(value)) {
                console.error("THREE.KeyframeTrack: Value is not a valid number.", this, i2, value);
                valid = false;
                break;
              }
            }
          }
        }
        return valid;
      }
      // removes equivalent sequential keys as common in morph target sequences
      // (0,0,0,0,1,1,1,0,0,0,0,0,0,0) --> (0,0,1,1,0,0)
      optimize() {
        const times = this.times.slice(), values = this.values.slice(), stride = this.getValueSize(), smoothInterpolation = this.getInterpolation() === InterpolateSmooth, lastIndex = times.length - 1;
        let writeIndex = 1;
        for (let i2 = 1; i2 < lastIndex; ++i2) {
          let keep = false;
          const time = times[i2];
          const timeNext = times[i2 + 1];
          if (time !== timeNext && (i2 !== 1 || time !== times[0])) {
            if (!smoothInterpolation) {
              const offset = i2 * stride, offsetP = offset - stride, offsetN = offset + stride;
              for (let j2 = 0; j2 !== stride; ++j2) {
                const value = values[offset + j2];
                if (value !== values[offsetP + j2] || value !== values[offsetN + j2]) {
                  keep = true;
                  break;
                }
              }
            } else {
              keep = true;
            }
          }
          if (keep) {
            if (i2 !== writeIndex) {
              times[writeIndex] = times[i2];
              const readOffset = i2 * stride, writeOffset = writeIndex * stride;
              for (let j2 = 0; j2 !== stride; ++j2) {
                values[writeOffset + j2] = values[readOffset + j2];
              }
            }
            ++writeIndex;
          }
        }
        if (lastIndex > 0) {
          times[writeIndex] = times[lastIndex];
          for (let readOffset = lastIndex * stride, writeOffset = writeIndex * stride, j2 = 0; j2 !== stride; ++j2) {
            values[writeOffset + j2] = values[readOffset + j2];
          }
          ++writeIndex;
        }
        if (writeIndex !== times.length) {
          this.times = times.slice(0, writeIndex);
          this.values = values.slice(0, writeIndex * stride);
        } else {
          this.times = times;
          this.values = values;
        }
        return this;
      }
      clone() {
        const times = this.times.slice();
        const values = this.values.slice();
        const TypedKeyframeTrack = this.constructor;
        const track = new TypedKeyframeTrack(this.name, times, values);
        track.createInterpolant = this.createInterpolant;
        return track;
      }
    };
    KeyframeTrack.prototype.TimeBufferType = Float32Array;
    KeyframeTrack.prototype.ValueBufferType = Float32Array;
    KeyframeTrack.prototype.DefaultInterpolation = InterpolateLinear;
    BooleanKeyframeTrack = class extends KeyframeTrack {
      // No interpolation parameter because only InterpolateDiscrete is valid.
      constructor(name, times, values) {
        super(name, times, values);
      }
    };
    BooleanKeyframeTrack.prototype.ValueTypeName = "bool";
    BooleanKeyframeTrack.prototype.ValueBufferType = Array;
    BooleanKeyframeTrack.prototype.DefaultInterpolation = InterpolateDiscrete;
    BooleanKeyframeTrack.prototype.InterpolantFactoryMethodLinear = void 0;
    BooleanKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = void 0;
    ColorKeyframeTrack = class extends KeyframeTrack {
    };
    ColorKeyframeTrack.prototype.ValueTypeName = "color";
    NumberKeyframeTrack = class extends KeyframeTrack {
    };
    NumberKeyframeTrack.prototype.ValueTypeName = "number";
    QuaternionLinearInterpolant = class extends Interpolant {
      constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
        super(parameterPositions, sampleValues, sampleSize, resultBuffer);
      }
      interpolate_(i1, t0, t2, t1) {
        const result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, alpha = (t2 - t0) / (t1 - t0);
        let offset = i1 * stride;
        for (let end = offset + stride; offset !== end; offset += 4) {
          Quaternion.slerpFlat(result, 0, values, offset - stride, values, offset, alpha);
        }
        return result;
      }
    };
    QuaternionKeyframeTrack = class extends KeyframeTrack {
      InterpolantFactoryMethodLinear(result) {
        return new QuaternionLinearInterpolant(this.times, this.values, this.getValueSize(), result);
      }
    };
    QuaternionKeyframeTrack.prototype.ValueTypeName = "quaternion";
    QuaternionKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = void 0;
    StringKeyframeTrack = class extends KeyframeTrack {
      // No interpolation parameter because only InterpolateDiscrete is valid.
      constructor(name, times, values) {
        super(name, times, values);
      }
    };
    StringKeyframeTrack.prototype.ValueTypeName = "string";
    StringKeyframeTrack.prototype.ValueBufferType = Array;
    StringKeyframeTrack.prototype.DefaultInterpolation = InterpolateDiscrete;
    StringKeyframeTrack.prototype.InterpolantFactoryMethodLinear = void 0;
    StringKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = void 0;
    VectorKeyframeTrack = class extends KeyframeTrack {
    };
    VectorKeyframeTrack.prototype.ValueTypeName = "vector";
    AnimationClip = class {
      constructor(name = "", duration = -1, tracks = [], blendMode = NormalAnimationBlendMode) {
        this.name = name;
        this.tracks = tracks;
        this.duration = duration;
        this.blendMode = blendMode;
        this.uuid = generateUUID();
        if (this.duration < 0) {
          this.resetDuration();
        }
      }
      static parse(json) {
        const tracks = [], jsonTracks = json.tracks, frameTime = 1 / (json.fps || 1);
        for (let i2 = 0, n = jsonTracks.length; i2 !== n; ++i2) {
          tracks.push(parseKeyframeTrack(jsonTracks[i2]).scale(frameTime));
        }
        const clip = new this(json.name, json.duration, tracks, json.blendMode);
        clip.uuid = json.uuid;
        return clip;
      }
      static toJSON(clip) {
        const tracks = [], clipTracks = clip.tracks;
        const json = {
          "name": clip.name,
          "duration": clip.duration,
          "tracks": tracks,
          "uuid": clip.uuid,
          "blendMode": clip.blendMode
        };
        for (let i2 = 0, n = clipTracks.length; i2 !== n; ++i2) {
          tracks.push(KeyframeTrack.toJSON(clipTracks[i2]));
        }
        return json;
      }
      static CreateFromMorphTargetSequence(name, morphTargetSequence, fps, noLoop) {
        const numMorphTargets = morphTargetSequence.length;
        const tracks = [];
        for (let i2 = 0; i2 < numMorphTargets; i2++) {
          let times = [];
          let values = [];
          times.push(
            (i2 + numMorphTargets - 1) % numMorphTargets,
            i2,
            (i2 + 1) % numMorphTargets
          );
          values.push(0, 1, 0);
          const order = getKeyframeOrder(times);
          times = sortedArray(times, 1, order);
          values = sortedArray(values, 1, order);
          if (!noLoop && times[0] === 0) {
            times.push(numMorphTargets);
            values.push(values[0]);
          }
          tracks.push(
            new NumberKeyframeTrack(
              ".morphTargetInfluences[" + morphTargetSequence[i2].name + "]",
              times,
              values
            ).scale(1 / fps)
          );
        }
        return new this(name, -1, tracks);
      }
      static findByName(objectOrClipArray, name) {
        let clipArray = objectOrClipArray;
        if (!Array.isArray(objectOrClipArray)) {
          const o = objectOrClipArray;
          clipArray = o.geometry && o.geometry.animations || o.animations;
        }
        for (let i2 = 0; i2 < clipArray.length; i2++) {
          if (clipArray[i2].name === name) {
            return clipArray[i2];
          }
        }
        return null;
      }
      static CreateClipsFromMorphTargetSequences(morphTargets, fps, noLoop) {
        const animationToMorphTargets = {};
        const pattern = /^([\w-]*?)([\d]+)$/;
        for (let i2 = 0, il = morphTargets.length; i2 < il; i2++) {
          const morphTarget = morphTargets[i2];
          const parts = morphTarget.name.match(pattern);
          if (parts && parts.length > 1) {
            const name = parts[1];
            let animationMorphTargets = animationToMorphTargets[name];
            if (!animationMorphTargets) {
              animationToMorphTargets[name] = animationMorphTargets = [];
            }
            animationMorphTargets.push(morphTarget);
          }
        }
        const clips = [];
        for (const name in animationToMorphTargets) {
          clips.push(this.CreateFromMorphTargetSequence(name, animationToMorphTargets[name], fps, noLoop));
        }
        return clips;
      }
      // parse the animation.hierarchy format
      static parseAnimation(animation, bones) {
        if (!animation) {
          console.error("THREE.AnimationClip: No animation in JSONLoader data.");
          return null;
        }
        const addNonemptyTrack = function(trackType, trackName, animationKeys, propertyName, destTracks) {
          if (animationKeys.length !== 0) {
            const times = [];
            const values = [];
            flattenJSON(animationKeys, times, values, propertyName);
            if (times.length !== 0) {
              destTracks.push(new trackType(trackName, times, values));
            }
          }
        };
        const tracks = [];
        const clipName = animation.name || "default";
        const fps = animation.fps || 30;
        const blendMode = animation.blendMode;
        let duration = animation.length || -1;
        const hierarchyTracks = animation.hierarchy || [];
        for (let h2 = 0; h2 < hierarchyTracks.length; h2++) {
          const animationKeys = hierarchyTracks[h2].keys;
          if (!animationKeys || animationKeys.length === 0) continue;
          if (animationKeys[0].morphTargets) {
            const morphTargetNames = {};
            let k3;
            for (k3 = 0; k3 < animationKeys.length; k3++) {
              if (animationKeys[k3].morphTargets) {
                for (let m = 0; m < animationKeys[k3].morphTargets.length; m++) {
                  morphTargetNames[animationKeys[k3].morphTargets[m]] = -1;
                }
              }
            }
            for (const morphTargetName in morphTargetNames) {
              const times = [];
              const values = [];
              for (let m = 0; m !== animationKeys[k3].morphTargets.length; ++m) {
                const animationKey = animationKeys[k3];
                times.push(animationKey.time);
                values.push(animationKey.morphTarget === morphTargetName ? 1 : 0);
              }
              tracks.push(new NumberKeyframeTrack(".morphTargetInfluence[" + morphTargetName + "]", times, values));
            }
            duration = morphTargetNames.length * fps;
          } else {
            const boneName = ".bones[" + bones[h2].name + "]";
            addNonemptyTrack(
              VectorKeyframeTrack,
              boneName + ".position",
              animationKeys,
              "pos",
              tracks
            );
            addNonemptyTrack(
              QuaternionKeyframeTrack,
              boneName + ".quaternion",
              animationKeys,
              "rot",
              tracks
            );
            addNonemptyTrack(
              VectorKeyframeTrack,
              boneName + ".scale",
              animationKeys,
              "scl",
              tracks
            );
          }
        }
        if (tracks.length === 0) {
          return null;
        }
        const clip = new this(clipName, duration, tracks, blendMode);
        return clip;
      }
      resetDuration() {
        const tracks = this.tracks;
        let duration = 0;
        for (let i2 = 0, n = tracks.length; i2 !== n; ++i2) {
          const track = this.tracks[i2];
          duration = Math.max(duration, track.times[track.times.length - 1]);
        }
        this.duration = duration;
        return this;
      }
      trim() {
        for (let i2 = 0; i2 < this.tracks.length; i2++) {
          this.tracks[i2].trim(0, this.duration);
        }
        return this;
      }
      validate() {
        let valid = true;
        for (let i2 = 0; i2 < this.tracks.length; i2++) {
          valid = valid && this.tracks[i2].validate();
        }
        return valid;
      }
      optimize() {
        for (let i2 = 0; i2 < this.tracks.length; i2++) {
          this.tracks[i2].optimize();
        }
        return this;
      }
      clone() {
        const tracks = [];
        for (let i2 = 0; i2 < this.tracks.length; i2++) {
          tracks.push(this.tracks[i2].clone());
        }
        return new this.constructor(this.name, this.duration, tracks, this.blendMode);
      }
      toJSON() {
        return this.constructor.toJSON(this);
      }
    };
    Cache = {
      enabled: false,
      files: {},
      add: function(key, file) {
        if (this.enabled === false) return;
        this.files[key] = file;
      },
      get: function(key) {
        if (this.enabled === false) return;
        return this.files[key];
      },
      remove: function(key) {
        delete this.files[key];
      },
      clear: function() {
        this.files = {};
      }
    };
    LoadingManager = class {
      constructor(onLoad, onProgress, onError) {
        const scope = this;
        let isLoading = false;
        let itemsLoaded = 0;
        let itemsTotal = 0;
        let urlModifier = void 0;
        const handlers = [];
        this.onStart = void 0;
        this.onLoad = onLoad;
        this.onProgress = onProgress;
        this.onError = onError;
        this.itemStart = function(url) {
          itemsTotal++;
          if (isLoading === false) {
            if (scope.onStart !== void 0) {
              scope.onStart(url, itemsLoaded, itemsTotal);
            }
          }
          isLoading = true;
        };
        this.itemEnd = function(url) {
          itemsLoaded++;
          if (scope.onProgress !== void 0) {
            scope.onProgress(url, itemsLoaded, itemsTotal);
          }
          if (itemsLoaded === itemsTotal) {
            isLoading = false;
            if (scope.onLoad !== void 0) {
              scope.onLoad();
            }
          }
        };
        this.itemError = function(url) {
          if (scope.onError !== void 0) {
            scope.onError(url);
          }
        };
        this.resolveURL = function(url) {
          if (urlModifier) {
            return urlModifier(url);
          }
          return url;
        };
        this.setURLModifier = function(transform) {
          urlModifier = transform;
          return this;
        };
        this.addHandler = function(regex, loader) {
          handlers.push(regex, loader);
          return this;
        };
        this.removeHandler = function(regex) {
          const index = handlers.indexOf(regex);
          if (index !== -1) {
            handlers.splice(index, 2);
          }
          return this;
        };
        this.getHandler = function(file) {
          for (let i2 = 0, l2 = handlers.length; i2 < l2; i2 += 2) {
            const regex = handlers[i2];
            const loader = handlers[i2 + 1];
            if (regex.global) regex.lastIndex = 0;
            if (regex.test(file)) {
              return loader;
            }
          }
          return null;
        };
      }
    };
    DefaultLoadingManager = /* @__PURE__ */ new LoadingManager();
    Loader = class {
      constructor(manager) {
        this.manager = manager !== void 0 ? manager : DefaultLoadingManager;
        this.crossOrigin = "anonymous";
        this.withCredentials = false;
        this.path = "";
        this.resourcePath = "";
        this.requestHeader = {};
      }
      load() {
      }
      loadAsync(url, onProgress) {
        const scope = this;
        return new Promise(function(resolve2, reject) {
          scope.load(url, resolve2, onProgress, reject);
        });
      }
      parse() {
      }
      setCrossOrigin(crossOrigin) {
        this.crossOrigin = crossOrigin;
        return this;
      }
      setWithCredentials(value) {
        this.withCredentials = value;
        return this;
      }
      setPath(path) {
        this.path = path;
        return this;
      }
      setResourcePath(resourcePath) {
        this.resourcePath = resourcePath;
        return this;
      }
      setRequestHeader(requestHeader) {
        this.requestHeader = requestHeader;
        return this;
      }
    };
    Loader.DEFAULT_MATERIAL_NAME = "__DEFAULT";
    loading = {};
    HttpError = class extends Error {
      constructor(message, response) {
        super(message);
        this.response = response;
      }
    };
    FileLoader = class extends Loader {
      constructor(manager) {
        super(manager);
      }
      load(url, onLoad, onProgress, onError) {
        if (url === void 0) url = "";
        if (this.path !== void 0) url = this.path + url;
        url = this.manager.resolveURL(url);
        const cached = Cache.get(url);
        if (cached !== void 0) {
          this.manager.itemStart(url);
          setTimeout(() => {
            if (onLoad) onLoad(cached);
            this.manager.itemEnd(url);
          }, 0);
          return cached;
        }
        if (loading[url] !== void 0) {
          loading[url].push({
            onLoad,
            onProgress,
            onError
          });
          return;
        }
        loading[url] = [];
        loading[url].push({
          onLoad,
          onProgress,
          onError
        });
        const req = new Request(url, {
          headers: new Headers(this.requestHeader),
          credentials: this.withCredentials ? "include" : "same-origin"
          // An abort controller could be added within a future PR
        });
        const mimeType = this.mimeType;
        const responseType = this.responseType;
        fetch(req).then((response) => {
          if (response.status === 200 || response.status === 0) {
            if (response.status === 0) {
              console.warn("THREE.FileLoader: HTTP Status 0 received.");
            }
            if (typeof ReadableStream === "undefined" || response.body === void 0 || response.body.getReader === void 0) {
              return response;
            }
            const callbacks = loading[url];
            const reader = response.body.getReader();
            const contentLength = response.headers.get("X-File-Size") || response.headers.get("Content-Length");
            const total = contentLength ? parseInt(contentLength) : 0;
            const lengthComputable = total !== 0;
            let loaded = 0;
            const stream = new ReadableStream({
              start(controller) {
                readData();
                function readData() {
                  reader.read().then(({ done, value }) => {
                    if (done) {
                      controller.close();
                    } else {
                      loaded += value.byteLength;
                      const event = new ProgressEvent("progress", { lengthComputable, loaded, total });
                      for (let i2 = 0, il = callbacks.length; i2 < il; i2++) {
                        const callback = callbacks[i2];
                        if (callback.onProgress) callback.onProgress(event);
                      }
                      controller.enqueue(value);
                      readData();
                    }
                  }, (e) => {
                    controller.error(e);
                  });
                }
              }
            });
            return new Response(stream);
          } else {
            throw new HttpError(`fetch for "${response.url}" responded with ${response.status}: ${response.statusText}`, response);
          }
        }).then((response) => {
          switch (responseType) {
            case "arraybuffer":
              return response.arrayBuffer();
            case "blob":
              return response.blob();
            case "document":
              return response.text().then((text) => {
                const parser = new DOMParser();
                return parser.parseFromString(text, mimeType);
              });
            case "json":
              return response.json();
            default:
              if (mimeType === void 0) {
                return response.text();
              } else {
                const re = /charset="?([^;"\s]*)"?/i;
                const exec = re.exec(mimeType);
                const label = exec && exec[1] ? exec[1].toLowerCase() : void 0;
                const decoder = new TextDecoder(label);
                return response.arrayBuffer().then((ab) => decoder.decode(ab));
              }
          }
        }).then((data) => {
          Cache.add(url, data);
          const callbacks = loading[url];
          delete loading[url];
          for (let i2 = 0, il = callbacks.length; i2 < il; i2++) {
            const callback = callbacks[i2];
            if (callback.onLoad) callback.onLoad(data);
          }
        }).catch((err) => {
          const callbacks = loading[url];
          if (callbacks === void 0) {
            this.manager.itemError(url);
            throw err;
          }
          delete loading[url];
          for (let i2 = 0, il = callbacks.length; i2 < il; i2++) {
            const callback = callbacks[i2];
            if (callback.onError) callback.onError(err);
          }
          this.manager.itemError(url);
        }).finally(() => {
          this.manager.itemEnd(url);
        });
        this.manager.itemStart(url);
      }
      setResponseType(value) {
        this.responseType = value;
        return this;
      }
      setMimeType(value) {
        this.mimeType = value;
        return this;
      }
    };
    AnimationLoader = class extends Loader {
      constructor(manager) {
        super(manager);
      }
      load(url, onLoad, onProgress, onError) {
        const scope = this;
        const loader = new FileLoader(this.manager);
        loader.setPath(this.path);
        loader.setRequestHeader(this.requestHeader);
        loader.setWithCredentials(this.withCredentials);
        loader.load(url, function(text) {
          try {
            onLoad(scope.parse(JSON.parse(text)));
          } catch (e) {
            if (onError) {
              onError(e);
            } else {
              console.error(e);
            }
            scope.manager.itemError(url);
          }
        }, onProgress, onError);
      }
      parse(json) {
        const animations = [];
        for (let i2 = 0; i2 < json.length; i2++) {
          const clip = AnimationClip.parse(json[i2]);
          animations.push(clip);
        }
        return animations;
      }
    };
    CompressedTextureLoader = class extends Loader {
      constructor(manager) {
        super(manager);
      }
      load(url, onLoad, onProgress, onError) {
        const scope = this;
        const images = [];
        const texture = new CompressedTexture();
        const loader = new FileLoader(this.manager);
        loader.setPath(this.path);
        loader.setResponseType("arraybuffer");
        loader.setRequestHeader(this.requestHeader);
        loader.setWithCredentials(scope.withCredentials);
        let loaded = 0;
        function loadTexture(i2) {
          loader.load(url[i2], function(buffer) {
            const texDatas = scope.parse(buffer, true);
            images[i2] = {
              width: texDatas.width,
              height: texDatas.height,
              format: texDatas.format,
              mipmaps: texDatas.mipmaps
            };
            loaded += 1;
            if (loaded === 6) {
              if (texDatas.mipmapCount === 1) texture.minFilter = LinearFilter;
              texture.image = images;
              texture.format = texDatas.format;
              texture.needsUpdate = true;
              if (onLoad) onLoad(texture);
            }
          }, onProgress, onError);
        }
        if (Array.isArray(url)) {
          for (let i2 = 0, il = url.length; i2 < il; ++i2) {
            loadTexture(i2);
          }
        } else {
          loader.load(url, function(buffer) {
            const texDatas = scope.parse(buffer, true);
            if (texDatas.isCubemap) {
              const faces = texDatas.mipmaps.length / texDatas.mipmapCount;
              for (let f2 = 0; f2 < faces; f2++) {
                images[f2] = { mipmaps: [] };
                for (let i2 = 0; i2 < texDatas.mipmapCount; i2++) {
                  images[f2].mipmaps.push(texDatas.mipmaps[f2 * texDatas.mipmapCount + i2]);
                  images[f2].format = texDatas.format;
                  images[f2].width = texDatas.width;
                  images[f2].height = texDatas.height;
                }
              }
              texture.image = images;
            } else {
              texture.image.width = texDatas.width;
              texture.image.height = texDatas.height;
              texture.mipmaps = texDatas.mipmaps;
            }
            if (texDatas.mipmapCount === 1) {
              texture.minFilter = LinearFilter;
            }
            texture.format = texDatas.format;
            texture.needsUpdate = true;
            if (onLoad) onLoad(texture);
          }, onProgress, onError);
        }
        return texture;
      }
    };
    ImageLoader = class extends Loader {
      constructor(manager) {
        super(manager);
      }
      load(url, onLoad, onProgress, onError) {
        if (this.path !== void 0) url = this.path + url;
        url = this.manager.resolveURL(url);
        const scope = this;
        const cached = Cache.get(url);
        if (cached !== void 0) {
          scope.manager.itemStart(url);
          setTimeout(function() {
            if (onLoad) onLoad(cached);
            scope.manager.itemEnd(url);
          }, 0);
          return cached;
        }
        const image = createElementNS("img");
        function onImageLoad() {
          removeEventListeners();
          Cache.add(url, this);
          if (onLoad) onLoad(this);
          scope.manager.itemEnd(url);
        }
        function onImageError(event) {
          removeEventListeners();
          if (onError) onError(event);
          scope.manager.itemError(url);
          scope.manager.itemEnd(url);
        }
        function removeEventListeners() {
          image.removeEventListener("load", onImageLoad, false);
          image.removeEventListener("error", onImageError, false);
        }
        image.addEventListener("load", onImageLoad, false);
        image.addEventListener("error", onImageError, false);
        if (url.slice(0, 5) !== "data:") {
          if (this.crossOrigin !== void 0) image.crossOrigin = this.crossOrigin;
        }
        scope.manager.itemStart(url);
        image.src = url;
        return image;
      }
    };
    CubeTextureLoader = class extends Loader {
      constructor(manager) {
        super(manager);
      }
      load(urls, onLoad, onProgress, onError) {
        const texture = new CubeTexture();
        texture.colorSpace = SRGBColorSpace;
        const loader = new ImageLoader(this.manager);
        loader.setCrossOrigin(this.crossOrigin);
        loader.setPath(this.path);
        let loaded = 0;
        function loadTexture(i2) {
          loader.load(urls[i2], function(image) {
            texture.images[i2] = image;
            loaded++;
            if (loaded === 6) {
              texture.needsUpdate = true;
              if (onLoad) onLoad(texture);
            }
          }, void 0, onError);
        }
        for (let i2 = 0; i2 < urls.length; ++i2) {
          loadTexture(i2);
        }
        return texture;
      }
    };
    DataTextureLoader = class extends Loader {
      constructor(manager) {
        super(manager);
      }
      load(url, onLoad, onProgress, onError) {
        const scope = this;
        const texture = new DataTexture();
        const loader = new FileLoader(this.manager);
        loader.setResponseType("arraybuffer");
        loader.setRequestHeader(this.requestHeader);
        loader.setPath(this.path);
        loader.setWithCredentials(scope.withCredentials);
        loader.load(url, function(buffer) {
          let texData;
          try {
            texData = scope.parse(buffer);
          } catch (error2) {
            if (onError !== void 0) {
              onError(error2);
            } else {
              console.error(error2);
              return;
            }
          }
          if (texData.image !== void 0) {
            texture.image = texData.image;
          } else if (texData.data !== void 0) {
            texture.image.width = texData.width;
            texture.image.height = texData.height;
            texture.image.data = texData.data;
          }
          texture.wrapS = texData.wrapS !== void 0 ? texData.wrapS : ClampToEdgeWrapping;
          texture.wrapT = texData.wrapT !== void 0 ? texData.wrapT : ClampToEdgeWrapping;
          texture.magFilter = texData.magFilter !== void 0 ? texData.magFilter : LinearFilter;
          texture.minFilter = texData.minFilter !== void 0 ? texData.minFilter : LinearFilter;
          texture.anisotropy = texData.anisotropy !== void 0 ? texData.anisotropy : 1;
          if (texData.colorSpace !== void 0) {
            texture.colorSpace = texData.colorSpace;
          }
          if (texData.flipY !== void 0) {
            texture.flipY = texData.flipY;
          }
          if (texData.format !== void 0) {
            texture.format = texData.format;
          }
          if (texData.type !== void 0) {
            texture.type = texData.type;
          }
          if (texData.mipmaps !== void 0) {
            texture.mipmaps = texData.mipmaps;
            texture.minFilter = LinearMipmapLinearFilter;
          }
          if (texData.mipmapCount === 1) {
            texture.minFilter = LinearFilter;
          }
          if (texData.generateMipmaps !== void 0) {
            texture.generateMipmaps = texData.generateMipmaps;
          }
          texture.needsUpdate = true;
          if (onLoad) onLoad(texture, texData);
        }, onProgress, onError);
        return texture;
      }
    };
    TextureLoader = class extends Loader {
      constructor(manager) {
        super(manager);
      }
      load(url, onLoad, onProgress, onError) {
        const texture = new Texture();
        const loader = new ImageLoader(this.manager);
        loader.setCrossOrigin(this.crossOrigin);
        loader.setPath(this.path);
        loader.load(url, function(image) {
          texture.image = image;
          texture.needsUpdate = true;
          if (onLoad !== void 0) {
            onLoad(texture);
          }
        }, onProgress, onError);
        return texture;
      }
    };
    Light = class extends Object3D {
      constructor(color, intensity = 1) {
        super();
        this.isLight = true;
        this.type = "Light";
        this.color = new Color(color);
        this.intensity = intensity;
      }
      dispose() {
      }
      copy(source, recursive) {
        super.copy(source, recursive);
        this.color.copy(source.color);
        this.intensity = source.intensity;
        return this;
      }
      toJSON(meta) {
        const data = super.toJSON(meta);
        data.object.color = this.color.getHex();
        data.object.intensity = this.intensity;
        if (this.groundColor !== void 0) data.object.groundColor = this.groundColor.getHex();
        if (this.distance !== void 0) data.object.distance = this.distance;
        if (this.angle !== void 0) data.object.angle = this.angle;
        if (this.decay !== void 0) data.object.decay = this.decay;
        if (this.penumbra !== void 0) data.object.penumbra = this.penumbra;
        if (this.shadow !== void 0) data.object.shadow = this.shadow.toJSON();
        if (this.target !== void 0) data.object.target = this.target.uuid;
        return data;
      }
    };
    HemisphereLight = class extends Light {
      constructor(skyColor, groundColor, intensity) {
        super(skyColor, intensity);
        this.isHemisphereLight = true;
        this.type = "HemisphereLight";
        this.position.copy(Object3D.DEFAULT_UP);
        this.updateMatrix();
        this.groundColor = new Color(groundColor);
      }
      copy(source, recursive) {
        super.copy(source, recursive);
        this.groundColor.copy(source.groundColor);
        return this;
      }
    };
    _projScreenMatrix$1 = /* @__PURE__ */ new Matrix4();
    _lightPositionWorld$1 = /* @__PURE__ */ new Vector3();
    _lookTarget$1 = /* @__PURE__ */ new Vector3();
    LightShadow = class {
      constructor(camera) {
        this.camera = camera;
        this.intensity = 1;
        this.bias = 0;
        this.normalBias = 0;
        this.radius = 1;
        this.blurSamples = 8;
        this.mapSize = new Vector2(512, 512);
        this.map = null;
        this.mapPass = null;
        this.matrix = new Matrix4();
        this.autoUpdate = true;
        this.needsUpdate = false;
        this._frustum = new Frustum();
        this._frameExtents = new Vector2(1, 1);
        this._viewportCount = 1;
        this._viewports = [
          new Vector4(0, 0, 1, 1)
        ];
      }
      getViewportCount() {
        return this._viewportCount;
      }
      getFrustum() {
        return this._frustum;
      }
      updateMatrices(light) {
        const shadowCamera = this.camera;
        const shadowMatrix = this.matrix;
        _lightPositionWorld$1.setFromMatrixPosition(light.matrixWorld);
        shadowCamera.position.copy(_lightPositionWorld$1);
        _lookTarget$1.setFromMatrixPosition(light.target.matrixWorld);
        shadowCamera.lookAt(_lookTarget$1);
        shadowCamera.updateMatrixWorld();
        _projScreenMatrix$1.multiplyMatrices(shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse);
        this._frustum.setFromProjectionMatrix(_projScreenMatrix$1);
        shadowMatrix.set(
          0.5,
          0,
          0,
          0.5,
          0,
          0.5,
          0,
          0.5,
          0,
          0,
          0.5,
          0.5,
          0,
          0,
          0,
          1
        );
        shadowMatrix.multiply(_projScreenMatrix$1);
      }
      getViewport(viewportIndex) {
        return this._viewports[viewportIndex];
      }
      getFrameExtents() {
        return this._frameExtents;
      }
      dispose() {
        if (this.map) {
          this.map.dispose();
        }
        if (this.mapPass) {
          this.mapPass.dispose();
        }
      }
      copy(source) {
        this.camera = source.camera.clone();
        this.intensity = source.intensity;
        this.bias = source.bias;
        this.radius = source.radius;
        this.mapSize.copy(source.mapSize);
        return this;
      }
      clone() {
        return new this.constructor().copy(this);
      }
      toJSON() {
        const object = {};
        if (this.intensity !== 1) object.intensity = this.intensity;
        if (this.bias !== 0) object.bias = this.bias;
        if (this.normalBias !== 0) object.normalBias = this.normalBias;
        if (this.radius !== 1) object.radius = this.radius;
        if (this.mapSize.x !== 512 || this.mapSize.y !== 512) object.mapSize = this.mapSize.toArray();
        object.camera = this.camera.toJSON(false).object;
        delete object.camera.matrix;
        return object;
      }
    };
    SpotLightShadow = class extends LightShadow {
      constructor() {
        super(new PerspectiveCamera(50, 1, 0.5, 500));
        this.isSpotLightShadow = true;
        this.focus = 1;
      }
      updateMatrices(light) {
        const camera = this.camera;
        const fov2 = RAD2DEG * 2 * light.angle * this.focus;
        const aspect2 = this.mapSize.width / this.mapSize.height;
        const far = light.distance || camera.far;
        if (fov2 !== camera.fov || aspect2 !== camera.aspect || far !== camera.far) {
          camera.fov = fov2;
          camera.aspect = aspect2;
          camera.far = far;
          camera.updateProjectionMatrix();
        }
        super.updateMatrices(light);
      }
      copy(source) {
        super.copy(source);
        this.focus = source.focus;
        return this;
      }
    };
    SpotLight = class extends Light {
      constructor(color, intensity, distance = 0, angle = Math.PI / 3, penumbra = 0, decay = 2) {
        super(color, intensity);
        this.isSpotLight = true;
        this.type = "SpotLight";
        this.position.copy(Object3D.DEFAULT_UP);
        this.updateMatrix();
        this.target = new Object3D();
        this.distance = distance;
        this.angle = angle;
        this.penumbra = penumbra;
        this.decay = decay;
        this.map = null;
        this.shadow = new SpotLightShadow();
      }
      get power() {
        return this.intensity * Math.PI;
      }
      set power(power) {
        this.intensity = power / Math.PI;
      }
      dispose() {
        this.shadow.dispose();
      }
      copy(source, recursive) {
        super.copy(source, recursive);
        this.distance = source.distance;
        this.angle = source.angle;
        this.penumbra = source.penumbra;
        this.decay = source.decay;
        this.target = source.target.clone();
        this.shadow = source.shadow.clone();
        return this;
      }
    };
    _projScreenMatrix = /* @__PURE__ */ new Matrix4();
    _lightPositionWorld = /* @__PURE__ */ new Vector3();
    _lookTarget = /* @__PURE__ */ new Vector3();
    PointLightShadow = class extends LightShadow {
      constructor() {
        super(new PerspectiveCamera(90, 1, 0.5, 500));
        this.isPointLightShadow = true;
        this._frameExtents = new Vector2(4, 2);
        this._viewportCount = 6;
        this._viewports = [
          // These viewports map a cube-map onto a 2D texture with the
          // following orientation:
          //
          //  xzXZ
          //   y Y
          //
          // X - Positive x direction
          // x - Negative x direction
          // Y - Positive y direction
          // y - Negative y direction
          // Z - Positive z direction
          // z - Negative z direction
          // positive X
          new Vector4(2, 1, 1, 1),
          // negative X
          new Vector4(0, 1, 1, 1),
          // positive Z
          new Vector4(3, 1, 1, 1),
          // negative Z
          new Vector4(1, 1, 1, 1),
          // positive Y
          new Vector4(3, 0, 1, 1),
          // negative Y
          new Vector4(1, 0, 1, 1)
        ];
        this._cubeDirections = [
          new Vector3(1, 0, 0),
          new Vector3(-1, 0, 0),
          new Vector3(0, 0, 1),
          new Vector3(0, 0, -1),
          new Vector3(0, 1, 0),
          new Vector3(0, -1, 0)
        ];
        this._cubeUps = [
          new Vector3(0, 1, 0),
          new Vector3(0, 1, 0),
          new Vector3(0, 1, 0),
          new Vector3(0, 1, 0),
          new Vector3(0, 0, 1),
          new Vector3(0, 0, -1)
        ];
      }
      updateMatrices(light, viewportIndex = 0) {
        const camera = this.camera;
        const shadowMatrix = this.matrix;
        const far = light.distance || camera.far;
        if (far !== camera.far) {
          camera.far = far;
          camera.updateProjectionMatrix();
        }
        _lightPositionWorld.setFromMatrixPosition(light.matrixWorld);
        camera.position.copy(_lightPositionWorld);
        _lookTarget.copy(camera.position);
        _lookTarget.add(this._cubeDirections[viewportIndex]);
        camera.up.copy(this._cubeUps[viewportIndex]);
        camera.lookAt(_lookTarget);
        camera.updateMatrixWorld();
        shadowMatrix.makeTranslation(-_lightPositionWorld.x, -_lightPositionWorld.y, -_lightPositionWorld.z);
        _projScreenMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);
        this._frustum.setFromProjectionMatrix(_projScreenMatrix);
      }
    };
    PointLight = class extends Light {
      constructor(color, intensity, distance = 0, decay = 2) {
        super(color, intensity);
        this.isPointLight = true;
        this.type = "PointLight";
        this.distance = distance;
        this.decay = decay;
        this.shadow = new PointLightShadow();
      }
      get power() {
        return this.intensity * 4 * Math.PI;
      }
      set power(power) {
        this.intensity = power / (4 * Math.PI);
      }
      dispose() {
        this.shadow.dispose();
      }
      copy(source, recursive) {
        super.copy(source, recursive);
        this.distance = source.distance;
        this.decay = source.decay;
        this.shadow = source.shadow.clone();
        return this;
      }
    };
    DirectionalLightShadow = class extends LightShadow {
      constructor() {
        super(new OrthographicCamera(-5, 5, 5, -5, 0.5, 500));
        this.isDirectionalLightShadow = true;
      }
    };
    DirectionalLight = class extends Light {
      constructor(color, intensity) {
        super(color, intensity);
        this.isDirectionalLight = true;
        this.type = "DirectionalLight";
        this.position.copy(Object3D.DEFAULT_UP);
        this.updateMatrix();
        this.target = new Object3D();
        this.shadow = new DirectionalLightShadow();
      }
      dispose() {
        this.shadow.dispose();
      }
      copy(source) {
        super.copy(source);
        this.target = source.target.clone();
        this.shadow = source.shadow.clone();
        return this;
      }
    };
    AmbientLight = class extends Light {
      constructor(color, intensity) {
        super(color, intensity);
        this.isAmbientLight = true;
        this.type = "AmbientLight";
      }
    };
    RectAreaLight = class extends Light {
      constructor(color, intensity, width = 10, height = 10) {
        super(color, intensity);
        this.isRectAreaLight = true;
        this.type = "RectAreaLight";
        this.width = width;
        this.height = height;
      }
      get power() {
        return this.intensity * this.width * this.height * Math.PI;
      }
      set power(power) {
        this.intensity = power / (this.width * this.height * Math.PI);
      }
      copy(source) {
        super.copy(source);
        this.width = source.width;
        this.height = source.height;
        return this;
      }
      toJSON(meta) {
        const data = super.toJSON(meta);
        data.object.width = this.width;
        data.object.height = this.height;
        return data;
      }
    };
    SphericalHarmonics3 = class {
      constructor() {
        this.isSphericalHarmonics3 = true;
        this.coefficients = [];
        for (let i2 = 0; i2 < 9; i2++) {
          this.coefficients.push(new Vector3());
        }
      }
      set(coefficients) {
        for (let i2 = 0; i2 < 9; i2++) {
          this.coefficients[i2].copy(coefficients[i2]);
        }
        return this;
      }
      zero() {
        for (let i2 = 0; i2 < 9; i2++) {
          this.coefficients[i2].set(0, 0, 0);
        }
        return this;
      }
      // get the radiance in the direction of the normal
      // target is a Vector3
      getAt(normal, target2) {
        const x = normal.x, y2 = normal.y, z2 = normal.z;
        const coeff = this.coefficients;
        target2.copy(coeff[0]).multiplyScalar(0.282095);
        target2.addScaledVector(coeff[1], 0.488603 * y2);
        target2.addScaledVector(coeff[2], 0.488603 * z2);
        target2.addScaledVector(coeff[3], 0.488603 * x);
        target2.addScaledVector(coeff[4], 1.092548 * (x * y2));
        target2.addScaledVector(coeff[5], 1.092548 * (y2 * z2));
        target2.addScaledVector(coeff[6], 0.315392 * (3 * z2 * z2 - 1));
        target2.addScaledVector(coeff[7], 1.092548 * (x * z2));
        target2.addScaledVector(coeff[8], 0.546274 * (x * x - y2 * y2));
        return target2;
      }
      // get the irradiance (radiance convolved with cosine lobe) in the direction of the normal
      // target is a Vector3
      // https://graphics.stanford.edu/papers/envmap/envmap.pdf
      getIrradianceAt(normal, target2) {
        const x = normal.x, y2 = normal.y, z2 = normal.z;
        const coeff = this.coefficients;
        target2.copy(coeff[0]).multiplyScalar(0.886227);
        target2.addScaledVector(coeff[1], 2 * 0.511664 * y2);
        target2.addScaledVector(coeff[2], 2 * 0.511664 * z2);
        target2.addScaledVector(coeff[3], 2 * 0.511664 * x);
        target2.addScaledVector(coeff[4], 2 * 0.429043 * x * y2);
        target2.addScaledVector(coeff[5], 2 * 0.429043 * y2 * z2);
        target2.addScaledVector(coeff[6], 0.743125 * z2 * z2 - 0.247708);
        target2.addScaledVector(coeff[7], 2 * 0.429043 * x * z2);
        target2.addScaledVector(coeff[8], 0.429043 * (x * x - y2 * y2));
        return target2;
      }
      add(sh) {
        for (let i2 = 0; i2 < 9; i2++) {
          this.coefficients[i2].add(sh.coefficients[i2]);
        }
        return this;
      }
      addScaledSH(sh, s) {
        for (let i2 = 0; i2 < 9; i2++) {
          this.coefficients[i2].addScaledVector(sh.coefficients[i2], s);
        }
        return this;
      }
      scale(s) {
        for (let i2 = 0; i2 < 9; i2++) {
          this.coefficients[i2].multiplyScalar(s);
        }
        return this;
      }
      lerp(sh, alpha) {
        for (let i2 = 0; i2 < 9; i2++) {
          this.coefficients[i2].lerp(sh.coefficients[i2], alpha);
        }
        return this;
      }
      equals(sh) {
        for (let i2 = 0; i2 < 9; i2++) {
          if (!this.coefficients[i2].equals(sh.coefficients[i2])) {
            return false;
          }
        }
        return true;
      }
      copy(sh) {
        return this.set(sh.coefficients);
      }
      clone() {
        return new this.constructor().copy(this);
      }
      fromArray(array, offset = 0) {
        const coefficients = this.coefficients;
        for (let i2 = 0; i2 < 9; i2++) {
          coefficients[i2].fromArray(array, offset + i2 * 3);
        }
        return this;
      }
      toArray(array = [], offset = 0) {
        const coefficients = this.coefficients;
        for (let i2 = 0; i2 < 9; i2++) {
          coefficients[i2].toArray(array, offset + i2 * 3);
        }
        return array;
      }
      // evaluate the basis functions
      // shBasis is an Array[ 9 ]
      static getBasisAt(normal, shBasis) {
        const x = normal.x, y2 = normal.y, z2 = normal.z;
        shBasis[0] = 0.282095;
        shBasis[1] = 0.488603 * y2;
        shBasis[2] = 0.488603 * z2;
        shBasis[3] = 0.488603 * x;
        shBasis[4] = 1.092548 * x * y2;
        shBasis[5] = 1.092548 * y2 * z2;
        shBasis[6] = 0.315392 * (3 * z2 * z2 - 1);
        shBasis[7] = 1.092548 * x * z2;
        shBasis[8] = 0.546274 * (x * x - y2 * y2);
      }
    };
    LightProbe = class extends Light {
      constructor(sh = new SphericalHarmonics3(), intensity = 1) {
        super(void 0, intensity);
        this.isLightProbe = true;
        this.sh = sh;
      }
      copy(source) {
        super.copy(source);
        this.sh.copy(source.sh);
        return this;
      }
      fromJSON(json) {
        this.intensity = json.intensity;
        this.sh.fromArray(json.sh);
        return this;
      }
      toJSON(meta) {
        const data = super.toJSON(meta);
        data.object.sh = this.sh.toArray();
        return data;
      }
    };
    MaterialLoader = class _MaterialLoader extends Loader {
      constructor(manager) {
        super(manager);
        this.textures = {};
      }
      load(url, onLoad, onProgress, onError) {
        const scope = this;
        const loader = new FileLoader(scope.manager);
        loader.setPath(scope.path);
        loader.setRequestHeader(scope.requestHeader);
        loader.setWithCredentials(scope.withCredentials);
        loader.load(url, function(text) {
          try {
            onLoad(scope.parse(JSON.parse(text)));
          } catch (e) {
            if (onError) {
              onError(e);
            } else {
              console.error(e);
            }
            scope.manager.itemError(url);
          }
        }, onProgress, onError);
      }
      parse(json) {
        const textures = this.textures;
        function getTexture(name) {
          if (textures[name] === void 0) {
            console.warn("THREE.MaterialLoader: Undefined texture", name);
          }
          return textures[name];
        }
        const material = this.createMaterialFromType(json.type);
        if (json.uuid !== void 0) material.uuid = json.uuid;
        if (json.name !== void 0) material.name = json.name;
        if (json.color !== void 0 && material.color !== void 0) material.color.setHex(json.color);
        if (json.roughness !== void 0) material.roughness = json.roughness;
        if (json.metalness !== void 0) material.metalness = json.metalness;
        if (json.sheen !== void 0) material.sheen = json.sheen;
        if (json.sheenColor !== void 0) material.sheenColor = new Color().setHex(json.sheenColor);
        if (json.sheenRoughness !== void 0) material.sheenRoughness = json.sheenRoughness;
        if (json.emissive !== void 0 && material.emissive !== void 0) material.emissive.setHex(json.emissive);
        if (json.specular !== void 0 && material.specular !== void 0) material.specular.setHex(json.specular);
        if (json.specularIntensity !== void 0) material.specularIntensity = json.specularIntensity;
        if (json.specularColor !== void 0 && material.specularColor !== void 0) material.specularColor.setHex(json.specularColor);
        if (json.shininess !== void 0) material.shininess = json.shininess;
        if (json.clearcoat !== void 0) material.clearcoat = json.clearcoat;
        if (json.clearcoatRoughness !== void 0) material.clearcoatRoughness = json.clearcoatRoughness;
        if (json.dispersion !== void 0) material.dispersion = json.dispersion;
        if (json.iridescence !== void 0) material.iridescence = json.iridescence;
        if (json.iridescenceIOR !== void 0) material.iridescenceIOR = json.iridescenceIOR;
        if (json.iridescenceThicknessRange !== void 0) material.iridescenceThicknessRange = json.iridescenceThicknessRange;
        if (json.transmission !== void 0) material.transmission = json.transmission;
        if (json.thickness !== void 0) material.thickness = json.thickness;
        if (json.attenuationDistance !== void 0) material.attenuationDistance = json.attenuationDistance;
        if (json.attenuationColor !== void 0 && material.attenuationColor !== void 0) material.attenuationColor.setHex(json.attenuationColor);
        if (json.anisotropy !== void 0) material.anisotropy = json.anisotropy;
        if (json.anisotropyRotation !== void 0) material.anisotropyRotation = json.anisotropyRotation;
        if (json.fog !== void 0) material.fog = json.fog;
        if (json.flatShading !== void 0) material.flatShading = json.flatShading;
        if (json.blending !== void 0) material.blending = json.blending;
        if (json.combine !== void 0) material.combine = json.combine;
        if (json.side !== void 0) material.side = json.side;
        if (json.shadowSide !== void 0) material.shadowSide = json.shadowSide;
        if (json.opacity !== void 0) material.opacity = json.opacity;
        if (json.transparent !== void 0) material.transparent = json.transparent;
        if (json.alphaTest !== void 0) material.alphaTest = json.alphaTest;
        if (json.alphaHash !== void 0) material.alphaHash = json.alphaHash;
        if (json.depthFunc !== void 0) material.depthFunc = json.depthFunc;
        if (json.depthTest !== void 0) material.depthTest = json.depthTest;
        if (json.depthWrite !== void 0) material.depthWrite = json.depthWrite;
        if (json.colorWrite !== void 0) material.colorWrite = json.colorWrite;
        if (json.blendSrc !== void 0) material.blendSrc = json.blendSrc;
        if (json.blendDst !== void 0) material.blendDst = json.blendDst;
        if (json.blendEquation !== void 0) material.blendEquation = json.blendEquation;
        if (json.blendSrcAlpha !== void 0) material.blendSrcAlpha = json.blendSrcAlpha;
        if (json.blendDstAlpha !== void 0) material.blendDstAlpha = json.blendDstAlpha;
        if (json.blendEquationAlpha !== void 0) material.blendEquationAlpha = json.blendEquationAlpha;
        if (json.blendColor !== void 0 && material.blendColor !== void 0) material.blendColor.setHex(json.blendColor);
        if (json.blendAlpha !== void 0) material.blendAlpha = json.blendAlpha;
        if (json.stencilWriteMask !== void 0) material.stencilWriteMask = json.stencilWriteMask;
        if (json.stencilFunc !== void 0) material.stencilFunc = json.stencilFunc;
        if (json.stencilRef !== void 0) material.stencilRef = json.stencilRef;
        if (json.stencilFuncMask !== void 0) material.stencilFuncMask = json.stencilFuncMask;
        if (json.stencilFail !== void 0) material.stencilFail = json.stencilFail;
        if (json.stencilZFail !== void 0) material.stencilZFail = json.stencilZFail;
        if (json.stencilZPass !== void 0) material.stencilZPass = json.stencilZPass;
        if (json.stencilWrite !== void 0) material.stencilWrite = json.stencilWrite;
        if (json.wireframe !== void 0) material.wireframe = json.wireframe;
        if (json.wireframeLinewidth !== void 0) material.wireframeLinewidth = json.wireframeLinewidth;
        if (json.wireframeLinecap !== void 0) material.wireframeLinecap = json.wireframeLinecap;
        if (json.wireframeLinejoin !== void 0) material.wireframeLinejoin = json.wireframeLinejoin;
        if (json.rotation !== void 0) material.rotation = json.rotation;
        if (json.linewidth !== void 0) material.linewidth = json.linewidth;
        if (json.dashSize !== void 0) material.dashSize = json.dashSize;
        if (json.gapSize !== void 0) material.gapSize = json.gapSize;
        if (json.scale !== void 0) material.scale = json.scale;
        if (json.polygonOffset !== void 0) material.polygonOffset = json.polygonOffset;
        if (json.polygonOffsetFactor !== void 0) material.polygonOffsetFactor = json.polygonOffsetFactor;
        if (json.polygonOffsetUnits !== void 0) material.polygonOffsetUnits = json.polygonOffsetUnits;
        if (json.dithering !== void 0) material.dithering = json.dithering;
        if (json.alphaToCoverage !== void 0) material.alphaToCoverage = json.alphaToCoverage;
        if (json.premultipliedAlpha !== void 0) material.premultipliedAlpha = json.premultipliedAlpha;
        if (json.forceSinglePass !== void 0) material.forceSinglePass = json.forceSinglePass;
        if (json.visible !== void 0) material.visible = json.visible;
        if (json.toneMapped !== void 0) material.toneMapped = json.toneMapped;
        if (json.userData !== void 0) material.userData = json.userData;
        if (json.vertexColors !== void 0) {
          if (typeof json.vertexColors === "number") {
            material.vertexColors = json.vertexColors > 0 ? true : false;
          } else {
            material.vertexColors = json.vertexColors;
          }
        }
        if (json.uniforms !== void 0) {
          for (const name in json.uniforms) {
            const uniform = json.uniforms[name];
            material.uniforms[name] = {};
            switch (uniform.type) {
              case "t":
                material.uniforms[name].value = getTexture(uniform.value);
                break;
              case "c":
                material.uniforms[name].value = new Color().setHex(uniform.value);
                break;
              case "v2":
                material.uniforms[name].value = new Vector2().fromArray(uniform.value);
                break;
              case "v3":
                material.uniforms[name].value = new Vector3().fromArray(uniform.value);
                break;
              case "v4":
                material.uniforms[name].value = new Vector4().fromArray(uniform.value);
                break;
              case "m3":
                material.uniforms[name].value = new Matrix3().fromArray(uniform.value);
                break;
              case "m4":
                material.uniforms[name].value = new Matrix4().fromArray(uniform.value);
                break;
              default:
                material.uniforms[name].value = uniform.value;
            }
          }
        }
        if (json.defines !== void 0) material.defines = json.defines;
        if (json.vertexShader !== void 0) material.vertexShader = json.vertexShader;
        if (json.fragmentShader !== void 0) material.fragmentShader = json.fragmentShader;
        if (json.glslVersion !== void 0) material.glslVersion = json.glslVersion;
        if (json.extensions !== void 0) {
          for (const key in json.extensions) {
            material.extensions[key] = json.extensions[key];
          }
        }
        if (json.lights !== void 0) material.lights = json.lights;
        if (json.clipping !== void 0) material.clipping = json.clipping;
        if (json.size !== void 0) material.size = json.size;
        if (json.sizeAttenuation !== void 0) material.sizeAttenuation = json.sizeAttenuation;
        if (json.map !== void 0) material.map = getTexture(json.map);
        if (json.matcap !== void 0) material.matcap = getTexture(json.matcap);
        if (json.alphaMap !== void 0) material.alphaMap = getTexture(json.alphaMap);
        if (json.bumpMap !== void 0) material.bumpMap = getTexture(json.bumpMap);
        if (json.bumpScale !== void 0) material.bumpScale = json.bumpScale;
        if (json.normalMap !== void 0) material.normalMap = getTexture(json.normalMap);
        if (json.normalMapType !== void 0) material.normalMapType = json.normalMapType;
        if (json.normalScale !== void 0) {
          let normalScale = json.normalScale;
          if (Array.isArray(normalScale) === false) {
            normalScale = [normalScale, normalScale];
          }
          material.normalScale = new Vector2().fromArray(normalScale);
        }
        if (json.displacementMap !== void 0) material.displacementMap = getTexture(json.displacementMap);
        if (json.displacementScale !== void 0) material.displacementScale = json.displacementScale;
        if (json.displacementBias !== void 0) material.displacementBias = json.displacementBias;
        if (json.roughnessMap !== void 0) material.roughnessMap = getTexture(json.roughnessMap);
        if (json.metalnessMap !== void 0) material.metalnessMap = getTexture(json.metalnessMap);
        if (json.emissiveMap !== void 0) material.emissiveMap = getTexture(json.emissiveMap);
        if (json.emissiveIntensity !== void 0) material.emissiveIntensity = json.emissiveIntensity;
        if (json.specularMap !== void 0) material.specularMap = getTexture(json.specularMap);
        if (json.specularIntensityMap !== void 0) material.specularIntensityMap = getTexture(json.specularIntensityMap);
        if (json.specularColorMap !== void 0) material.specularColorMap = getTexture(json.specularColorMap);
        if (json.envMap !== void 0) material.envMap = getTexture(json.envMap);
        if (json.envMapRotation !== void 0) material.envMapRotation.fromArray(json.envMapRotation);
        if (json.envMapIntensity !== void 0) material.envMapIntensity = json.envMapIntensity;
        if (json.reflectivity !== void 0) material.reflectivity = json.reflectivity;
        if (json.refractionRatio !== void 0) material.refractionRatio = json.refractionRatio;
        if (json.lightMap !== void 0) material.lightMap = getTexture(json.lightMap);
        if (json.lightMapIntensity !== void 0) material.lightMapIntensity = json.lightMapIntensity;
        if (json.aoMap !== void 0) material.aoMap = getTexture(json.aoMap);
        if (json.aoMapIntensity !== void 0) material.aoMapIntensity = json.aoMapIntensity;
        if (json.gradientMap !== void 0) material.gradientMap = getTexture(json.gradientMap);
        if (json.clearcoatMap !== void 0) material.clearcoatMap = getTexture(json.clearcoatMap);
        if (json.clearcoatRoughnessMap !== void 0) material.clearcoatRoughnessMap = getTexture(json.clearcoatRoughnessMap);
        if (json.clearcoatNormalMap !== void 0) material.clearcoatNormalMap = getTexture(json.clearcoatNormalMap);
        if (json.clearcoatNormalScale !== void 0) material.clearcoatNormalScale = new Vector2().fromArray(json.clearcoatNormalScale);
        if (json.iridescenceMap !== void 0) material.iridescenceMap = getTexture(json.iridescenceMap);
        if (json.iridescenceThicknessMap !== void 0) material.iridescenceThicknessMap = getTexture(json.iridescenceThicknessMap);
        if (json.transmissionMap !== void 0) material.transmissionMap = getTexture(json.transmissionMap);
        if (json.thicknessMap !== void 0) material.thicknessMap = getTexture(json.thicknessMap);
        if (json.anisotropyMap !== void 0) material.anisotropyMap = getTexture(json.anisotropyMap);
        if (json.sheenColorMap !== void 0) material.sheenColorMap = getTexture(json.sheenColorMap);
        if (json.sheenRoughnessMap !== void 0) material.sheenRoughnessMap = getTexture(json.sheenRoughnessMap);
        return material;
      }
      setTextures(value) {
        this.textures = value;
        return this;
      }
      createMaterialFromType(type) {
        return _MaterialLoader.createMaterialFromType(type);
      }
      static createMaterialFromType(type) {
        const materialLib = {
          ShadowMaterial,
          SpriteMaterial,
          RawShaderMaterial,
          ShaderMaterial,
          PointsMaterial,
          MeshPhysicalMaterial,
          MeshStandardMaterial,
          MeshPhongMaterial,
          MeshToonMaterial,
          MeshNormalMaterial,
          MeshLambertMaterial,
          MeshDepthMaterial,
          MeshDistanceMaterial,
          MeshBasicMaterial,
          MeshMatcapMaterial,
          LineDashedMaterial,
          LineBasicMaterial,
          Material
        };
        return new materialLib[type]();
      }
    };
    LoaderUtils = class {
      static decodeText(array) {
        console.warn("THREE.LoaderUtils: decodeText() has been deprecated with r165 and will be removed with r175. Use TextDecoder instead.");
        if (typeof TextDecoder !== "undefined") {
          return new TextDecoder().decode(array);
        }
        let s = "";
        for (let i2 = 0, il = array.length; i2 < il; i2++) {
          s += String.fromCharCode(array[i2]);
        }
        try {
          return decodeURIComponent(escape(s));
        } catch (e) {
          return s;
        }
      }
      static extractUrlBase(url) {
        const index = url.lastIndexOf("/");
        if (index === -1) return "./";
        return url.slice(0, index + 1);
      }
      static resolveURL(url, path) {
        if (typeof url !== "string" || url === "") return "";
        if (/^https?:\/\//i.test(path) && /^\//.test(url)) {
          path = path.replace(/(^https?:\/\/[^\/]+).*/i, "$1");
        }
        if (/^(https?:)?\/\//i.test(url)) return url;
        if (/^data:.*,.*$/i.test(url)) return url;
        if (/^blob:.*$/i.test(url)) return url;
        return path + url;
      }
    };
    InstancedBufferGeometry = class extends BufferGeometry {
      constructor() {
        super();
        this.isInstancedBufferGeometry = true;
        this.type = "InstancedBufferGeometry";
        this.instanceCount = Infinity;
      }
      copy(source) {
        super.copy(source);
        this.instanceCount = source.instanceCount;
        return this;
      }
      toJSON() {
        const data = super.toJSON();
        data.instanceCount = this.instanceCount;
        data.isInstancedBufferGeometry = true;
        return data;
      }
    };
    BufferGeometryLoader = class extends Loader {
      constructor(manager) {
        super(manager);
      }
      load(url, onLoad, onProgress, onError) {
        const scope = this;
        const loader = new FileLoader(scope.manager);
        loader.setPath(scope.path);
        loader.setRequestHeader(scope.requestHeader);
        loader.setWithCredentials(scope.withCredentials);
        loader.load(url, function(text) {
          try {
            onLoad(scope.parse(JSON.parse(text)));
          } catch (e) {
            if (onError) {
              onError(e);
            } else {
              console.error(e);
            }
            scope.manager.itemError(url);
          }
        }, onProgress, onError);
      }
      parse(json) {
        const interleavedBufferMap = {};
        const arrayBufferMap = {};
        function getInterleavedBuffer(json2, uuid) {
          if (interleavedBufferMap[uuid] !== void 0) return interleavedBufferMap[uuid];
          const interleavedBuffers = json2.interleavedBuffers;
          const interleavedBuffer = interleavedBuffers[uuid];
          const buffer = getArrayBuffer(json2, interleavedBuffer.buffer);
          const array = getTypedArray(interleavedBuffer.type, buffer);
          const ib = new InterleavedBuffer(array, interleavedBuffer.stride);
          ib.uuid = interleavedBuffer.uuid;
          interleavedBufferMap[uuid] = ib;
          return ib;
        }
        function getArrayBuffer(json2, uuid) {
          if (arrayBufferMap[uuid] !== void 0) return arrayBufferMap[uuid];
          const arrayBuffers = json2.arrayBuffers;
          const arrayBuffer = arrayBuffers[uuid];
          const ab = new Uint32Array(arrayBuffer).buffer;
          arrayBufferMap[uuid] = ab;
          return ab;
        }
        const geometry = json.isInstancedBufferGeometry ? new InstancedBufferGeometry() : new BufferGeometry();
        const index = json.data.index;
        if (index !== void 0) {
          const typedArray = getTypedArray(index.type, index.array);
          geometry.setIndex(new BufferAttribute(typedArray, 1));
        }
        const attributes = json.data.attributes;
        for (const key in attributes) {
          const attribute = attributes[key];
          let bufferAttribute;
          if (attribute.isInterleavedBufferAttribute) {
            const interleavedBuffer = getInterleavedBuffer(json.data, attribute.data);
            bufferAttribute = new InterleavedBufferAttribute(interleavedBuffer, attribute.itemSize, attribute.offset, attribute.normalized);
          } else {
            const typedArray = getTypedArray(attribute.type, attribute.array);
            const bufferAttributeConstr = attribute.isInstancedBufferAttribute ? InstancedBufferAttribute : BufferAttribute;
            bufferAttribute = new bufferAttributeConstr(typedArray, attribute.itemSize, attribute.normalized);
          }
          if (attribute.name !== void 0) bufferAttribute.name = attribute.name;
          if (attribute.usage !== void 0) bufferAttribute.setUsage(attribute.usage);
          geometry.setAttribute(key, bufferAttribute);
        }
        const morphAttributes = json.data.morphAttributes;
        if (morphAttributes) {
          for (const key in morphAttributes) {
            const attributeArray = morphAttributes[key];
            const array = [];
            for (let i2 = 0, il = attributeArray.length; i2 < il; i2++) {
              const attribute = attributeArray[i2];
              let bufferAttribute;
              if (attribute.isInterleavedBufferAttribute) {
                const interleavedBuffer = getInterleavedBuffer(json.data, attribute.data);
                bufferAttribute = new InterleavedBufferAttribute(interleavedBuffer, attribute.itemSize, attribute.offset, attribute.normalized);
              } else {
                const typedArray = getTypedArray(attribute.type, attribute.array);
                bufferAttribute = new BufferAttribute(typedArray, attribute.itemSize, attribute.normalized);
              }
              if (attribute.name !== void 0) bufferAttribute.name = attribute.name;
              array.push(bufferAttribute);
            }
            geometry.morphAttributes[key] = array;
          }
        }
        const morphTargetsRelative = json.data.morphTargetsRelative;
        if (morphTargetsRelative) {
          geometry.morphTargetsRelative = true;
        }
        const groups = json.data.groups || json.data.drawcalls || json.data.offsets;
        if (groups !== void 0) {
          for (let i2 = 0, n = groups.length; i2 !== n; ++i2) {
            const group = groups[i2];
            geometry.addGroup(group.start, group.count, group.materialIndex);
          }
        }
        const boundingSphere = json.data.boundingSphere;
        if (boundingSphere !== void 0) {
          const center = new Vector3();
          if (boundingSphere.center !== void 0) {
            center.fromArray(boundingSphere.center);
          }
          geometry.boundingSphere = new Sphere(center, boundingSphere.radius);
        }
        if (json.name) geometry.name = json.name;
        if (json.userData) geometry.userData = json.userData;
        return geometry;
      }
    };
    ObjectLoader = class extends Loader {
      constructor(manager) {
        super(manager);
      }
      load(url, onLoad, onProgress, onError) {
        const scope = this;
        const path = this.path === "" ? LoaderUtils.extractUrlBase(url) : this.path;
        this.resourcePath = this.resourcePath || path;
        const loader = new FileLoader(this.manager);
        loader.setPath(this.path);
        loader.setRequestHeader(this.requestHeader);
        loader.setWithCredentials(this.withCredentials);
        loader.load(url, function(text) {
          let json = null;
          try {
            json = JSON.parse(text);
          } catch (error2) {
            if (onError !== void 0) onError(error2);
            console.error("THREE:ObjectLoader: Can't parse " + url + ".", error2.message);
            return;
          }
          const metadata = json.metadata;
          if (metadata === void 0 || metadata.type === void 0 || metadata.type.toLowerCase() === "geometry") {
            if (onError !== void 0) onError(new Error("THREE.ObjectLoader: Can't load " + url));
            console.error("THREE.ObjectLoader: Can't load " + url);
            return;
          }
          scope.parse(json, onLoad);
        }, onProgress, onError);
      }
      loadAsync(url, onProgress) {
        return __async(this, null, function* () {
          const scope = this;
          const path = this.path === "" ? LoaderUtils.extractUrlBase(url) : this.path;
          this.resourcePath = this.resourcePath || path;
          const loader = new FileLoader(this.manager);
          loader.setPath(this.path);
          loader.setRequestHeader(this.requestHeader);
          loader.setWithCredentials(this.withCredentials);
          const text = yield loader.loadAsync(url, onProgress);
          const json = JSON.parse(text);
          const metadata = json.metadata;
          if (metadata === void 0 || metadata.type === void 0 || metadata.type.toLowerCase() === "geometry") {
            throw new Error("THREE.ObjectLoader: Can't load " + url);
          }
          return yield scope.parseAsync(json);
        });
      }
      parse(json, onLoad) {
        const animations = this.parseAnimations(json.animations);
        const shapes = this.parseShapes(json.shapes);
        const geometries = this.parseGeometries(json.geometries, shapes);
        const images = this.parseImages(json.images, function() {
          if (onLoad !== void 0) onLoad(object);
        });
        const textures = this.parseTextures(json.textures, images);
        const materials = this.parseMaterials(json.materials, textures);
        const object = this.parseObject(json.object, geometries, materials, textures, animations);
        const skeletons = this.parseSkeletons(json.skeletons, object);
        this.bindSkeletons(object, skeletons);
        this.bindLightTargets(object);
        if (onLoad !== void 0) {
          let hasImages = false;
          for (const uuid in images) {
            if (images[uuid].data instanceof HTMLImageElement) {
              hasImages = true;
              break;
            }
          }
          if (hasImages === false) onLoad(object);
        }
        return object;
      }
      parseAsync(json) {
        return __async(this, null, function* () {
          const animations = this.parseAnimations(json.animations);
          const shapes = this.parseShapes(json.shapes);
          const geometries = this.parseGeometries(json.geometries, shapes);
          const images = yield this.parseImagesAsync(json.images);
          const textures = this.parseTextures(json.textures, images);
          const materials = this.parseMaterials(json.materials, textures);
          const object = this.parseObject(json.object, geometries, materials, textures, animations);
          const skeletons = this.parseSkeletons(json.skeletons, object);
          this.bindSkeletons(object, skeletons);
          this.bindLightTargets(object);
          return object;
        });
      }
      parseShapes(json) {
        const shapes = {};
        if (json !== void 0) {
          for (let i2 = 0, l2 = json.length; i2 < l2; i2++) {
            const shape = new Shape().fromJSON(json[i2]);
            shapes[shape.uuid] = shape;
          }
        }
        return shapes;
      }
      parseSkeletons(json, object) {
        const skeletons = {};
        const bones = {};
        object.traverse(function(child) {
          if (child.isBone) bones[child.uuid] = child;
        });
        if (json !== void 0) {
          for (let i2 = 0, l2 = json.length; i2 < l2; i2++) {
            const skeleton = new Skeleton().fromJSON(json[i2], bones);
            skeletons[skeleton.uuid] = skeleton;
          }
        }
        return skeletons;
      }
      parseGeometries(json, shapes) {
        const geometries = {};
        if (json !== void 0) {
          const bufferGeometryLoader = new BufferGeometryLoader();
          for (let i2 = 0, l2 = json.length; i2 < l2; i2++) {
            let geometry;
            const data = json[i2];
            switch (data.type) {
              case "BufferGeometry":
              case "InstancedBufferGeometry":
                geometry = bufferGeometryLoader.parse(data);
                break;
              default:
                if (data.type in Geometries) {
                  geometry = Geometries[data.type].fromJSON(data, shapes);
                } else {
                  console.warn(`THREE.ObjectLoader: Unsupported geometry type "${data.type}"`);
                }
            }
            geometry.uuid = data.uuid;
            if (data.name !== void 0) geometry.name = data.name;
            if (data.userData !== void 0) geometry.userData = data.userData;
            geometries[data.uuid] = geometry;
          }
        }
        return geometries;
      }
      parseMaterials(json, textures) {
        const cache = {};
        const materials = {};
        if (json !== void 0) {
          const loader = new MaterialLoader();
          loader.setTextures(textures);
          for (let i2 = 0, l2 = json.length; i2 < l2; i2++) {
            const data = json[i2];
            if (cache[data.uuid] === void 0) {
              cache[data.uuid] = loader.parse(data);
            }
            materials[data.uuid] = cache[data.uuid];
          }
        }
        return materials;
      }
      parseAnimations(json) {
        const animations = {};
        if (json !== void 0) {
          for (let i2 = 0; i2 < json.length; i2++) {
            const data = json[i2];
            const clip = AnimationClip.parse(data);
            animations[clip.uuid] = clip;
          }
        }
        return animations;
      }
      parseImages(json, onLoad) {
        const scope = this;
        const images = {};
        let loader;
        function loadImage(url) {
          scope.manager.itemStart(url);
          return loader.load(url, function() {
            scope.manager.itemEnd(url);
          }, void 0, function() {
            scope.manager.itemError(url);
            scope.manager.itemEnd(url);
          });
        }
        function deserializeImage(image) {
          if (typeof image === "string") {
            const url = image;
            const path = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(url) ? url : scope.resourcePath + url;
            return loadImage(path);
          } else {
            if (image.data) {
              return {
                data: getTypedArray(image.type, image.data),
                width: image.width,
                height: image.height
              };
            } else {
              return null;
            }
          }
        }
        if (json !== void 0 && json.length > 0) {
          const manager = new LoadingManager(onLoad);
          loader = new ImageLoader(manager);
          loader.setCrossOrigin(this.crossOrigin);
          for (let i2 = 0, il = json.length; i2 < il; i2++) {
            const image = json[i2];
            const url = image.url;
            if (Array.isArray(url)) {
              const imageArray = [];
              for (let j2 = 0, jl = url.length; j2 < jl; j2++) {
                const currentUrl = url[j2];
                const deserializedImage = deserializeImage(currentUrl);
                if (deserializedImage !== null) {
                  if (deserializedImage instanceof HTMLImageElement) {
                    imageArray.push(deserializedImage);
                  } else {
                    imageArray.push(new DataTexture(deserializedImage.data, deserializedImage.width, deserializedImage.height));
                  }
                }
              }
              images[image.uuid] = new Source(imageArray);
            } else {
              const deserializedImage = deserializeImage(image.url);
              images[image.uuid] = new Source(deserializedImage);
            }
          }
        }
        return images;
      }
      parseImagesAsync(json) {
        return __async(this, null, function* () {
          const scope = this;
          const images = {};
          let loader;
          function deserializeImage(image) {
            return __async(this, null, function* () {
              if (typeof image === "string") {
                const url = image;
                const path = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(url) ? url : scope.resourcePath + url;
                return yield loader.loadAsync(path);
              } else {
                if (image.data) {
                  return {
                    data: getTypedArray(image.type, image.data),
                    width: image.width,
                    height: image.height
                  };
                } else {
                  return null;
                }
              }
            });
          }
          if (json !== void 0 && json.length > 0) {
            loader = new ImageLoader(this.manager);
            loader.setCrossOrigin(this.crossOrigin);
            for (let i2 = 0, il = json.length; i2 < il; i2++) {
              const image = json[i2];
              const url = image.url;
              if (Array.isArray(url)) {
                const imageArray = [];
                for (let j2 = 0, jl = url.length; j2 < jl; j2++) {
                  const currentUrl = url[j2];
                  const deserializedImage = yield deserializeImage(currentUrl);
                  if (deserializedImage !== null) {
                    if (deserializedImage instanceof HTMLImageElement) {
                      imageArray.push(deserializedImage);
                    } else {
                      imageArray.push(new DataTexture(deserializedImage.data, deserializedImage.width, deserializedImage.height));
                    }
                  }
                }
                images[image.uuid] = new Source(imageArray);
              } else {
                const deserializedImage = yield deserializeImage(image.url);
                images[image.uuid] = new Source(deserializedImage);
              }
            }
          }
          return images;
        });
      }
      parseTextures(json, images) {
        function parseConstant(value, type) {
          if (typeof value === "number") return value;
          console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.", value);
          return type[value];
        }
        const textures = {};
        if (json !== void 0) {
          for (let i2 = 0, l2 = json.length; i2 < l2; i2++) {
            const data = json[i2];
            if (data.image === void 0) {
              console.warn('THREE.ObjectLoader: No "image" specified for', data.uuid);
            }
            if (images[data.image] === void 0) {
              console.warn("THREE.ObjectLoader: Undefined image", data.image);
            }
            const source = images[data.image];
            const image = source.data;
            let texture;
            if (Array.isArray(image)) {
              texture = new CubeTexture();
              if (image.length === 6) texture.needsUpdate = true;
            } else {
              if (image && image.data) {
                texture = new DataTexture();
              } else {
                texture = new Texture();
              }
              if (image) texture.needsUpdate = true;
            }
            texture.source = source;
            texture.uuid = data.uuid;
            if (data.name !== void 0) texture.name = data.name;
            if (data.mapping !== void 0) texture.mapping = parseConstant(data.mapping, TEXTURE_MAPPING);
            if (data.channel !== void 0) texture.channel = data.channel;
            if (data.offset !== void 0) texture.offset.fromArray(data.offset);
            if (data.repeat !== void 0) texture.repeat.fromArray(data.repeat);
            if (data.center !== void 0) texture.center.fromArray(data.center);
            if (data.rotation !== void 0) texture.rotation = data.rotation;
            if (data.wrap !== void 0) {
              texture.wrapS = parseConstant(data.wrap[0], TEXTURE_WRAPPING);
              texture.wrapT = parseConstant(data.wrap[1], TEXTURE_WRAPPING);
            }
            if (data.format !== void 0) texture.format = data.format;
            if (data.internalFormat !== void 0) texture.internalFormat = data.internalFormat;
            if (data.type !== void 0) texture.type = data.type;
            if (data.colorSpace !== void 0) texture.colorSpace = data.colorSpace;
            if (data.minFilter !== void 0) texture.minFilter = parseConstant(data.minFilter, TEXTURE_FILTER);
            if (data.magFilter !== void 0) texture.magFilter = parseConstant(data.magFilter, TEXTURE_FILTER);
            if (data.anisotropy !== void 0) texture.anisotropy = data.anisotropy;
            if (data.flipY !== void 0) texture.flipY = data.flipY;
            if (data.generateMipmaps !== void 0) texture.generateMipmaps = data.generateMipmaps;
            if (data.premultiplyAlpha !== void 0) texture.premultiplyAlpha = data.premultiplyAlpha;
            if (data.unpackAlignment !== void 0) texture.unpackAlignment = data.unpackAlignment;
            if (data.compareFunction !== void 0) texture.compareFunction = data.compareFunction;
            if (data.userData !== void 0) texture.userData = data.userData;
            textures[data.uuid] = texture;
          }
        }
        return textures;
      }
      parseObject(data, geometries, materials, textures, animations) {
        let object;
        function getGeometry(name) {
          if (geometries[name] === void 0) {
            console.warn("THREE.ObjectLoader: Undefined geometry", name);
          }
          return geometries[name];
        }
        function getMaterial(name) {
          if (name === void 0) return void 0;
          if (Array.isArray(name)) {
            const array = [];
            for (let i2 = 0, l2 = name.length; i2 < l2; i2++) {
              const uuid = name[i2];
              if (materials[uuid] === void 0) {
                console.warn("THREE.ObjectLoader: Undefined material", uuid);
              }
              array.push(materials[uuid]);
            }
            return array;
          }
          if (materials[name] === void 0) {
            console.warn("THREE.ObjectLoader: Undefined material", name);
          }
          return materials[name];
        }
        function getTexture(uuid) {
          if (textures[uuid] === void 0) {
            console.warn("THREE.ObjectLoader: Undefined texture", uuid);
          }
          return textures[uuid];
        }
        let geometry, material;
        switch (data.type) {
          case "Scene":
            object = new Scene();
            if (data.background !== void 0) {
              if (Number.isInteger(data.background)) {
                object.background = new Color(data.background);
              } else {
                object.background = getTexture(data.background);
              }
            }
            if (data.environment !== void 0) {
              object.environment = getTexture(data.environment);
            }
            if (data.fog !== void 0) {
              if (data.fog.type === "Fog") {
                object.fog = new Fog(data.fog.color, data.fog.near, data.fog.far);
              } else if (data.fog.type === "FogExp2") {
                object.fog = new FogExp2(data.fog.color, data.fog.density);
              }
              if (data.fog.name !== "") {
                object.fog.name = data.fog.name;
              }
            }
            if (data.backgroundBlurriness !== void 0) object.backgroundBlurriness = data.backgroundBlurriness;
            if (data.backgroundIntensity !== void 0) object.backgroundIntensity = data.backgroundIntensity;
            if (data.backgroundRotation !== void 0) object.backgroundRotation.fromArray(data.backgroundRotation);
            if (data.environmentIntensity !== void 0) object.environmentIntensity = data.environmentIntensity;
            if (data.environmentRotation !== void 0) object.environmentRotation.fromArray(data.environmentRotation);
            break;
          case "PerspectiveCamera":
            object = new PerspectiveCamera(data.fov, data.aspect, data.near, data.far);
            if (data.focus !== void 0) object.focus = data.focus;
            if (data.zoom !== void 0) object.zoom = data.zoom;
            if (data.filmGauge !== void 0) object.filmGauge = data.filmGauge;
            if (data.filmOffset !== void 0) object.filmOffset = data.filmOffset;
            if (data.view !== void 0) object.view = Object.assign({}, data.view);
            break;
          case "OrthographicCamera":
            object = new OrthographicCamera(data.left, data.right, data.top, data.bottom, data.near, data.far);
            if (data.zoom !== void 0) object.zoom = data.zoom;
            if (data.view !== void 0) object.view = Object.assign({}, data.view);
            break;
          case "AmbientLight":
            object = new AmbientLight(data.color, data.intensity);
            break;
          case "DirectionalLight":
            object = new DirectionalLight(data.color, data.intensity);
            object.target = data.target || "";
            break;
          case "PointLight":
            object = new PointLight(data.color, data.intensity, data.distance, data.decay);
            break;
          case "RectAreaLight":
            object = new RectAreaLight(data.color, data.intensity, data.width, data.height);
            break;
          case "SpotLight":
            object = new SpotLight(data.color, data.intensity, data.distance, data.angle, data.penumbra, data.decay);
            object.target = data.target || "";
            break;
          case "HemisphereLight":
            object = new HemisphereLight(data.color, data.groundColor, data.intensity);
            break;
          case "LightProbe":
            object = new LightProbe().fromJSON(data);
            break;
          case "SkinnedMesh":
            geometry = getGeometry(data.geometry);
            material = getMaterial(data.material);
            object = new SkinnedMesh(geometry, material);
            if (data.bindMode !== void 0) object.bindMode = data.bindMode;
            if (data.bindMatrix !== void 0) object.bindMatrix.fromArray(data.bindMatrix);
            if (data.skeleton !== void 0) object.skeleton = data.skeleton;
            break;
          case "Mesh":
            geometry = getGeometry(data.geometry);
            material = getMaterial(data.material);
            object = new Mesh(geometry, material);
            break;
          case "InstancedMesh":
            geometry = getGeometry(data.geometry);
            material = getMaterial(data.material);
            const count = data.count;
            const instanceMatrix = data.instanceMatrix;
            const instanceColor = data.instanceColor;
            object = new InstancedMesh(geometry, material, count);
            object.instanceMatrix = new InstancedBufferAttribute(new Float32Array(instanceMatrix.array), 16);
            if (instanceColor !== void 0) object.instanceColor = new InstancedBufferAttribute(new Float32Array(instanceColor.array), instanceColor.itemSize);
            break;
          case "BatchedMesh":
            geometry = getGeometry(data.geometry);
            material = getMaterial(data.material);
            object = new BatchedMesh(data.maxInstanceCount, data.maxVertexCount, data.maxIndexCount, material);
            object.geometry = geometry;
            object.perObjectFrustumCulled = data.perObjectFrustumCulled;
            object.sortObjects = data.sortObjects;
            object._drawRanges = data.drawRanges;
            object._reservedRanges = data.reservedRanges;
            object._visibility = data.visibility;
            object._active = data.active;
            object._bounds = data.bounds.map((bound) => {
              const box = new Box3();
              box.min.fromArray(bound.boxMin);
              box.max.fromArray(bound.boxMax);
              const sphere = new Sphere();
              sphere.radius = bound.sphereRadius;
              sphere.center.fromArray(bound.sphereCenter);
              return {
                boxInitialized: bound.boxInitialized,
                box,
                sphereInitialized: bound.sphereInitialized,
                sphere
              };
            });
            object._maxInstanceCount = data.maxInstanceCount;
            object._maxVertexCount = data.maxVertexCount;
            object._maxIndexCount = data.maxIndexCount;
            object._geometryInitialized = data.geometryInitialized;
            object._geometryCount = data.geometryCount;
            object._matricesTexture = getTexture(data.matricesTexture.uuid);
            if (data.colorsTexture !== void 0) object._colorsTexture = getTexture(data.colorsTexture.uuid);
            break;
          case "LOD":
            object = new LOD();
            break;
          case "Line":
            object = new Line(getGeometry(data.geometry), getMaterial(data.material));
            break;
          case "LineLoop":
            object = new LineLoop(getGeometry(data.geometry), getMaterial(data.material));
            break;
          case "LineSegments":
            object = new LineSegments(getGeometry(data.geometry), getMaterial(data.material));
            break;
          case "PointCloud":
          case "Points":
            object = new Points(getGeometry(data.geometry), getMaterial(data.material));
            break;
          case "Sprite":
            object = new Sprite(getMaterial(data.material));
            break;
          case "Group":
            object = new Group();
            break;
          case "Bone":
            object = new Bone();
            break;
          default:
            object = new Object3D();
        }
        object.uuid = data.uuid;
        if (data.name !== void 0) object.name = data.name;
        if (data.matrix !== void 0) {
          object.matrix.fromArray(data.matrix);
          if (data.matrixAutoUpdate !== void 0) object.matrixAutoUpdate = data.matrixAutoUpdate;
          if (object.matrixAutoUpdate) object.matrix.decompose(object.position, object.quaternion, object.scale);
        } else {
          if (data.position !== void 0) object.position.fromArray(data.position);
          if (data.rotation !== void 0) object.rotation.fromArray(data.rotation);
          if (data.quaternion !== void 0) object.quaternion.fromArray(data.quaternion);
          if (data.scale !== void 0) object.scale.fromArray(data.scale);
        }
        if (data.up !== void 0) object.up.fromArray(data.up);
        if (data.castShadow !== void 0) object.castShadow = data.castShadow;
        if (data.receiveShadow !== void 0) object.receiveShadow = data.receiveShadow;
        if (data.shadow) {
          if (data.shadow.intensity !== void 0) object.shadow.intensity = data.shadow.intensity;
          if (data.shadow.bias !== void 0) object.shadow.bias = data.shadow.bias;
          if (data.shadow.normalBias !== void 0) object.shadow.normalBias = data.shadow.normalBias;
          if (data.shadow.radius !== void 0) object.shadow.radius = data.shadow.radius;
          if (data.shadow.mapSize !== void 0) object.shadow.mapSize.fromArray(data.shadow.mapSize);
          if (data.shadow.camera !== void 0) object.shadow.camera = this.parseObject(data.shadow.camera);
        }
        if (data.visible !== void 0) object.visible = data.visible;
        if (data.frustumCulled !== void 0) object.frustumCulled = data.frustumCulled;
        if (data.renderOrder !== void 0) object.renderOrder = data.renderOrder;
        if (data.userData !== void 0) object.userData = data.userData;
        if (data.layers !== void 0) object.layers.mask = data.layers;
        if (data.children !== void 0) {
          const children = data.children;
          for (let i2 = 0; i2 < children.length; i2++) {
            object.add(this.parseObject(children[i2], geometries, materials, textures, animations));
          }
        }
        if (data.animations !== void 0) {
          const objectAnimations = data.animations;
          for (let i2 = 0; i2 < objectAnimations.length; i2++) {
            const uuid = objectAnimations[i2];
            object.animations.push(animations[uuid]);
          }
        }
        if (data.type === "LOD") {
          if (data.autoUpdate !== void 0) object.autoUpdate = data.autoUpdate;
          const levels = data.levels;
          for (let l2 = 0; l2 < levels.length; l2++) {
            const level = levels[l2];
            const child = object.getObjectByProperty("uuid", level.object);
            if (child !== void 0) {
              object.addLevel(child, level.distance, level.hysteresis);
            }
          }
        }
        return object;
      }
      bindSkeletons(object, skeletons) {
        if (Object.keys(skeletons).length === 0) return;
        object.traverse(function(child) {
          if (child.isSkinnedMesh === true && child.skeleton !== void 0) {
            const skeleton = skeletons[child.skeleton];
            if (skeleton === void 0) {
              console.warn("THREE.ObjectLoader: No skeleton found with UUID:", child.skeleton);
            } else {
              child.bind(skeleton, child.bindMatrix);
            }
          }
        });
      }
      bindLightTargets(object) {
        object.traverse(function(child) {
          if (child.isDirectionalLight || child.isSpotLight) {
            const uuid = child.target;
            const target2 = object.getObjectByProperty("uuid", uuid);
            if (target2 !== void 0) {
              child.target = target2;
            } else {
              child.target = new Object3D();
            }
          }
        });
      }
    };
    TEXTURE_MAPPING = {
      UVMapping,
      CubeReflectionMapping,
      CubeRefractionMapping,
      EquirectangularReflectionMapping,
      EquirectangularRefractionMapping,
      CubeUVReflectionMapping
    };
    TEXTURE_WRAPPING = {
      RepeatWrapping,
      ClampToEdgeWrapping,
      MirroredRepeatWrapping
    };
    TEXTURE_FILTER = {
      NearestFilter,
      NearestMipmapNearestFilter,
      NearestMipmapLinearFilter,
      LinearFilter,
      LinearMipmapNearestFilter,
      LinearMipmapLinearFilter
    };
    ImageBitmapLoader = class extends Loader {
      constructor(manager) {
        super(manager);
        this.isImageBitmapLoader = true;
        if (typeof createImageBitmap === "undefined") {
          console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported.");
        }
        if (typeof fetch === "undefined") {
          console.warn("THREE.ImageBitmapLoader: fetch() not supported.");
        }
        this.options = { premultiplyAlpha: "none" };
      }
      setOptions(options) {
        this.options = options;
        return this;
      }
      load(url, onLoad, onProgress, onError) {
        if (url === void 0) url = "";
        if (this.path !== void 0) url = this.path + url;
        url = this.manager.resolveURL(url);
        const scope = this;
        const cached = Cache.get(url);
        if (cached !== void 0) {
          scope.manager.itemStart(url);
          if (cached.then) {
            cached.then((imageBitmap) => {
              if (onLoad) onLoad(imageBitmap);
              scope.manager.itemEnd(url);
            }).catch((e) => {
              if (onError) onError(e);
            });
            return;
          }
          setTimeout(function() {
            if (onLoad) onLoad(cached);
            scope.manager.itemEnd(url);
          }, 0);
          return cached;
        }
        const fetchOptions = {};
        fetchOptions.credentials = this.crossOrigin === "anonymous" ? "same-origin" : "include";
        fetchOptions.headers = this.requestHeader;
        const promise = fetch(url, fetchOptions).then(function(res) {
          return res.blob();
        }).then(function(blob) {
          return createImageBitmap(blob, Object.assign(scope.options, { colorSpaceConversion: "none" }));
        }).then(function(imageBitmap) {
          Cache.add(url, imageBitmap);
          if (onLoad) onLoad(imageBitmap);
          scope.manager.itemEnd(url);
          return imageBitmap;
        }).catch(function(e) {
          if (onError) onError(e);
          Cache.remove(url);
          scope.manager.itemError(url);
          scope.manager.itemEnd(url);
        });
        Cache.add(url, promise);
        scope.manager.itemStart(url);
      }
    };
    AudioContext = class {
      static getContext() {
        if (_context === void 0) {
          _context = new (window.AudioContext || window.webkitAudioContext)();
        }
        return _context;
      }
      static setContext(value) {
        _context = value;
      }
    };
    AudioLoader = class extends Loader {
      constructor(manager) {
        super(manager);
      }
      load(url, onLoad, onProgress, onError) {
        const scope = this;
        const loader = new FileLoader(this.manager);
        loader.setResponseType("arraybuffer");
        loader.setPath(this.path);
        loader.setRequestHeader(this.requestHeader);
        loader.setWithCredentials(this.withCredentials);
        loader.load(url, function(buffer) {
          try {
            const bufferCopy = buffer.slice(0);
            const context2 = AudioContext.getContext();
            context2.decodeAudioData(bufferCopy, function(audioBuffer) {
              onLoad(audioBuffer);
            }).catch(handleError);
          } catch (e) {
            handleError(e);
          }
        }, onProgress, onError);
        function handleError(e) {
          if (onError) {
            onError(e);
          } else {
            console.error(e);
          }
          scope.manager.itemError(url);
        }
      }
    };
    _eyeRight = /* @__PURE__ */ new Matrix4();
    _eyeLeft = /* @__PURE__ */ new Matrix4();
    _projectionMatrix = /* @__PURE__ */ new Matrix4();
    StereoCamera = class {
      constructor() {
        this.type = "StereoCamera";
        this.aspect = 1;
        this.eyeSep = 0.064;
        this.cameraL = new PerspectiveCamera();
        this.cameraL.layers.enable(1);
        this.cameraL.matrixAutoUpdate = false;
        this.cameraR = new PerspectiveCamera();
        this.cameraR.layers.enable(2);
        this.cameraR.matrixAutoUpdate = false;
        this._cache = {
          focus: null,
          fov: null,
          aspect: null,
          near: null,
          far: null,
          zoom: null,
          eyeSep: null
        };
      }
      update(camera) {
        const cache = this._cache;
        const needsUpdate = cache.focus !== camera.focus || cache.fov !== camera.fov || cache.aspect !== camera.aspect * this.aspect || cache.near !== camera.near || cache.far !== camera.far || cache.zoom !== camera.zoom || cache.eyeSep !== this.eyeSep;
        if (needsUpdate) {
          cache.focus = camera.focus;
          cache.fov = camera.fov;
          cache.aspect = camera.aspect * this.aspect;
          cache.near = camera.near;
          cache.far = camera.far;
          cache.zoom = camera.zoom;
          cache.eyeSep = this.eyeSep;
          _projectionMatrix.copy(camera.projectionMatrix);
          const eyeSepHalf = cache.eyeSep / 2;
          const eyeSepOnProjection = eyeSepHalf * cache.near / cache.focus;
          const ymax = cache.near * Math.tan(DEG2RAD * cache.fov * 0.5) / cache.zoom;
          let xmin, xmax;
          _eyeLeft.elements[12] = -eyeSepHalf;
          _eyeRight.elements[12] = eyeSepHalf;
          xmin = -ymax * cache.aspect + eyeSepOnProjection;
          xmax = ymax * cache.aspect + eyeSepOnProjection;
          _projectionMatrix.elements[0] = 2 * cache.near / (xmax - xmin);
          _projectionMatrix.elements[8] = (xmax + xmin) / (xmax - xmin);
          this.cameraL.projectionMatrix.copy(_projectionMatrix);
          xmin = -ymax * cache.aspect - eyeSepOnProjection;
          xmax = ymax * cache.aspect - eyeSepOnProjection;
          _projectionMatrix.elements[0] = 2 * cache.near / (xmax - xmin);
          _projectionMatrix.elements[8] = (xmax + xmin) / (xmax - xmin);
          this.cameraR.projectionMatrix.copy(_projectionMatrix);
        }
        this.cameraL.matrixWorld.copy(camera.matrixWorld).multiply(_eyeLeft);
        this.cameraR.matrixWorld.copy(camera.matrixWorld).multiply(_eyeRight);
      }
    };
    Clock = class {
      constructor(autoStart = true) {
        this.autoStart = autoStart;
        this.startTime = 0;
        this.oldTime = 0;
        this.elapsedTime = 0;
        this.running = false;
      }
      start() {
        this.startTime = now();
        this.oldTime = this.startTime;
        this.elapsedTime = 0;
        this.running = true;
      }
      stop() {
        this.getElapsedTime();
        this.running = false;
        this.autoStart = false;
      }
      getElapsedTime() {
        this.getDelta();
        return this.elapsedTime;
      }
      getDelta() {
        let diff = 0;
        if (this.autoStart && !this.running) {
          this.start();
          return 0;
        }
        if (this.running) {
          const newTime = now();
          diff = (newTime - this.oldTime) / 1e3;
          this.oldTime = newTime;
          this.elapsedTime += diff;
        }
        return diff;
      }
    };
    _position$1 = /* @__PURE__ */ new Vector3();
    _quaternion$1 = /* @__PURE__ */ new Quaternion();
    _scale$1 = /* @__PURE__ */ new Vector3();
    _orientation$1 = /* @__PURE__ */ new Vector3();
    AudioListener = class extends Object3D {
      constructor() {
        super();
        this.type = "AudioListener";
        this.context = AudioContext.getContext();
        this.gain = this.context.createGain();
        this.gain.connect(this.context.destination);
        this.filter = null;
        this.timeDelta = 0;
        this._clock = new Clock();
      }
      getInput() {
        return this.gain;
      }
      removeFilter() {
        if (this.filter !== null) {
          this.gain.disconnect(this.filter);
          this.filter.disconnect(this.context.destination);
          this.gain.connect(this.context.destination);
          this.filter = null;
        }
        return this;
      }
      getFilter() {
        return this.filter;
      }
      setFilter(value) {
        if (this.filter !== null) {
          this.gain.disconnect(this.filter);
          this.filter.disconnect(this.context.destination);
        } else {
          this.gain.disconnect(this.context.destination);
        }
        this.filter = value;
        this.gain.connect(this.filter);
        this.filter.connect(this.context.destination);
        return this;
      }
      getMasterVolume() {
        return this.gain.gain.value;
      }
      setMasterVolume(value) {
        this.gain.gain.setTargetAtTime(value, this.context.currentTime, 0.01);
        return this;
      }
      updateMatrixWorld(force) {
        super.updateMatrixWorld(force);
        const listener = this.context.listener;
        const up = this.up;
        this.timeDelta = this._clock.getDelta();
        this.matrixWorld.decompose(_position$1, _quaternion$1, _scale$1);
        _orientation$1.set(0, 0, -1).applyQuaternion(_quaternion$1);
        if (listener.positionX) {
          const endTime = this.context.currentTime + this.timeDelta;
          listener.positionX.linearRampToValueAtTime(_position$1.x, endTime);
          listener.positionY.linearRampToValueAtTime(_position$1.y, endTime);
          listener.positionZ.linearRampToValueAtTime(_position$1.z, endTime);
          listener.forwardX.linearRampToValueAtTime(_orientation$1.x, endTime);
          listener.forwardY.linearRampToValueAtTime(_orientation$1.y, endTime);
          listener.forwardZ.linearRampToValueAtTime(_orientation$1.z, endTime);
          listener.upX.linearRampToValueAtTime(up.x, endTime);
          listener.upY.linearRampToValueAtTime(up.y, endTime);
          listener.upZ.linearRampToValueAtTime(up.z, endTime);
        } else {
          listener.setPosition(_position$1.x, _position$1.y, _position$1.z);
          listener.setOrientation(_orientation$1.x, _orientation$1.y, _orientation$1.z, up.x, up.y, up.z);
        }
      }
    };
    Audio = class extends Object3D {
      constructor(listener) {
        super();
        this.type = "Audio";
        this.listener = listener;
        this.context = listener.context;
        this.gain = this.context.createGain();
        this.gain.connect(listener.getInput());
        this.autoplay = false;
        this.buffer = null;
        this.detune = 0;
        this.loop = false;
        this.loopStart = 0;
        this.loopEnd = 0;
        this.offset = 0;
        this.duration = void 0;
        this.playbackRate = 1;
        this.isPlaying = false;
        this.hasPlaybackControl = true;
        this.source = null;
        this.sourceType = "empty";
        this._startedAt = 0;
        this._progress = 0;
        this._connected = false;
        this.filters = [];
      }
      getOutput() {
        return this.gain;
      }
      setNodeSource(audioNode) {
        this.hasPlaybackControl = false;
        this.sourceType = "audioNode";
        this.source = audioNode;
        this.connect();
        return this;
      }
      setMediaElementSource(mediaElement) {
        this.hasPlaybackControl = false;
        this.sourceType = "mediaNode";
        this.source = this.context.createMediaElementSource(mediaElement);
        this.connect();
        return this;
      }
      setMediaStreamSource(mediaStream) {
        this.hasPlaybackControl = false;
        this.sourceType = "mediaStreamNode";
        this.source = this.context.createMediaStreamSource(mediaStream);
        this.connect();
        return this;
      }
      setBuffer(audioBuffer) {
        this.buffer = audioBuffer;
        this.sourceType = "buffer";
        if (this.autoplay) this.play();
        return this;
      }
      play(delay = 0) {
        if (this.isPlaying === true) {
          console.warn("THREE.Audio: Audio is already playing.");
          return;
        }
        if (this.hasPlaybackControl === false) {
          console.warn("THREE.Audio: this Audio has no playback control.");
          return;
        }
        this._startedAt = this.context.currentTime + delay;
        const source = this.context.createBufferSource();
        source.buffer = this.buffer;
        source.loop = this.loop;
        source.loopStart = this.loopStart;
        source.loopEnd = this.loopEnd;
        source.onended = this.onEnded.bind(this);
        source.start(this._startedAt, this._progress + this.offset, this.duration);
        this.isPlaying = true;
        this.source = source;
        this.setDetune(this.detune);
        this.setPlaybackRate(this.playbackRate);
        return this.connect();
      }
      pause() {
        if (this.hasPlaybackControl === false) {
          console.warn("THREE.Audio: this Audio has no playback control.");
          return;
        }
        if (this.isPlaying === true) {
          this._progress += Math.max(this.context.currentTime - this._startedAt, 0) * this.playbackRate;
          if (this.loop === true) {
            this._progress = this._progress % (this.duration || this.buffer.duration);
          }
          this.source.stop();
          this.source.onended = null;
          this.isPlaying = false;
        }
        return this;
      }
      stop(delay = 0) {
        if (this.hasPlaybackControl === false) {
          console.warn("THREE.Audio: this Audio has no playback control.");
          return;
        }
        this._progress = 0;
        if (this.source !== null) {
          this.source.stop(this.context.currentTime + delay);
          this.source.onended = null;
        }
        this.isPlaying = false;
        return this;
      }
      connect() {
        if (this.filters.length > 0) {
          this.source.connect(this.filters[0]);
          for (let i2 = 1, l2 = this.filters.length; i2 < l2; i2++) {
            this.filters[i2 - 1].connect(this.filters[i2]);
          }
          this.filters[this.filters.length - 1].connect(this.getOutput());
        } else {
          this.source.connect(this.getOutput());
        }
        this._connected = true;
        return this;
      }
      disconnect() {
        if (this._connected === false) {
          return;
        }
        if (this.filters.length > 0) {
          this.source.disconnect(this.filters[0]);
          for (let i2 = 1, l2 = this.filters.length; i2 < l2; i2++) {
            this.filters[i2 - 1].disconnect(this.filters[i2]);
          }
          this.filters[this.filters.length - 1].disconnect(this.getOutput());
        } else {
          this.source.disconnect(this.getOutput());
        }
        this._connected = false;
        return this;
      }
      getFilters() {
        return this.filters;
      }
      setFilters(value) {
        if (!value) value = [];
        if (this._connected === true) {
          this.disconnect();
          this.filters = value.slice();
          this.connect();
        } else {
          this.filters = value.slice();
        }
        return this;
      }
      setDetune(value) {
        this.detune = value;
        if (this.isPlaying === true && this.source.detune !== void 0) {
          this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, 0.01);
        }
        return this;
      }
      getDetune() {
        return this.detune;
      }
      getFilter() {
        return this.getFilters()[0];
      }
      setFilter(filter) {
        return this.setFilters(filter ? [filter] : []);
      }
      setPlaybackRate(value) {
        if (this.hasPlaybackControl === false) {
          console.warn("THREE.Audio: this Audio has no playback control.");
          return;
        }
        this.playbackRate = value;
        if (this.isPlaying === true) {
          this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, 0.01);
        }
        return this;
      }
      getPlaybackRate() {
        return this.playbackRate;
      }
      onEnded() {
        this.isPlaying = false;
      }
      getLoop() {
        if (this.hasPlaybackControl === false) {
          console.warn("THREE.Audio: this Audio has no playback control.");
          return false;
        }
        return this.loop;
      }
      setLoop(value) {
        if (this.hasPlaybackControl === false) {
          console.warn("THREE.Audio: this Audio has no playback control.");
          return;
        }
        this.loop = value;
        if (this.isPlaying === true) {
          this.source.loop = this.loop;
        }
        return this;
      }
      setLoopStart(value) {
        this.loopStart = value;
        return this;
      }
      setLoopEnd(value) {
        this.loopEnd = value;
        return this;
      }
      getVolume() {
        return this.gain.gain.value;
      }
      setVolume(value) {
        this.gain.gain.setTargetAtTime(value, this.context.currentTime, 0.01);
        return this;
      }
    };
    _position = /* @__PURE__ */ new Vector3();
    _quaternion = /* @__PURE__ */ new Quaternion();
    _scale = /* @__PURE__ */ new Vector3();
    _orientation = /* @__PURE__ */ new Vector3();
    PositionalAudio = class extends Audio {
      constructor(listener) {
        super(listener);
        this.panner = this.context.createPanner();
        this.panner.panningModel = "HRTF";
        this.panner.connect(this.gain);
      }
      connect() {
        super.connect();
        this.panner.connect(this.gain);
      }
      disconnect() {
        super.disconnect();
        this.panner.disconnect(this.gain);
      }
      getOutput() {
        return this.panner;
      }
      getRefDistance() {
        return this.panner.refDistance;
      }
      setRefDistance(value) {
        this.panner.refDistance = value;
        return this;
      }
      getRolloffFactor() {
        return this.panner.rolloffFactor;
      }
      setRolloffFactor(value) {
        this.panner.rolloffFactor = value;
        return this;
      }
      getDistanceModel() {
        return this.panner.distanceModel;
      }
      setDistanceModel(value) {
        this.panner.distanceModel = value;
        return this;
      }
      getMaxDistance() {
        return this.panner.maxDistance;
      }
      setMaxDistance(value) {
        this.panner.maxDistance = value;
        return this;
      }
      setDirectionalCone(coneInnerAngle, coneOuterAngle, coneOuterGain) {
        this.panner.coneInnerAngle = coneInnerAngle;
        this.panner.coneOuterAngle = coneOuterAngle;
        this.panner.coneOuterGain = coneOuterGain;
        return this;
      }
      updateMatrixWorld(force) {
        super.updateMatrixWorld(force);
        if (this.hasPlaybackControl === true && this.isPlaying === false) return;
        this.matrixWorld.decompose(_position, _quaternion, _scale);
        _orientation.set(0, 0, 1).applyQuaternion(_quaternion);
        const panner = this.panner;
        if (panner.positionX) {
          const endTime = this.context.currentTime + this.listener.timeDelta;
          panner.positionX.linearRampToValueAtTime(_position.x, endTime);
          panner.positionY.linearRampToValueAtTime(_position.y, endTime);
          panner.positionZ.linearRampToValueAtTime(_position.z, endTime);
          panner.orientationX.linearRampToValueAtTime(_orientation.x, endTime);
          panner.orientationY.linearRampToValueAtTime(_orientation.y, endTime);
          panner.orientationZ.linearRampToValueAtTime(_orientation.z, endTime);
        } else {
          panner.setPosition(_position.x, _position.y, _position.z);
          panner.setOrientation(_orientation.x, _orientation.y, _orientation.z);
        }
      }
    };
    AudioAnalyser = class {
      constructor(audio, fftSize = 2048) {
        this.analyser = audio.context.createAnalyser();
        this.analyser.fftSize = fftSize;
        this.data = new Uint8Array(this.analyser.frequencyBinCount);
        audio.getOutput().connect(this.analyser);
      }
      getFrequencyData() {
        this.analyser.getByteFrequencyData(this.data);
        return this.data;
      }
      getAverageFrequency() {
        let value = 0;
        const data = this.getFrequencyData();
        for (let i2 = 0; i2 < data.length; i2++) {
          value += data[i2];
        }
        return value / data.length;
      }
    };
    PropertyMixer = class {
      constructor(binding, typeName, valueSize) {
        this.binding = binding;
        this.valueSize = valueSize;
        let mixFunction, mixFunctionAdditive, setIdentity;
        switch (typeName) {
          case "quaternion":
            mixFunction = this._slerp;
            mixFunctionAdditive = this._slerpAdditive;
            setIdentity = this._setAdditiveIdentityQuaternion;
            this.buffer = new Float64Array(valueSize * 6);
            this._workIndex = 5;
            break;
          case "string":
          case "bool":
            mixFunction = this._select;
            mixFunctionAdditive = this._select;
            setIdentity = this._setAdditiveIdentityOther;
            this.buffer = new Array(valueSize * 5);
            break;
          default:
            mixFunction = this._lerp;
            mixFunctionAdditive = this._lerpAdditive;
            setIdentity = this._setAdditiveIdentityNumeric;
            this.buffer = new Float64Array(valueSize * 5);
        }
        this._mixBufferRegion = mixFunction;
        this._mixBufferRegionAdditive = mixFunctionAdditive;
        this._setIdentity = setIdentity;
        this._origIndex = 3;
        this._addIndex = 4;
        this.cumulativeWeight = 0;
        this.cumulativeWeightAdditive = 0;
        this.useCount = 0;
        this.referenceCount = 0;
      }
      // accumulate data in the 'incoming' region into 'accu<i>'
      accumulate(accuIndex, weight) {
        const buffer = this.buffer, stride = this.valueSize, offset = accuIndex * stride + stride;
        let currentWeight = this.cumulativeWeight;
        if (currentWeight === 0) {
          for (let i2 = 0; i2 !== stride; ++i2) {
            buffer[offset + i2] = buffer[i2];
          }
          currentWeight = weight;
        } else {
          currentWeight += weight;
          const mix = weight / currentWeight;
          this._mixBufferRegion(buffer, offset, 0, mix, stride);
        }
        this.cumulativeWeight = currentWeight;
      }
      // accumulate data in the 'incoming' region into 'add'
      accumulateAdditive(weight) {
        const buffer = this.buffer, stride = this.valueSize, offset = stride * this._addIndex;
        if (this.cumulativeWeightAdditive === 0) {
          this._setIdentity();
        }
        this._mixBufferRegionAdditive(buffer, offset, 0, weight, stride);
        this.cumulativeWeightAdditive += weight;
      }
      // apply the state of 'accu<i>' to the binding when accus differ
      apply(accuIndex) {
        const stride = this.valueSize, buffer = this.buffer, offset = accuIndex * stride + stride, weight = this.cumulativeWeight, weightAdditive = this.cumulativeWeightAdditive, binding = this.binding;
        this.cumulativeWeight = 0;
        this.cumulativeWeightAdditive = 0;
        if (weight < 1) {
          const originalValueOffset = stride * this._origIndex;
          this._mixBufferRegion(
            buffer,
            offset,
            originalValueOffset,
            1 - weight,
            stride
          );
        }
        if (weightAdditive > 0) {
          this._mixBufferRegionAdditive(buffer, offset, this._addIndex * stride, 1, stride);
        }
        for (let i2 = stride, e = stride + stride; i2 !== e; ++i2) {
          if (buffer[i2] !== buffer[i2 + stride]) {
            binding.setValue(buffer, offset);
            break;
          }
        }
      }
      // remember the state of the bound property and copy it to both accus
      saveOriginalState() {
        const binding = this.binding;
        const buffer = this.buffer, stride = this.valueSize, originalValueOffset = stride * this._origIndex;
        binding.getValue(buffer, originalValueOffset);
        for (let i2 = stride, e = originalValueOffset; i2 !== e; ++i2) {
          buffer[i2] = buffer[originalValueOffset + i2 % stride];
        }
        this._setIdentity();
        this.cumulativeWeight = 0;
        this.cumulativeWeightAdditive = 0;
      }
      // apply the state previously taken via 'saveOriginalState' to the binding
      restoreOriginalState() {
        const originalValueOffset = this.valueSize * 3;
        this.binding.setValue(this.buffer, originalValueOffset);
      }
      _setAdditiveIdentityNumeric() {
        const startIndex = this._addIndex * this.valueSize;
        const endIndex = startIndex + this.valueSize;
        for (let i2 = startIndex; i2 < endIndex; i2++) {
          this.buffer[i2] = 0;
        }
      }
      _setAdditiveIdentityQuaternion() {
        this._setAdditiveIdentityNumeric();
        this.buffer[this._addIndex * this.valueSize + 3] = 1;
      }
      _setAdditiveIdentityOther() {
        const startIndex = this._origIndex * this.valueSize;
        const targetIndex = this._addIndex * this.valueSize;
        for (let i2 = 0; i2 < this.valueSize; i2++) {
          this.buffer[targetIndex + i2] = this.buffer[startIndex + i2];
        }
      }
      // mix functions
      _select(buffer, dstOffset, srcOffset, t2, stride) {
        if (t2 >= 0.5) {
          for (let i2 = 0; i2 !== stride; ++i2) {
            buffer[dstOffset + i2] = buffer[srcOffset + i2];
          }
        }
      }
      _slerp(buffer, dstOffset, srcOffset, t2) {
        Quaternion.slerpFlat(buffer, dstOffset, buffer, dstOffset, buffer, srcOffset, t2);
      }
      _slerpAdditive(buffer, dstOffset, srcOffset, t2, stride) {
        const workOffset = this._workIndex * stride;
        Quaternion.multiplyQuaternionsFlat(buffer, workOffset, buffer, dstOffset, buffer, srcOffset);
        Quaternion.slerpFlat(buffer, dstOffset, buffer, dstOffset, buffer, workOffset, t2);
      }
      _lerp(buffer, dstOffset, srcOffset, t2, stride) {
        const s = 1 - t2;
        for (let i2 = 0; i2 !== stride; ++i2) {
          const j2 = dstOffset + i2;
          buffer[j2] = buffer[j2] * s + buffer[srcOffset + i2] * t2;
        }
      }
      _lerpAdditive(buffer, dstOffset, srcOffset, t2, stride) {
        for (let i2 = 0; i2 !== stride; ++i2) {
          const j2 = dstOffset + i2;
          buffer[j2] = buffer[j2] + buffer[srcOffset + i2] * t2;
        }
      }
    };
    _RESERVED_CHARS_RE = "\\[\\]\\.:\\/";
    _reservedRe = new RegExp("[" + _RESERVED_CHARS_RE + "]", "g");
    _wordChar = "[^" + _RESERVED_CHARS_RE + "]";
    _wordCharOrDot = "[^" + _RESERVED_CHARS_RE.replace("\\.", "") + "]";
    _directoryRe = /* @__PURE__ */ /((?:WC+[\/:])*)/.source.replace("WC", _wordChar);
    _nodeRe = /* @__PURE__ */ /(WCOD+)?/.source.replace("WCOD", _wordCharOrDot);
    _objectRe = /* @__PURE__ */ /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", _wordChar);
    _propertyRe = /* @__PURE__ */ /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", _wordChar);
    _trackRe = new RegExp(
      "^" + _directoryRe + _nodeRe + _objectRe + _propertyRe + "$"
    );
    _supportedObjectNames = ["material", "materials", "bones", "map"];
    Composite = class {
      constructor(targetGroup, path, optionalParsedPath) {
        const parsedPath = optionalParsedPath || PropertyBinding.parseTrackName(path);
        this._targetGroup = targetGroup;
        this._bindings = targetGroup.subscribe_(path, parsedPath);
      }
      getValue(array, offset) {
        this.bind();
        const firstValidIndex = this._targetGroup.nCachedObjects_, binding = this._bindings[firstValidIndex];
        if (binding !== void 0) binding.getValue(array, offset);
      }
      setValue(array, offset) {
        const bindings = this._bindings;
        for (let i2 = this._targetGroup.nCachedObjects_, n = bindings.length; i2 !== n; ++i2) {
          bindings[i2].setValue(array, offset);
        }
      }
      bind() {
        const bindings = this._bindings;
        for (let i2 = this._targetGroup.nCachedObjects_, n = bindings.length; i2 !== n; ++i2) {
          bindings[i2].bind();
        }
      }
      unbind() {
        const bindings = this._bindings;
        for (let i2 = this._targetGroup.nCachedObjects_, n = bindings.length; i2 !== n; ++i2) {
          bindings[i2].unbind();
        }
      }
    };
    PropertyBinding = class _PropertyBinding {
      constructor(rootNode, path, parsedPath) {
        this.path = path;
        this.parsedPath = parsedPath || _PropertyBinding.parseTrackName(path);
        this.node = _PropertyBinding.findNode(rootNode, this.parsedPath.nodeName);
        this.rootNode = rootNode;
        this.getValue = this._getValue_unbound;
        this.setValue = this._setValue_unbound;
      }
      static create(root, path, parsedPath) {
        if (!(root && root.isAnimationObjectGroup)) {
          return new _PropertyBinding(root, path, parsedPath);
        } else {
          return new _PropertyBinding.Composite(root, path, parsedPath);
        }
      }
      /**
       * Replaces spaces with underscores and removes unsupported characters from
       * node names, to ensure compatibility with parseTrackName().
       *
       * @param {string} name Node name to be sanitized.
       * @return {string}
       */
      static sanitizeNodeName(name) {
        return name.replace(/\s/g, "_").replace(_reservedRe, "");
      }
      static parseTrackName(trackName) {
        const matches = _trackRe.exec(trackName);
        if (matches === null) {
          throw new Error("PropertyBinding: Cannot parse trackName: " + trackName);
        }
        const results = {
          // directoryName: matches[ 1 ], // (tschw) currently unused
          nodeName: matches[2],
          objectName: matches[3],
          objectIndex: matches[4],
          propertyName: matches[5],
          // required
          propertyIndex: matches[6]
        };
        const lastDot = results.nodeName && results.nodeName.lastIndexOf(".");
        if (lastDot !== void 0 && lastDot !== -1) {
          const objectName = results.nodeName.substring(lastDot + 1);
          if (_supportedObjectNames.indexOf(objectName) !== -1) {
            results.nodeName = results.nodeName.substring(0, lastDot);
            results.objectName = objectName;
          }
        }
        if (results.propertyName === null || results.propertyName.length === 0) {
          throw new Error("PropertyBinding: can not parse propertyName from trackName: " + trackName);
        }
        return results;
      }
      static findNode(root, nodeName) {
        if (nodeName === void 0 || nodeName === "" || nodeName === "." || nodeName === -1 || nodeName === root.name || nodeName === root.uuid) {
          return root;
        }
        if (root.skeleton) {
          const bone = root.skeleton.getBoneByName(nodeName);
          if (bone !== void 0) {
            return bone;
          }
        }
        if (root.children) {
          const searchNodeSubtree = function(children) {
            for (let i2 = 0; i2 < children.length; i2++) {
              const childNode = children[i2];
              if (childNode.name === nodeName || childNode.uuid === nodeName) {
                return childNode;
              }
              const result = searchNodeSubtree(childNode.children);
              if (result) return result;
            }
            return null;
          };
          const subTreeNode = searchNodeSubtree(root.children);
          if (subTreeNode) {
            return subTreeNode;
          }
        }
        return null;
      }
      // these are used to "bind" a nonexistent property
      _getValue_unavailable() {
      }
      _setValue_unavailable() {
      }
      // Getters
      _getValue_direct(buffer, offset) {
        buffer[offset] = this.targetObject[this.propertyName];
      }
      _getValue_array(buffer, offset) {
        const source = this.resolvedProperty;
        for (let i2 = 0, n = source.length; i2 !== n; ++i2) {
          buffer[offset++] = source[i2];
        }
      }
      _getValue_arrayElement(buffer, offset) {
        buffer[offset] = this.resolvedProperty[this.propertyIndex];
      }
      _getValue_toArray(buffer, offset) {
        this.resolvedProperty.toArray(buffer, offset);
      }
      // Direct
      _setValue_direct(buffer, offset) {
        this.targetObject[this.propertyName] = buffer[offset];
      }
      _setValue_direct_setNeedsUpdate(buffer, offset) {
        this.targetObject[this.propertyName] = buffer[offset];
        this.targetObject.needsUpdate = true;
      }
      _setValue_direct_setMatrixWorldNeedsUpdate(buffer, offset) {
        this.targetObject[this.propertyName] = buffer[offset];
        this.targetObject.matrixWorldNeedsUpdate = true;
      }
      // EntireArray
      _setValue_array(buffer, offset) {
        const dest = this.resolvedProperty;
        for (let i2 = 0, n = dest.length; i2 !== n; ++i2) {
          dest[i2] = buffer[offset++];
        }
      }
      _setValue_array_setNeedsUpdate(buffer, offset) {
        const dest = this.resolvedProperty;
        for (let i2 = 0, n = dest.length; i2 !== n; ++i2) {
          dest[i2] = buffer[offset++];
        }
        this.targetObject.needsUpdate = true;
      }
      _setValue_array_setMatrixWorldNeedsUpdate(buffer, offset) {
        const dest = this.resolvedProperty;
        for (let i2 = 0, n = dest.length; i2 !== n; ++i2) {
          dest[i2] = buffer[offset++];
        }
        this.targetObject.matrixWorldNeedsUpdate = true;
      }
      // ArrayElement
      _setValue_arrayElement(buffer, offset) {
        this.resolvedProperty[this.propertyIndex] = buffer[offset];
      }
      _setValue_arrayElement_setNeedsUpdate(buffer, offset) {
        this.resolvedProperty[this.propertyIndex] = buffer[offset];
        this.targetObject.needsUpdate = true;
      }
      _setValue_arrayElement_setMatrixWorldNeedsUpdate(buffer, offset) {
        this.resolvedProperty[this.propertyIndex] = buffer[offset];
        this.targetObject.matrixWorldNeedsUpdate = true;
      }
      // HasToFromArray
      _setValue_fromArray(buffer, offset) {
        this.resolvedProperty.fromArray(buffer, offset);
      }
      _setValue_fromArray_setNeedsUpdate(buffer, offset) {
        this.resolvedProperty.fromArray(buffer, offset);
        this.targetObject.needsUpdate = true;
      }
      _setValue_fromArray_setMatrixWorldNeedsUpdate(buffer, offset) {
        this.resolvedProperty.fromArray(buffer, offset);
        this.targetObject.matrixWorldNeedsUpdate = true;
      }
      _getValue_unbound(targetArray, offset) {
        this.bind();
        this.getValue(targetArray, offset);
      }
      _setValue_unbound(sourceArray, offset) {
        this.bind();
        this.setValue(sourceArray, offset);
      }
      // create getter / setter pair for a property in the scene graph
      bind() {
        let targetObject = this.node;
        const parsedPath = this.parsedPath;
        const objectName = parsedPath.objectName;
        const propertyName = parsedPath.propertyName;
        let propertyIndex = parsedPath.propertyIndex;
        if (!targetObject) {
          targetObject = _PropertyBinding.findNode(this.rootNode, parsedPath.nodeName);
          this.node = targetObject;
        }
        this.getValue = this._getValue_unavailable;
        this.setValue = this._setValue_unavailable;
        if (!targetObject) {
          console.warn("THREE.PropertyBinding: No target node found for track: " + this.path + ".");
          return;
        }
        if (objectName) {
          let objectIndex = parsedPath.objectIndex;
          switch (objectName) {
            case "materials":
              if (!targetObject.material) {
                console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
                return;
              }
              if (!targetObject.material.materials) {
                console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
                return;
              }
              targetObject = targetObject.material.materials;
              break;
            case "bones":
              if (!targetObject.skeleton) {
                console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
                return;
              }
              targetObject = targetObject.skeleton.bones;
              for (let i2 = 0; i2 < targetObject.length; i2++) {
                if (targetObject[i2].name === objectIndex) {
                  objectIndex = i2;
                  break;
                }
              }
              break;
            case "map":
              if ("map" in targetObject) {
                targetObject = targetObject.map;
                break;
              }
              if (!targetObject.material) {
                console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
                return;
              }
              if (!targetObject.material.map) {
                console.error("THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.", this);
                return;
              }
              targetObject = targetObject.material.map;
              break;
            default:
              if (targetObject[objectName] === void 0) {
                console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
                return;
              }
              targetObject = targetObject[objectName];
          }
          if (objectIndex !== void 0) {
            if (targetObject[objectIndex] === void 0) {
              console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, targetObject);
              return;
            }
            targetObject = targetObject[objectIndex];
          }
        }
        const nodeProperty = targetObject[propertyName];
        if (nodeProperty === void 0) {
          const nodeName = parsedPath.nodeName;
          console.error("THREE.PropertyBinding: Trying to update property for track: " + nodeName + "." + propertyName + " but it wasn't found.", targetObject);
          return;
        }
        let versioning = this.Versioning.None;
        this.targetObject = targetObject;
        if (targetObject.needsUpdate !== void 0) {
          versioning = this.Versioning.NeedsUpdate;
        } else if (targetObject.matrixWorldNeedsUpdate !== void 0) {
          versioning = this.Versioning.MatrixWorldNeedsUpdate;
        }
        let bindingType = this.BindingType.Direct;
        if (propertyIndex !== void 0) {
          if (propertyName === "morphTargetInfluences") {
            if (!targetObject.geometry) {
              console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
              return;
            }
            if (!targetObject.geometry.morphAttributes) {
              console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
              return;
            }
            if (targetObject.morphTargetDictionary[propertyIndex] !== void 0) {
              propertyIndex = targetObject.morphTargetDictionary[propertyIndex];
            }
          }
          bindingType = this.BindingType.ArrayElement;
          this.resolvedProperty = nodeProperty;
          this.propertyIndex = propertyIndex;
        } else if (nodeProperty.fromArray !== void 0 && nodeProperty.toArray !== void 0) {
          bindingType = this.BindingType.HasFromToArray;
          this.resolvedProperty = nodeProperty;
        } else if (Array.isArray(nodeProperty)) {
          bindingType = this.BindingType.EntireArray;
          this.resolvedProperty = nodeProperty;
        } else {
          this.propertyName = propertyName;
        }
        this.getValue = this.GetterByBindingType[bindingType];
        this.setValue = this.SetterByBindingTypeAndVersioning[bindingType][versioning];
      }
      unbind() {
        this.node = null;
        this.getValue = this._getValue_unbound;
        this.setValue = this._setValue_unbound;
      }
    };
    PropertyBinding.Composite = Composite;
    PropertyBinding.prototype.BindingType = {
      Direct: 0,
      EntireArray: 1,
      ArrayElement: 2,
      HasFromToArray: 3
    };
    PropertyBinding.prototype.Versioning = {
      None: 0,
      NeedsUpdate: 1,
      MatrixWorldNeedsUpdate: 2
    };
    PropertyBinding.prototype.GetterByBindingType = [
      PropertyBinding.prototype._getValue_direct,
      PropertyBinding.prototype._getValue_array,
      PropertyBinding.prototype._getValue_arrayElement,
      PropertyBinding.prototype._getValue_toArray
    ];
    PropertyBinding.prototype.SetterByBindingTypeAndVersioning = [
      [
        // Direct
        PropertyBinding.prototype._setValue_direct,
        PropertyBinding.prototype._setValue_direct_setNeedsUpdate,
        PropertyBinding.prototype._setValue_direct_setMatrixWorldNeedsUpdate
      ],
      [
        // EntireArray
        PropertyBinding.prototype._setValue_array,
        PropertyBinding.prototype._setValue_array_setNeedsUpdate,
        PropertyBinding.prototype._setValue_array_setMatrixWorldNeedsUpdate
      ],
      [
        // ArrayElement
        PropertyBinding.prototype._setValue_arrayElement,
        PropertyBinding.prototype._setValue_arrayElement_setNeedsUpdate,
        PropertyBinding.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate
      ],
      [
        // HasToFromArray
        PropertyBinding.prototype._setValue_fromArray,
        PropertyBinding.prototype._setValue_fromArray_setNeedsUpdate,
        PropertyBinding.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate
      ]
    ];
    AnimationObjectGroup = class {
      constructor() {
        this.isAnimationObjectGroup = true;
        this.uuid = generateUUID();
        this._objects = Array.prototype.slice.call(arguments);
        this.nCachedObjects_ = 0;
        const indices = {};
        this._indicesByUUID = indices;
        for (let i2 = 0, n = arguments.length; i2 !== n; ++i2) {
          indices[arguments[i2].uuid] = i2;
        }
        this._paths = [];
        this._parsedPaths = [];
        this._bindings = [];
        this._bindingsIndicesByPath = {};
        const scope = this;
        this.stats = {
          objects: {
            get total() {
              return scope._objects.length;
            },
            get inUse() {
              return this.total - scope.nCachedObjects_;
            }
          },
          get bindingsPerObject() {
            return scope._bindings.length;
          }
        };
      }
      add() {
        const objects = this._objects, indicesByUUID = this._indicesByUUID, paths = this._paths, parsedPaths = this._parsedPaths, bindings = this._bindings, nBindings = bindings.length;
        let knownObject = void 0, nObjects = objects.length, nCachedObjects = this.nCachedObjects_;
        for (let i2 = 0, n = arguments.length; i2 !== n; ++i2) {
          const object = arguments[i2], uuid = object.uuid;
          let index = indicesByUUID[uuid];
          if (index === void 0) {
            index = nObjects++;
            indicesByUUID[uuid] = index;
            objects.push(object);
            for (let j2 = 0, m = nBindings; j2 !== m; ++j2) {
              bindings[j2].push(new PropertyBinding(object, paths[j2], parsedPaths[j2]));
            }
          } else if (index < nCachedObjects) {
            knownObject = objects[index];
            const firstActiveIndex = --nCachedObjects, lastCachedObject = objects[firstActiveIndex];
            indicesByUUID[lastCachedObject.uuid] = index;
            objects[index] = lastCachedObject;
            indicesByUUID[uuid] = firstActiveIndex;
            objects[firstActiveIndex] = object;
            for (let j2 = 0, m = nBindings; j2 !== m; ++j2) {
              const bindingsForPath = bindings[j2], lastCached = bindingsForPath[firstActiveIndex];
              let binding = bindingsForPath[index];
              bindingsForPath[index] = lastCached;
              if (binding === void 0) {
                binding = new PropertyBinding(object, paths[j2], parsedPaths[j2]);
              }
              bindingsForPath[firstActiveIndex] = binding;
            }
          } else if (objects[index] !== knownObject) {
            console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.");
          }
        }
        this.nCachedObjects_ = nCachedObjects;
      }
      remove() {
        const objects = this._objects, indicesByUUID = this._indicesByUUID, bindings = this._bindings, nBindings = bindings.length;
        let nCachedObjects = this.nCachedObjects_;
        for (let i2 = 0, n = arguments.length; i2 !== n; ++i2) {
          const object = arguments[i2], uuid = object.uuid, index = indicesByUUID[uuid];
          if (index !== void 0 && index >= nCachedObjects) {
            const lastCachedIndex = nCachedObjects++, firstActiveObject = objects[lastCachedIndex];
            indicesByUUID[firstActiveObject.uuid] = index;
            objects[index] = firstActiveObject;
            indicesByUUID[uuid] = lastCachedIndex;
            objects[lastCachedIndex] = object;
            for (let j2 = 0, m = nBindings; j2 !== m; ++j2) {
              const bindingsForPath = bindings[j2], firstActive = bindingsForPath[lastCachedIndex], binding = bindingsForPath[index];
              bindingsForPath[index] = firstActive;
              bindingsForPath[lastCachedIndex] = binding;
            }
          }
        }
        this.nCachedObjects_ = nCachedObjects;
      }
      // remove & forget
      uncache() {
        const objects = this._objects, indicesByUUID = this._indicesByUUID, bindings = this._bindings, nBindings = bindings.length;
        let nCachedObjects = this.nCachedObjects_, nObjects = objects.length;
        for (let i2 = 0, n = arguments.length; i2 !== n; ++i2) {
          const object = arguments[i2], uuid = object.uuid, index = indicesByUUID[uuid];
          if (index !== void 0) {
            delete indicesByUUID[uuid];
            if (index < nCachedObjects) {
              const firstActiveIndex = --nCachedObjects, lastCachedObject = objects[firstActiveIndex], lastIndex = --nObjects, lastObject = objects[lastIndex];
              indicesByUUID[lastCachedObject.uuid] = index;
              objects[index] = lastCachedObject;
              indicesByUUID[lastObject.uuid] = firstActiveIndex;
              objects[firstActiveIndex] = lastObject;
              objects.pop();
              for (let j2 = 0, m = nBindings; j2 !== m; ++j2) {
                const bindingsForPath = bindings[j2], lastCached = bindingsForPath[firstActiveIndex], last = bindingsForPath[lastIndex];
                bindingsForPath[index] = lastCached;
                bindingsForPath[firstActiveIndex] = last;
                bindingsForPath.pop();
              }
            } else {
              const lastIndex = --nObjects, lastObject = objects[lastIndex];
              if (lastIndex > 0) {
                indicesByUUID[lastObject.uuid] = index;
              }
              objects[index] = lastObject;
              objects.pop();
              for (let j2 = 0, m = nBindings; j2 !== m; ++j2) {
                const bindingsForPath = bindings[j2];
                bindingsForPath[index] = bindingsForPath[lastIndex];
                bindingsForPath.pop();
              }
            }
          }
        }
        this.nCachedObjects_ = nCachedObjects;
      }
      // Internal interface used by befriended PropertyBinding.Composite:
      subscribe_(path, parsedPath) {
        const indicesByPath = this._bindingsIndicesByPath;
        let index = indicesByPath[path];
        const bindings = this._bindings;
        if (index !== void 0) return bindings[index];
        const paths = this._paths, parsedPaths = this._parsedPaths, objects = this._objects, nObjects = objects.length, nCachedObjects = this.nCachedObjects_, bindingsForPath = new Array(nObjects);
        index = bindings.length;
        indicesByPath[path] = index;
        paths.push(path);
        parsedPaths.push(parsedPath);
        bindings.push(bindingsForPath);
        for (let i2 = nCachedObjects, n = objects.length; i2 !== n; ++i2) {
          const object = objects[i2];
          bindingsForPath[i2] = new PropertyBinding(object, path, parsedPath);
        }
        return bindingsForPath;
      }
      unsubscribe_(path) {
        const indicesByPath = this._bindingsIndicesByPath, index = indicesByPath[path];
        if (index !== void 0) {
          const paths = this._paths, parsedPaths = this._parsedPaths, bindings = this._bindings, lastBindingsIndex = bindings.length - 1, lastBindings = bindings[lastBindingsIndex], lastBindingsPath = path[lastBindingsIndex];
          indicesByPath[lastBindingsPath] = index;
          bindings[index] = lastBindings;
          bindings.pop();
          parsedPaths[index] = parsedPaths[lastBindingsIndex];
          parsedPaths.pop();
          paths[index] = paths[lastBindingsIndex];
          paths.pop();
        }
      }
    };
    AnimationAction = class {
      constructor(mixer, clip, localRoot = null, blendMode = clip.blendMode) {
        this._mixer = mixer;
        this._clip = clip;
        this._localRoot = localRoot;
        this.blendMode = blendMode;
        const tracks = clip.tracks, nTracks = tracks.length, interpolants = new Array(nTracks);
        const interpolantSettings = {
          endingStart: ZeroCurvatureEnding,
          endingEnd: ZeroCurvatureEnding
        };
        for (let i2 = 0; i2 !== nTracks; ++i2) {
          const interpolant = tracks[i2].createInterpolant(null);
          interpolants[i2] = interpolant;
          interpolant.settings = interpolantSettings;
        }
        this._interpolantSettings = interpolantSettings;
        this._interpolants = interpolants;
        this._propertyBindings = new Array(nTracks);
        this._cacheIndex = null;
        this._byClipCacheIndex = null;
        this._timeScaleInterpolant = null;
        this._weightInterpolant = null;
        this.loop = LoopRepeat;
        this._loopCount = -1;
        this._startTime = null;
        this.time = 0;
        this.timeScale = 1;
        this._effectiveTimeScale = 1;
        this.weight = 1;
        this._effectiveWeight = 1;
        this.repetitions = Infinity;
        this.paused = false;
        this.enabled = true;
        this.clampWhenFinished = false;
        this.zeroSlopeAtStart = true;
        this.zeroSlopeAtEnd = true;
      }
      // State & Scheduling
      play() {
        this._mixer._activateAction(this);
        return this;
      }
      stop() {
        this._mixer._deactivateAction(this);
        return this.reset();
      }
      reset() {
        this.paused = false;
        this.enabled = true;
        this.time = 0;
        this._loopCount = -1;
        this._startTime = null;
        return this.stopFading().stopWarping();
      }
      isRunning() {
        return this.enabled && !this.paused && this.timeScale !== 0 && this._startTime === null && this._mixer._isActiveAction(this);
      }
      // return true when play has been called
      isScheduled() {
        return this._mixer._isActiveAction(this);
      }
      startAt(time) {
        this._startTime = time;
        return this;
      }
      setLoop(mode, repetitions) {
        this.loop = mode;
        this.repetitions = repetitions;
        return this;
      }
      // Weight
      // set the weight stopping any scheduled fading
      // although .enabled = false yields an effective weight of zero, this
      // method does *not* change .enabled, because it would be confusing
      setEffectiveWeight(weight) {
        this.weight = weight;
        this._effectiveWeight = this.enabled ? weight : 0;
        return this.stopFading();
      }
      // return the weight considering fading and .enabled
      getEffectiveWeight() {
        return this._effectiveWeight;
      }
      fadeIn(duration) {
        return this._scheduleFading(duration, 0, 1);
      }
      fadeOut(duration) {
        return this._scheduleFading(duration, 1, 0);
      }
      crossFadeFrom(fadeOutAction, duration, warp) {
        fadeOutAction.fadeOut(duration);
        this.fadeIn(duration);
        if (warp) {
          const fadeInDuration = this._clip.duration, fadeOutDuration = fadeOutAction._clip.duration, startEndRatio = fadeOutDuration / fadeInDuration, endStartRatio = fadeInDuration / fadeOutDuration;
          fadeOutAction.warp(1, startEndRatio, duration);
          this.warp(endStartRatio, 1, duration);
        }
        return this;
      }
      crossFadeTo(fadeInAction, duration, warp) {
        return fadeInAction.crossFadeFrom(this, duration, warp);
      }
      stopFading() {
        const weightInterpolant = this._weightInterpolant;
        if (weightInterpolant !== null) {
          this._weightInterpolant = null;
          this._mixer._takeBackControlInterpolant(weightInterpolant);
        }
        return this;
      }
      // Time Scale Control
      // set the time scale stopping any scheduled warping
      // although .paused = true yields an effective time scale of zero, this
      // method does *not* change .paused, because it would be confusing
      setEffectiveTimeScale(timeScale) {
        this.timeScale = timeScale;
        this._effectiveTimeScale = this.paused ? 0 : timeScale;
        return this.stopWarping();
      }
      // return the time scale considering warping and .paused
      getEffectiveTimeScale() {
        return this._effectiveTimeScale;
      }
      setDuration(duration) {
        this.timeScale = this._clip.duration / duration;
        return this.stopWarping();
      }
      syncWith(action) {
        this.time = action.time;
        this.timeScale = action.timeScale;
        return this.stopWarping();
      }
      halt(duration) {
        return this.warp(this._effectiveTimeScale, 0, duration);
      }
      warp(startTimeScale, endTimeScale, duration) {
        const mixer = this._mixer, now2 = mixer.time, timeScale = this.timeScale;
        let interpolant = this._timeScaleInterpolant;
        if (interpolant === null) {
          interpolant = mixer._lendControlInterpolant();
          this._timeScaleInterpolant = interpolant;
        }
        const times = interpolant.parameterPositions, values = interpolant.sampleValues;
        times[0] = now2;
        times[1] = now2 + duration;
        values[0] = startTimeScale / timeScale;
        values[1] = endTimeScale / timeScale;
        return this;
      }
      stopWarping() {
        const timeScaleInterpolant = this._timeScaleInterpolant;
        if (timeScaleInterpolant !== null) {
          this._timeScaleInterpolant = null;
          this._mixer._takeBackControlInterpolant(timeScaleInterpolant);
        }
        return this;
      }
      // Object Accessors
      getMixer() {
        return this._mixer;
      }
      getClip() {
        return this._clip;
      }
      getRoot() {
        return this._localRoot || this._mixer._root;
      }
      // Interna
      _update(time, deltaTime, timeDirection, accuIndex) {
        if (!this.enabled) {
          this._updateWeight(time);
          return;
        }
        const startTime = this._startTime;
        if (startTime !== null) {
          const timeRunning = (time - startTime) * timeDirection;
          if (timeRunning < 0 || timeDirection === 0) {
            deltaTime = 0;
          } else {
            this._startTime = null;
            deltaTime = timeDirection * timeRunning;
          }
        }
        deltaTime *= this._updateTimeScale(time);
        const clipTime = this._updateTime(deltaTime);
        const weight = this._updateWeight(time);
        if (weight > 0) {
          const interpolants = this._interpolants;
          const propertyMixers = this._propertyBindings;
          switch (this.blendMode) {
            case AdditiveAnimationBlendMode:
              for (let j2 = 0, m = interpolants.length; j2 !== m; ++j2) {
                interpolants[j2].evaluate(clipTime);
                propertyMixers[j2].accumulateAdditive(weight);
              }
              break;
            case NormalAnimationBlendMode:
            default:
              for (let j2 = 0, m = interpolants.length; j2 !== m; ++j2) {
                interpolants[j2].evaluate(clipTime);
                propertyMixers[j2].accumulate(accuIndex, weight);
              }
          }
        }
      }
      _updateWeight(time) {
        let weight = 0;
        if (this.enabled) {
          weight = this.weight;
          const interpolant = this._weightInterpolant;
          if (interpolant !== null) {
            const interpolantValue = interpolant.evaluate(time)[0];
            weight *= interpolantValue;
            if (time > interpolant.parameterPositions[1]) {
              this.stopFading();
              if (interpolantValue === 0) {
                this.enabled = false;
              }
            }
          }
        }
        this._effectiveWeight = weight;
        return weight;
      }
      _updateTimeScale(time) {
        let timeScale = 0;
        if (!this.paused) {
          timeScale = this.timeScale;
          const interpolant = this._timeScaleInterpolant;
          if (interpolant !== null) {
            const interpolantValue = interpolant.evaluate(time)[0];
            timeScale *= interpolantValue;
            if (time > interpolant.parameterPositions[1]) {
              this.stopWarping();
              if (timeScale === 0) {
                this.paused = true;
              } else {
                this.timeScale = timeScale;
              }
            }
          }
        }
        this._effectiveTimeScale = timeScale;
        return timeScale;
      }
      _updateTime(deltaTime) {
        const duration = this._clip.duration;
        const loop = this.loop;
        let time = this.time + deltaTime;
        let loopCount = this._loopCount;
        const pingPong = loop === LoopPingPong;
        if (deltaTime === 0) {
          if (loopCount === -1) return time;
          return pingPong && (loopCount & 1) === 1 ? duration - time : time;
        }
        if (loop === LoopOnce) {
          if (loopCount === -1) {
            this._loopCount = 0;
            this._setEndings(true, true, false);
          }
          handle_stop: {
            if (time >= duration) {
              time = duration;
            } else if (time < 0) {
              time = 0;
            } else {
              this.time = time;
              break handle_stop;
            }
            if (this.clampWhenFinished) this.paused = true;
            else this.enabled = false;
            this.time = time;
            this._mixer.dispatchEvent({
              type: "finished",
              action: this,
              direction: deltaTime < 0 ? -1 : 1
            });
          }
        } else {
          if (loopCount === -1) {
            if (deltaTime >= 0) {
              loopCount = 0;
              this._setEndings(true, this.repetitions === 0, pingPong);
            } else {
              this._setEndings(this.repetitions === 0, true, pingPong);
            }
          }
          if (time >= duration || time < 0) {
            const loopDelta = Math.floor(time / duration);
            time -= duration * loopDelta;
            loopCount += Math.abs(loopDelta);
            const pending = this.repetitions - loopCount;
            if (pending <= 0) {
              if (this.clampWhenFinished) this.paused = true;
              else this.enabled = false;
              time = deltaTime > 0 ? duration : 0;
              this.time = time;
              this._mixer.dispatchEvent({
                type: "finished",
                action: this,
                direction: deltaTime > 0 ? 1 : -1
              });
            } else {
              if (pending === 1) {
                const atStart = deltaTime < 0;
                this._setEndings(atStart, !atStart, pingPong);
              } else {
                this._setEndings(false, false, pingPong);
              }
              this._loopCount = loopCount;
              this.time = time;
              this._mixer.dispatchEvent({
                type: "loop",
                action: this,
                loopDelta
              });
            }
          } else {
            this.time = time;
          }
          if (pingPong && (loopCount & 1) === 1) {
            return duration - time;
          }
        }
        return time;
      }
      _setEndings(atStart, atEnd, pingPong) {
        const settings = this._interpolantSettings;
        if (pingPong) {
          settings.endingStart = ZeroSlopeEnding;
          settings.endingEnd = ZeroSlopeEnding;
        } else {
          if (atStart) {
            settings.endingStart = this.zeroSlopeAtStart ? ZeroSlopeEnding : ZeroCurvatureEnding;
          } else {
            settings.endingStart = WrapAroundEnding;
          }
          if (atEnd) {
            settings.endingEnd = this.zeroSlopeAtEnd ? ZeroSlopeEnding : ZeroCurvatureEnding;
          } else {
            settings.endingEnd = WrapAroundEnding;
          }
        }
      }
      _scheduleFading(duration, weightNow, weightThen) {
        const mixer = this._mixer, now2 = mixer.time;
        let interpolant = this._weightInterpolant;
        if (interpolant === null) {
          interpolant = mixer._lendControlInterpolant();
          this._weightInterpolant = interpolant;
        }
        const times = interpolant.parameterPositions, values = interpolant.sampleValues;
        times[0] = now2;
        values[0] = weightNow;
        times[1] = now2 + duration;
        values[1] = weightThen;
        return this;
      }
    };
    _controlInterpolantsResultBuffer = new Float32Array(1);
    AnimationMixer = class extends EventDispatcher {
      constructor(root) {
        super();
        this._root = root;
        this._initMemoryManager();
        this._accuIndex = 0;
        this.time = 0;
        this.timeScale = 1;
      }
      _bindAction(action, prototypeAction) {
        const root = action._localRoot || this._root, tracks = action._clip.tracks, nTracks = tracks.length, bindings = action._propertyBindings, interpolants = action._interpolants, rootUuid = root.uuid, bindingsByRoot = this._bindingsByRootAndName;
        let bindingsByName = bindingsByRoot[rootUuid];
        if (bindingsByName === void 0) {
          bindingsByName = {};
          bindingsByRoot[rootUuid] = bindingsByName;
        }
        for (let i2 = 0; i2 !== nTracks; ++i2) {
          const track = tracks[i2], trackName = track.name;
          let binding = bindingsByName[trackName];
          if (binding !== void 0) {
            ++binding.referenceCount;
            bindings[i2] = binding;
          } else {
            binding = bindings[i2];
            if (binding !== void 0) {
              if (binding._cacheIndex === null) {
                ++binding.referenceCount;
                this._addInactiveBinding(binding, rootUuid, trackName);
              }
              continue;
            }
            const path = prototypeAction && prototypeAction._propertyBindings[i2].binding.parsedPath;
            binding = new PropertyMixer(
              PropertyBinding.create(root, trackName, path),
              track.ValueTypeName,
              track.getValueSize()
            );
            ++binding.referenceCount;
            this._addInactiveBinding(binding, rootUuid, trackName);
            bindings[i2] = binding;
          }
          interpolants[i2].resultBuffer = binding.buffer;
        }
      }
      _activateAction(action) {
        if (!this._isActiveAction(action)) {
          if (action._cacheIndex === null) {
            const rootUuid = (action._localRoot || this._root).uuid, clipUuid = action._clip.uuid, actionsForClip = this._actionsByClip[clipUuid];
            this._bindAction(
              action,
              actionsForClip && actionsForClip.knownActions[0]
            );
            this._addInactiveAction(action, clipUuid, rootUuid);
          }
          const bindings = action._propertyBindings;
          for (let i2 = 0, n = bindings.length; i2 !== n; ++i2) {
            const binding = bindings[i2];
            if (binding.useCount++ === 0) {
              this._lendBinding(binding);
              binding.saveOriginalState();
            }
          }
          this._lendAction(action);
        }
      }
      _deactivateAction(action) {
        if (this._isActiveAction(action)) {
          const bindings = action._propertyBindings;
          for (let i2 = 0, n = bindings.length; i2 !== n; ++i2) {
            const binding = bindings[i2];
            if (--binding.useCount === 0) {
              binding.restoreOriginalState();
              this._takeBackBinding(binding);
            }
          }
          this._takeBackAction(action);
        }
      }
      // Memory manager
      _initMemoryManager() {
        this._actions = [];
        this._nActiveActions = 0;
        this._actionsByClip = {};
        this._bindings = [];
        this._nActiveBindings = 0;
        this._bindingsByRootAndName = {};
        this._controlInterpolants = [];
        this._nActiveControlInterpolants = 0;
        const scope = this;
        this.stats = {
          actions: {
            get total() {
              return scope._actions.length;
            },
            get inUse() {
              return scope._nActiveActions;
            }
          },
          bindings: {
            get total() {
              return scope._bindings.length;
            },
            get inUse() {
              return scope._nActiveBindings;
            }
          },
          controlInterpolants: {
            get total() {
              return scope._controlInterpolants.length;
            },
            get inUse() {
              return scope._nActiveControlInterpolants;
            }
          }
        };
      }
      // Memory management for AnimationAction objects
      _isActiveAction(action) {
        const index = action._cacheIndex;
        return index !== null && index < this._nActiveActions;
      }
      _addInactiveAction(action, clipUuid, rootUuid) {
        const actions = this._actions, actionsByClip = this._actionsByClip;
        let actionsForClip = actionsByClip[clipUuid];
        if (actionsForClip === void 0) {
          actionsForClip = {
            knownActions: [action],
            actionByRoot: {}
          };
          action._byClipCacheIndex = 0;
          actionsByClip[clipUuid] = actionsForClip;
        } else {
          const knownActions = actionsForClip.knownActions;
          action._byClipCacheIndex = knownActions.length;
          knownActions.push(action);
        }
        action._cacheIndex = actions.length;
        actions.push(action);
        actionsForClip.actionByRoot[rootUuid] = action;
      }
      _removeInactiveAction(action) {
        const actions = this._actions, lastInactiveAction = actions[actions.length - 1], cacheIndex = action._cacheIndex;
        lastInactiveAction._cacheIndex = cacheIndex;
        actions[cacheIndex] = lastInactiveAction;
        actions.pop();
        action._cacheIndex = null;
        const clipUuid = action._clip.uuid, actionsByClip = this._actionsByClip, actionsForClip = actionsByClip[clipUuid], knownActionsForClip = actionsForClip.knownActions, lastKnownAction = knownActionsForClip[knownActionsForClip.length - 1], byClipCacheIndex = action._byClipCacheIndex;
        lastKnownAction._byClipCacheIndex = byClipCacheIndex;
        knownActionsForClip[byClipCacheIndex] = lastKnownAction;
        knownActionsForClip.pop();
        action._byClipCacheIndex = null;
        const actionByRoot = actionsForClip.actionByRoot, rootUuid = (action._localRoot || this._root).uuid;
        delete actionByRoot[rootUuid];
        if (knownActionsForClip.length === 0) {
          delete actionsByClip[clipUuid];
        }
        this._removeInactiveBindingsForAction(action);
      }
      _removeInactiveBindingsForAction(action) {
        const bindings = action._propertyBindings;
        for (let i2 = 0, n = bindings.length; i2 !== n; ++i2) {
          const binding = bindings[i2];
          if (--binding.referenceCount === 0) {
            this._removeInactiveBinding(binding);
          }
        }
      }
      _lendAction(action) {
        const actions = this._actions, prevIndex = action._cacheIndex, lastActiveIndex = this._nActiveActions++, firstInactiveAction = actions[lastActiveIndex];
        action._cacheIndex = lastActiveIndex;
        actions[lastActiveIndex] = action;
        firstInactiveAction._cacheIndex = prevIndex;
        actions[prevIndex] = firstInactiveAction;
      }
      _takeBackAction(action) {
        const actions = this._actions, prevIndex = action._cacheIndex, firstInactiveIndex = --this._nActiveActions, lastActiveAction = actions[firstInactiveIndex];
        action._cacheIndex = firstInactiveIndex;
        actions[firstInactiveIndex] = action;
        lastActiveAction._cacheIndex = prevIndex;
        actions[prevIndex] = lastActiveAction;
      }
      // Memory management for PropertyMixer objects
      _addInactiveBinding(binding, rootUuid, trackName) {
        const bindingsByRoot = this._bindingsByRootAndName, bindings = this._bindings;
        let bindingByName = bindingsByRoot[rootUuid];
        if (bindingByName === void 0) {
          bindingByName = {};
          bindingsByRoot[rootUuid] = bindingByName;
        }
        bindingByName[trackName] = binding;
        binding._cacheIndex = bindings.length;
        bindings.push(binding);
      }
      _removeInactiveBinding(binding) {
        const bindings = this._bindings, propBinding = binding.binding, rootUuid = propBinding.rootNode.uuid, trackName = propBinding.path, bindingsByRoot = this._bindingsByRootAndName, bindingByName = bindingsByRoot[rootUuid], lastInactiveBinding = bindings[bindings.length - 1], cacheIndex = binding._cacheIndex;
        lastInactiveBinding._cacheIndex = cacheIndex;
        bindings[cacheIndex] = lastInactiveBinding;
        bindings.pop();
        delete bindingByName[trackName];
        if (Object.keys(bindingByName).length === 0) {
          delete bindingsByRoot[rootUuid];
        }
      }
      _lendBinding(binding) {
        const bindings = this._bindings, prevIndex = binding._cacheIndex, lastActiveIndex = this._nActiveBindings++, firstInactiveBinding = bindings[lastActiveIndex];
        binding._cacheIndex = lastActiveIndex;
        bindings[lastActiveIndex] = binding;
        firstInactiveBinding._cacheIndex = prevIndex;
        bindings[prevIndex] = firstInactiveBinding;
      }
      _takeBackBinding(binding) {
        const bindings = this._bindings, prevIndex = binding._cacheIndex, firstInactiveIndex = --this._nActiveBindings, lastActiveBinding = bindings[firstInactiveIndex];
        binding._cacheIndex = firstInactiveIndex;
        bindings[firstInactiveIndex] = binding;
        lastActiveBinding._cacheIndex = prevIndex;
        bindings[prevIndex] = lastActiveBinding;
      }
      // Memory management of Interpolants for weight and time scale
      _lendControlInterpolant() {
        const interpolants = this._controlInterpolants, lastActiveIndex = this._nActiveControlInterpolants++;
        let interpolant = interpolants[lastActiveIndex];
        if (interpolant === void 0) {
          interpolant = new LinearInterpolant(
            new Float32Array(2),
            new Float32Array(2),
            1,
            _controlInterpolantsResultBuffer
          );
          interpolant.__cacheIndex = lastActiveIndex;
          interpolants[lastActiveIndex] = interpolant;
        }
        return interpolant;
      }
      _takeBackControlInterpolant(interpolant) {
        const interpolants = this._controlInterpolants, prevIndex = interpolant.__cacheIndex, firstInactiveIndex = --this._nActiveControlInterpolants, lastActiveInterpolant = interpolants[firstInactiveIndex];
        interpolant.__cacheIndex = firstInactiveIndex;
        interpolants[firstInactiveIndex] = interpolant;
        lastActiveInterpolant.__cacheIndex = prevIndex;
        interpolants[prevIndex] = lastActiveInterpolant;
      }
      // return an action for a clip optionally using a custom root target
      // object (this method allocates a lot of dynamic memory in case a
      // previously unknown clip/root combination is specified)
      clipAction(clip, optionalRoot, blendMode) {
        const root = optionalRoot || this._root, rootUuid = root.uuid;
        let clipObject = typeof clip === "string" ? AnimationClip.findByName(root, clip) : clip;
        const clipUuid = clipObject !== null ? clipObject.uuid : clip;
        const actionsForClip = this._actionsByClip[clipUuid];
        let prototypeAction = null;
        if (blendMode === void 0) {
          if (clipObject !== null) {
            blendMode = clipObject.blendMode;
          } else {
            blendMode = NormalAnimationBlendMode;
          }
        }
        if (actionsForClip !== void 0) {
          const existingAction = actionsForClip.actionByRoot[rootUuid];
          if (existingAction !== void 0 && existingAction.blendMode === blendMode) {
            return existingAction;
          }
          prototypeAction = actionsForClip.knownActions[0];
          if (clipObject === null)
            clipObject = prototypeAction._clip;
        }
        if (clipObject === null) return null;
        const newAction = new AnimationAction(this, clipObject, optionalRoot, blendMode);
        this._bindAction(newAction, prototypeAction);
        this._addInactiveAction(newAction, clipUuid, rootUuid);
        return newAction;
      }
      // get an existing action
      existingAction(clip, optionalRoot) {
        const root = optionalRoot || this._root, rootUuid = root.uuid, clipObject = typeof clip === "string" ? AnimationClip.findByName(root, clip) : clip, clipUuid = clipObject ? clipObject.uuid : clip, actionsForClip = this._actionsByClip[clipUuid];
        if (actionsForClip !== void 0) {
          return actionsForClip.actionByRoot[rootUuid] || null;
        }
        return null;
      }
      // deactivates all previously scheduled actions
      stopAllAction() {
        const actions = this._actions, nActions = this._nActiveActions;
        for (let i2 = nActions - 1; i2 >= 0; --i2) {
          actions[i2].stop();
        }
        return this;
      }
      // advance the time and update apply the animation
      update(deltaTime) {
        deltaTime *= this.timeScale;
        const actions = this._actions, nActions = this._nActiveActions, time = this.time += deltaTime, timeDirection = Math.sign(deltaTime), accuIndex = this._accuIndex ^= 1;
        for (let i2 = 0; i2 !== nActions; ++i2) {
          const action = actions[i2];
          action._update(time, deltaTime, timeDirection, accuIndex);
        }
        const bindings = this._bindings, nBindings = this._nActiveBindings;
        for (let i2 = 0; i2 !== nBindings; ++i2) {
          bindings[i2].apply(accuIndex);
        }
        return this;
      }
      // Allows you to seek to a specific time in an animation.
      setTime(timeInSeconds) {
        this.time = 0;
        for (let i2 = 0; i2 < this._actions.length; i2++) {
          this._actions[i2].time = 0;
        }
        return this.update(timeInSeconds);
      }
      // return this mixer's root target object
      getRoot() {
        return this._root;
      }
      // free all resources specific to a particular clip
      uncacheClip(clip) {
        const actions = this._actions, clipUuid = clip.uuid, actionsByClip = this._actionsByClip, actionsForClip = actionsByClip[clipUuid];
        if (actionsForClip !== void 0) {
          const actionsToRemove = actionsForClip.knownActions;
          for (let i2 = 0, n = actionsToRemove.length; i2 !== n; ++i2) {
            const action = actionsToRemove[i2];
            this._deactivateAction(action);
            const cacheIndex = action._cacheIndex, lastInactiveAction = actions[actions.length - 1];
            action._cacheIndex = null;
            action._byClipCacheIndex = null;
            lastInactiveAction._cacheIndex = cacheIndex;
            actions[cacheIndex] = lastInactiveAction;
            actions.pop();
            this._removeInactiveBindingsForAction(action);
          }
          delete actionsByClip[clipUuid];
        }
      }
      // free all resources specific to a particular root target object
      uncacheRoot(root) {
        const rootUuid = root.uuid, actionsByClip = this._actionsByClip;
        for (const clipUuid in actionsByClip) {
          const actionByRoot = actionsByClip[clipUuid].actionByRoot, action = actionByRoot[rootUuid];
          if (action !== void 0) {
            this._deactivateAction(action);
            this._removeInactiveAction(action);
          }
        }
        const bindingsByRoot = this._bindingsByRootAndName, bindingByName = bindingsByRoot[rootUuid];
        if (bindingByName !== void 0) {
          for (const trackName in bindingByName) {
            const binding = bindingByName[trackName];
            binding.restoreOriginalState();
            this._removeInactiveBinding(binding);
          }
        }
      }
      // remove a targeted clip from the cache
      uncacheAction(clip, optionalRoot) {
        const action = this.existingAction(clip, optionalRoot);
        if (action !== null) {
          this._deactivateAction(action);
          this._removeInactiveAction(action);
        }
      }
    };
    Uniform = class _Uniform {
      constructor(value) {
        this.value = value;
      }
      clone() {
        return new _Uniform(this.value.clone === void 0 ? this.value : this.value.clone());
      }
    };
    _id = 0;
    UniformsGroup = class extends EventDispatcher {
      constructor() {
        super();
        this.isUniformsGroup = true;
        Object.defineProperty(this, "id", { value: _id++ });
        this.name = "";
        this.usage = StaticDrawUsage;
        this.uniforms = [];
      }
      add(uniform) {
        this.uniforms.push(uniform);
        return this;
      }
      remove(uniform) {
        const index = this.uniforms.indexOf(uniform);
        if (index !== -1) this.uniforms.splice(index, 1);
        return this;
      }
      setName(name) {
        this.name = name;
        return this;
      }
      setUsage(value) {
        this.usage = value;
        return this;
      }
      dispose() {
        this.dispatchEvent({ type: "dispose" });
        return this;
      }
      copy(source) {
        this.name = source.name;
        this.usage = source.usage;
        const uniformsSource = source.uniforms;
        this.uniforms.length = 0;
        for (let i2 = 0, l2 = uniformsSource.length; i2 < l2; i2++) {
          const uniforms = Array.isArray(uniformsSource[i2]) ? uniformsSource[i2] : [uniformsSource[i2]];
          for (let j2 = 0; j2 < uniforms.length; j2++) {
            this.uniforms.push(uniforms[j2].clone());
          }
        }
        return this;
      }
      clone() {
        return new this.constructor().copy(this);
      }
    };
    InstancedInterleavedBuffer = class extends InterleavedBuffer {
      constructor(array, stride, meshPerAttribute = 1) {
        super(array, stride);
        this.isInstancedInterleavedBuffer = true;
        this.meshPerAttribute = meshPerAttribute;
      }
      copy(source) {
        super.copy(source);
        this.meshPerAttribute = source.meshPerAttribute;
        return this;
      }
      clone(data) {
        const ib = super.clone(data);
        ib.meshPerAttribute = this.meshPerAttribute;
        return ib;
      }
      toJSON(data) {
        const json = super.toJSON(data);
        json.isInstancedInterleavedBuffer = true;
        json.meshPerAttribute = this.meshPerAttribute;
        return json;
      }
    };
    GLBufferAttribute = class {
      constructor(buffer, type, itemSize, elementSize, count) {
        this.isGLBufferAttribute = true;
        this.name = "";
        this.buffer = buffer;
        this.type = type;
        this.itemSize = itemSize;
        this.elementSize = elementSize;
        this.count = count;
        this.version = 0;
      }
      set needsUpdate(value) {
        if (value === true) this.version++;
      }
      setBuffer(buffer) {
        this.buffer = buffer;
        return this;
      }
      setType(type, elementSize) {
        this.type = type;
        this.elementSize = elementSize;
        return this;
      }
      setItemSize(itemSize) {
        this.itemSize = itemSize;
        return this;
      }
      setCount(count) {
        this.count = count;
        return this;
      }
    };
    _matrix = /* @__PURE__ */ new Matrix4();
    Raycaster = class {
      constructor(origin, direction, near = 0, far = Infinity) {
        this.ray = new Ray(origin, direction);
        this.near = near;
        this.far = far;
        this.camera = null;
        this.layers = new Layers();
        this.params = {
          Mesh: {},
          Line: { threshold: 1 },
          LOD: {},
          Points: { threshold: 1 },
          Sprite: {}
        };
      }
      set(origin, direction) {
        this.ray.set(origin, direction);
      }
      setFromCamera(coords, camera) {
        if (camera.isPerspectiveCamera) {
          this.ray.origin.setFromMatrixPosition(camera.matrixWorld);
          this.ray.direction.set(coords.x, coords.y, 0.5).unproject(camera).sub(this.ray.origin).normalize();
          this.camera = camera;
        } else if (camera.isOrthographicCamera) {
          this.ray.origin.set(coords.x, coords.y, (camera.near + camera.far) / (camera.near - camera.far)).unproject(camera);
          this.ray.direction.set(0, 0, -1).transformDirection(camera.matrixWorld);
          this.camera = camera;
        } else {
          console.error("THREE.Raycaster: Unsupported camera type: " + camera.type);
        }
      }
      setFromXRController(controller) {
        _matrix.identity().extractRotation(controller.matrixWorld);
        this.ray.origin.setFromMatrixPosition(controller.matrixWorld);
        this.ray.direction.set(0, 0, -1).applyMatrix4(_matrix);
        return this;
      }
      intersectObject(object, recursive = true, intersects2 = []) {
        intersect(object, this, intersects2, recursive);
        intersects2.sort(ascSort);
        return intersects2;
      }
      intersectObjects(objects, recursive = true, intersects2 = []) {
        for (let i2 = 0, l2 = objects.length; i2 < l2; i2++) {
          intersect(objects[i2], this, intersects2, recursive);
        }
        intersects2.sort(ascSort);
        return intersects2;
      }
    };
    Spherical = class {
      constructor(radius = 1, phi = 0, theta = 0) {
        this.radius = radius;
        this.phi = phi;
        this.theta = theta;
        return this;
      }
      set(radius, phi, theta) {
        this.radius = radius;
        this.phi = phi;
        this.theta = theta;
        return this;
      }
      copy(other) {
        this.radius = other.radius;
        this.phi = other.phi;
        this.theta = other.theta;
        return this;
      }
      // restrict phi to be between EPS and PI-EPS
      makeSafe() {
        const EPS = 1e-6;
        this.phi = Math.max(EPS, Math.min(Math.PI - EPS, this.phi));
        return this;
      }
      setFromVector3(v2) {
        return this.setFromCartesianCoords(v2.x, v2.y, v2.z);
      }
      setFromCartesianCoords(x, y2, z2) {
        this.radius = Math.sqrt(x * x + y2 * y2 + z2 * z2);
        if (this.radius === 0) {
          this.theta = 0;
          this.phi = 0;
        } else {
          this.theta = Math.atan2(x, z2);
          this.phi = Math.acos(clamp(y2 / this.radius, -1, 1));
        }
        return this;
      }
      clone() {
        return new this.constructor().copy(this);
      }
    };
    Cylindrical = class {
      constructor(radius = 1, theta = 0, y2 = 0) {
        this.radius = radius;
        this.theta = theta;
        this.y = y2;
        return this;
      }
      set(radius, theta, y2) {
        this.radius = radius;
        this.theta = theta;
        this.y = y2;
        return this;
      }
      copy(other) {
        this.radius = other.radius;
        this.theta = other.theta;
        this.y = other.y;
        return this;
      }
      setFromVector3(v2) {
        return this.setFromCartesianCoords(v2.x, v2.y, v2.z);
      }
      setFromCartesianCoords(x, y2, z2) {
        this.radius = Math.sqrt(x * x + z2 * z2);
        this.theta = Math.atan2(x, z2);
        this.y = y2;
        return this;
      }
      clone() {
        return new this.constructor().copy(this);
      }
    };
    Matrix2 = class _Matrix2 {
      constructor(n11, n12, n21, n22) {
        _Matrix2.prototype.isMatrix2 = true;
        this.elements = [
          1,
          0,
          0,
          1
        ];
        if (n11 !== void 0) {
          this.set(n11, n12, n21, n22);
        }
      }
      identity() {
        this.set(
          1,
          0,
          0,
          1
        );
        return this;
      }
      fromArray(array, offset = 0) {
        for (let i2 = 0; i2 < 4; i2++) {
          this.elements[i2] = array[i2 + offset];
        }
        return this;
      }
      set(n11, n12, n21, n22) {
        const te = this.elements;
        te[0] = n11;
        te[2] = n12;
        te[1] = n21;
        te[3] = n22;
        return this;
      }
    };
    _vector$4 = /* @__PURE__ */ new Vector2();
    Box2 = class {
      constructor(min = new Vector2(Infinity, Infinity), max = new Vector2(-Infinity, -Infinity)) {
        this.isBox2 = true;
        this.min = min;
        this.max = max;
      }
      set(min, max) {
        this.min.copy(min);
        this.max.copy(max);
        return this;
      }
      setFromPoints(points) {
        this.makeEmpty();
        for (let i2 = 0, il = points.length; i2 < il; i2++) {
          this.expandByPoint(points[i2]);
        }
        return this;
      }
      setFromCenterAndSize(center, size) {
        const halfSize = _vector$4.copy(size).multiplyScalar(0.5);
        this.min.copy(center).sub(halfSize);
        this.max.copy(center).add(halfSize);
        return this;
      }
      clone() {
        return new this.constructor().copy(this);
      }
      copy(box) {
        this.min.copy(box.min);
        this.max.copy(box.max);
        return this;
      }
      makeEmpty() {
        this.min.x = this.min.y = Infinity;
        this.max.x = this.max.y = -Infinity;
        return this;
      }
      isEmpty() {
        return this.max.x < this.min.x || this.max.y < this.min.y;
      }
      getCenter(target2) {
        return this.isEmpty() ? target2.set(0, 0) : target2.addVectors(this.min, this.max).multiplyScalar(0.5);
      }
      getSize(target2) {
        return this.isEmpty() ? target2.set(0, 0) : target2.subVectors(this.max, this.min);
      }
      expandByPoint(point) {
        this.min.min(point);
        this.max.max(point);
        return this;
      }
      expandByVector(vector) {
        this.min.sub(vector);
        this.max.add(vector);
        return this;
      }
      expandByScalar(scalar) {
        this.min.addScalar(-scalar);
        this.max.addScalar(scalar);
        return this;
      }
      containsPoint(point) {
        return point.x >= this.min.x && point.x <= this.max.x && point.y >= this.min.y && point.y <= this.max.y;
      }
      containsBox(box) {
        return this.min.x <= box.min.x && box.max.x <= this.max.x && this.min.y <= box.min.y && box.max.y <= this.max.y;
      }
      getParameter(point, target2) {
        return target2.set(
          (point.x - this.min.x) / (this.max.x - this.min.x),
          (point.y - this.min.y) / (this.max.y - this.min.y)
        );
      }
      intersectsBox(box) {
        return box.max.x >= this.min.x && box.min.x <= this.max.x && box.max.y >= this.min.y && box.min.y <= this.max.y;
      }
      clampPoint(point, target2) {
        return target2.copy(point).clamp(this.min, this.max);
      }
      distanceToPoint(point) {
        return this.clampPoint(point, _vector$4).distanceTo(point);
      }
      intersect(box) {
        this.min.max(box.min);
        this.max.min(box.max);
        if (this.isEmpty()) this.makeEmpty();
        return this;
      }
      union(box) {
        this.min.min(box.min);
        this.max.max(box.max);
        return this;
      }
      translate(offset) {
        this.min.add(offset);
        this.max.add(offset);
        return this;
      }
      equals(box) {
        return box.min.equals(this.min) && box.max.equals(this.max);
      }
    };
    _startP = /* @__PURE__ */ new Vector3();
    _startEnd = /* @__PURE__ */ new Vector3();
    Line3 = class {
      constructor(start = new Vector3(), end = new Vector3()) {
        this.start = start;
        this.end = end;
      }
      set(start, end) {
        this.start.copy(start);
        this.end.copy(end);
        return this;
      }
      copy(line) {
        this.start.copy(line.start);
        this.end.copy(line.end);
        return this;
      }
      getCenter(target2) {
        return target2.addVectors(this.start, this.end).multiplyScalar(0.5);
      }
      delta(target2) {
        return target2.subVectors(this.end, this.start);
      }
      distanceSq() {
        return this.start.distanceToSquared(this.end);
      }
      distance() {
        return this.start.distanceTo(this.end);
      }
      at(t2, target2) {
        return this.delta(target2).multiplyScalar(t2).add(this.start);
      }
      closestPointToPointParameter(point, clampToLine) {
        _startP.subVectors(point, this.start);
        _startEnd.subVectors(this.end, this.start);
        const startEnd2 = _startEnd.dot(_startEnd);
        const startEnd_startP = _startEnd.dot(_startP);
        let t2 = startEnd_startP / startEnd2;
        if (clampToLine) {
          t2 = clamp(t2, 0, 1);
        }
        return t2;
      }
      closestPointToPoint(point, clampToLine, target2) {
        const t2 = this.closestPointToPointParameter(point, clampToLine);
        return this.delta(target2).multiplyScalar(t2).add(this.start);
      }
      applyMatrix4(matrix2) {
        this.start.applyMatrix4(matrix2);
        this.end.applyMatrix4(matrix2);
        return this;
      }
      equals(line) {
        return line.start.equals(this.start) && line.end.equals(this.end);
      }
      clone() {
        return new this.constructor().copy(this);
      }
    };
    _vector$3 = /* @__PURE__ */ new Vector3();
    SpotLightHelper = class extends Object3D {
      constructor(light, color) {
        super();
        this.light = light;
        this.matrixAutoUpdate = false;
        this.color = color;
        this.type = "SpotLightHelper";
        const geometry = new BufferGeometry();
        const positions = [
          0,
          0,
          0,
          0,
          0,
          1,
          0,
          0,
          0,
          1,
          0,
          1,
          0,
          0,
          0,
          -1,
          0,
          1,
          0,
          0,
          0,
          0,
          1,
          1,
          0,
          0,
          0,
          0,
          -1,
          1
        ];
        for (let i2 = 0, j2 = 1, l2 = 32; i2 < l2; i2++, j2++) {
          const p1 = i2 / l2 * Math.PI * 2;
          const p22 = j2 / l2 * Math.PI * 2;
          positions.push(
            Math.cos(p1),
            Math.sin(p1),
            1,
            Math.cos(p22),
            Math.sin(p22),
            1
          );
        }
        geometry.setAttribute("position", new Float32BufferAttribute(positions, 3));
        const material = new LineBasicMaterial({ fog: false, toneMapped: false });
        this.cone = new LineSegments(geometry, material);
        this.add(this.cone);
        this.update();
      }
      dispose() {
        this.cone.geometry.dispose();
        this.cone.material.dispose();
      }
      update() {
        this.light.updateWorldMatrix(true, false);
        this.light.target.updateWorldMatrix(true, false);
        if (this.parent) {
          this.parent.updateWorldMatrix(true);
          this.matrix.copy(this.parent.matrixWorld).invert().multiply(this.light.matrixWorld);
        } else {
          this.matrix.copy(this.light.matrixWorld);
        }
        this.matrixWorld.copy(this.light.matrixWorld);
        const coneLength = this.light.distance ? this.light.distance : 1e3;
        const coneWidth = coneLength * Math.tan(this.light.angle);
        this.cone.scale.set(coneWidth, coneWidth, coneLength);
        _vector$3.setFromMatrixPosition(this.light.target.matrixWorld);
        this.cone.lookAt(_vector$3);
        if (this.color !== void 0) {
          this.cone.material.color.set(this.color);
        } else {
          this.cone.material.color.copy(this.light.color);
        }
      }
    };
    _vector$2 = /* @__PURE__ */ new Vector3();
    _boneMatrix = /* @__PURE__ */ new Matrix4();
    _matrixWorldInv = /* @__PURE__ */ new Matrix4();
    SkeletonHelper = class extends LineSegments {
      constructor(object) {
        const bones = getBoneList(object);
        const geometry = new BufferGeometry();
        const vertices = [];
        const colors = [];
        const color1 = new Color(0, 0, 1);
        const color2 = new Color(0, 1, 0);
        for (let i2 = 0; i2 < bones.length; i2++) {
          const bone = bones[i2];
          if (bone.parent && bone.parent.isBone) {
            vertices.push(0, 0, 0);
            vertices.push(0, 0, 0);
            colors.push(color1.r, color1.g, color1.b);
            colors.push(color2.r, color2.g, color2.b);
          }
        }
        geometry.setAttribute("position", new Float32BufferAttribute(vertices, 3));
        geometry.setAttribute("color", new Float32BufferAttribute(colors, 3));
        const material = new LineBasicMaterial({ vertexColors: true, depthTest: false, depthWrite: false, toneMapped: false, transparent: true });
        super(geometry, material);
        this.isSkeletonHelper = true;
        this.type = "SkeletonHelper";
        this.root = object;
        this.bones = bones;
        this.matrix = object.matrixWorld;
        this.matrixAutoUpdate = false;
      }
      updateMatrixWorld(force) {
        const bones = this.bones;
        const geometry = this.geometry;
        const position = geometry.getAttribute("position");
        _matrixWorldInv.copy(this.root.matrixWorld).invert();
        for (let i2 = 0, j2 = 0; i2 < bones.length; i2++) {
          const bone = bones[i2];
          if (bone.parent && bone.parent.isBone) {
            _boneMatrix.multiplyMatrices(_matrixWorldInv, bone.matrixWorld);
            _vector$2.setFromMatrixPosition(_boneMatrix);
            position.setXYZ(j2, _vector$2.x, _vector$2.y, _vector$2.z);
            _boneMatrix.multiplyMatrices(_matrixWorldInv, bone.parent.matrixWorld);
            _vector$2.setFromMatrixPosition(_boneMatrix);
            position.setXYZ(j2 + 1, _vector$2.x, _vector$2.y, _vector$2.z);
            j2 += 2;
          }
        }
        geometry.getAttribute("position").needsUpdate = true;
        super.updateMatrixWorld(force);
      }
      dispose() {
        this.geometry.dispose();
        this.material.dispose();
      }
    };
    PointLightHelper = class extends Mesh {
      constructor(light, sphereSize, color) {
        const geometry = new SphereGeometry(sphereSize, 4, 2);
        const material = new MeshBasicMaterial({ wireframe: true, fog: false, toneMapped: false });
        super(geometry, material);
        this.light = light;
        this.color = color;
        this.type = "PointLightHelper";
        this.matrix = this.light.matrixWorld;
        this.matrixAutoUpdate = false;
        this.update();
      }
      dispose() {
        this.geometry.dispose();
        this.material.dispose();
      }
      update() {
        this.light.updateWorldMatrix(true, false);
        if (this.color !== void 0) {
          this.material.color.set(this.color);
        } else {
          this.material.color.copy(this.light.color);
        }
      }
    };
    _vector$1 = /* @__PURE__ */ new Vector3();
    _color1 = /* @__PURE__ */ new Color();
    _color2 = /* @__PURE__ */ new Color();
    HemisphereLightHelper = class extends Object3D {
      constructor(light, size, color) {
        super();
        this.light = light;
        this.matrix = light.matrixWorld;
        this.matrixAutoUpdate = false;
        this.color = color;
        this.type = "HemisphereLightHelper";
        const geometry = new OctahedronGeometry(size);
        geometry.rotateY(Math.PI * 0.5);
        this.material = new MeshBasicMaterial({ wireframe: true, fog: false, toneMapped: false });
        if (this.color === void 0) this.material.vertexColors = true;
        const position = geometry.getAttribute("position");
        const colors = new Float32Array(position.count * 3);
        geometry.setAttribute("color", new BufferAttribute(colors, 3));
        this.add(new Mesh(geometry, this.material));
        this.update();
      }
      dispose() {
        this.children[0].geometry.dispose();
        this.children[0].material.dispose();
      }
      update() {
        const mesh = this.children[0];
        if (this.color !== void 0) {
          this.material.color.set(this.color);
        } else {
          const colors = mesh.geometry.getAttribute("color");
          _color1.copy(this.light.color);
          _color2.copy(this.light.groundColor);
          for (let i2 = 0, l2 = colors.count; i2 < l2; i2++) {
            const color = i2 < l2 / 2 ? _color1 : _color2;
            colors.setXYZ(i2, color.r, color.g, color.b);
          }
          colors.needsUpdate = true;
        }
        this.light.updateWorldMatrix(true, false);
        mesh.lookAt(_vector$1.setFromMatrixPosition(this.light.matrixWorld).negate());
      }
    };
    GridHelper = class extends LineSegments {
      constructor(size = 10, divisions = 10, color1 = 4473924, color2 = 8947848) {
        color1 = new Color(color1);
        color2 = new Color(color2);
        const center = divisions / 2;
        const step = size / divisions;
        const halfSize = size / 2;
        const vertices = [], colors = [];
        for (let i2 = 0, j2 = 0, k3 = -halfSize; i2 <= divisions; i2++, k3 += step) {
          vertices.push(-halfSize, 0, k3, halfSize, 0, k3);
          vertices.push(k3, 0, -halfSize, k3, 0, halfSize);
          const color = i2 === center ? color1 : color2;
          color.toArray(colors, j2);
          j2 += 3;
          color.toArray(colors, j2);
          j2 += 3;
          color.toArray(colors, j2);
          j2 += 3;
          color.toArray(colors, j2);
          j2 += 3;
        }
        const geometry = new BufferGeometry();
        geometry.setAttribute("position", new Float32BufferAttribute(vertices, 3));
        geometry.setAttribute("color", new Float32BufferAttribute(colors, 3));
        const material = new LineBasicMaterial({ vertexColors: true, toneMapped: false });
        super(geometry, material);
        this.type = "GridHelper";
      }
      dispose() {
        this.geometry.dispose();
        this.material.dispose();
      }
    };
    PolarGridHelper = class extends LineSegments {
      constructor(radius = 10, sectors = 16, rings = 8, divisions = 64, color1 = 4473924, color2 = 8947848) {
        color1 = new Color(color1);
        color2 = new Color(color2);
        const vertices = [];
        const colors = [];
        if (sectors > 1) {
          for (let i2 = 0; i2 < sectors; i2++) {
            const v2 = i2 / sectors * (Math.PI * 2);
            const x = Math.sin(v2) * radius;
            const z2 = Math.cos(v2) * radius;
            vertices.push(0, 0, 0);
            vertices.push(x, 0, z2);
            const color = i2 & 1 ? color1 : color2;
            colors.push(color.r, color.g, color.b);
            colors.push(color.r, color.g, color.b);
          }
        }
        for (let i2 = 0; i2 < rings; i2++) {
          const color = i2 & 1 ? color1 : color2;
          const r2 = radius - radius / rings * i2;
          for (let j2 = 0; j2 < divisions; j2++) {
            let v2 = j2 / divisions * (Math.PI * 2);
            let x = Math.sin(v2) * r2;
            let z2 = Math.cos(v2) * r2;
            vertices.push(x, 0, z2);
            colors.push(color.r, color.g, color.b);
            v2 = (j2 + 1) / divisions * (Math.PI * 2);
            x = Math.sin(v2) * r2;
            z2 = Math.cos(v2) * r2;
            vertices.push(x, 0, z2);
            colors.push(color.r, color.g, color.b);
          }
        }
        const geometry = new BufferGeometry();
        geometry.setAttribute("position", new Float32BufferAttribute(vertices, 3));
        geometry.setAttribute("color", new Float32BufferAttribute(colors, 3));
        const material = new LineBasicMaterial({ vertexColors: true, toneMapped: false });
        super(geometry, material);
        this.type = "PolarGridHelper";
      }
      dispose() {
        this.geometry.dispose();
        this.material.dispose();
      }
    };
    _v1 = /* @__PURE__ */ new Vector3();
    _v2 = /* @__PURE__ */ new Vector3();
    _v3 = /* @__PURE__ */ new Vector3();
    DirectionalLightHelper = class extends Object3D {
      constructor(light, size, color) {
        super();
        this.light = light;
        this.matrix = light.matrixWorld;
        this.matrixAutoUpdate = false;
        this.color = color;
        this.type = "DirectionalLightHelper";
        if (size === void 0) size = 1;
        let geometry = new BufferGeometry();
        geometry.setAttribute("position", new Float32BufferAttribute([
          -size,
          size,
          0,
          size,
          size,
          0,
          size,
          -size,
          0,
          -size,
          -size,
          0,
          -size,
          size,
          0
        ], 3));
        const material = new LineBasicMaterial({ fog: false, toneMapped: false });
        this.lightPlane = new Line(geometry, material);
        this.add(this.lightPlane);
        geometry = new BufferGeometry();
        geometry.setAttribute("position", new Float32BufferAttribute([0, 0, 0, 0, 0, 1], 3));
        this.targetLine = new Line(geometry, material);
        this.add(this.targetLine);
        this.update();
      }
      dispose() {
        this.lightPlane.geometry.dispose();
        this.lightPlane.material.dispose();
        this.targetLine.geometry.dispose();
        this.targetLine.material.dispose();
      }
      update() {
        this.light.updateWorldMatrix(true, false);
        this.light.target.updateWorldMatrix(true, false);
        _v1.setFromMatrixPosition(this.light.matrixWorld);
        _v2.setFromMatrixPosition(this.light.target.matrixWorld);
        _v3.subVectors(_v2, _v1);
        this.lightPlane.lookAt(_v2);
        if (this.color !== void 0) {
          this.lightPlane.material.color.set(this.color);
          this.targetLine.material.color.set(this.color);
        } else {
          this.lightPlane.material.color.copy(this.light.color);
          this.targetLine.material.color.copy(this.light.color);
        }
        this.targetLine.lookAt(_v2);
        this.targetLine.scale.z = _v3.length();
      }
    };
    _vector = /* @__PURE__ */ new Vector3();
    _camera = /* @__PURE__ */ new Camera();
    CameraHelper = class extends LineSegments {
      constructor(camera) {
        const geometry = new BufferGeometry();
        const material = new LineBasicMaterial({ color: 16777215, vertexColors: true, toneMapped: false });
        const vertices = [];
        const colors = [];
        const pointMap = {};
        addLine("n1", "n2");
        addLine("n2", "n4");
        addLine("n4", "n3");
        addLine("n3", "n1");
        addLine("f1", "f2");
        addLine("f2", "f4");
        addLine("f4", "f3");
        addLine("f3", "f1");
        addLine("n1", "f1");
        addLine("n2", "f2");
        addLine("n3", "f3");
        addLine("n4", "f4");
        addLine("p", "n1");
        addLine("p", "n2");
        addLine("p", "n3");
        addLine("p", "n4");
        addLine("u1", "u2");
        addLine("u2", "u3");
        addLine("u3", "u1");
        addLine("c", "t");
        addLine("p", "c");
        addLine("cn1", "cn2");
        addLine("cn3", "cn4");
        addLine("cf1", "cf2");
        addLine("cf3", "cf4");
        function addLine(a, b) {
          addPoint(a);
          addPoint(b);
        }
        function addPoint(id) {
          vertices.push(0, 0, 0);
          colors.push(0, 0, 0);
          if (pointMap[id] === void 0) {
            pointMap[id] = [];
          }
          pointMap[id].push(vertices.length / 3 - 1);
        }
        geometry.setAttribute("position", new Float32BufferAttribute(vertices, 3));
        geometry.setAttribute("color", new Float32BufferAttribute(colors, 3));
        super(geometry, material);
        this.type = "CameraHelper";
        this.camera = camera;
        if (this.camera.updateProjectionMatrix) this.camera.updateProjectionMatrix();
        this.matrix = camera.matrixWorld;
        this.matrixAutoUpdate = false;
        this.pointMap = pointMap;
        this.update();
        const colorFrustum = new Color(16755200);
        const colorCone = new Color(16711680);
        const colorUp = new Color(43775);
        const colorTarget = new Color(16777215);
        const colorCross = new Color(3355443);
        this.setColors(colorFrustum, colorCone, colorUp, colorTarget, colorCross);
      }
      setColors(frustum, cone, up, target2, cross) {
        const geometry = this.geometry;
        const colorAttribute = geometry.getAttribute("color");
        colorAttribute.setXYZ(0, frustum.r, frustum.g, frustum.b);
        colorAttribute.setXYZ(1, frustum.r, frustum.g, frustum.b);
        colorAttribute.setXYZ(2, frustum.r, frustum.g, frustum.b);
        colorAttribute.setXYZ(3, frustum.r, frustum.g, frustum.b);
        colorAttribute.setXYZ(4, frustum.r, frustum.g, frustum.b);
        colorAttribute.setXYZ(5, frustum.r, frustum.g, frustum.b);
        colorAttribute.setXYZ(6, frustum.r, frustum.g, frustum.b);
        colorAttribute.setXYZ(7, frustum.r, frustum.g, frustum.b);
        colorAttribute.setXYZ(8, frustum.r, frustum.g, frustum.b);
        colorAttribute.setXYZ(9, frustum.r, frustum.g, frustum.b);
        colorAttribute.setXYZ(10, frustum.r, frustum.g, frustum.b);
        colorAttribute.setXYZ(11, frustum.r, frustum.g, frustum.b);
        colorAttribute.setXYZ(12, frustum.r, frustum.g, frustum.b);
        colorAttribute.setXYZ(13, frustum.r, frustum.g, frustum.b);
        colorAttribute.setXYZ(14, frustum.r, frustum.g, frustum.b);
        colorAttribute.setXYZ(15, frustum.r, frustum.g, frustum.b);
        colorAttribute.setXYZ(16, frustum.r, frustum.g, frustum.b);
        colorAttribute.setXYZ(17, frustum.r, frustum.g, frustum.b);
        colorAttribute.setXYZ(18, frustum.r, frustum.g, frustum.b);
        colorAttribute.setXYZ(19, frustum.r, frustum.g, frustum.b);
        colorAttribute.setXYZ(20, frustum.r, frustum.g, frustum.b);
        colorAttribute.setXYZ(21, frustum.r, frustum.g, frustum.b);
        colorAttribute.setXYZ(22, frustum.r, frustum.g, frustum.b);
        colorAttribute.setXYZ(23, frustum.r, frustum.g, frustum.b);
        colorAttribute.setXYZ(24, cone.r, cone.g, cone.b);
        colorAttribute.setXYZ(25, cone.r, cone.g, cone.b);
        colorAttribute.setXYZ(26, cone.r, cone.g, cone.b);
        colorAttribute.setXYZ(27, cone.r, cone.g, cone.b);
        colorAttribute.setXYZ(28, cone.r, cone.g, cone.b);
        colorAttribute.setXYZ(29, cone.r, cone.g, cone.b);
        colorAttribute.setXYZ(30, cone.r, cone.g, cone.b);
        colorAttribute.setXYZ(31, cone.r, cone.g, cone.b);
        colorAttribute.setXYZ(32, up.r, up.g, up.b);
        colorAttribute.setXYZ(33, up.r, up.g, up.b);
        colorAttribute.setXYZ(34, up.r, up.g, up.b);
        colorAttribute.setXYZ(35, up.r, up.g, up.b);
        colorAttribute.setXYZ(36, up.r, up.g, up.b);
        colorAttribute.setXYZ(37, up.r, up.g, up.b);
        colorAttribute.setXYZ(38, target2.r, target2.g, target2.b);
        colorAttribute.setXYZ(39, target2.r, target2.g, target2.b);
        colorAttribute.setXYZ(40, cross.r, cross.g, cross.b);
        colorAttribute.setXYZ(41, cross.r, cross.g, cross.b);
        colorAttribute.setXYZ(42, cross.r, cross.g, cross.b);
        colorAttribute.setXYZ(43, cross.r, cross.g, cross.b);
        colorAttribute.setXYZ(44, cross.r, cross.g, cross.b);
        colorAttribute.setXYZ(45, cross.r, cross.g, cross.b);
        colorAttribute.setXYZ(46, cross.r, cross.g, cross.b);
        colorAttribute.setXYZ(47, cross.r, cross.g, cross.b);
        colorAttribute.setXYZ(48, cross.r, cross.g, cross.b);
        colorAttribute.setXYZ(49, cross.r, cross.g, cross.b);
        colorAttribute.needsUpdate = true;
      }
      update() {
        const geometry = this.geometry;
        const pointMap = this.pointMap;
        const w = 1, h2 = 1;
        _camera.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse);
        setPoint("c", pointMap, geometry, _camera, 0, 0, -1);
        setPoint("t", pointMap, geometry, _camera, 0, 0, 1);
        setPoint("n1", pointMap, geometry, _camera, -w, -h2, -1);
        setPoint("n2", pointMap, geometry, _camera, w, -h2, -1);
        setPoint("n3", pointMap, geometry, _camera, -w, h2, -1);
        setPoint("n4", pointMap, geometry, _camera, w, h2, -1);
        setPoint("f1", pointMap, geometry, _camera, -w, -h2, 1);
        setPoint("f2", pointMap, geometry, _camera, w, -h2, 1);
        setPoint("f3", pointMap, geometry, _camera, -w, h2, 1);
        setPoint("f4", pointMap, geometry, _camera, w, h2, 1);
        setPoint("u1", pointMap, geometry, _camera, w * 0.7, h2 * 1.1, -1);
        setPoint("u2", pointMap, geometry, _camera, -w * 0.7, h2 * 1.1, -1);
        setPoint("u3", pointMap, geometry, _camera, 0, h2 * 2, -1);
        setPoint("cf1", pointMap, geometry, _camera, -w, 0, 1);
        setPoint("cf2", pointMap, geometry, _camera, w, 0, 1);
        setPoint("cf3", pointMap, geometry, _camera, 0, -h2, 1);
        setPoint("cf4", pointMap, geometry, _camera, 0, h2, 1);
        setPoint("cn1", pointMap, geometry, _camera, -w, 0, -1);
        setPoint("cn2", pointMap, geometry, _camera, w, 0, -1);
        setPoint("cn3", pointMap, geometry, _camera, 0, -h2, -1);
        setPoint("cn4", pointMap, geometry, _camera, 0, h2, -1);
        geometry.getAttribute("position").needsUpdate = true;
      }
      dispose() {
        this.geometry.dispose();
        this.material.dispose();
      }
    };
    _box = /* @__PURE__ */ new Box3();
    BoxHelper = class extends LineSegments {
      constructor(object, color = 16776960) {
        const indices = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]);
        const positions = new Float32Array(8 * 3);
        const geometry = new BufferGeometry();
        geometry.setIndex(new BufferAttribute(indices, 1));
        geometry.setAttribute("position", new BufferAttribute(positions, 3));
        super(geometry, new LineBasicMaterial({ color, toneMapped: false }));
        this.object = object;
        this.type = "BoxHelper";
        this.matrixAutoUpdate = false;
        this.update();
      }
      update(object) {
        if (object !== void 0) {
          console.warn("THREE.BoxHelper: .update() has no longer arguments.");
        }
        if (this.object !== void 0) {
          _box.setFromObject(this.object);
        }
        if (_box.isEmpty()) return;
        const min = _box.min;
        const max = _box.max;
        const position = this.geometry.attributes.position;
        const array = position.array;
        array[0] = max.x;
        array[1] = max.y;
        array[2] = max.z;
        array[3] = min.x;
        array[4] = max.y;
        array[5] = max.z;
        array[6] = min.x;
        array[7] = min.y;
        array[8] = max.z;
        array[9] = max.x;
        array[10] = min.y;
        array[11] = max.z;
        array[12] = max.x;
        array[13] = max.y;
        array[14] = min.z;
        array[15] = min.x;
        array[16] = max.y;
        array[17] = min.z;
        array[18] = min.x;
        array[19] = min.y;
        array[20] = min.z;
        array[21] = max.x;
        array[22] = min.y;
        array[23] = min.z;
        position.needsUpdate = true;
        this.geometry.computeBoundingSphere();
      }
      setFromObject(object) {
        this.object = object;
        this.update();
        return this;
      }
      copy(source, recursive) {
        super.copy(source, recursive);
        this.object = source.object;
        return this;
      }
      dispose() {
        this.geometry.dispose();
        this.material.dispose();
      }
    };
    Box3Helper = class extends LineSegments {
      constructor(box, color = 16776960) {
        const indices = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]);
        const positions = [1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1];
        const geometry = new BufferGeometry();
        geometry.setIndex(new BufferAttribute(indices, 1));
        geometry.setAttribute("position", new Float32BufferAttribute(positions, 3));
        super(geometry, new LineBasicMaterial({ color, toneMapped: false }));
        this.box = box;
        this.type = "Box3Helper";
        this.geometry.computeBoundingSphere();
      }
      updateMatrixWorld(force) {
        const box = this.box;
        if (box.isEmpty()) return;
        box.getCenter(this.position);
        box.getSize(this.scale);
        this.scale.multiplyScalar(0.5);
        super.updateMatrixWorld(force);
      }
      dispose() {
        this.geometry.dispose();
        this.material.dispose();
      }
    };
    PlaneHelper = class extends Line {
      constructor(plane, size = 1, hex = 16776960) {
        const color = hex;
        const positions = [1, -1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, 1, 0, -1, -1, 0, 1, -1, 0, 1, 1, 0];
        const geometry = new BufferGeometry();
        geometry.setAttribute("position", new Float32BufferAttribute(positions, 3));
        geometry.computeBoundingSphere();
        super(geometry, new LineBasicMaterial({ color, toneMapped: false }));
        this.type = "PlaneHelper";
        this.plane = plane;
        this.size = size;
        const positions2 = [1, 1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, -1, 0, 1, -1, 0];
        const geometry2 = new BufferGeometry();
        geometry2.setAttribute("position", new Float32BufferAttribute(positions2, 3));
        geometry2.computeBoundingSphere();
        this.add(new Mesh(geometry2, new MeshBasicMaterial({ color, opacity: 0.2, transparent: true, depthWrite: false, toneMapped: false })));
      }
      updateMatrixWorld(force) {
        this.position.set(0, 0, 0);
        this.scale.set(0.5 * this.size, 0.5 * this.size, 1);
        this.lookAt(this.plane.normal);
        this.translateZ(-this.plane.constant);
        super.updateMatrixWorld(force);
      }
      dispose() {
        this.geometry.dispose();
        this.material.dispose();
        this.children[0].geometry.dispose();
        this.children[0].material.dispose();
      }
    };
    _axis = /* @__PURE__ */ new Vector3();
    ArrowHelper = class extends Object3D {
      // dir is assumed to be normalized
      constructor(dir = new Vector3(0, 0, 1), origin = new Vector3(0, 0, 0), length = 1, color = 16776960, headLength = length * 0.2, headWidth = headLength * 0.2) {
        super();
        this.type = "ArrowHelper";
        if (_lineGeometry === void 0) {
          _lineGeometry = new BufferGeometry();
          _lineGeometry.setAttribute("position", new Float32BufferAttribute([0, 0, 0, 0, 1, 0], 3));
          _coneGeometry = new CylinderGeometry(0, 0.5, 1, 5, 1);
          _coneGeometry.translate(0, -0.5, 0);
        }
        this.position.copy(origin);
        this.line = new Line(_lineGeometry, new LineBasicMaterial({ color, toneMapped: false }));
        this.line.matrixAutoUpdate = false;
        this.add(this.line);
        this.cone = new Mesh(_coneGeometry, new MeshBasicMaterial({ color, toneMapped: false }));
        this.cone.matrixAutoUpdate = false;
        this.add(this.cone);
        this.setDirection(dir);
        this.setLength(length, headLength, headWidth);
      }
      setDirection(dir) {
        if (dir.y > 0.99999) {
          this.quaternion.set(0, 0, 0, 1);
        } else if (dir.y < -0.99999) {
          this.quaternion.set(1, 0, 0, 0);
        } else {
          _axis.set(dir.z, 0, -dir.x).normalize();
          const radians = Math.acos(dir.y);
          this.quaternion.setFromAxisAngle(_axis, radians);
        }
      }
      setLength(length, headLength = length * 0.2, headWidth = headLength * 0.2) {
        this.line.scale.set(1, Math.max(1e-4, length - headLength), 1);
        this.line.updateMatrix();
        this.cone.scale.set(headWidth, headLength, headWidth);
        this.cone.position.y = length;
        this.cone.updateMatrix();
      }
      setColor(color) {
        this.line.material.color.set(color);
        this.cone.material.color.set(color);
      }
      copy(source) {
        super.copy(source, false);
        this.line.copy(source.line);
        this.cone.copy(source.cone);
        return this;
      }
      dispose() {
        this.line.geometry.dispose();
        this.line.material.dispose();
        this.cone.geometry.dispose();
        this.cone.material.dispose();
      }
    };
    AxesHelper = class extends LineSegments {
      constructor(size = 1) {
        const vertices = [
          0,
          0,
          0,
          size,
          0,
          0,
          0,
          0,
          0,
          0,
          size,
          0,
          0,
          0,
          0,
          0,
          0,
          size
        ];
        const colors = [
          1,
          0,
          0,
          1,
          0.6,
          0,
          0,
          1,
          0,
          0.6,
          1,
          0,
          0,
          0,
          1,
          0,
          0.6,
          1
        ];
        const geometry = new BufferGeometry();
        geometry.setAttribute("position", new Float32BufferAttribute(vertices, 3));
        geometry.setAttribute("color", new Float32BufferAttribute(colors, 3));
        const material = new LineBasicMaterial({ vertexColors: true, toneMapped: false });
        super(geometry, material);
        this.type = "AxesHelper";
      }
      setColors(xAxisColor, yAxisColor, zAxisColor) {
        const color = new Color();
        const array = this.geometry.attributes.color.array;
        color.set(xAxisColor);
        color.toArray(array, 0);
        color.toArray(array, 3);
        color.set(yAxisColor);
        color.toArray(array, 6);
        color.toArray(array, 9);
        color.set(zAxisColor);
        color.toArray(array, 12);
        color.toArray(array, 15);
        this.geometry.attributes.color.needsUpdate = true;
        return this;
      }
      dispose() {
        this.geometry.dispose();
        this.material.dispose();
      }
    };
    ShapePath = class {
      constructor() {
        this.type = "ShapePath";
        this.color = new Color();
        this.subPaths = [];
        this.currentPath = null;
      }
      moveTo(x, y2) {
        this.currentPath = new Path();
        this.subPaths.push(this.currentPath);
        this.currentPath.moveTo(x, y2);
        return this;
      }
      lineTo(x, y2) {
        this.currentPath.lineTo(x, y2);
        return this;
      }
      quadraticCurveTo(aCPx, aCPy, aX, aY) {
        this.currentPath.quadraticCurveTo(aCPx, aCPy, aX, aY);
        return this;
      }
      bezierCurveTo(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY) {
        this.currentPath.bezierCurveTo(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY);
        return this;
      }
      splineThru(pts) {
        this.currentPath.splineThru(pts);
        return this;
      }
      toShapes(isCCW) {
        function toShapesNoHoles(inSubpaths) {
          const shapes2 = [];
          for (let i2 = 0, l2 = inSubpaths.length; i2 < l2; i2++) {
            const tmpPath2 = inSubpaths[i2];
            const tmpShape2 = new Shape();
            tmpShape2.curves = tmpPath2.curves;
            shapes2.push(tmpShape2);
          }
          return shapes2;
        }
        function isPointInsidePolygon(inPt, inPolygon) {
          const polyLen = inPolygon.length;
          let inside = false;
          for (let p3 = polyLen - 1, q3 = 0; q3 < polyLen; p3 = q3++) {
            let edgeLowPt = inPolygon[p3];
            let edgeHighPt = inPolygon[q3];
            let edgeDx = edgeHighPt.x - edgeLowPt.x;
            let edgeDy = edgeHighPt.y - edgeLowPt.y;
            if (Math.abs(edgeDy) > Number.EPSILON) {
              if (edgeDy < 0) {
                edgeLowPt = inPolygon[q3];
                edgeDx = -edgeDx;
                edgeHighPt = inPolygon[p3];
                edgeDy = -edgeDy;
              }
              if (inPt.y < edgeLowPt.y || inPt.y > edgeHighPt.y) continue;
              if (inPt.y === edgeLowPt.y) {
                if (inPt.x === edgeLowPt.x) return true;
              } else {
                const perpEdge = edgeDy * (inPt.x - edgeLowPt.x) - edgeDx * (inPt.y - edgeLowPt.y);
                if (perpEdge === 0) return true;
                if (perpEdge < 0) continue;
                inside = !inside;
              }
            } else {
              if (inPt.y !== edgeLowPt.y) continue;
              if (edgeHighPt.x <= inPt.x && inPt.x <= edgeLowPt.x || edgeLowPt.x <= inPt.x && inPt.x <= edgeHighPt.x) return true;
            }
          }
          return inside;
        }
        const isClockWise = ShapeUtils.isClockWise;
        const subPaths = this.subPaths;
        if (subPaths.length === 0) return [];
        let solid, tmpPath, tmpShape;
        const shapes = [];
        if (subPaths.length === 1) {
          tmpPath = subPaths[0];
          tmpShape = new Shape();
          tmpShape.curves = tmpPath.curves;
          shapes.push(tmpShape);
          return shapes;
        }
        let holesFirst = !isClockWise(subPaths[0].getPoints());
        holesFirst = isCCW ? !holesFirst : holesFirst;
        const betterShapeHoles = [];
        const newShapes = [];
        let newShapeHoles = [];
        let mainIdx = 0;
        let tmpPoints;
        newShapes[mainIdx] = void 0;
        newShapeHoles[mainIdx] = [];
        for (let i2 = 0, l2 = subPaths.length; i2 < l2; i2++) {
          tmpPath = subPaths[i2];
          tmpPoints = tmpPath.getPoints();
          solid = isClockWise(tmpPoints);
          solid = isCCW ? !solid : solid;
          if (solid) {
            if (!holesFirst && newShapes[mainIdx]) mainIdx++;
            newShapes[mainIdx] = { s: new Shape(), p: tmpPoints };
            newShapes[mainIdx].s.curves = tmpPath.curves;
            if (holesFirst) mainIdx++;
            newShapeHoles[mainIdx] = [];
          } else {
            newShapeHoles[mainIdx].push({ h: tmpPath, p: tmpPoints[0] });
          }
        }
        if (!newShapes[0]) return toShapesNoHoles(subPaths);
        if (newShapes.length > 1) {
          let ambiguous = false;
          let toChange = 0;
          for (let sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx++) {
            betterShapeHoles[sIdx] = [];
          }
          for (let sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx++) {
            const sho = newShapeHoles[sIdx];
            for (let hIdx = 0; hIdx < sho.length; hIdx++) {
              const ho = sho[hIdx];
              let hole_unassigned = true;
              for (let s2Idx = 0; s2Idx < newShapes.length; s2Idx++) {
                if (isPointInsidePolygon(ho.p, newShapes[s2Idx].p)) {
                  if (sIdx !== s2Idx) toChange++;
                  if (hole_unassigned) {
                    hole_unassigned = false;
                    betterShapeHoles[s2Idx].push(ho);
                  } else {
                    ambiguous = true;
                  }
                }
              }
              if (hole_unassigned) {
                betterShapeHoles[sIdx].push(ho);
              }
            }
          }
          if (toChange > 0 && ambiguous === false) {
            newShapeHoles = betterShapeHoles;
          }
        }
        let tmpHoles;
        for (let i2 = 0, il = newShapes.length; i2 < il; i2++) {
          tmpShape = newShapes[i2].s;
          shapes.push(tmpShape);
          tmpHoles = newShapeHoles[i2];
          for (let j2 = 0, jl = tmpHoles.length; j2 < jl; j2++) {
            tmpShape.holes.push(tmpHoles[j2].h);
          }
        }
        return shapes;
      }
    };
    Controls = class extends EventDispatcher {
      constructor(object, domElement = null) {
        super();
        this.object = object;
        this.domElement = domElement;
        this.enabled = true;
        this.state = -1;
        this.keys = {};
        this.mouseButtons = { LEFT: null, MIDDLE: null, RIGHT: null };
        this.touches = { ONE: null, TWO: null };
      }
      connect() {
      }
      disconnect() {
      }
      dispose() {
      }
      update() {
      }
    };
    WebGLMultipleRenderTargets = class extends WebGLRenderTarget {
      // @deprecated, r162
      constructor(width = 1, height = 1, count = 1, options = {}) {
        console.warn('THREE.WebGLMultipleRenderTargets has been deprecated and will be removed in r172. Use THREE.WebGLRenderTarget and set the "count" parameter to enable MRT.');
        super(width, height, __spreadProps(__spreadValues({}, options), { count }));
        this.isWebGLMultipleRenderTargets = true;
      }
      get texture() {
        return this.textures;
      }
    };
    if (typeof __THREE_DEVTOOLS__ !== "undefined") {
      __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", { detail: {
        revision: REVISION
      } }));
    }
    if (typeof window !== "undefined") {
      if (window.__THREE__) {
        console.warn("WARNING: Multiple instances of Three.js being imported.");
      } else {
        window.__THREE__ = REVISION;
      }
    }
  }
});

// ../shadergradient-v2/dist/chunk-73SH6GTX.mjs
import * as React from "react";
import { DefaultEventPriority, ContinuousEventPriority, DiscreteEventPriority, ConcurrentRoot } from "react-reconciler/constants";
import { useReducer, useRef as useRef2, useDebugValue, useEffect as useEffect2, useLayoutEffect as useLayoutEffect2 } from "react";
import { jsx as jsx2, Fragment as Fragment2 } from "react/jsx-runtime";
import Reconciler from "react-reconciler";
import * as React3 from "react";
import { useState as T, useRef as p, useEffect as u2, useMemo as M2 } from "react";
import * as React2 from "react";
import { jsx as jsx22 } from "react/jsx-runtime";
import "react-reconciler/constants";
import "react-reconciler";
function createStore(createState) {
  let state;
  const listeners = /* @__PURE__ */ new Set();
  const setState = (partial, replace) => {
    const nextState = typeof partial === "function" ? partial(state) : partial;
    if (nextState !== state) {
      const previousState = state;
      state = replace ? nextState : Object.assign({}, state, nextState);
      listeners.forEach((listener) => listener(state, previousState));
    }
  };
  const getState = () => state;
  const subscribeWithSelector = (listener, selector = getState, equalityFn = Object.is) => {
    console.warn("[DEPRECATED] Please use `subscribeWithSelector` middleware");
    let currentSlice = selector(state);
    function listenerToAdd() {
      const nextSlice = selector(state);
      if (!equalityFn(currentSlice, nextSlice)) {
        const previousSlice = currentSlice;
        listener(currentSlice = nextSlice, previousSlice);
      }
    }
    listeners.add(listenerToAdd);
    return () => listeners.delete(listenerToAdd);
  };
  const subscribe = (listener, selector, equalityFn) => {
    if (selector || equalityFn) {
      return subscribeWithSelector(listener, selector, equalityFn);
    }
    listeners.add(listener);
    return () => listeners.delete(listener);
  };
  const destroy = () => listeners.clear();
  const api = { setState, getState, subscribe, destroy };
  state = createState(setState, getState, api);
  return api;
}
function create(createState) {
  const api = typeof createState === "function" ? createStore(createState) : createState;
  const useStore2 = (selector = api.getState, equalityFn = Object.is) => {
    const [, forceUpdate] = useReducer((c) => c + 1, 0);
    const state = api.getState();
    const stateRef = useRef2(state);
    const selectorRef = useRef2(selector);
    const equalityFnRef = useRef2(equalityFn);
    const erroredRef = useRef2(false);
    const currentSliceRef = useRef2();
    if (currentSliceRef.current === void 0) {
      currentSliceRef.current = selector(state);
    }
    let newStateSlice;
    let hasNewStateSlice = false;
    if (stateRef.current !== state || selectorRef.current !== selector || equalityFnRef.current !== equalityFn || erroredRef.current) {
      newStateSlice = selector(state);
      hasNewStateSlice = !equalityFn(currentSliceRef.current, newStateSlice);
    }
    useIsomorphicLayoutEffect(() => {
      if (hasNewStateSlice) {
        currentSliceRef.current = newStateSlice;
      }
      stateRef.current = state;
      selectorRef.current = selector;
      equalityFnRef.current = equalityFn;
      erroredRef.current = false;
    });
    const stateBeforeSubscriptionRef = useRef2(state);
    useIsomorphicLayoutEffect(() => {
      const listener = () => {
        try {
          const nextState = api.getState();
          const nextStateSlice = selectorRef.current(nextState);
          if (!equalityFnRef.current(currentSliceRef.current, nextStateSlice)) {
            stateRef.current = nextState;
            currentSliceRef.current = nextStateSlice;
            forceUpdate();
          }
        } catch (error2) {
          erroredRef.current = true;
          forceUpdate();
        }
      };
      const unsubscribe = api.subscribe(listener);
      if (api.getState() !== stateBeforeSubscriptionRef.current) {
        listener();
      }
      return unsubscribe;
    }, []);
    const sliceToReturn = hasNewStateSlice ? newStateSlice : currentSliceRef.current;
    useDebugValue(sliceToReturn);
    return sliceToReturn;
  };
  Object.assign(useStore2, api);
  useStore2[Symbol.iterator] = function() {
    console.warn("[useStore, api] = create() is deprecated and will be removed in v4");
    const items = [useStore2, api];
    return {
      next() {
        const done = items.length <= 0;
        return { value: items.shift(), done };
      }
    };
  };
  return useStore2;
}
function shallowEqualArrays(arrA, arrB, equal = (a, b) => a === b) {
  if (arrA === arrB) return true;
  if (!arrA || !arrB) return false;
  const len = arrA.length;
  if (arrB.length !== len) return false;
  for (let i2 = 0; i2 < len; i2++) if (!equal(arrA[i2], arrB[i2])) return false;
  return true;
}
function query(fn, keys = null, preload2 = false, config = {}) {
  if (keys === null) keys = [fn];
  for (const entry2 of globalCache) {
    if (shallowEqualArrays(keys, entry2.keys, entry2.equal)) {
      if (preload2) return void 0;
      if (Object.prototype.hasOwnProperty.call(entry2, "error")) throw entry2.error;
      if (Object.prototype.hasOwnProperty.call(entry2, "response")) {
        if (config.lifespan && config.lifespan > 0) {
          if (entry2.timeout) clearTimeout(entry2.timeout);
          entry2.timeout = setTimeout(entry2.remove, config.lifespan);
        }
        return entry2.response;
      }
      if (!preload2) throw entry2.promise;
    }
  }
  const entry = {
    keys,
    equal: config.equal,
    remove: () => {
      const index = globalCache.indexOf(entry);
      if (index !== -1) globalCache.splice(index, 1);
    },
    promise: (
      // Execute the promise
      (isPromise(fn) ? fn : fn(...keys)).then((response) => {
        entry.response = response;
        if (config.lifespan && config.lifespan > 0) {
          entry.timeout = setTimeout(entry.remove, config.lifespan);
        }
      }).catch((error2) => entry.error = error2)
    )
  };
  globalCache.push(entry);
  if (!preload2) throw entry.promise;
  return void 0;
}
function f(a, b) {
  var c = a.length;
  a.push(b);
  a: for (; 0 < c; ) {
    var d = c - 1 >>> 1, e = a[d];
    if (0 < g(e, b)) a[d] = b, a[c] = e, c = d;
    else break a;
  }
}
function h(a) {
  return 0 === a.length ? null : a[0];
}
function k(a) {
  if (0 === a.length) return null;
  var b = a[0], c = a.pop();
  if (c !== b) {
    a[0] = c;
    a: for (var d = 0, e = a.length, w = e >>> 1; d < w; ) {
      var m = 2 * (d + 1) - 1, C = a[m], n = m + 1, x = a[n];
      if (0 > g(C, c)) n < e && 0 > g(x, C) ? (a[d] = x, a[n] = c, d = n) : (a[d] = C, a[m] = c, d = m);
      else if (n < e && 0 > g(x, c)) a[d] = x, a[n] = c, d = n;
      else break a;
    }
  }
  return b;
}
function g(a, b) {
  var c = a.sortIndex - b.sortIndex;
  return 0 !== c ? c : a.id - b.id;
}
function G(a) {
  for (var b = h(t); null !== b; ) {
    if (null === b.callback) k(t);
    else if (b.startTime <= a) k(t), b.sortIndex = b.expirationTime, f(r, b);
    else break;
    b = h(t);
  }
}
function H(a) {
  B = false;
  G(a);
  if (!A) if (null !== h(r)) A = true, I(J);
  else {
    var b = h(t);
    null !== b && K(H, b.startTime - a);
  }
}
function J(a, b) {
  A = false;
  B && (B = false, E(L), L = -1);
  z = true;
  var c = y;
  try {
    G(b);
    for (v = h(r); null !== v && (!(v.expirationTime > b) || a && !M()); ) {
      var d = v.callback;
      if ("function" === typeof d) {
        v.callback = null;
        y = v.priorityLevel;
        var e = d(v.expirationTime <= b);
        b = exports2.unstable_now();
        "function" === typeof e ? v.callback = e : v === h(r) && k(r);
        G(b);
      } else k(r);
      v = h(r);
    }
    if (null !== v) var w = true;
    else {
      var m = h(t);
      null !== m && K(H, m.startTime - b);
      w = false;
    }
    return w;
  } finally {
    v = null, y = c, z = false;
  }
}
function M() {
  return exports2.unstable_now() - Q < P ? false : true;
}
function R() {
  if (null !== O) {
    var a = exports2.unstable_now();
    Q = a;
    var b = true;
    try {
      b = O(true, a);
    } finally {
      b ? S() : (N = false, O = null);
    }
  } else N = false;
}
function I(a) {
  O = a;
  N || (N = true, S());
}
function K(a, b) {
  L = D(function() {
    a(exports2.unstable_now());
  }, b);
}
function __cjs_default__(requiredModule) {
  var Object2 = (typeof window !== "undefined" && window || typeof self !== "undefined" && self || typeof global !== "undefined" && global || typeof globalThis !== "undefined" && globalThis || {}).Object;
  var isEsModule = false;
  var specifiers = Object2.create(null);
  var hasNamedExports = false;
  var hasDefaultExport = false;
  Object2.defineProperty(specifiers, "__esModule", {
    value: true,
    enumerable: false,
    configurable: true
  });
  if (requiredModule) {
    var names = Object2.getOwnPropertyNames(requiredModule);
    ;
    names.forEach(function(k3) {
      if (k3 === "default") {
        hasDefaultExport = true;
      } else if (!hasNamedExports && k3 != "__esModule") {
        try {
          hasNamedExports = requiredModule[k3] != null;
        } catch (err) {
        }
      }
      Object2.defineProperty(specifiers, k3, {
        get: function() {
          return requiredModule[k3];
        },
        enumerable: true,
        configurable: false
      });
    });
    if (Object2.getOwnPropertySymbols) {
      var symbols = Object2.getOwnPropertySymbols(requiredModule);
      symbols.forEach(function(k3) {
        Object2.defineProperty(specifiers, k3, {
          get: function() {
            return requiredModule[k3];
          },
          enumerable: false,
          configurable: false
        });
      });
    }
    Object2.preventExtensions(specifiers);
    Object2.seal(specifiers);
    if (Object2.freeze) {
      Object2.freeze(specifiers);
    }
  }
  if (hasNamedExports) {
    return specifiers;
  }
  if (hasDefaultExport) {
    if (Object2.isExtensible(specifiers.default) && !("default" in specifiers.default)) {
      Object2.defineProperty(specifiers.default, "default", {
        value: specifiers.default,
        configurable: false,
        enumerable: false
      });
    }
    return specifiers.default;
  }
  return specifiers;
}
function createRenderer(_roots, _getEventPriority) {
  function createInstance(type, _a22, root) {
    var _b2 = _a22, {
      args = [],
      attach: attach2
    } = _b2, props = __objRest(_b2, [
      "args",
      "attach"
    ]);
    let name = `${type[0].toUpperCase()}${type.slice(1)}`;
    let instance;
    if (type === "primitive") {
      if (props.object === void 0) throw new Error("R3F: Primitives without 'object' are invalid!");
      const object = props.object;
      instance = prepare(object, {
        type,
        root,
        attach: attach2,
        primitive: true
      });
    } else {
      const target2 = catalogue[name];
      if (!target2) {
        throw new Error(`R3F: ${name} is not part of the THREE namespace! Did you forget to extend? See: https://docs.pmnd.rs/react-three-fiber/api/objects#using-3rd-party-objects-declaratively`);
      }
      if (!Array.isArray(args)) throw new Error("R3F: The args prop must be an array!");
      instance = prepare(new target2(...args), {
        type,
        root,
        attach: attach2,
        // Save args in case we need to reconstruct later for HMR
        memoizedProps: {
          args
        }
      });
    }
    if (instance.__r3f.attach === void 0) {
      if (instance.isBufferGeometry) instance.__r3f.attach = "geometry";
      else if (instance.isMaterial) instance.__r3f.attach = "material";
    }
    if (name !== "inject") applyProps$1(instance, props);
    return instance;
  }
  function appendChild(parentInstance, child) {
    let added = false;
    if (child) {
      var _child$__r3f, _parentInstance$__r3f;
      if ((_child$__r3f = child.__r3f) != null && _child$__r3f.attach) {
        attach(parentInstance, child, child.__r3f.attach);
      } else if (child.isObject3D && parentInstance.isObject3D) {
        parentInstance.add(child);
        added = true;
      }
      if (!added) (_parentInstance$__r3f = parentInstance.__r3f) == null ? void 0 : _parentInstance$__r3f.objects.push(child);
      if (!child.__r3f) prepare(child, {});
      child.__r3f.parent = parentInstance;
      updateInstance(child);
      invalidateInstance(child);
    }
  }
  function insertBefore(parentInstance, child, beforeChild) {
    let added = false;
    if (child) {
      var _child$__r3f2, _parentInstance$__r3f2;
      if ((_child$__r3f2 = child.__r3f) != null && _child$__r3f2.attach) {
        attach(parentInstance, child, child.__r3f.attach);
      } else if (child.isObject3D && parentInstance.isObject3D) {
        child.parent = parentInstance;
        child.dispatchEvent({
          type: "added"
        });
        parentInstance.dispatchEvent({
          type: "childadded",
          child
        });
        const restSiblings = parentInstance.children.filter((sibling) => sibling !== child);
        const index = restSiblings.indexOf(beforeChild);
        parentInstance.children = [...restSiblings.slice(0, index), child, ...restSiblings.slice(index)];
        added = true;
      }
      if (!added) (_parentInstance$__r3f2 = parentInstance.__r3f) == null ? void 0 : _parentInstance$__r3f2.objects.push(child);
      if (!child.__r3f) prepare(child, {});
      child.__r3f.parent = parentInstance;
      updateInstance(child);
      invalidateInstance(child);
    }
  }
  function removeRecursive(array, parent, dispose2 = false) {
    if (array) [...array].forEach((child) => removeChild(parent, child, dispose2));
  }
  function removeChild(parentInstance, child, dispose2) {
    if (child) {
      var _parentInstance$__r3f3, _child$__r3f3, _child$__r3f5;
      if (child.__r3f) child.__r3f.parent = null;
      if ((_parentInstance$__r3f3 = parentInstance.__r3f) != null && _parentInstance$__r3f3.objects) parentInstance.__r3f.objects = parentInstance.__r3f.objects.filter((x) => x !== child);
      if ((_child$__r3f3 = child.__r3f) != null && _child$__r3f3.attach) {
        detach(parentInstance, child, child.__r3f.attach);
      } else if (child.isObject3D && parentInstance.isObject3D) {
        var _child$__r3f4;
        parentInstance.remove(child);
        if ((_child$__r3f4 = child.__r3f) != null && _child$__r3f4.root) {
          removeInteractivity(findInitialRoot(child), child);
        }
      }
      const isPrimitive = (_child$__r3f5 = child.__r3f) == null ? void 0 : _child$__r3f5.primitive;
      const shouldDispose = !isPrimitive && (dispose2 === void 0 ? child.dispose !== null : dispose2);
      if (!isPrimitive) {
        var _child$__r3f6;
        removeRecursive((_child$__r3f6 = child.__r3f) == null ? void 0 : _child$__r3f6.objects, child, shouldDispose);
        removeRecursive(child.children, child, shouldDispose);
      }
      delete child.__r3f;
      if (shouldDispose && child.dispose && child.type !== "Scene") {
        const callback = () => {
          try {
            child.dispose();
          } catch (e) {
          }
        };
        if (typeof IS_REACT_ACT_ENVIRONMENT === "undefined") {
          __export16(__export1, callback);
        } else {
          callback();
        }
      }
      invalidateInstance(parentInstance);
    }
  }
  function switchInstance(instance, type, newProps, fiber) {
    var _instance$__r3f;
    const parent = (_instance$__r3f = instance.__r3f) == null ? void 0 : _instance$__r3f.parent;
    if (!parent) return;
    const newInstance = createInstance(type, newProps, instance.__r3f.root);
    if (instance.children) {
      for (const child of instance.children) {
        if (child.__r3f) appendChild(newInstance, child);
      }
      instance.children = instance.children.filter((child) => !child.__r3f);
    }
    instance.__r3f.objects.forEach((child) => appendChild(newInstance, child));
    instance.__r3f.objects = [];
    if (!instance.__r3f.autoRemovedBeforeAppend) {
      removeChild(parent, instance);
    }
    if (newInstance.parent) {
      newInstance.__r3f.autoRemovedBeforeAppend = true;
    }
    appendChild(parent, newInstance);
    if (newInstance.raycast && newInstance.__r3f.eventCount) {
      const rootState = findInitialRoot(newInstance).getState();
      rootState.internal.interaction.push(newInstance);
    }
    [fiber, fiber.alternate].forEach((fiber2) => {
      if (fiber2 !== null) {
        fiber2.stateNode = newInstance;
        if (fiber2.ref) {
          if (typeof fiber2.ref === "function") fiber2.ref(newInstance);
          else fiber2.ref.current = newInstance;
        }
      }
    });
  }
  const handleTextInstance = () => {
  };
  const reconciler2 = Reconciler({
    createInstance,
    removeChild,
    appendChild,
    appendInitialChild: appendChild,
    insertBefore,
    supportsMutation: true,
    isPrimaryRenderer: false,
    supportsPersistence: false,
    supportsHydration: false,
    noTimeout: -1,
    appendChildToContainer: (container, child) => {
      if (!child) return;
      const scene = container.getState().scene;
      if (!scene.__r3f) return;
      scene.__r3f.root = container;
      appendChild(scene, child);
    },
    removeChildFromContainer: (container, child) => {
      if (!child) return;
      removeChild(container.getState().scene, child);
    },
    insertInContainerBefore: (container, child, beforeChild) => {
      if (!child || !beforeChild) return;
      const scene = container.getState().scene;
      if (!scene.__r3f) return;
      insertBefore(scene, child, beforeChild);
    },
    getRootHostContext: () => null,
    getChildHostContext: (parentHostContext) => parentHostContext,
    finalizeInitialChildren(instance) {
      var _instance$__r3f2;
      const localState = (_instance$__r3f2 = instance == null ? void 0 : instance.__r3f) != null ? _instance$__r3f2 : {};
      return Boolean(localState.handlers);
    },
    prepareUpdate(instance, _type, oldProps, newProps) {
      var _instance$__r3f3;
      const localState = (_instance$__r3f3 = instance == null ? void 0 : instance.__r3f) != null ? _instance$__r3f3 : {};
      if (localState.primitive && newProps.object && newProps.object !== instance) {
        return [true];
      } else {
        const _a22 = newProps, {
          args: argsNew = [],
          children: cN
        } = _a22, restNew = __objRest(_a22, [
          "args",
          "children"
        ]);
        const _b2 = oldProps, {
          args: argsOld = [],
          children: cO
        } = _b2, restOld = __objRest(_b2, [
          "args",
          "children"
        ]);
        if (!Array.isArray(argsNew)) throw new Error("R3F: the args prop must be an array!");
        if (argsNew.some((value, index) => value !== argsOld[index])) return [true];
        const diff = diffProps(instance, restNew, restOld, true);
        if (diff.changes.length) return [false, diff];
        return null;
      }
    },
    commitUpdate(instance, [reconstruct, diff], type, _oldProps, newProps, fiber) {
      if (reconstruct) switchInstance(instance, type, newProps, fiber);
      else applyProps$1(instance, diff);
    },
    commitMount(instance, _type, _props, _int) {
      var _instance$__r3f4;
      const localState = (_instance$__r3f4 = instance.__r3f) != null ? _instance$__r3f4 : {};
      if (instance.raycast && localState.handlers && localState.eventCount) {
        findInitialRoot(instance).getState().internal.interaction.push(instance);
      }
    },
    getPublicInstance: (instance) => instance,
    prepareForCommit: () => null,
    preparePortalMount: (container) => prepare(container.getState().scene),
    resetAfterCommit: () => {
    },
    shouldSetTextContent: () => false,
    clearContainer: () => false,
    hideInstance(instance) {
      var _instance$__r3f5;
      const {
        attach: type,
        parent
      } = (_instance$__r3f5 = instance.__r3f) != null ? _instance$__r3f5 : {};
      if (type && parent) detach(parent, instance, type);
      if (instance.isObject3D) instance.visible = false;
      invalidateInstance(instance);
    },
    unhideInstance(instance, props) {
      var _instance$__r3f6;
      const {
        attach: type,
        parent
      } = (_instance$__r3f6 = instance.__r3f) != null ? _instance$__r3f6 : {};
      if (type && parent) attach(parent, instance, type);
      if (instance.isObject3D && props.visible == null || props.visible) instance.visible = true;
      invalidateInstance(instance);
    },
    createTextInstance: handleTextInstance,
    hideTextInstance: handleTextInstance,
    unhideTextInstance: handleTextInstance,
    // https://github.com/pmndrs/react-three-fiber/pull/2360#discussion_r916356874
    // @ts-expect-error
    getCurrentEventPriority: () => _getEventPriority ? _getEventPriority() : DefaultEventPriority,
    beforeActiveInstanceBlur: () => {
    },
    afterActiveInstanceBlur: () => {
    },
    detachDeletedInstance: () => {
    },
    now: typeof performance !== "undefined" && is.fun(performance.now) ? performance.now : is.fun(Date.now) ? Date.now : () => 0,
    // https://github.com/pmndrs/react-three-fiber/pull/2360#discussion_r920883503
    scheduleTimeout: is.fun(setTimeout) ? setTimeout : void 0,
    cancelTimeout: is.fun(clearTimeout) ? clearTimeout : void 0
  });
  return {
    reconciler: reconciler2,
    applyProps: applyProps$1
  };
}
function useMutableCallback(fn) {
  const ref = React.useRef(fn);
  useIsomorphicLayoutEffect2(() => void (ref.current = fn), [fn]);
  return ref;
}
function Block({
  set
}) {
  useIsomorphicLayoutEffect2(() => {
    set(new Promise(() => null));
    return () => set(false);
  }, [set]);
  return null;
}
function calculateDpr(dpr) {
  var _window$devicePixelRa;
  const target2 = typeof window !== "undefined" ? (_window$devicePixelRa = window.devicePixelRatio) != null ? _window$devicePixelRa : 2 : 1;
  return Array.isArray(dpr) ? Math.min(Math.max(dpr[0], target2), dpr[1]) : dpr;
}
function findInitialRoot(child) {
  let root = child.__r3f.root;
  while (root.getState().previousRoot) root = root.getState().previousRoot;
  return root;
}
function buildGraph(object) {
  const data = {
    nodes: {},
    materials: {}
  };
  if (object) {
    object.traverse((obj) => {
      if (obj.name) data.nodes[obj.name] = obj;
      if (obj.material && !data.materials[obj.material.name]) data.materials[obj.material.name] = obj.material;
    });
  }
  return data;
}
function dispose(obj) {
  if (obj.dispose && obj.type !== "Scene") obj.dispose();
  for (const p22 in obj) {
    p22.dispose == null ? void 0 : p22.dispose();
    delete obj[p22];
  }
}
function prepare(object, state) {
  const instance = object;
  instance.__r3f = __spreadValues({
    type: "",
    root: null,
    previousAttach: null,
    memoizedProps: {},
    eventCount: 0,
    handlers: {},
    objects: [],
    parent: null
  }, state);
  return object;
}
function resolve(instance, key) {
  let target2 = instance;
  if (key.includes("-")) {
    const entries = key.split("-");
    const last = entries.pop();
    target2 = entries.reduce((acc, key2) => acc[key2], instance);
    return {
      target: target2,
      key: last
    };
  } else return {
    target: target2,
    key
  };
}
function attach(parent, child, type) {
  if (is.str(type)) {
    if (INDEX_REGEX.test(type)) {
      const root = type.replace(INDEX_REGEX, "");
      const {
        target: target22,
        key: key2
      } = resolve(parent, root);
      if (!Array.isArray(target22[key2])) target22[key2] = [];
    }
    const {
      target: target2,
      key
    } = resolve(parent, type);
    child.__r3f.previousAttach = target2[key];
    target2[key] = child;
  } else child.__r3f.previousAttach = type(parent, child);
}
function detach(parent, child, type) {
  var _child$__r3f, _child$__r3f2;
  if (is.str(type)) {
    const {
      target: target2,
      key
    } = resolve(parent, type);
    const previous = child.__r3f.previousAttach;
    if (previous === void 0) delete target2[key];
    else target2[key] = previous;
  } else (_child$__r3f = child.__r3f) == null ? void 0 : _child$__r3f.previousAttach == null ? void 0 : _child$__r3f.previousAttach(parent, child);
  (_child$__r3f2 = child.__r3f) == null ? true : delete _child$__r3f2.previousAttach;
}
function diffProps(instance, _a22, _c = {}, remove = false) {
  var _b2 = _a22, {
    children: cN,
    key: kN,
    ref: rN
  } = _b2, props = __objRest(_b2, [
    "children",
    "key",
    "ref"
  ]);
  var _d = _c, {
    children: cP,
    key: kP,
    ref: rP
  } = _d, previous = __objRest(_d, [
    "children",
    "key",
    "ref"
  ]);
  const localState = instance.__r3f;
  const entries = Object.entries(props);
  const changes = [];
  if (remove) {
    const previousKeys = Object.keys(previous);
    for (let i2 = 0; i2 < previousKeys.length; i2++) {
      if (!props.hasOwnProperty(previousKeys[i2])) entries.unshift([previousKeys[i2], DEFAULT + "remove"]);
    }
  }
  entries.forEach(([key, value]) => {
    var _instance$__r3f;
    if ((_instance$__r3f = instance.__r3f) != null && _instance$__r3f.primitive && key === "object") return;
    if (is.equ(value, previous[key])) return;
    if (/^on(Pointer|Click|DoubleClick|ContextMenu|Wheel)/.test(key)) return changes.push([key, value, true, []]);
    let entries2 = [];
    if (key.includes("-")) entries2 = key.split("-");
    changes.push([key, value, false, entries2]);
    for (const prop in props) {
      const value2 = props[prop];
      if (prop.startsWith(`${key}-`)) changes.push([prop, value2, false, prop.split("-")]);
    }
  });
  const memoized = __spreadValues({}, props);
  if (localState != null && localState.memoizedProps && localState != null && localState.memoizedProps.args) memoized.args = localState.memoizedProps.args;
  if (localState != null && localState.memoizedProps && localState != null && localState.memoizedProps.attach) memoized.attach = localState.memoizedProps.attach;
  return {
    memoized,
    changes
  };
}
function applyProps$1(instance, data) {
  var _instance$__r3f2;
  const localState = instance.__r3f;
  const root = localState == null ? void 0 : localState.root;
  const rootState = root == null ? void 0 : root.getState == null ? void 0 : root.getState();
  const {
    memoized,
    changes
  } = isDiffSet(data) ? data : diffProps(instance, data);
  const prevHandlers = localState == null ? void 0 : localState.eventCount;
  if (instance.__r3f) instance.__r3f.memoizedProps = memoized;
  for (let i2 = 0; i2 < changes.length; i2++) {
    let [key, value, isEvent, keys] = changes[i2];
    if (hasColorSpace(instance)) {
      const sRGBEncoding = 3001;
      const SRGBColorSpace2 = "srgb";
      const LinearSRGBColorSpace2 = "srgb-linear";
      if (key === "encoding") {
        key = "colorSpace";
        value = value === sRGBEncoding ? SRGBColorSpace2 : LinearSRGBColorSpace2;
      } else if (key === "outputEncoding") {
        key = "outputColorSpace";
        value = value === sRGBEncoding ? SRGBColorSpace2 : LinearSRGBColorSpace2;
      }
    }
    let currentInstance = instance;
    let targetProp = currentInstance[key];
    if (keys.length) {
      targetProp = keys.reduce((acc, key2) => acc[key2], instance);
      if (!(targetProp && targetProp.set)) {
        const [name, ...reverseEntries] = keys.reverse();
        currentInstance = reverseEntries.reverse().reduce((acc, key2) => acc[key2], instance);
        key = name;
      }
    }
    if (value === DEFAULT + "remove") {
      if (currentInstance.constructor) {
        let ctor = DEFAULTS.get(currentInstance.constructor);
        if (!ctor) {
          ctor = new currentInstance.constructor();
          DEFAULTS.set(currentInstance.constructor, ctor);
        }
        value = ctor[key];
      } else {
        value = 0;
      }
    }
    if (isEvent && localState) {
      if (value) localState.handlers[key] = value;
      else delete localState.handlers[key];
      localState.eventCount = Object.keys(localState.handlers).length;
    } else if (targetProp && targetProp.set && (targetProp.copy || targetProp instanceof Layers)) {
      if (Array.isArray(value)) {
        if (targetProp.fromArray) targetProp.fromArray(value);
        else targetProp.set(...value);
      } else if (targetProp.copy && value && value.constructor && // Some environments may break strict identity checks by duplicating versions of three.js.
      // Loosen to unminified names, ignoring descendents.
      // https://github.com/pmndrs/react-three-fiber/issues/2856
      // TODO: fix upstream and remove in v9
      (__DEV__ ? targetProp.constructor.name === value.constructor.name : targetProp.constructor === value.constructor)) {
        targetProp.copy(value);
      } else if (value !== void 0) {
        var _targetProp;
        const isColor = (_targetProp = targetProp) == null ? void 0 : _targetProp.isColor;
        if (!isColor && targetProp.setScalar) targetProp.setScalar(value);
        else if (targetProp instanceof Layers && value instanceof Layers) targetProp.mask = value.mask;
        else targetProp.set(value);
        if (!getColorManagement() && rootState && !rootState.linear && isColor) targetProp.convertSRGBToLinear();
      }
    } else {
      var _currentInstance$key;
      currentInstance[key] = value;
      if ((_currentInstance$key = currentInstance[key]) != null && _currentInstance$key.isTexture && // sRGB textures must be RGBA8 since r137 https://github.com/mrdoob/three.js/pull/23129
      currentInstance[key].format === RGBAFormat && currentInstance[key].type === UnsignedByteType && rootState) {
        const texture = currentInstance[key];
        if (hasColorSpace(texture) && hasColorSpace(rootState.gl)) texture.colorSpace = rootState.gl.outputColorSpace;
        else texture.encoding = rootState.gl.outputEncoding;
      }
    }
    invalidateInstance(instance);
  }
  if (localState && localState.parent && instance.raycast && prevHandlers !== localState.eventCount) {
    const internal = findInitialRoot(instance).getState().internal;
    const index = internal.interaction.indexOf(instance);
    if (index > -1) internal.interaction.splice(index, 1);
    if (localState.eventCount) internal.interaction.push(instance);
  }
  const isCircular = changes.length === 1 && changes[0][0] === "onUpdate";
  if (!isCircular && changes.length && (_instance$__r3f2 = instance.__r3f) != null && _instance$__r3f2.parent) updateInstance(instance);
  return instance;
}
function invalidateInstance(instance) {
  var _instance$__r3f3, _instance$__r3f3$root;
  const state = (_instance$__r3f3 = instance.__r3f) == null ? void 0 : (_instance$__r3f3$root = _instance$__r3f3.root) == null ? void 0 : _instance$__r3f3$root.getState == null ? void 0 : _instance$__r3f3$root.getState();
  if (state && state.internal.frames === 0) state.invalidate();
}
function updateInstance(instance) {
  instance.onUpdate == null ? void 0 : instance.onUpdate(instance);
}
function updateCamera(camera, size) {
  if (!camera.manual) {
    if (isOrthographicCamera(camera)) {
      camera.left = size.width / -2;
      camera.right = size.width / 2;
      camera.top = size.height / 2;
      camera.bottom = size.height / -2;
    } else {
      camera.aspect = size.width / size.height;
    }
    camera.updateProjectionMatrix();
    camera.updateMatrixWorld();
  }
}
function makeId(event) {
  return (event.eventObject || event.object).uuid + "/" + event.index + event.instanceId;
}
function getEventPriority() {
  var _globalScope$event;
  const globalScope = typeof self !== "undefined" && self || typeof window !== "undefined" && window;
  if (!globalScope) return DefaultEventPriority;
  const name = (_globalScope$event = globalScope.event) == null ? void 0 : _globalScope$event.type;
  switch (name) {
    case "click":
    case "contextmenu":
    case "dblclick":
    case "pointercancel":
    case "pointerdown":
    case "pointerup":
      return DiscreteEventPriority;
    case "pointermove":
    case "pointerout":
    case "pointerover":
    case "pointerenter":
    case "pointerleave":
    case "wheel":
      return ContinuousEventPriority;
    default:
      return DefaultEventPriority;
  }
}
function releaseInternalPointerCapture(capturedMap, obj, captures, pointerId) {
  const captureData = captures.get(obj);
  if (captureData) {
    captures.delete(obj);
    if (captures.size === 0) {
      capturedMap.delete(pointerId);
      captureData.target.releasePointerCapture(pointerId);
    }
  }
}
function removeInteractivity(store, object) {
  const {
    internal
  } = store.getState();
  internal.interaction = internal.interaction.filter((o) => o !== object);
  internal.initialHits = internal.initialHits.filter((o) => o !== object);
  internal.hovered.forEach((value, key) => {
    if (value.eventObject === object || value.object === object) {
      internal.hovered.delete(key);
    }
  });
  internal.capturedMap.forEach((captures, pointerId) => {
    releaseInternalPointerCapture(internal.capturedMap, object, captures, pointerId);
  });
}
function createEvents(store) {
  function calculateDistance(event) {
    const {
      internal
    } = store.getState();
    const dx = event.offsetX - internal.initialClick[0];
    const dy = event.offsetY - internal.initialClick[1];
    return Math.round(Math.sqrt(dx * dx + dy * dy));
  }
  function filterPointerEvents(objects) {
    return objects.filter((obj) => ["Move", "Over", "Enter", "Out", "Leave"].some((name) => {
      var _r3f;
      return (_r3f = obj.__r3f) == null ? void 0 : _r3f.handlers["onPointer" + name];
    }));
  }
  function intersect2(event, filter) {
    const state = store.getState();
    const duplicates = /* @__PURE__ */ new Set();
    const intersections = [];
    const eventsObjects = filter ? filter(state.internal.interaction) : state.internal.interaction;
    for (let i2 = 0; i2 < eventsObjects.length; i2++) {
      const state2 = getRootState(eventsObjects[i2]);
      if (state2) {
        state2.raycaster.camera = void 0;
      }
    }
    if (!state.previousRoot) {
      state.events.compute == null ? void 0 : state.events.compute(event, state);
    }
    function handleRaycast(obj) {
      const state2 = getRootState(obj);
      if (!state2 || !state2.events.enabled || state2.raycaster.camera === null) return [];
      if (state2.raycaster.camera === void 0) {
        var _state$previousRoot;
        state2.events.compute == null ? void 0 : state2.events.compute(event, state2, (_state$previousRoot = state2.previousRoot) == null ? void 0 : _state$previousRoot.getState());
        if (state2.raycaster.camera === void 0) state2.raycaster.camera = null;
      }
      return state2.raycaster.camera ? state2.raycaster.intersectObject(obj, true) : [];
    }
    let hits = eventsObjects.flatMap(handleRaycast).sort((a, b) => {
      const aState = getRootState(a.object);
      const bState = getRootState(b.object);
      if (!aState || !bState) return a.distance - b.distance;
      return bState.events.priority - aState.events.priority || a.distance - b.distance;
    }).filter((item) => {
      const id = makeId(item);
      if (duplicates.has(id)) return false;
      duplicates.add(id);
      return true;
    });
    if (state.events.filter) hits = state.events.filter(hits, state);
    for (const hit of hits) {
      let eventObject = hit.object;
      while (eventObject) {
        var _r3f2;
        if ((_r3f2 = eventObject.__r3f) != null && _r3f2.eventCount) intersections.push(__spreadProps(__spreadValues({}, hit), {
          eventObject
        }));
        eventObject = eventObject.parent;
      }
    }
    if ("pointerId" in event && state.internal.capturedMap.has(event.pointerId)) {
      for (let captureData of state.internal.capturedMap.get(event.pointerId).values()) {
        if (!duplicates.has(makeId(captureData.intersection))) intersections.push(captureData.intersection);
      }
    }
    return intersections;
  }
  function handleIntersects(intersections, event, delta, callback) {
    const rootState = store.getState();
    if (intersections.length) {
      const localState = {
        stopped: false
      };
      for (const hit of intersections) {
        const state = getRootState(hit.object) || rootState;
        const {
          raycaster,
          pointer,
          camera,
          internal
        } = state;
        const unprojectedPoint = new Vector3(pointer.x, pointer.y, 0).unproject(camera);
        const hasPointerCapture = (id) => {
          var _internal$capturedMap, _internal$capturedMap2;
          return (_internal$capturedMap = (_internal$capturedMap2 = internal.capturedMap.get(id)) == null ? void 0 : _internal$capturedMap2.has(hit.eventObject)) != null ? _internal$capturedMap : false;
        };
        const setPointerCapture = (id) => {
          const captureData = {
            intersection: hit,
            target: event.target
          };
          if (internal.capturedMap.has(id)) {
            internal.capturedMap.get(id).set(hit.eventObject, captureData);
          } else {
            internal.capturedMap.set(id, /* @__PURE__ */ new Map([[hit.eventObject, captureData]]));
          }
          event.target.setPointerCapture(id);
        };
        const releasePointerCapture = (id) => {
          const captures = internal.capturedMap.get(id);
          if (captures) {
            releaseInternalPointerCapture(internal.capturedMap, hit.eventObject, captures, id);
          }
        };
        let extractEventProps = {};
        for (let prop in event) {
          let property = event[prop];
          if (typeof property !== "function") extractEventProps[prop] = property;
        }
        let raycastEvent = __spreadProps(__spreadValues(__spreadValues({}, hit), extractEventProps), {
          pointer,
          intersections,
          stopped: localState.stopped,
          delta,
          unprojectedPoint,
          ray: raycaster.ray,
          camera,
          // Hijack stopPropagation, which just sets a flag
          stopPropagation() {
            const capturesForPointer = "pointerId" in event && internal.capturedMap.get(event.pointerId);
            if (
              // ...if this pointer hasn't been captured
              !capturesForPointer || // ... or if the hit object is capturing the pointer
              capturesForPointer.has(hit.eventObject)
            ) {
              raycastEvent.stopped = localState.stopped = true;
              if (internal.hovered.size && Array.from(internal.hovered.values()).find((i2) => i2.eventObject === hit.eventObject)) {
                const higher = intersections.slice(0, intersections.indexOf(hit));
                cancelPointer([...higher, hit]);
              }
            }
          },
          // there should be a distinction between target and currentTarget
          target: {
            hasPointerCapture,
            setPointerCapture,
            releasePointerCapture
          },
          currentTarget: {
            hasPointerCapture,
            setPointerCapture,
            releasePointerCapture
          },
          nativeEvent: event
        });
        callback(raycastEvent);
        if (localState.stopped === true) break;
      }
    }
    return intersections;
  }
  function cancelPointer(intersections) {
    const {
      internal
    } = store.getState();
    for (const hoveredObj of internal.hovered.values()) {
      if (!intersections.length || !intersections.find((hit) => hit.object === hoveredObj.object && hit.index === hoveredObj.index && hit.instanceId === hoveredObj.instanceId)) {
        const eventObject = hoveredObj.eventObject;
        const instance = eventObject.__r3f;
        const handlers = instance == null ? void 0 : instance.handlers;
        internal.hovered.delete(makeId(hoveredObj));
        if (instance != null && instance.eventCount) {
          const data = __spreadProps(__spreadValues({}, hoveredObj), {
            intersections
          });
          handlers.onPointerOut == null ? void 0 : handlers.onPointerOut(data);
          handlers.onPointerLeave == null ? void 0 : handlers.onPointerLeave(data);
        }
      }
    }
  }
  function pointerMissed(event, objects) {
    for (let i2 = 0; i2 < objects.length; i2++) {
      const instance = objects[i2].__r3f;
      instance == null ? void 0 : instance.handlers.onPointerMissed == null ? void 0 : instance.handlers.onPointerMissed(event);
    }
  }
  function handlePointer(name) {
    switch (name) {
      case "onPointerLeave":
      case "onPointerCancel":
        return () => cancelPointer([]);
      case "onLostPointerCapture":
        return (event) => {
          const {
            internal
          } = store.getState();
          if ("pointerId" in event && internal.capturedMap.has(event.pointerId)) {
            requestAnimationFrame(() => {
              if (internal.capturedMap.has(event.pointerId)) {
                internal.capturedMap.delete(event.pointerId);
                cancelPointer([]);
              }
            });
          }
        };
    }
    return function handleEvent(event) {
      const {
        onPointerMissed,
        internal
      } = store.getState();
      internal.lastEvent.current = event;
      const isPointerMove = name === "onPointerMove";
      const isClickEvent = name === "onClick" || name === "onContextMenu" || name === "onDoubleClick";
      const filter = isPointerMove ? filterPointerEvents : void 0;
      const hits = intersect2(event, filter);
      const delta = isClickEvent ? calculateDistance(event) : 0;
      if (name === "onPointerDown") {
        internal.initialClick = [event.offsetX, event.offsetY];
        internal.initialHits = hits.map((hit) => hit.eventObject);
      }
      if (isClickEvent && !hits.length) {
        if (delta <= 2) {
          pointerMissed(event, internal.interaction);
          if (onPointerMissed) onPointerMissed(event);
        }
      }
      if (isPointerMove) cancelPointer(hits);
      function onIntersect(data) {
        const eventObject = data.eventObject;
        const instance = eventObject.__r3f;
        const handlers = instance == null ? void 0 : instance.handlers;
        if (!(instance != null && instance.eventCount)) return;
        if (isPointerMove) {
          if (handlers.onPointerOver || handlers.onPointerEnter || handlers.onPointerOut || handlers.onPointerLeave) {
            const id = makeId(data);
            const hoveredItem = internal.hovered.get(id);
            if (!hoveredItem) {
              internal.hovered.set(id, data);
              handlers.onPointerOver == null ? void 0 : handlers.onPointerOver(data);
              handlers.onPointerEnter == null ? void 0 : handlers.onPointerEnter(data);
            } else if (hoveredItem.stopped) {
              data.stopPropagation();
            }
          }
          handlers.onPointerMove == null ? void 0 : handlers.onPointerMove(data);
        } else {
          const handler = handlers[name];
          if (handler) {
            if (!isClickEvent || internal.initialHits.includes(eventObject)) {
              pointerMissed(event, internal.interaction.filter((object) => !internal.initialHits.includes(object)));
              handler(data);
            }
          } else {
            if (isClickEvent && internal.initialHits.includes(eventObject)) {
              pointerMissed(event, internal.interaction.filter((object) => !internal.initialHits.includes(object)));
            }
          }
        }
      }
      handleIntersects(hits, event, delta, onIntersect);
    };
  }
  return {
    handlePointer
  };
}
function run(effects, timestamp) {
  if (!effects.size) return;
  for (const {
    callback
  } of effects.values()) {
    callback(timestamp);
  }
}
function flushGlobalEffects(type, timestamp) {
  switch (type) {
    case "before":
      return run(globalEffects, timestamp);
    case "after":
      return run(globalAfterEffects, timestamp);
    case "tail":
      return run(globalTailEffects, timestamp);
  }
}
function render$1(timestamp, state, frame) {
  let delta = state.clock.getDelta();
  if (state.frameloop === "never" && typeof timestamp === "number") {
    delta = timestamp - state.clock.elapsedTime;
    state.clock.oldTime = state.clock.elapsedTime;
    state.clock.elapsedTime = timestamp;
  }
  subscribers = state.internal.subscribers;
  for (i = 0; i < subscribers.length; i++) {
    subscription = subscribers[i];
    subscription.ref.current(subscription.store.getState(), delta, frame);
  }
  if (!state.internal.priority && state.gl.render) state.gl.render(state.scene, state.camera);
  state.internal.frames = Math.max(0, state.internal.frames - 1);
  return state.frameloop === "always" ? 1 : state.internal.frames;
}
function createLoop(roots2) {
  let running = false;
  let useFrameInProgress = false;
  let repeat;
  let frame;
  let state;
  function loop(timestamp) {
    frame = requestAnimationFrame(loop);
    running = true;
    repeat = 0;
    flushGlobalEffects("before", timestamp);
    useFrameInProgress = true;
    for (const root of roots2.values()) {
      var _state$gl$xr;
      state = root.store.getState();
      if (state.internal.active && (state.frameloop === "always" || state.internal.frames > 0) && !((_state$gl$xr = state.gl.xr) != null && _state$gl$xr.isPresenting)) {
        repeat += render$1(timestamp, state);
      }
    }
    useFrameInProgress = false;
    flushGlobalEffects("after", timestamp);
    if (repeat === 0) {
      flushGlobalEffects("tail", timestamp);
      running = false;
      return cancelAnimationFrame(frame);
    }
  }
  function invalidate2(state2, frames = 1) {
    var _state$gl$xr2;
    if (!state2) return roots2.forEach((root) => invalidate2(root.store.getState(), frames));
    if ((_state$gl$xr2 = state2.gl.xr) != null && _state$gl$xr2.isPresenting || !state2.internal.active || state2.frameloop === "never") return;
    if (frames > 1) {
      state2.internal.frames = Math.min(60, state2.internal.frames + frames);
    } else {
      if (useFrameInProgress) {
        state2.internal.frames = 2;
      } else {
        state2.internal.frames = 1;
      }
    }
    if (!running) {
      running = true;
      requestAnimationFrame(loop);
    }
  }
  function advance2(timestamp, runGlobalEffects = true, state2, frame2) {
    if (runGlobalEffects) flushGlobalEffects("before", timestamp);
    if (!state2) for (const root of roots2.values()) render$1(timestamp, root.store.getState());
    else render$1(timestamp, state2, frame2);
    if (runGlobalEffects) flushGlobalEffects("after", timestamp);
  }
  return {
    loop,
    invalidate: invalidate2,
    advance: advance2
  };
}
function useStore() {
  const store = React.useContext(context);
  if (!store) throw new Error("R3F: Hooks can only be used within the Canvas component!");
  return store;
}
function useThree(selector = (state) => state, equalityFn) {
  return useStore()(selector, equalityFn);
}
function useFrame(callback, renderPriority = 0) {
  const store = useStore();
  const subscribe = store.getState().internal.subscribe;
  const ref = useMutableCallback(callback);
  useIsomorphicLayoutEffect2(() => subscribe(ref, renderPriority, store), [renderPriority, subscribe, store]);
  return null;
}
function loadingFn(extensions, onProgress) {
  return function(Proto, ...input) {
    let loader = memoizedLoaders.get(Proto);
    if (!loader) {
      loader = new Proto();
      memoizedLoaders.set(Proto, loader);
    }
    if (extensions) extensions(loader);
    return Promise.all(input.map((input2) => new Promise((res, reject) => loader.load(input2, (data) => {
      if (data.scene) Object.assign(data, buildGraph(data.scene));
      res(data);
    }, onProgress, (error2) => reject(new Error(`Could not load ${input2}: ${error2 == null ? void 0 : error2.message}`))))));
  };
}
function useLoader(Proto, input, extensions, onProgress) {
  const keys = Array.isArray(input) ? input : [input];
  const results = suspend(loadingFn(extensions, onProgress), [Proto, ...keys], {
    equal: is.equ
  });
  return Array.isArray(input) ? results : results[0];
}
function computeInitialSize(canvas, defaultSize) {
  const defaultStyle = typeof HTMLCanvasElement !== "undefined" && canvas instanceof HTMLCanvasElement;
  if (defaultSize) {
    const {
      width,
      height,
      top,
      left,
      updateStyle = defaultStyle
    } = defaultSize;
    return {
      width,
      height,
      top,
      left,
      updateStyle
    };
  } else if (typeof HTMLCanvasElement !== "undefined" && canvas instanceof HTMLCanvasElement && canvas.parentElement) {
    const {
      width,
      height,
      top,
      left
    } = canvas.parentElement.getBoundingClientRect();
    return {
      width,
      height,
      top,
      left,
      updateStyle: defaultStyle
    };
  } else if (typeof OffscreenCanvas !== "undefined" && canvas instanceof OffscreenCanvas) {
    return {
      width: canvas.width,
      height: canvas.height,
      top: 0,
      left: 0,
      updateStyle: defaultStyle
    };
  }
  return {
    width: 0,
    height: 0,
    top: 0,
    left: 0
  };
}
function createRoot(canvas) {
  const prevRoot = roots.get(canvas);
  const prevFiber = prevRoot == null ? void 0 : prevRoot.fiber;
  const prevStore = prevRoot == null ? void 0 : prevRoot.store;
  if (prevRoot) console.warn("R3F.createRoot should only be called once!");
  const logRecoverableError = typeof reportError === "function" ? (
    // In modern browsers, reportError will dispatch an error event,
    // emulating an uncaught JavaScript error.
    reportError
  ) : (
    // In older browsers and test environments, fallback to console.error.
    console.error
  );
  const store = prevStore || createStore2(invalidate, advance);
  const fiber = prevFiber || reconciler.createContainer(store, ConcurrentRoot, null, false, null, "", logRecoverableError, null);
  if (!prevRoot) roots.set(canvas, {
    fiber,
    store
  });
  let onCreated;
  let configured = false;
  let lastCamera;
  return {
    configure(props = {}) {
      let {
        gl: glConfig,
        size: propsSize,
        scene: sceneOptions,
        events,
        onCreated: onCreatedCallback,
        shadows = false,
        linear = false,
        flat = false,
        legacy = false,
        orthographic = false,
        frameloop = "always",
        dpr = [1, 2],
        performance: performance2,
        raycaster: raycastOptions,
        camera: cameraOptions,
        onPointerMissed
      } = props;
      let state = store.getState();
      let gl = state.gl;
      if (!state.gl) state.set({
        gl: gl = createRendererInstance(glConfig, canvas)
      });
      let raycaster = state.raycaster;
      if (!raycaster) state.set({
        raycaster: raycaster = new Raycaster()
      });
      const _a22 = raycastOptions || {}, {
        params
      } = _a22, options = __objRest(_a22, [
        "params"
      ]);
      if (!is.equ(options, raycaster, shallowLoose)) applyProps(raycaster, __spreadValues({}, options));
      if (!is.equ(params, raycaster.params, shallowLoose)) applyProps(raycaster, {
        params: __spreadValues(__spreadValues({}, raycaster.params), params)
      });
      if (!state.camera || state.camera === lastCamera && !is.equ(lastCamera, cameraOptions, shallowLoose)) {
        lastCamera = cameraOptions;
        const isCamera = cameraOptions instanceof Camera;
        const camera = isCamera ? cameraOptions : orthographic ? new OrthographicCamera(0, 0, 0, 0, 0.1, 1e3) : new PerspectiveCamera(75, 0, 0.1, 1e3);
        if (!isCamera) {
          camera.position.z = 5;
          if (cameraOptions) {
            applyProps(camera, cameraOptions);
            if ("aspect" in cameraOptions || "left" in cameraOptions || "right" in cameraOptions || "bottom" in cameraOptions || "top" in cameraOptions) {
              camera.manual = true;
              camera.updateProjectionMatrix();
            }
          }
          if (!state.camera && !(cameraOptions != null && cameraOptions.rotation)) camera.lookAt(0, 0, 0);
        }
        state.set({
          camera
        });
        raycaster.camera = camera;
      }
      if (!state.scene) {
        let scene;
        if (sceneOptions != null && sceneOptions.isScene) {
          scene = sceneOptions;
        } else {
          scene = new Scene();
          if (sceneOptions) applyProps(scene, sceneOptions);
        }
        state.set({
          scene: prepare(scene)
        });
      }
      if (!state.xr) {
        var _gl$xr;
        const handleXRFrame = (timestamp, frame) => {
          const state2 = store.getState();
          if (state2.frameloop === "never") return;
          advance(timestamp, true, state2, frame);
        };
        const handleSessionChange = () => {
          const state2 = store.getState();
          state2.gl.xr.enabled = state2.gl.xr.isPresenting;
          state2.gl.xr.setAnimationLoop(state2.gl.xr.isPresenting ? handleXRFrame : null);
          if (!state2.gl.xr.isPresenting) invalidate(state2);
        };
        const xr = {
          connect() {
            const gl2 = store.getState().gl;
            gl2.xr.addEventListener("sessionstart", handleSessionChange);
            gl2.xr.addEventListener("sessionend", handleSessionChange);
          },
          disconnect() {
            const gl2 = store.getState().gl;
            gl2.xr.removeEventListener("sessionstart", handleSessionChange);
            gl2.xr.removeEventListener("sessionend", handleSessionChange);
          }
        };
        if (typeof ((_gl$xr = gl.xr) == null ? void 0 : _gl$xr.addEventListener) === "function") xr.connect();
        state.set({
          xr
        });
      }
      if (gl.shadowMap) {
        const oldEnabled = gl.shadowMap.enabled;
        const oldType = gl.shadowMap.type;
        gl.shadowMap.enabled = !!shadows;
        if (is.boo(shadows)) {
          gl.shadowMap.type = PCFSoftShadowMap;
        } else if (is.str(shadows)) {
          var _types$shadows;
          const types = {
            basic: BasicShadowMap,
            percentage: PCFShadowMap,
            soft: PCFSoftShadowMap,
            variance: VSMShadowMap
          };
          gl.shadowMap.type = (_types$shadows = types[shadows]) != null ? _types$shadows : PCFSoftShadowMap;
        } else if (is.obj(shadows)) {
          Object.assign(gl.shadowMap, shadows);
        }
        if (oldEnabled !== gl.shadowMap.enabled || oldType !== gl.shadowMap.type) gl.shadowMap.needsUpdate = true;
      }
      const ColorManagement2 = getColorManagement();
      if (ColorManagement2) {
        if ("enabled" in ColorManagement2) ColorManagement2.enabled = !legacy;
        else if ("legacyMode" in ColorManagement2) ColorManagement2.legacyMode = legacy;
      }
      if (!configured) {
        const LinearEncoding = 3e3;
        const sRGBEncoding = 3001;
        applyProps(gl, {
          outputEncoding: linear ? LinearEncoding : sRGBEncoding,
          toneMapping: flat ? NoToneMapping : ACESFilmicToneMapping
        });
      }
      if (state.legacy !== legacy) state.set(() => ({
        legacy
      }));
      if (state.linear !== linear) state.set(() => ({
        linear
      }));
      if (state.flat !== flat) state.set(() => ({
        flat
      }));
      if (glConfig && !is.fun(glConfig) && !isRenderer(glConfig) && !is.equ(glConfig, gl, shallowLoose)) applyProps(gl, glConfig);
      if (events && !state.events.handlers) state.set({
        events: events(store)
      });
      const size = computeInitialSize(canvas, propsSize);
      if (!is.equ(size, state.size, shallowLoose)) {
        state.setSize(size.width, size.height, size.updateStyle, size.top, size.left);
      }
      if (dpr && state.viewport.dpr !== calculateDpr(dpr)) state.setDpr(dpr);
      if (state.frameloop !== frameloop) state.setFrameloop(frameloop);
      if (!state.onPointerMissed) state.set({
        onPointerMissed
      });
      if (performance2 && !is.equ(performance2, state.performance, shallowLoose)) state.set((state2) => ({
        performance: __spreadValues(__spreadValues({}, state2.performance), performance2)
      }));
      onCreated = onCreatedCallback;
      configured = true;
      return this;
    },
    render(children) {
      if (!configured) this.configure();
      reconciler.updateContainer(/* @__PURE__ */ jsx2(Provider, {
        store,
        children,
        onCreated,
        rootElement: canvas
      }), fiber, null, () => void 0);
      return store;
    },
    unmount() {
      unmountComponentAtNode(canvas);
    }
  };
}
function Provider({
  store,
  children,
  onCreated,
  rootElement
}) {
  useIsomorphicLayoutEffect2(() => {
    const state = store.getState();
    state.set((state2) => ({
      internal: __spreadProps(__spreadValues({}, state2.internal), {
        active: true
      })
    }));
    if (onCreated) onCreated(state);
    if (!store.getState().events.connected) state.events.connect == null ? void 0 : state.events.connect(rootElement);
  }, []);
  return /* @__PURE__ */ jsx2(context.Provider, {
    value: store,
    children
  });
}
function unmountComponentAtNode(canvas, callback) {
  const root = roots.get(canvas);
  const fiber = root == null ? void 0 : root.fiber;
  if (fiber) {
    const state = root == null ? void 0 : root.store.getState();
    if (state) state.internal.active = false;
    reconciler.updateContainer(null, fiber, null, () => {
      if (state) {
        setTimeout(() => {
          try {
            var _state$gl, _state$gl$renderLists, _state$gl2, _state$gl3;
            state.events.disconnect == null ? void 0 : state.events.disconnect();
            (_state$gl = state.gl) == null ? void 0 : (_state$gl$renderLists = _state$gl.renderLists) == null ? void 0 : _state$gl$renderLists.dispose == null ? void 0 : _state$gl$renderLists.dispose();
            (_state$gl2 = state.gl) == null ? void 0 : _state$gl2.forceContextLoss == null ? void 0 : _state$gl2.forceContextLoss();
            if ((_state$gl3 = state.gl) != null && _state$gl3.xr) state.xr.disconnect();
            dispose(state);
            roots.delete(canvas);
            if (callback) callback(canvas);
          } catch (e) {
          }
        }, 500);
      }
    });
  }
}
function createPortal(children, container, state) {
  return /* @__PURE__ */ jsx2(Portal, {
    children,
    container,
    state
  }, container.uuid);
}
function Portal({
  state = {},
  children,
  container
}) {
  const _a22 = state, {
    events,
    size
  } = _a22, rest = __objRest(_a22, [
    "events",
    "size"
  ]);
  const previousRoot = useStore();
  const [raycaster] = React.useState(() => new Raycaster());
  const [pointer] = React.useState(() => new Vector2());
  const inject = React.useCallback(
    (rootState, injectState) => {
      const intersect2 = __spreadValues({}, rootState);
      Object.keys(rootState).forEach((key) => {
        if (
          // Some props should be off-limits
          privateKeys.includes(key) || // Otherwise filter out the props that are different and let the inject layer take precedence
          // Unless the inject layer props is undefined, then we keep the root layer
          rootState[key] !== injectState[key] && injectState[key]
        ) {
          delete intersect2[key];
        }
      });
      let viewport = void 0;
      if (injectState && size) {
        const camera = injectState.camera;
        viewport = rootState.viewport.getCurrentViewport(camera, new Vector3(), size);
        if (camera !== rootState.camera) updateCamera(camera, size);
      }
      return __spreadValues(__spreadProps(__spreadValues({}, intersect2), {
        // Portals have their own scene, which forms the root, a raycaster and a pointer
        scene: container,
        raycaster,
        pointer,
        mouse: pointer,
        // Their previous root is the layer before it
        previousRoot,
        // Events, size and viewport can be overridden by the inject layer
        events: __spreadValues(__spreadValues(__spreadValues({}, rootState.events), injectState == null ? void 0 : injectState.events), events),
        size: __spreadValues(__spreadValues({}, rootState.size), size),
        viewport: __spreadValues(__spreadValues({}, rootState.viewport), viewport)
      }), rest);
    },
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [state]
  );
  const [usePortalStore] = React.useState(() => {
    const previousState = previousRoot.getState();
    const store = create((set, get) => __spreadProps(__spreadValues(__spreadProps(__spreadValues({}, previousState), {
      scene: container,
      raycaster,
      pointer,
      mouse: pointer,
      previousRoot,
      events: __spreadValues(__spreadValues({}, previousState.events), events),
      size: __spreadValues(__spreadValues({}, previousState.size), size)
    }), rest), {
      // Set and get refer to this root-state
      set,
      get,
      // Layers are allowed to override events
      setEvents: (events2) => set((state2) => __spreadProps(__spreadValues({}, state2), {
        events: __spreadValues(__spreadValues({}, state2.events), events2)
      }))
    }));
    return store;
  });
  React.useEffect(() => {
    const unsub = previousRoot.subscribe((prev) => usePortalStore.setState((state2) => inject(prev, state2)));
    return () => {
      unsub();
    };
  }, [inject]);
  React.useEffect(() => {
    usePortalStore.setState((injectState) => inject(previousRoot.getState(), injectState));
  }, [inject]);
  React.useEffect(() => {
    return () => {
      usePortalStore.destroy();
    };
  }, []);
  return /* @__PURE__ */ jsx2(Fragment2, {
    children: reconciler.createPortal(/* @__PURE__ */ jsx2(context.Provider, {
      value: usePortalStore,
      children
    }), usePortalStore, null)
  });
}
function createPointerEvents(store) {
  const {
    handlePointer
  } = createEvents(store);
  return {
    priority: 1,
    enabled: true,
    compute(event, state, previous) {
      state.pointer.set(event.offsetX / state.size.width * 2 - 1, -(event.offsetY / state.size.height) * 2 + 1);
      state.raycaster.setFromCamera(state.pointer, state.camera);
    },
    connected: void 0,
    handlers: Object.keys(DOM_EVENTS).reduce((acc, key) => __spreadProps(__spreadValues({}, acc), {
      [key]: handlePointer(key)
    }), {}),
    update: () => {
      var _internal$lastEvent;
      const {
        events,
        internal
      } = store.getState();
      if ((_internal$lastEvent = internal.lastEvent) != null && _internal$lastEvent.current && events.handlers) events.handlers.onPointerMove(internal.lastEvent.current);
    },
    connect: (target2) => {
      var _events$handlers;
      const {
        set,
        events
      } = store.getState();
      events.disconnect == null ? void 0 : events.disconnect();
      set((state) => ({
        events: __spreadProps(__spreadValues({}, state.events), {
          connected: target2
        })
      }));
      Object.entries((_events$handlers = events.handlers) != null ? _events$handlers : []).forEach(([name, event]) => {
        const [eventName, passive] = DOM_EVENTS[name];
        target2.addEventListener(eventName, event, {
          passive
        });
      });
    },
    disconnect: () => {
      const {
        set,
        events
      } = store.getState();
      if (events.connected) {
        var _events$handlers2;
        Object.entries((_events$handlers2 = events.handlers) != null ? _events$handlers2 : []).forEach(([name, event]) => {
          if (events && events.connected instanceof HTMLElement) {
            const [eventName] = DOM_EVENTS[name];
            events.connected.removeEventListener(eventName, event);
          }
        });
        set((state) => ({
          events: __spreadProps(__spreadValues({}, state.events), {
            connected: void 0
          })
        }));
      }
    }
  };
}
function g2(n, t2) {
  let o;
  return (...i2) => {
    window.clearTimeout(o), o = window.setTimeout(() => n(...i2), t2);
  };
}
function j({ debounce: n, scroll: t2, polyfill: o, offsetSize: i2 } = { debounce: 0, scroll: false, offsetSize: false }) {
  const a = o || (typeof window == "undefined" ? class {
  } : window.ResizeObserver);
  if (!a) throw new Error("This browser does not support ResizeObserver out of the box. See: https://github.com/react-spring/react-use-measure/#resize-observer-polyfills");
  const [c, h2] = T({ left: 0, top: 0, width: 0, height: 0, bottom: 0, right: 0, x: 0, y: 0 }), e = p({ element: null, scrollContainers: null, resizeObserver: null, lastBounds: c, orientationHandler: null }), d = n ? typeof n == "number" ? n : n.scroll : null, f2 = n ? typeof n == "number" ? n : n.resize : null, w = p(false);
  u2(() => (w.current = true, () => void (w.current = false)));
  const [z2, m, s] = M2(() => {
    const r2 = () => {
      if (!e.current.element) return;
      const { left: y2, top: C, width: H2, height: O2, bottom: S2, right: x, x: B2, y: R2 } = e.current.element.getBoundingClientRect(), l2 = { left: y2, top: C, width: H2, height: O2, bottom: S2, right: x, x: B2, y: R2 };
      e.current.element instanceof HTMLElement && i2 && (l2.height = e.current.element.offsetHeight, l2.width = e.current.element.offsetWidth), Object.freeze(l2), w.current && !D2(e.current.lastBounds, l2) && h2(e.current.lastBounds = l2);
    };
    return [r2, f2 ? g2(r2, f2) : r2, d ? g2(r2, d) : r2];
  }, [h2, i2, d, f2]);
  function v2() {
    e.current.scrollContainers && (e.current.scrollContainers.forEach((r2) => r2.removeEventListener("scroll", s, true)), e.current.scrollContainers = null), e.current.resizeObserver && (e.current.resizeObserver.disconnect(), e.current.resizeObserver = null), e.current.orientationHandler && ("orientation" in screen && "removeEventListener" in screen.orientation ? screen.orientation.removeEventListener("change", e.current.orientationHandler) : "onorientationchange" in window && window.removeEventListener("orientationchange", e.current.orientationHandler));
  }
  function b() {
    e.current.element && (e.current.resizeObserver = new a(s), e.current.resizeObserver.observe(e.current.element), t2 && e.current.scrollContainers && e.current.scrollContainers.forEach((r2) => r2.addEventListener("scroll", s, { capture: true, passive: true })), e.current.orientationHandler = () => {
      s();
    }, "orientation" in screen && "addEventListener" in screen.orientation ? screen.orientation.addEventListener("change", e.current.orientationHandler) : "onorientationchange" in window && window.addEventListener("orientationchange", e.current.orientationHandler));
  }
  const L2 = (r2) => {
    !r2 || r2 === e.current.element || (v2(), e.current.element = r2, e.current.scrollContainers = E2(r2), b());
  };
  return X(s, !!t2), W(m), u2(() => {
    v2(), b();
  }, [t2, s, m]), u2(() => v2, []), [L2, c, z2];
}
function W(n) {
  u2(() => {
    const t2 = n;
    return window.addEventListener("resize", t2), () => void window.removeEventListener("resize", t2);
  }, [n]);
}
function X(n, t2) {
  u2(() => {
    if (t2) {
      const o = n;
      return window.addEventListener("scroll", o, { capture: true, passive: true }), () => void window.removeEventListener("scroll", o, true);
    }
  }, [n, t2]);
}
function E2(n) {
  const t2 = [];
  if (!n || n === document.body) return t2;
  const { overflow: o, overflowX: i2, overflowY: a } = window.getComputedStyle(n);
  return [o, i2, a].some((c) => c === "auto" || c === "scroll") && t2.push(n), [...t2, ...E2(n.parentElement)];
}
function traverseFiber(fiber, ascending, selector) {
  if (!fiber)
    return;
  if (selector(fiber) === true)
    return fiber;
  let child = ascending ? fiber.return : fiber.child;
  while (child) {
    const match = traverseFiber(child, ascending, selector);
    if (match)
      return match;
    child = ascending ? null : child.sibling;
  }
}
function wrapContext(context2) {
  try {
    return Object.defineProperties(context2, {
      _currentRenderer: {
        get() {
          return null;
        },
        set() {
        }
      },
      _currentRenderer2: {
        get() {
          return null;
        },
        set() {
        }
      }
    });
  } catch (_) {
    return context2;
  }
}
function useFiber() {
  const root = React2.useContext(FiberContext);
  if (root === null)
    throw new Error("its-fine: useFiber must be called within a <FiberProvider />!");
  const id = React2.useId();
  const fiber = React2.useMemo(() => {
    for (const maybeFiber of [root, root == null ? void 0 : root.alternate]) {
      if (!maybeFiber)
        continue;
      const fiber2 = traverseFiber(maybeFiber, false, (node) => {
        let state = node.memoizedState;
        while (state) {
          if (state.memoizedState === id)
            return true;
          state = state.next;
        }
      });
      if (fiber2)
        return fiber2;
    }
  }, [root, id]);
  return fiber;
}
function useContextMap() {
  const fiber = useFiber();
  const [contextMap] = React2.useState(() => /* @__PURE__ */ new Map());
  contextMap.clear();
  let node = fiber;
  while (node) {
    if (node.type && typeof node.type === "object") {
      const enableRenderableContext = node.type._context === void 0 && node.type.Provider === node.type;
      const context2 = enableRenderableContext ? node.type : node.type._context;
      if (context2 && context2 !== FiberContext && !contextMap.has(context2)) {
        contextMap.set(context2, React2.useContext(wrapContext(context2)));
      }
    }
    node = node.return;
  }
  return contextMap;
}
function useContextBridge() {
  const contextMap = useContextMap();
  return React2.useMemo(
    () => Array.from(contextMap.keys()).reduce(
      (Prev, context2) => (props) => /* @__PURE__ */ React2.createElement(Prev, null, /* @__PURE__ */ React2.createElement(context2.Provider, __spreadProps2(__spreadValues2({}, props), {
        value: contextMap.get(context2)
      }))),
      (props) => /* @__PURE__ */ React2.createElement(FiberProvider, __spreadValues2({}, props))
    ),
    [contextMap]
  );
}
var isSSR, useIsomorphicLayoutEffect, isPromise, globalCache, suspend, preload, clear, scheduler_development_exports, exports, module, __export0, __export1, __export2, __export3, __export4, __export5, __export6, __export7, __export8, __export9, __export10, __export11, __export12, __export13, __export14, __export15, __export16, __export17, __export18, scheduler_development_default, exports2, module2, l, p2, q, r, t, u, v, y, z, A, B, D, E, F, N, O, L, P, Q, S, T2, U, __export02, __export19, __export22, __export32, __export42, __export52, __export62, __export72, __export82, __export92, __export102, __export112, __export122, __export132, __export142, __export152, __export162, __export172, __export182, scheduler_production_min_default, global, exports3, module3, scheduler_default, catalogue, extend, _window$document, _window$navigator, hasColorSpace, getColorManagement, isOrthographicCamera, isRef, useIsomorphicLayoutEffect2, ErrorBoundary, DEFAULT, DEFAULTS, isDiffSet, getRootState, is, INDEX_REGEX, __DEV__, privateKeys, isRenderer, context, createStore2, i, globalEffects, globalAfterEffects, globalTailEffects, subscribers, subscription, memoizedLoaders, roots, invalidate, advance, reconciler, applyProps, shallowLoose, createRendererInstance, DOM_EVENTS, k2, D2, __defProp2, __defProps2, __getOwnPropDescs2, __getOwnPropSymbols2, __hasOwnProp2, __propIsEnum2, __defNormalProp2, __spreadValues2, __spreadProps2, _a, _b, useIsomorphicLayoutEffect3, error, FiberContext, FiberProvider, CanvasImpl, Canvas2;
var init_chunk_73SH6GTX = __esm({
  "../shadergradient-v2/dist/chunk-73SH6GTX.mjs"() {
    init_chunk_BT6X4JN2();
    init_chunk_5BEQP2BQ();
    isSSR = typeof window === "undefined" || !window.navigator || /ServerSideRendering|^Deno\//.test(window.navigator.userAgent);
    useIsomorphicLayoutEffect = isSSR ? useEffect2 : useLayoutEffect2;
    isPromise = (promise) => typeof promise === "object" && typeof promise.then === "function";
    globalCache = [];
    suspend = (fn, keys, config) => query(fn, keys, false, config);
    preload = (fn, keys, config) => void query(fn, keys, true, config);
    clear = (keys) => {
      if (keys === void 0 || keys.length === 0) globalCache.splice(0, globalCache.length);
      else {
        const entry = globalCache.find((entry2) => shallowEqualArrays(keys, entry2.keys, entry2.equal));
        if (entry) entry.remove();
      }
    };
    scheduler_development_exports = {};
    __export(scheduler_development_exports, {
      default: () => scheduler_development_default,
      unstable_IdlePriority: () => __export1,
      unstable_ImmediatePriority: () => __export2,
      unstable_LowPriority: () => __export3,
      unstable_NormalPriority: () => __export4,
      unstable_Profiling: () => __export5,
      unstable_UserBlockingPriority: () => __export6,
      unstable_cancelCallback: () => __export7,
      unstable_continueExecution: () => __export8,
      unstable_forceFrameRate: () => __export9,
      unstable_getCurrentPriorityLevel: () => __export10,
      unstable_getFirstCallbackNode: () => __export11,
      unstable_next: () => __export12,
      unstable_now: () => __export0,
      unstable_pauseExecution: () => __export13,
      unstable_requestPaint: () => __export14,
      unstable_runWithPriority: () => __export15,
      unstable_scheduleCallback: () => __export16,
      unstable_shouldYield: () => __export17,
      unstable_wrapCallback: () => __export18
    });
    exports = {};
    module = {
      get exports() {
        return exports;
      },
      set exports(value) {
        exports = value;
      }
    };
    if (true) {
      (function() {
        "use strict";
        if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart === "function") {
          __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
        }
        var enableSchedulerDebugging = false;
        var enableProfiling = false;
        var frameYieldMs = 5;
        function push(heap, node) {
          var index = heap.length;
          heap.push(node);
          siftUp(heap, node, index);
        }
        function peek(heap) {
          return heap.length === 0 ? null : heap[0];
        }
        function pop(heap) {
          if (heap.length === 0) {
            return null;
          }
          var first = heap[0];
          var last = heap.pop();
          if (last !== first) {
            heap[0] = last;
            siftDown(heap, last, 0);
          }
          return first;
        }
        function siftUp(heap, node, i2) {
          var index = i2;
          while (index > 0) {
            var parentIndex = index - 1 >>> 1;
            var parent = heap[parentIndex];
            if (compare(parent, node) > 0) {
              heap[parentIndex] = node;
              heap[index] = parent;
              index = parentIndex;
            } else {
              return;
            }
          }
        }
        function siftDown(heap, node, i2) {
          var index = i2;
          var length = heap.length;
          var halfLength = length >>> 1;
          while (index < halfLength) {
            var leftIndex = (index + 1) * 2 - 1;
            var left = heap[leftIndex];
            var rightIndex = leftIndex + 1;
            var right = heap[rightIndex];
            if (compare(left, node) < 0) {
              if (rightIndex < length && compare(right, left) < 0) {
                heap[index] = right;
                heap[rightIndex] = node;
                index = rightIndex;
              } else {
                heap[index] = left;
                heap[leftIndex] = node;
                index = leftIndex;
              }
            } else if (rightIndex < length && compare(right, node) < 0) {
              heap[index] = right;
              heap[rightIndex] = node;
              index = rightIndex;
            } else {
              return;
            }
          }
        }
        function compare(a, b) {
          var diff = a.sortIndex - b.sortIndex;
          return diff !== 0 ? diff : a.id - b.id;
        }
        var ImmediatePriority = 1;
        var UserBlockingPriority = 2;
        var NormalPriority = 3;
        var LowPriority = 4;
        var IdlePriority = 5;
        function markTaskErrored(task, ms) {
        }
        var hasPerformanceNow = typeof performance === "object" && typeof performance.now === "function";
        if (hasPerformanceNow) {
          var localPerformance = performance;
          exports.unstable_now = function() {
            return localPerformance.now();
          };
        } else {
          var localDate = Date;
          var initialTime = localDate.now();
          exports.unstable_now = function() {
            return localDate.now() - initialTime;
          };
        }
        var maxSigned31BitInt = 1073741823;
        var IMMEDIATE_PRIORITY_TIMEOUT = -1;
        var USER_BLOCKING_PRIORITY_TIMEOUT = 250;
        var NORMAL_PRIORITY_TIMEOUT = 5e3;
        var LOW_PRIORITY_TIMEOUT = 1e4;
        var IDLE_PRIORITY_TIMEOUT = maxSigned31BitInt;
        var taskQueue = [];
        var timerQueue = [];
        var taskIdCounter = 1;
        var currentTask = null;
        var currentPriorityLevel = NormalPriority;
        var isPerformingWork = false;
        var isHostCallbackScheduled = false;
        var isHostTimeoutScheduled = false;
        var localSetTimeout = typeof setTimeout === "function" ? setTimeout : null;
        var localClearTimeout = typeof clearTimeout === "function" ? clearTimeout : null;
        var localSetImmediate = typeof setImmediate !== "undefined" ? setImmediate : null;
        var isInputPending = typeof navigator !== "undefined" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 ? navigator.scheduling.isInputPending.bind(navigator.scheduling) : null;
        function advanceTimers(currentTime) {
          var timer = peek(timerQueue);
          while (timer !== null) {
            if (timer.callback === null) {
              pop(timerQueue);
            } else if (timer.startTime <= currentTime) {
              pop(timerQueue);
              timer.sortIndex = timer.expirationTime;
              push(taskQueue, timer);
            } else {
              return;
            }
            timer = peek(timerQueue);
          }
        }
        function handleTimeout(currentTime) {
          isHostTimeoutScheduled = false;
          advanceTimers(currentTime);
          if (!isHostCallbackScheduled) {
            if (peek(taskQueue) !== null) {
              isHostCallbackScheduled = true;
              requestHostCallback(flushWork);
            } else {
              var firstTimer = peek(timerQueue);
              if (firstTimer !== null) {
                requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);
              }
            }
          }
        }
        function flushWork(hasTimeRemaining, initialTime2) {
          isHostCallbackScheduled = false;
          if (isHostTimeoutScheduled) {
            isHostTimeoutScheduled = false;
            cancelHostTimeout();
          }
          isPerformingWork = true;
          var previousPriorityLevel = currentPriorityLevel;
          try {
            if (enableProfiling) {
              try {
                return workLoop(hasTimeRemaining, initialTime2);
              } catch (error2) {
                if (currentTask !== null) {
                  var currentTime = exports.unstable_now();
                  markTaskErrored(currentTask, currentTime);
                  currentTask.isQueued = false;
                }
                throw error2;
              }
            } else {
              return workLoop(hasTimeRemaining, initialTime2);
            }
          } finally {
            currentTask = null;
            currentPriorityLevel = previousPriorityLevel;
            isPerformingWork = false;
          }
        }
        function workLoop(hasTimeRemaining, initialTime2) {
          var currentTime = initialTime2;
          advanceTimers(currentTime);
          currentTask = peek(taskQueue);
          while (currentTask !== null && !enableSchedulerDebugging) {
            if (currentTask.expirationTime > currentTime && (!hasTimeRemaining || shouldYieldToHost())) {
              break;
            }
            var callback = currentTask.callback;
            if (typeof callback === "function") {
              currentTask.callback = null;
              currentPriorityLevel = currentTask.priorityLevel;
              var didUserCallbackTimeout = currentTask.expirationTime <= currentTime;
              var continuationCallback = callback(didUserCallbackTimeout);
              currentTime = exports.unstable_now();
              if (typeof continuationCallback === "function") {
                currentTask.callback = continuationCallback;
              } else {
                if (currentTask === peek(taskQueue)) {
                  pop(taskQueue);
                }
              }
              advanceTimers(currentTime);
            } else {
              pop(taskQueue);
            }
            currentTask = peek(taskQueue);
          }
          if (currentTask !== null) {
            return true;
          } else {
            var firstTimer = peek(timerQueue);
            if (firstTimer !== null) {
              requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);
            }
            return false;
          }
        }
        function unstable_runWithPriority(priorityLevel, eventHandler) {
          switch (priorityLevel) {
            case ImmediatePriority:
            case UserBlockingPriority:
            case NormalPriority:
            case LowPriority:
            case IdlePriority:
              break;
            default:
              priorityLevel = NormalPriority;
          }
          var previousPriorityLevel = currentPriorityLevel;
          currentPriorityLevel = priorityLevel;
          try {
            return eventHandler();
          } finally {
            currentPriorityLevel = previousPriorityLevel;
          }
        }
        function unstable_next(eventHandler) {
          var priorityLevel;
          switch (currentPriorityLevel) {
            case ImmediatePriority:
            case UserBlockingPriority:
            case NormalPriority:
              priorityLevel = NormalPriority;
              break;
            default:
              priorityLevel = currentPriorityLevel;
              break;
          }
          var previousPriorityLevel = currentPriorityLevel;
          currentPriorityLevel = priorityLevel;
          try {
            return eventHandler();
          } finally {
            currentPriorityLevel = previousPriorityLevel;
          }
        }
        function unstable_wrapCallback(callback) {
          var parentPriorityLevel = currentPriorityLevel;
          return function() {
            var previousPriorityLevel = currentPriorityLevel;
            currentPriorityLevel = parentPriorityLevel;
            try {
              return callback.apply(this, arguments);
            } finally {
              currentPriorityLevel = previousPriorityLevel;
            }
          };
        }
        function unstable_scheduleCallback(priorityLevel, callback, options) {
          var currentTime = exports.unstable_now();
          var startTime2;
          if (typeof options === "object" && options !== null) {
            var delay = options.delay;
            if (typeof delay === "number" && delay > 0) {
              startTime2 = currentTime + delay;
            } else {
              startTime2 = currentTime;
            }
          } else {
            startTime2 = currentTime;
          }
          var timeout;
          switch (priorityLevel) {
            case ImmediatePriority:
              timeout = IMMEDIATE_PRIORITY_TIMEOUT;
              break;
            case UserBlockingPriority:
              timeout = USER_BLOCKING_PRIORITY_TIMEOUT;
              break;
            case IdlePriority:
              timeout = IDLE_PRIORITY_TIMEOUT;
              break;
            case LowPriority:
              timeout = LOW_PRIORITY_TIMEOUT;
              break;
            case NormalPriority:
            default:
              timeout = NORMAL_PRIORITY_TIMEOUT;
              break;
          }
          var expirationTime = startTime2 + timeout;
          var newTask = {
            id: taskIdCounter++,
            callback,
            priorityLevel,
            startTime: startTime2,
            expirationTime,
            sortIndex: -1
          };
          if (startTime2 > currentTime) {
            newTask.sortIndex = startTime2;
            push(timerQueue, newTask);
            if (peek(taskQueue) === null && newTask === peek(timerQueue)) {
              if (isHostTimeoutScheduled) {
                cancelHostTimeout();
              } else {
                isHostTimeoutScheduled = true;
              }
              requestHostTimeout(handleTimeout, startTime2 - currentTime);
            }
          } else {
            newTask.sortIndex = expirationTime;
            push(taskQueue, newTask);
            if (!isHostCallbackScheduled && !isPerformingWork) {
              isHostCallbackScheduled = true;
              requestHostCallback(flushWork);
            }
          }
          return newTask;
        }
        function unstable_pauseExecution() {
        }
        function unstable_continueExecution() {
          if (!isHostCallbackScheduled && !isPerformingWork) {
            isHostCallbackScheduled = true;
            requestHostCallback(flushWork);
          }
        }
        function unstable_getFirstCallbackNode() {
          return peek(taskQueue);
        }
        function unstable_cancelCallback(task) {
          task.callback = null;
        }
        function unstable_getCurrentPriorityLevel() {
          return currentPriorityLevel;
        }
        var isMessageLoopRunning = false;
        var scheduledHostCallback = null;
        var taskTimeoutID = -1;
        var frameInterval = frameYieldMs;
        var startTime = -1;
        function shouldYieldToHost() {
          var timeElapsed = exports.unstable_now() - startTime;
          if (timeElapsed < frameInterval) {
            return false;
          }
          return true;
        }
        function requestPaint() {
        }
        function forceFrameRate(fps) {
          if (fps < 0 || fps > 125) {
            console["error"]("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported");
            return;
          }
          if (fps > 0) {
            frameInterval = Math.floor(1e3 / fps);
          } else {
            frameInterval = frameYieldMs;
          }
        }
        var performWorkUntilDeadline = function() {
          if (scheduledHostCallback !== null) {
            var currentTime = exports.unstable_now();
            startTime = currentTime;
            var hasTimeRemaining = true;
            var hasMoreWork = true;
            try {
              hasMoreWork = scheduledHostCallback(hasTimeRemaining, currentTime);
            } finally {
              if (hasMoreWork) {
                schedulePerformWorkUntilDeadline();
              } else {
                isMessageLoopRunning = false;
                scheduledHostCallback = null;
              }
            }
          } else {
            isMessageLoopRunning = false;
          }
        };
        var schedulePerformWorkUntilDeadline;
        if (typeof localSetImmediate === "function") {
          schedulePerformWorkUntilDeadline = function() {
            localSetImmediate(performWorkUntilDeadline);
          };
        } else if (typeof MessageChannel !== "undefined") {
          var channel = new MessageChannel();
          var port = channel.port2;
          channel.port1.onmessage = performWorkUntilDeadline;
          schedulePerformWorkUntilDeadline = function() {
            port.postMessage(null);
          };
        } else {
          schedulePerformWorkUntilDeadline = function() {
            localSetTimeout(performWorkUntilDeadline, 0);
          };
        }
        function requestHostCallback(callback) {
          scheduledHostCallback = callback;
          if (!isMessageLoopRunning) {
            isMessageLoopRunning = true;
            schedulePerformWorkUntilDeadline();
          }
        }
        function requestHostTimeout(callback, ms) {
          taskTimeoutID = localSetTimeout(function() {
            callback(exports.unstable_now());
          }, ms);
        }
        function cancelHostTimeout() {
          localClearTimeout(taskTimeoutID);
          taskTimeoutID = -1;
        }
        var unstable_requestPaint = requestPaint;
        var unstable_Profiling = null;
        exports.unstable_IdlePriority = IdlePriority;
        exports.unstable_ImmediatePriority = ImmediatePriority;
        exports.unstable_LowPriority = LowPriority;
        exports.unstable_NormalPriority = NormalPriority;
        exports.unstable_Profiling = unstable_Profiling;
        exports.unstable_UserBlockingPriority = UserBlockingPriority;
        exports.unstable_cancelCallback = unstable_cancelCallback;
        exports.unstable_continueExecution = unstable_continueExecution;
        exports.unstable_forceFrameRate = forceFrameRate;
        exports.unstable_getCurrentPriorityLevel = unstable_getCurrentPriorityLevel;
        exports.unstable_getFirstCallbackNode = unstable_getFirstCallbackNode;
        exports.unstable_next = unstable_next;
        exports.unstable_pauseExecution = unstable_pauseExecution;
        exports.unstable_requestPaint = unstable_requestPaint;
        exports.unstable_runWithPriority = unstable_runWithPriority;
        exports.unstable_scheduleCallback = unstable_scheduleCallback;
        exports.unstable_shouldYield = shouldYieldToHost;
        exports.unstable_wrapCallback = unstable_wrapCallback;
        if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop === "function") {
          __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
        }
      })();
    }
    if (Object.isExtensible(module.exports) && Object.keys(module.exports).length === 19) {
      __export0 = module.exports["unstable_now"];
      __export1 = module.exports["unstable_IdlePriority"];
      __export2 = module.exports["unstable_ImmediatePriority"];
      __export3 = module.exports["unstable_LowPriority"];
      __export4 = module.exports["unstable_NormalPriority"];
      __export5 = module.exports["unstable_Profiling"];
      __export6 = module.exports["unstable_UserBlockingPriority"];
      __export7 = module.exports["unstable_cancelCallback"];
      __export8 = module.exports["unstable_continueExecution"];
      __export9 = module.exports["unstable_forceFrameRate"];
      __export10 = module.exports["unstable_getCurrentPriorityLevel"];
      __export11 = module.exports["unstable_getFirstCallbackNode"];
      __export12 = module.exports["unstable_next"];
      __export13 = module.exports["unstable_pauseExecution"];
      __export14 = module.exports["unstable_requestPaint"];
      __export15 = module.exports["unstable_runWithPriority"];
      __export16 = module.exports["unstable_scheduleCallback"];
      __export17 = module.exports["unstable_shouldYield"];
      __export18 = module.exports["unstable_wrapCallback"];
    }
    scheduler_development_default = module.exports;
    exports2 = {};
    module2 = {
      get exports() {
        return exports2;
      },
      set exports(value) {
        exports2 = value;
      }
    };
    if ("object" === typeof performance && "function" === typeof performance.now) {
      l = performance;
      exports2.unstable_now = function() {
        return l.now();
      };
    } else {
      p2 = Date, q = p2.now();
      exports2.unstable_now = function() {
        return p2.now() - q;
      };
    }
    r = [];
    t = [];
    u = 1;
    v = null;
    y = 3;
    z = false;
    A = false;
    B = false;
    D = "function" === typeof setTimeout ? setTimeout : null;
    E = "function" === typeof clearTimeout ? clearTimeout : null;
    F = "undefined" !== typeof setImmediate ? setImmediate : null;
    "undefined" !== typeof navigator && void 0 !== navigator.scheduling && void 0 !== navigator.scheduling.isInputPending && navigator.scheduling.isInputPending.bind(navigator.scheduling);
    N = false;
    O = null;
    L = -1;
    P = 5;
    Q = -1;
    if ("function" === typeof F) S = function() {
      F(R);
    };
    else if ("undefined" !== typeof MessageChannel) {
      T2 = new MessageChannel(), U = T2.port2;
      T2.port1.onmessage = R;
      S = function() {
        U.postMessage(null);
      };
    } else S = function() {
      D(R, 0);
    };
    exports2.unstable_IdlePriority = 5;
    exports2.unstable_ImmediatePriority = 1;
    exports2.unstable_LowPriority = 4;
    exports2.unstable_NormalPriority = 3;
    exports2.unstable_Profiling = null;
    exports2.unstable_UserBlockingPriority = 2;
    exports2.unstable_cancelCallback = function(a) {
      a.callback = null;
    };
    exports2.unstable_continueExecution = function() {
      A || z || (A = true, I(J));
    };
    exports2.unstable_forceFrameRate = function(a) {
      0 > a || 125 < a ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : P = 0 < a ? Math.floor(1e3 / a) : 5;
    };
    exports2.unstable_getCurrentPriorityLevel = function() {
      return y;
    };
    exports2.unstable_getFirstCallbackNode = function() {
      return h(r);
    };
    exports2.unstable_next = function(a) {
      switch (y) {
        case 1:
        case 2:
        case 3:
          var b = 3;
          break;
        default:
          b = y;
      }
      var c = y;
      y = b;
      try {
        return a();
      } finally {
        y = c;
      }
    };
    exports2.unstable_pauseExecution = function() {
    };
    exports2.unstable_requestPaint = function() {
    };
    exports2.unstable_runWithPriority = function(a, b) {
      switch (a) {
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
          break;
        default:
          a = 3;
      }
      var c = y;
      y = a;
      try {
        return b();
      } finally {
        y = c;
      }
    };
    exports2.unstable_scheduleCallback = function(a, b, c) {
      var d = exports2.unstable_now();
      "object" === typeof c && null !== c ? (c = c.delay, c = "number" === typeof c && 0 < c ? d + c : d) : c = d;
      switch (a) {
        case 1:
          var e = -1;
          break;
        case 2:
          e = 250;
          break;
        case 5:
          e = 1073741823;
          break;
        case 4:
          e = 1e4;
          break;
        default:
          e = 5e3;
      }
      e = c + e;
      a = { id: u++, callback: b, priorityLevel: a, startTime: c, expirationTime: e, sortIndex: -1 };
      c > d ? (a.sortIndex = c, f(t, a), null === h(r) && a === h(t) && (B ? (E(L), L = -1) : B = true, K(H, c - d))) : (a.sortIndex = e, f(r, a), A || z || (A = true, I(J)));
      return a;
    };
    exports2.unstable_shouldYield = M;
    exports2.unstable_wrapCallback = function(a) {
      var b = y;
      return function() {
        var c = y;
        y = b;
        try {
          return a.apply(this, arguments);
        } finally {
          y = c;
        }
      };
    };
    if (Object.isExtensible(module2.exports) && Object.keys(module2.exports).length === 19) {
      __export02 = module2.exports["unstable_now"];
      __export19 = module2.exports["unstable_IdlePriority"];
      __export22 = module2.exports["unstable_ImmediatePriority"];
      __export32 = module2.exports["unstable_LowPriority"];
      __export42 = module2.exports["unstable_NormalPriority"];
      __export52 = module2.exports["unstable_Profiling"];
      __export62 = module2.exports["unstable_UserBlockingPriority"];
      __export72 = module2.exports["unstable_cancelCallback"];
      __export82 = module2.exports["unstable_continueExecution"];
      __export92 = module2.exports["unstable_forceFrameRate"];
      __export102 = module2.exports["unstable_getCurrentPriorityLevel"];
      __export112 = module2.exports["unstable_getFirstCallbackNode"];
      __export122 = module2.exports["unstable_next"];
      __export132 = module2.exports["unstable_pauseExecution"];
      __export142 = module2.exports["unstable_requestPaint"];
      __export152 = module2.exports["unstable_runWithPriority"];
      __export162 = module2.exports["unstable_scheduleCallback"];
      __export172 = module2.exports["unstable_shouldYield"];
      __export182 = module2.exports["unstable_wrapCallback"];
    }
    scheduler_production_min_default = module2.exports;
    global = typeof window !== "undefined" && window || typeof self !== "undefined" && self || typeof global !== "undefined" && global || typeof globalThis !== "undefined" && globalThis || {};
    exports3 = {};
    module3 = {
      get exports() {
        return exports3;
      },
      set exports(value) {
        exports3 = value;
      }
    };
    if (false) {
      module3.exports = __cjs_default__(typeof scheduler_production_min_exports !== "undefined" ? scheduler_production_min_exports : {});
    } else {
      module3.exports = __cjs_default__(typeof scheduler_development_exports !== "undefined" ? scheduler_development_exports : {});
    }
    scheduler_default = module3.exports;
    catalogue = {};
    extend = (objects) => void Object.assign(catalogue, objects);
    hasColorSpace = (object) => "colorSpace" in object || "outputColorSpace" in object;
    getColorManagement = () => {
      var _ColorManagement;
      return (_ColorManagement = catalogue.ColorManagement) != null ? _ColorManagement : null;
    };
    isOrthographicCamera = (def) => def && def.isOrthographicCamera;
    isRef = (obj) => obj && obj.hasOwnProperty("current");
    useIsomorphicLayoutEffect2 = typeof window !== "undefined" && ((_window$document = window.document) != null && _window$document.createElement || ((_window$navigator = window.navigator) == null ? void 0 : _window$navigator.product) === "ReactNative") ? React.useLayoutEffect : React.useEffect;
    ErrorBoundary = class extends React.Component {
      constructor(...args) {
        super(...args);
        this.state = {
          error: false
        };
      }
      componentDidCatch(err) {
        this.props.set(err);
      }
      render() {
        return this.state.error ? null : this.props.children;
      }
    };
    ErrorBoundary.getDerivedStateFromError = () => ({
      error: true
    });
    DEFAULT = "__default";
    DEFAULTS = /* @__PURE__ */ new Map();
    isDiffSet = (def) => def && !!def.memoized && !!def.changes;
    getRootState = (obj) => {
      var _r3f;
      return (_r3f = obj.__r3f) == null ? void 0 : _r3f.root.getState();
    };
    is = {
      obj: (a) => a === Object(a) && !is.arr(a) && typeof a !== "function",
      fun: (a) => typeof a === "function",
      str: (a) => typeof a === "string",
      num: (a) => typeof a === "number",
      boo: (a) => typeof a === "boolean",
      und: (a) => a === void 0,
      arr: (a) => Array.isArray(a),
      equ(a, b, {
        arrays = "shallow",
        objects = "reference",
        strict = true
      } = {}) {
        if (typeof a !== typeof b || !!a !== !!b) return false;
        if (is.str(a) || is.num(a) || is.boo(a)) return a === b;
        const isObj = is.obj(a);
        if (isObj && objects === "reference") return a === b;
        const isArr = is.arr(a);
        if (isArr && arrays === "reference") return a === b;
        if ((isArr || isObj) && a === b) return true;
        let i2;
        for (i2 in a) if (!(i2 in b)) return false;
        if (isObj && arrays === "shallow" && objects === "shallow") {
          for (i2 in strict ? b : a) if (!is.equ(a[i2], b[i2], {
            strict,
            objects: "reference"
          })) return false;
        } else {
          for (i2 in strict ? b : a) if (a[i2] !== b[i2]) return false;
        }
        if (is.und(i2)) {
          if (isArr && a.length === 0 && b.length === 0) return true;
          if (isObj && Object.keys(a).length === 0 && Object.keys(b).length === 0) return true;
          if (a !== b) return false;
        }
        return true;
      }
    };
    INDEX_REGEX = /-\d+$/;
    __DEV__ = typeof process !== "undefined" && true;
    privateKeys = ["set", "get", "setSize", "setFrameloop", "setDpr", "events", "invalidate", "advance", "size", "viewport"];
    isRenderer = (def) => !!(def != null && def.render);
    context = /* @__PURE__ */ React.createContext(null);
    createStore2 = (invalidate2, advance2) => {
      const rootState = create((set, get) => {
        const position = new Vector3();
        const defaultTarget = new Vector3();
        const tempTarget = new Vector3();
        function getCurrentViewport(camera = get().camera, target2 = defaultTarget, size = get().size) {
          const {
            width,
            height,
            top,
            left
          } = size;
          const aspect2 = width / height;
          if (target2.isVector3) tempTarget.copy(target2);
          else tempTarget.set(...target2);
          const distance = camera.getWorldPosition(position).distanceTo(tempTarget);
          if (isOrthographicCamera(camera)) {
            return {
              width: width / camera.zoom,
              height: height / camera.zoom,
              top,
              left,
              factor: 1,
              distance,
              aspect: aspect2
            };
          } else {
            const fov2 = camera.fov * Math.PI / 180;
            const h2 = 2 * Math.tan(fov2 / 2) * distance;
            const w = h2 * (width / height);
            return {
              width: w,
              height: h2,
              top,
              left,
              factor: width / w,
              distance,
              aspect: aspect2
            };
          }
        }
        let performanceTimeout = void 0;
        const setPerformanceCurrent = (current) => set((state2) => ({
          performance: __spreadProps(__spreadValues({}, state2.performance), {
            current
          })
        }));
        const pointer = new Vector2();
        const rootState2 = {
          set,
          get,
          // Mock objects that have to be configured
          gl: null,
          camera: null,
          raycaster: null,
          events: {
            priority: 1,
            enabled: true,
            connected: false
          },
          xr: null,
          scene: null,
          invalidate: (frames = 1) => invalidate2(get(), frames),
          advance: (timestamp, runGlobalEffects) => advance2(timestamp, runGlobalEffects, get()),
          legacy: false,
          linear: false,
          flat: false,
          controls: null,
          clock: new Clock(),
          pointer,
          mouse: pointer,
          frameloop: "always",
          onPointerMissed: void 0,
          performance: {
            current: 1,
            min: 0.5,
            max: 1,
            debounce: 200,
            regress: () => {
              const state2 = get();
              if (performanceTimeout) clearTimeout(performanceTimeout);
              if (state2.performance.current !== state2.performance.min) setPerformanceCurrent(state2.performance.min);
              performanceTimeout = setTimeout(() => setPerformanceCurrent(get().performance.max), state2.performance.debounce);
            }
          },
          size: {
            width: 0,
            height: 0,
            top: 0,
            left: 0,
            updateStyle: false
          },
          viewport: {
            initialDpr: 0,
            dpr: 0,
            width: 0,
            height: 0,
            top: 0,
            left: 0,
            aspect: 0,
            distance: 0,
            factor: 0,
            getCurrentViewport
          },
          setEvents: (events) => set((state2) => __spreadProps(__spreadValues({}, state2), {
            events: __spreadValues(__spreadValues({}, state2.events), events)
          })),
          setSize: (width, height, updateStyle, top, left) => {
            const camera = get().camera;
            const size = {
              width,
              height,
              top: top || 0,
              left: left || 0,
              updateStyle
            };
            set((state2) => ({
              size,
              viewport: __spreadValues(__spreadValues({}, state2.viewport), getCurrentViewport(camera, defaultTarget, size))
            }));
          },
          setDpr: (dpr) => set((state2) => {
            const resolved = calculateDpr(dpr);
            return {
              viewport: __spreadProps(__spreadValues({}, state2.viewport), {
                dpr: resolved,
                initialDpr: state2.viewport.initialDpr || resolved
              })
            };
          }),
          setFrameloop: (frameloop = "always") => {
            const clock = get().clock;
            clock.stop();
            clock.elapsedTime = 0;
            if (frameloop !== "never") {
              clock.start();
              clock.elapsedTime = 0;
            }
            set(() => ({
              frameloop
            }));
          },
          previousRoot: void 0,
          internal: {
            active: false,
            priority: 0,
            frames: 0,
            lastEvent: /* @__PURE__ */ React.createRef(),
            interaction: [],
            hovered: /* @__PURE__ */ new Map(),
            subscribers: [],
            initialClick: [0, 0],
            initialHits: [],
            capturedMap: /* @__PURE__ */ new Map(),
            subscribe: (ref, priority, store) => {
              const internal = get().internal;
              internal.priority = internal.priority + (priority > 0 ? 1 : 0);
              internal.subscribers.push({
                ref,
                priority,
                store
              });
              internal.subscribers = internal.subscribers.sort((a, b) => a.priority - b.priority);
              return () => {
                const internal2 = get().internal;
                if (internal2 != null && internal2.subscribers) {
                  internal2.priority = internal2.priority - (priority > 0 ? 1 : 0);
                  internal2.subscribers = internal2.subscribers.filter((s) => s.ref !== ref);
                }
              };
            }
          }
        };
        return rootState2;
      });
      const state = rootState.getState();
      let oldSize = state.size;
      let oldDpr = state.viewport.dpr;
      let oldCamera = state.camera;
      rootState.subscribe(() => {
        const {
          camera,
          size,
          viewport,
          gl,
          set
        } = rootState.getState();
        if (size.width !== oldSize.width || size.height !== oldSize.height || viewport.dpr !== oldDpr) {
          var _size$updateStyle;
          oldSize = size;
          oldDpr = viewport.dpr;
          updateCamera(camera, size);
          gl.setPixelRatio(viewport.dpr);
          const updateStyle = (_size$updateStyle = size.updateStyle) != null ? _size$updateStyle : typeof HTMLCanvasElement !== "undefined" && gl.domElement instanceof HTMLCanvasElement;
          gl.setSize(size.width, size.height, updateStyle);
        }
        if (camera !== oldCamera) {
          oldCamera = camera;
          set((state2) => ({
            viewport: __spreadValues(__spreadValues({}, state2.viewport), state2.viewport.getCurrentViewport(camera))
          }));
        }
      });
      rootState.subscribe((state2) => invalidate2(state2));
      return rootState;
    };
    globalEffects = /* @__PURE__ */ new Set();
    globalAfterEffects = /* @__PURE__ */ new Set();
    globalTailEffects = /* @__PURE__ */ new Set();
    memoizedLoaders = /* @__PURE__ */ new WeakMap();
    useLoader.preload = function(Proto, input, extensions) {
      const keys = Array.isArray(input) ? input : [input];
      return preload(loadingFn(extensions), [Proto, ...keys]);
    };
    useLoader.clear = function(Proto, input) {
      const keys = Array.isArray(input) ? input : [input];
      return clear([Proto, ...keys]);
    };
    roots = /* @__PURE__ */ new Map();
    ({
      invalidate,
      advance
    } = createLoop(roots));
    ({
      reconciler,
      applyProps
    } = createRenderer(roots, getEventPriority));
    shallowLoose = {
      objects: "shallow",
      strict: false
    };
    createRendererInstance = (gl, canvas) => {
      const customRenderer = typeof gl === "function" ? gl(canvas) : gl;
      if (isRenderer(customRenderer)) return customRenderer;
      else return new WebGLRenderer(__spreadValues({
        powerPreference: "high-performance",
        canvas,
        antialias: true,
        alpha: true
      }, gl));
    };
    reconciler.injectIntoDevTools({
      bundleType: false ? 0 : 1,
      rendererPackageName: "@react-three/fiber",
      version: React.version
    });
    DOM_EVENTS = {
      onClick: ["click", false],
      onContextMenu: ["contextmenu", false],
      onDoubleClick: ["dblclick", false],
      onWheel: ["wheel", true],
      onPointerDown: ["pointerdown", true],
      onPointerUp: ["pointerup", true],
      onPointerLeave: ["pointerleave", true],
      onPointerMove: ["pointermove", true],
      onPointerCancel: ["pointercancel", true],
      onLostPointerCapture: ["lostpointercapture", true]
    };
    k2 = ["x", "y", "top", "bottom", "left", "right", "width", "height"];
    D2 = (n, t2) => k2.every((o) => n[o] === t2[o]);
    __defProp2 = Object.defineProperty;
    __defProps2 = Object.defineProperties;
    __getOwnPropDescs2 = Object.getOwnPropertyDescriptors;
    __getOwnPropSymbols2 = Object.getOwnPropertySymbols;
    __hasOwnProp2 = Object.prototype.hasOwnProperty;
    __propIsEnum2 = Object.prototype.propertyIsEnumerable;
    __defNormalProp2 = (obj, key, value) => key in obj ? __defProp2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
    __spreadValues2 = (a, b) => {
      for (var prop in b || (b = {}))
        if (__hasOwnProp2.call(b, prop))
          __defNormalProp2(a, prop, b[prop]);
      if (__getOwnPropSymbols2)
        for (var prop of __getOwnPropSymbols2(b)) {
          if (__propIsEnum2.call(b, prop))
            __defNormalProp2(a, prop, b[prop]);
        }
      return a;
    };
    __spreadProps2 = (a, b) => __defProps2(a, __getOwnPropDescs2(b));
    useIsomorphicLayoutEffect3 = typeof window !== "undefined" && (((_a = window.document) == null ? void 0 : _a.createElement) || ((_b = window.navigator) == null ? void 0 : _b.product) === "ReactNative") ? React2.useLayoutEffect : React2.useEffect;
    error = console.error;
    console.error = function() {
      const message = [...arguments].join("");
      if ((message == null ? void 0 : message.startsWith("Warning:")) && message.includes("useContext")) {
        console.error = error;
        return;
      }
      return error.apply(this, arguments);
    };
    FiberContext = wrapContext(React2.createContext(null));
    FiberProvider = class extends React2.Component {
      render() {
        return /* @__PURE__ */ React2.createElement(FiberContext.Provider, {
          value: this._reactInternals
        }, this.props.children);
      }
    };
    CanvasImpl = /* @__PURE__ */ React3.forwardRef(function Canvas(_a22, forwardedRef) {
      var _b2 = _a22, {
        children,
        fallback,
        resize,
        style,
        gl,
        events = createPointerEvents,
        eventSource,
        eventPrefix,
        shadows,
        linear,
        flat,
        legacy,
        orthographic,
        frameloop,
        dpr,
        performance: performance2,
        raycaster,
        camera,
        scene,
        onPointerMissed,
        onCreated
      } = _b2, props = __objRest(_b2, [
        "children",
        "fallback",
        "resize",
        "style",
        "gl",
        "events",
        "eventSource",
        "eventPrefix",
        "shadows",
        "linear",
        "flat",
        "legacy",
        "orthographic",
        "frameloop",
        "dpr",
        "performance",
        "raycaster",
        "camera",
        "scene",
        "onPointerMissed",
        "onCreated"
      ]);
      React3.useMemo(() => extend(three_module_exports), []);
      const Bridge = useContextBridge();
      const [containerRef, containerRect] = j(__spreadValues({
        scroll: true,
        debounce: {
          scroll: 50,
          resize: 0
        }
      }, resize));
      const canvasRef = React3.useRef(null);
      const divRef = React3.useRef(null);
      React3.useImperativeHandle(forwardedRef, () => canvasRef.current);
      const handlePointerMissed = useMutableCallback(onPointerMissed);
      const [block, setBlock] = React3.useState(false);
      const [error2, setError] = React3.useState(false);
      if (block) throw block;
      if (error2) throw error2;
      const root = React3.useRef(null);
      useIsomorphicLayoutEffect2(() => {
        const canvas = canvasRef.current;
        if (containerRect.width > 0 && containerRect.height > 0 && canvas) {
          if (!root.current) root.current = createRoot(canvas);
          root.current.configure({
            gl,
            events,
            shadows,
            linear,
            flat,
            legacy,
            orthographic,
            frameloop,
            dpr,
            performance: performance2,
            raycaster,
            camera,
            scene,
            size: containerRect,
            // Pass mutable reference to onPointerMissed so it's free to update
            onPointerMissed: (...args) => handlePointerMissed.current == null ? void 0 : handlePointerMissed.current(...args),
            onCreated: (state) => {
              state.events.connect == null ? void 0 : state.events.connect(eventSource ? isRef(eventSource) ? eventSource.current : eventSource : divRef.current);
              if (eventPrefix) {
                state.setEvents({
                  compute: (event, state2) => {
                    const x = event[eventPrefix + "X"];
                    const y2 = event[eventPrefix + "Y"];
                    state2.pointer.set(x / state2.size.width * 2 - 1, -(y2 / state2.size.height) * 2 + 1);
                    state2.raycaster.setFromCamera(state2.pointer, state2.camera);
                  }
                });
              }
              onCreated == null ? void 0 : onCreated(state);
            }
          });
          root.current.render(/* @__PURE__ */ jsx22(Bridge, {
            children: /* @__PURE__ */ jsx22(ErrorBoundary, {
              set: setError,
              children: /* @__PURE__ */ jsx22(React3.Suspense, {
                fallback: /* @__PURE__ */ jsx22(Block, {
                  set: setBlock
                }),
                children: children != null ? children : null
              })
            })
          }));
        }
      });
      React3.useEffect(() => {
        const canvas = canvasRef.current;
        if (canvas) return () => unmountComponentAtNode(canvas);
      }, []);
      const pointerEvents = eventSource ? "none" : "auto";
      return /* @__PURE__ */ jsx22("div", __spreadProps(__spreadValues({
        ref: divRef,
        style: __spreadValues({
          position: "relative",
          width: "100%",
          height: "100%",
          overflow: "hidden",
          pointerEvents
        }, style)
      }, props), {
        children: /* @__PURE__ */ jsx22("div", {
          ref: containerRef,
          style: {
            width: "100%",
            height: "100%"
          },
          children: /* @__PURE__ */ jsx22("canvas", {
            ref: canvasRef,
            style: {
              display: "block"
            },
            children: fallback
          })
        })
      }));
    });
    Canvas2 = /* @__PURE__ */ React3.forwardRef(function CanvasWrapper(props, ref) {
      return /* @__PURE__ */ jsx22(FiberProvider, {
        children: /* @__PURE__ */ jsx22(CanvasImpl, __spreadProps(__spreadValues({}, props), {
          ref
        }))
      });
    });
  }
});

// ../shadergradient-v2/dist/chunk-V62OMFTZ.mjs
import { useEffect as useEffect5, useMemo as useMemo3, useRef as useRef4 } from "react";
import { jsx as jsx3 } from "react/jsx-runtime";
var Materials;
var init_chunk_V62OMFTZ = __esm({
  "../shadergradient-v2/dist/chunk-V62OMFTZ.mjs"() {
    init_chunk_BI5IV7LU();
    init_chunk_73SH6GTX();
    init_chunk_BT6X4JN2();
    init_chunk_5BEQP2BQ();
    Materials = ({
      animate,
      range,
      rangeStart,
      rangeEnd,
      loop,
      loopDuration,
      reflection,
      uniforms,
      vertexShader,
      fragmentShader,
      onInit,
      shader
    }) => {
      const localClockRef = useRef4(new Clock());
      const material = useMemo3(() => {
        const entries = Object.entries(uniforms);
        const colors = uniforms.colors;
        const uC1 = colorToRgb(colors[0]);
        const uC2 = colorToRgb(colors[1]);
        const uC3 = colorToRgb(colors[2]);
        const rgbColors = {
          uC1r: { value: formatColor(uC1 == null ? void 0 : uC1.r) },
          uC1g: { value: formatColor(uC1 == null ? void 0 : uC1.g) },
          uC1b: { value: formatColor(uC1 == null ? void 0 : uC1.b) },
          uC2r: { value: formatColor(uC2 == null ? void 0 : uC2.r) },
          uC2g: { value: formatColor(uC2 == null ? void 0 : uC2.g) },
          uC2b: { value: formatColor(uC2 == null ? void 0 : uC2.b) },
          uC3r: { value: formatColor(uC3 == null ? void 0 : uC3.r) },
          uC3g: { value: formatColor(uC3 == null ? void 0 : uC3.g) },
          uC3b: { value: formatColor(uC3 == null ? void 0 : uC3.b) }
        };
        const uniformValues = entries.reduce((acc, [name, value]) => {
          const uniform = UniformsUtils.clone({ [name]: { value } });
          return __spreadValues(__spreadValues({}, acc), uniform);
        }, {});
        const materialConfig = {
          userData: uniformValues,
          // sync uniform and userData to update uniforms from outside (MeshPhysicalMaterial)
          metalness: shader === "glass" ? 0 : 0.2,
          roughness: shader === "glass" ? 0.1 : 1 - (typeof reflection === "number" ? reflection : 0.1),
          side: DoubleSide,
          onBeforeCompile: (shader2) => {
            shader2.uniforms = __spreadValues(__spreadValues(__spreadValues({}, shader2.uniforms), uniformValues), rgbColors);
            shader2.vertexShader = vertexShader;
            shader2.fragmentShader = fragmentShader;
          }
          // wireframe: true,
        };
        if (shader === "glass") {
          materialConfig.transparent = true;
          materialConfig.opacity = 0.3;
          materialConfig.transmission = 0.9;
          materialConfig.thickness = 0.5;
          materialConfig.clearcoat = 1;
          materialConfig.clearcoatRoughness = 0;
          materialConfig.ior = 1.5;
          materialConfig.envMapIntensity = 1;
        }
        const material2 = new MeshPhysicalMaterial(materialConfig);
        entries.forEach(
          ([name]) => Object.defineProperty(material2, name, {
            get: () => material2.uniforms[name].value,
            set: (v2) => material2.uniforms[name].value = v2
          })
        );
        if (onInit) onInit(material2);
        return material2;
      }, [uniforms, vertexShader, fragmentShader, onInit, reflection, shader]);
      useEffect5(() => {
        return () => {
          material.dispose();
        };
      }, [material]);
      useEffect5(() => {
        if (animate === "on") {
          localClockRef.current.start();
        } else {
          localClockRef.current.stop();
        }
      }, [animate]);
      useFrame(() => {
        if (animate === "on" && material.userData.uTime) {
          let elapsed = localClockRef.current.getElapsedTime();
          if (loop === "on" && Number.isFinite(loopDuration) && loopDuration > 0) {
            elapsed = elapsed % loopDuration;
            if (material.userData.uLoop) {
              material.userData.uLoop.value = 1;
            }
            if (material.userData.uLoopDuration) {
              material.userData.uLoopDuration.value = loopDuration;
            }
          } else {
            if (material.userData.uLoop) {
              material.userData.uLoop.value = 0;
            }
            if (range === "enabled" && Number.isFinite(rangeStart) && Number.isFinite(rangeEnd) && rangeEnd > rangeStart) {
              elapsed = rangeStart + elapsed;
              if (elapsed >= rangeEnd) {
                elapsed = rangeStart;
                localClockRef.current.start();
              }
            }
          }
          material.userData.uTime.value = elapsed;
        }
      });
      return /* @__PURE__ */ jsx3("primitive", { attach: "material", object: material });
    };
  }
});

// ../shadergradient-v2/dist/chunk-KR7RCWZK.mjs
var plane_exports, fragment_default, vertex_default;
var init_chunk_KR7RCWZK = __esm({
  "../shadergradient-v2/dist/chunk-KR7RCWZK.mjs"() {
    init_chunk_5BEQP2BQ();
    plane_exports = {};
    __export(plane_exports, {
      fragment: () => fragment_default,
      vertex: () => vertex_default
    });
    fragment_default = "uniform float uC1r;\nuniform float uC1g;\nuniform float uC1b;\nuniform float uC2r;\nuniform float uC2g;\nuniform float uC2b;\nuniform float uC3r;\nuniform float uC3g;\nuniform float uC3b;\n\n\nvarying vec3 vNormal;\nvarying vec3 vPos;\n\nvoid main() {\n  vec3 color1 = vec3(uC1r, uC1g, uC1b);\n  vec3 color2 = vec3(uC2r, uC2g, uC2b);\n  vec3 color3 = vec3(uC3r, uC3g, uC3b);\n\n  gl_FragColor = vec4(color1 * vPos.x + color2 * vPos.y + color3 * vPos.z, 1.);\n\n}\n";
    vertex_default = "// #pragma glslify: cnoise3 = require(glsl-noise/classic/3d) \n\n// noise source from https://github.com/hughsk/glsl-noise/blob/master/periodic/3d.glsl\n\nvec3 mod289(vec3 x)\n{\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289(vec4 x)\n{\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x)\n{\n  return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nvec3 fade(vec3 t) {\n  return t*t*t*(t*(t*6.0-15.0)+10.0);\n}\n\nfloat cnoise(vec3 P)\n{\n  vec3 Pi0 = floor(P); // Integer part for indexing\n  vec3 Pi1 = Pi0 + vec3(1.0); // Integer part + 1\n  Pi0 = mod289(Pi0);\n  Pi1 = mod289(Pi1);\n  vec3 Pf0 = fract(P); // Fractional part for interpolation\n  vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\n  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n  vec4 iy = vec4(Pi0.yy, Pi1.yy);\n  vec4 iz0 = Pi0.zzzz;\n  vec4 iz1 = Pi1.zzzz;\n\n  vec4 ixy = permute(permute(ix) + iy);\n  vec4 ixy0 = permute(ixy + iz0);\n  vec4 ixy1 = permute(ixy + iz1);\n\n  vec4 gx0 = ixy0 * (1.0 / 7.0);\n  vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;\n  gx0 = fract(gx0);\n  vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\n  vec4 sz0 = step(gz0, vec4(0.0));\n  gx0 -= sz0 * (step(0.0, gx0) - 0.5);\n  gy0 -= sz0 * (step(0.0, gy0) - 0.5);\n\n  vec4 gx1 = ixy1 * (1.0 / 7.0);\n  vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;\n  gx1 = fract(gx1);\n  vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\n  vec4 sz1 = step(gz1, vec4(0.0));\n  gx1 -= sz1 * (step(0.0, gx1) - 0.5);\n  gy1 -= sz1 * (step(0.0, gy1) - 0.5);\n\n  vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);\n  vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);\n  vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);\n  vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);\n  vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);\n  vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);\n  vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);\n  vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);\n\n  vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n  g000 *= norm0.x;\n  g010 *= norm0.y;\n  g100 *= norm0.z;\n  g110 *= norm0.w;\n  vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n  g001 *= norm1.x;\n  g011 *= norm1.y;\n  g101 *= norm1.z;\n  g111 *= norm1.w;\n\n  float n000 = dot(g000, Pf0);\n  float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\n  float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\n  float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\n  float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\n  float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\n  float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\n  float n111 = dot(g111, Pf1);\n\n  vec3 fade_xyz = fade(Pf0);\n  vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\n  vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\n  float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x); \n  return 2.2 * n_xyz;\n}\n\n//-------- start here ------------\n\nmat3 rotation3dY(float angle) {\n  float s = sin(angle);\n  float c = cos(angle);\n\n  return mat3(c, 0.0, -s, 0.0, 1.0, 0.0, s, 0.0, c);\n}\n\nvec3 rotateY(vec3 v, float angle) { return rotation3dY(angle) * v; }\n\nvarying vec3 vNormal;\nvarying float displacement;\nvarying vec3 vPos;\nvarying float vDistort;\n\nvarying vec2 vUv;\n\nuniform float uTime;\nuniform float uSpeed;\n\nuniform float uLoadingTime;\n\nuniform float uNoiseDensity;\nuniform float uNoiseStrength;\n\n#define STANDARD\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n#ifdef USE_TANGENT\nvarying vec3 vTangent;\nvarying vec3 vBitangent;\n#endif\n#endif\n#include <clipping_planes_pars_vertex>\n#include <color_pars_vertex>\n#include <common>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <skinning_pars_vertex>\n#include <uv2_pars_vertex>\n#include <uv_pars_vertex>\n\nvoid main() {\n\n  #include <beginnormal_vertex>\n  #include <color_vertex>\n  #include <defaultnormal_vertex>\n  #include <morphnormal_vertex>\n  #include <skinbase_vertex>\n  #include <skinnormal_vertex>\n  #include <uv2_vertex>\n  #include <uv_vertex>\n  #ifndef FLAT_SHADED\n    vNormal = normalize(transformedNormal);\n  #ifdef USE_TANGENT\n    vTangent = normalize(transformedTangent);\n    vBitangent = normalize(cross(vNormal, vTangent) * tangent.w);\n  #endif\n  #endif\n  #include <begin_vertex>\n\n  #include <clipping_planes_vertex>\n  #include <displacementmap_vertex>\n  #include <logdepthbuf_vertex>\n  #include <morphtarget_vertex>\n  #include <project_vertex>\n  #include <skinning_vertex>\n    vViewPosition = -mvPosition.xyz;\n  #include <fog_vertex>\n  #include <shadowmap_vertex>\n  #include <worldpos_vertex>\n\n  //-------- start vertex ------------\n  vUv = uv;\n\n  // vNormal = normal;\n\n  float t = uTime * uSpeed;\n  // Create a sine wave from top to bottom of the sphere\n  float distortion = 0.75 * cnoise(0.43 * position * uNoiseDensity + t);\n\n  vec3 pos = position + normal * distortion * uNoiseStrength * uLoadingTime;\n  vPos = pos;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.);\n}\n";
  }
});

// ../shadergradient-v2/dist/chunk-Q2QAY7NM.mjs
var sphere_exports, fragment_default2, vertex_default2;
var init_chunk_Q2QAY7NM = __esm({
  "../shadergradient-v2/dist/chunk-Q2QAY7NM.mjs"() {
    init_chunk_5BEQP2BQ();
    sphere_exports = {};
    __export(sphere_exports, {
      fragment: () => fragment_default2,
      vertex: () => vertex_default2
    });
    fragment_default2 = "\n#define STANDARD\n#ifdef PHYSICAL\n#define REFLECTIVITY\n#define CLEARCOAT\n#define TRANSMISSION\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef TRANSMISSION\nuniform float transmission;\n#endif\n#ifdef REFLECTIVITY\nuniform float reflectivity;\n#endif\n#ifdef CLEARCOAT\nuniform float clearcoat;\nuniform float clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\nuniform vec3 sheen;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n#ifdef USE_TANGENT\nvarying vec3 vTangent;\nvarying vec3 vBitangent;\n#endif\n#endif\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <color_pars_fragment>\n#include <common>\n#include <dithering_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <map_pars_fragment>\n#include <packing>\n#include <uv2_pars_fragment>\n#include <uv_pars_fragment>\n// #include <transmissionmap_pars_fragment>\n#include <bsdfs>\n#include <bumpmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <clipping_planes_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <lights_physical_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <shadowmap_pars_fragment>\n// include\uB97C \uD1B5\uD574 \uAC00\uC838\uC628 \uAC12\uC740 \uB300\uBD80\uBD84 \uD658\uACBD, \uBE5B \uB4F1\uC744 \uACC4\uC0B0\uD558\uAE30 \uC704\uD574\uC11C \uAE30\uBCF8 fragment\n// shader\uC758 \uAC12\uB4E4\uC744 \uBC1B\uC544\uC654\uC2B5\uB2C8\uB2E4. \uC77C\uB2E8\uC740 \uBB34\uC2DC\uD558\uC154\uB3C4 \uB429\uB2C8\uB2E4.\nvarying vec3 vNormal;\nvarying float displacement;\nvarying vec3 vPos;\nvarying float vDistort;\nuniform float uC1r;\nuniform float uC1g;\nuniform float uC1b;\nuniform float uC2r;\nuniform float uC2g;\nuniform float uC2b;\nuniform float uC3r;\nuniform float uC3g;\nuniform float uC3b;\nvarying vec3 color1;\nvarying vec3 color2;\nvarying vec3 color3;\nvarying float distanceToCenter;\nvoid main() {\n  //-------- basic gradient ------------\n  vec3 color1 = vec3(uC1r, uC1g, uC1b);\n  vec3 color2 = vec3(uC2r, uC2g, uC2b);\n  vec3 color3 = vec3(uC3r, uC3g, uC3b);\n  float clearcoat = 1.0;\n  float clearcoatRoughness = 0.5;\n#include <clipping_planes_fragment>\n\n  float distanceToCenter = distance(vPos, vec3(0, 0, 0));\n  // distanceToCenter\uB85C \uC911\uC2EC\uC810\uACFC\uC758 \uAC70\uB9AC\uB97C \uAD6C\uD568.\n\n  vec4 diffuseColor =\n      vec4(mix(color3, mix(color2, color1, smoothstep(-1.0, 1.0, vPos.y)),\n               distanceToCenter),\n           1);\n\n  //-------- materiality ------------\n  ReflectedLight reflectedLight =\n      ReflectedLight(vec3(0.0), vec3(0.0), vec3(0.0), vec3(0.0));\n  vec3 totalEmissiveRadiance = emissive;\n#ifdef TRANSMISSION\n  float totalTransmission = transmission;\n#endif\n#include <logdepthbuf_fragment>\n#include <map_fragment>\n#include <color_fragment>\n#include <alphamap_fragment>\n#include <alphatest_fragment>\n#include <roughnessmap_fragment>\n#include <metalnessmap_fragment>\n#include <normal_fragment_begin>\n#include <normal_fragment_maps>\n#include <clearcoat_normal_fragment_begin>\n#include <clearcoat_normal_fragment_maps>\n#include <emissivemap_fragment>\n// #include <transmissionmap_fragment>\n#include <lights_physical_fragment>\n#include <lights_fragment_begin>\n#include <lights_fragment_maps>\n#include <lights_fragment_end>\n#include <aomap_fragment>\n  vec3 outgoingLight =\n      reflectedLight.directDiffuse + reflectedLight.indirectDiffuse +\n      reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n//\uC704\uC5D0\uC11C \uC815\uC758\uD55C diffuseColor\uC5D0 \uD658\uACBD\uC774\uB098 \uBC18\uC0AC\uAC12\uB4E4\uC744 \uBC18\uC601\uD55C \uAC12.\n#ifdef TRANSMISSION\n  diffuseColor.a *=\n      mix(saturate(1. - totalTransmission +\n                   linearToRelativeLuminance(reflectedLight.directSpecular +\n                                             reflectedLight.indirectSpecular)),\n          1.0, metalness);\n#endif\n  gl_FragColor = vec4(outgoingLight, diffuseColor.a);\n  // gl_FragColor\uAC00 fragment shader\uB97C \uD1B5\uD574 \uB098\uD0C0\uB098\uB294 \uCD5C\uC885\uAC12\uC73C\uB85C, diffuseColor\uC5D0\uC11C\n  // \uC815\uC758\uD55C \uADF8\uB77C\uB514\uC5B8\uD2B8 \uC0C9\uC0C1 \uC704\uC5D0 \uBC18\uC0AC\uB098 \uBE5B\uC744 \uACC4\uC0B0\uD55C \uAC12\uC744 \uCD5C\uC885\uAC12\uC73C\uB85C \uC815\uC758.\n  // gl_FragColor = vec4(mix(mix(color1, color3, smoothstep(-3.0, 3.0,vPos.x)),\n  // color2, vNormal.z), 1.0); \uC704\uCC98\uB7FC \uCD5C\uC885\uAC12\uC744 \uADF8\uB77C\uB514\uC5B8\uD2B8 \uAC12 \uC790\uCCB4\uB97C \uB123\uC73C\uBA74 \uD658\uACBD\n  // \uC601\uD5A5\uC5C6\uB294 \uADF8\uB77C\uB514\uC5B8\uD2B8\uB9CC \uD45C\uD604\uB428.\n\n#include <tonemapping_fragment>\n#include <encodings_fragment>\n#include <fog_fragment>\n#include <premultiplied_alpha_fragment>\n#include <dithering_fragment>\n}\n";
    vertex_default2 = "// #pragma glslify: pnoise = require(glsl-noise/periodic/3d)\n\nvec3 mod289(vec3 x)\n{\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289(vec4 x)\n{\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x)\n{\n  return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nvec3 fade(vec3 t) {\n  return t*t*t*(t*(t*6.0-15.0)+10.0);\n}\n\n// Classic Perlin noise, periodic variant\nfloat pnoise(vec3 P, vec3 rep)\n{\n  vec3 Pi0 = mod(floor(P), rep); // Integer part, modulo period\n  vec3 Pi1 = mod(Pi0 + vec3(1.0), rep); // Integer part + 1, mod period\n  Pi0 = mod289(Pi0);\n  Pi1 = mod289(Pi1);\n  vec3 Pf0 = fract(P); // Fractional part for interpolation\n  vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\n  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n  vec4 iy = vec4(Pi0.yy, Pi1.yy);\n  vec4 iz0 = Pi0.zzzz;\n  vec4 iz1 = Pi1.zzzz;\n\n  vec4 ixy = permute(permute(ix) + iy);\n  vec4 ixy0 = permute(ixy + iz0);\n  vec4 ixy1 = permute(ixy + iz1);\n\n  vec4 gx0 = ixy0 * (1.0 / 7.0);\n  vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;\n  gx0 = fract(gx0);\n  vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\n  vec4 sz0 = step(gz0, vec4(0.0));\n  gx0 -= sz0 * (step(0.0, gx0) - 0.5);\n  gy0 -= sz0 * (step(0.0, gy0) - 0.5);\n\n  vec4 gx1 = ixy1 * (1.0 / 7.0);\n  vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;\n  gx1 = fract(gx1);\n  vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\n  vec4 sz1 = step(gz1, vec4(0.0));\n  gx1 -= sz1 * (step(0.0, gx1) - 0.5);\n  gy1 -= sz1 * (step(0.0, gy1) - 0.5);\n\n  vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);\n  vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);\n  vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);\n  vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);\n  vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);\n  vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);\n  vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);\n  vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);\n\n  vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n  g000 *= norm0.x;\n  g010 *= norm0.y;\n  g100 *= norm0.z;\n  g110 *= norm0.w;\n  vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n  g001 *= norm1.x;\n  g011 *= norm1.y;\n  g101 *= norm1.z;\n  g111 *= norm1.w;\n\n  float n000 = dot(g000, Pf0);\n  float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\n  float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\n  float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\n  float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\n  float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\n  float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\n  float n111 = dot(g111, Pf1);\n\n  vec3 fade_xyz = fade(Pf0);\n  vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\n  vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\n  float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x);\n  return 2.2 * n_xyz;\n}\n\n\n//-------- start here ------------\n\nvarying vec3 vNormal;\nuniform float uTime;\nuniform float uSpeed;\nuniform float uNoiseDensity;\nuniform float uNoiseStrength;\nuniform float uFrequency;\nuniform float uAmplitude;\nvarying vec3 vPos;\nvarying float vDistort;\nvarying vec2 vUv;\nvarying vec3 vViewPosition;\n\n#define STANDARD\n#ifndef FLAT_SHADED\n  #ifdef USE_TANGENT\n    varying vec3 vTangent;\n    varying vec3 vBitangent;\n  #endif\n#endif\n\n#include <clipping_planes_pars_vertex>\n#include <color_pars_vertex>\n#include <common>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <skinning_pars_vertex>\n#include <uv2_pars_vertex>\n#include <uv_pars_vertex>\n\n\n// rotation\nmat3 rotation3dY(float angle) {\n  float s = sin(angle);\n  float c = cos(angle);\n  return mat3(c, 0.0, -s, 0.0, 1.0, 0.0, s, 0.0, c);\n}\n\nvec3 rotateY(vec3 v, float angle) { return rotation3dY(angle) * v; }\n\nvoid main() {\n  #include <beginnormal_vertex>\n  #include <color_vertex>\n  #include <defaultnormal_vertex>\n  #include <morphnormal_vertex>\n  #include <skinbase_vertex>\n  #include <skinnormal_vertex>\n  #include <uv2_vertex>\n  #include <uv_vertex>\n  #ifndef FLAT_SHADED\n    vNormal = normalize(transformedNormal);\n  #ifdef USE_TANGENT\n    vTangent = normalize(transformedTangent);\n    vBitangent = normalize(cross(vNormal, vTangent) * tangent.w);\n  #endif\n  #endif\n  #include <begin_vertex>\n\n  #include <clipping_planes_vertex>\n  #include <displacementmap_vertex>\n  #include <logdepthbuf_vertex>\n  #include <morphtarget_vertex>\n  #include <project_vertex>\n  #include <skinning_vertex>\n    vViewPosition = -mvPosition.xyz;\n  #include <fog_vertex>\n  #include <shadowmap_vertex>\n  #include <worldpos_vertex>\n\n  //-------- start vertex ------------\n  float t = uTime * uSpeed;\n  float distortion =\n      pnoise((normal + t) * uNoiseDensity, vec3(10.0)) * uNoiseStrength;\n  vec3 pos = position + (normal * distortion);\n  float angle = sin(uv.y * uFrequency + t) * uAmplitude;\n  pos = rotateY(pos, angle);\n\n  vPos = pos;\n  vDistort = distortion;\n  vNormal = normal;\n  vUv = uv;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.);\n}\n";
  }
});

// ../shadergradient-v2/dist/chunk-NYQYF5HU.mjs
var waterPlane_exports, fragment_default3, vertex_default3;
var init_chunk_NYQYF5HU = __esm({
  "../shadergradient-v2/dist/chunk-NYQYF5HU.mjs"() {
    init_chunk_5BEQP2BQ();
    waterPlane_exports = {};
    __export(waterPlane_exports, {
      fragment: () => fragment_default3,
      vertex: () => vertex_default3
    });
    fragment_default3 = "uniform float uC1r;\nuniform float uC1g;\nuniform float uC1b;\nuniform float uC2r;\nuniform float uC2g;\nuniform float uC2b;\nuniform float uC3r;\nuniform float uC3g;\nuniform float uC3b;\n\n\nvarying vec3 vNormal;\nvarying vec3 vPos;\n\nvoid main() {\n  vec3 color1 = vec3(uC1r, uC1g, uC1b);\n  vec3 color2 = vec3(uC2r, uC2g, uC2b);\n  vec3 color3 = vec3(uC3r, uC3g, uC3b);\n\n  gl_FragColor = vec4(color1 * vPos.x + color2 * vPos.y + color3 * vPos.z, 1.);\n\n}\n";
    vertex_default3 = "// #pragma glslify: cnoise3 = require(glsl-noise/classic/3d) \n\n// noise source from https://github.com/hughsk/glsl-noise/blob/master/periodic/3d.glsl\n\nvec3 mod289(vec3 x)\n{\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289(vec4 x)\n{\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x)\n{\n  return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nvec3 fade(vec3 t) {\n  return t*t*t*(t*(t*6.0-15.0)+10.0);\n}\n\nfloat cnoise(vec3 P)\n{\n  vec3 Pi0 = floor(P); // Integer part for indexing\n  vec3 Pi1 = Pi0 + vec3(1.0); // Integer part + 1\n  Pi0 = mod289(Pi0);\n  Pi1 = mod289(Pi1);\n  vec3 Pf0 = fract(P); // Fractional part for interpolation\n  vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\n  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n  vec4 iy = vec4(Pi0.yy, Pi1.yy);\n  vec4 iz0 = Pi0.zzzz;\n  vec4 iz1 = Pi1.zzzz;\n\n  vec4 ixy = permute(permute(ix) + iy);\n  vec4 ixy0 = permute(ixy + iz0);\n  vec4 ixy1 = permute(ixy + iz1);\n\n  vec4 gx0 = ixy0 * (1.0 / 7.0);\n  vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;\n  gx0 = fract(gx0);\n  vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\n  vec4 sz0 = step(gz0, vec4(0.0));\n  gx0 -= sz0 * (step(0.0, gx0) - 0.5);\n  gy0 -= sz0 * (step(0.0, gy0) - 0.5);\n\n  vec4 gx1 = ixy1 * (1.0 / 7.0);\n  vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;\n  gx1 = fract(gx1);\n  vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\n  vec4 sz1 = step(gz1, vec4(0.0));\n  gx1 -= sz1 * (step(0.0, gx1) - 0.5);\n  gy1 -= sz1 * (step(0.0, gy1) - 0.5);\n\n  vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);\n  vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);\n  vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);\n  vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);\n  vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);\n  vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);\n  vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);\n  vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);\n\n  vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n  g000 *= norm0.x;\n  g010 *= norm0.y;\n  g100 *= norm0.z;\n  g110 *= norm0.w;\n  vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n  g001 *= norm1.x;\n  g011 *= norm1.y;\n  g101 *= norm1.z;\n  g111 *= norm1.w;\n\n  float n000 = dot(g000, Pf0);\n  float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\n  float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\n  float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\n  float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\n  float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\n  float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\n  float n111 = dot(g111, Pf1);\n\n  vec3 fade_xyz = fade(Pf0);\n  vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\n  vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\n  float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x); \n  return 2.2 * n_xyz;\n}\n\n//-------- start here ------------\n\nmat3 rotation3dY(float angle) {\n  float s = sin(angle);\n  float c = cos(angle);\n\n  return mat3(c, 0.0, -s, 0.0, 1.0, 0.0, s, 0.0, c);\n}\n\nvec3 rotateY(vec3 v, float angle) { return rotation3dY(angle) * v; }\n\nvarying vec3 vNormal;\nvarying float displacement;\nvarying vec3 vPos;\nvarying float vDistort;\n\nvarying vec2 vUv;\n\nuniform float uTime;\nuniform float uSpeed;\n\nuniform float uLoadingTime;\n\nuniform float uNoiseDensity;\nuniform float uNoiseStrength;\n\n#define STANDARD\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n#ifdef USE_TANGENT\nvarying vec3 vTangent;\nvarying vec3 vBitangent;\n#endif\n#endif\n#include <clipping_planes_pars_vertex>\n#include <color_pars_vertex>\n#include <common>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <skinning_pars_vertex>\n#include <uv2_pars_vertex>\n#include <uv_pars_vertex>\n\nvoid main() {\n\n  #include <beginnormal_vertex>\n  #include <color_vertex>\n  #include <defaultnormal_vertex>\n  #include <morphnormal_vertex>\n  #include <skinbase_vertex>\n  #include <skinnormal_vertex>\n  #include <uv2_vertex>\n  #include <uv_vertex>\n  #ifndef FLAT_SHADED\n    vNormal = normalize(transformedNormal);\n  #ifdef USE_TANGENT\n    vTangent = normalize(transformedTangent);\n    vBitangent = normalize(cross(vNormal, vTangent) * tangent.w);\n  #endif\n  #endif\n  #include <begin_vertex>\n\n  #include <clipping_planes_vertex>\n  #include <displacementmap_vertex>\n  #include <logdepthbuf_vertex>\n  #include <morphtarget_vertex>\n  #include <project_vertex>\n  #include <skinning_vertex>\n    vViewPosition = -mvPosition.xyz;\n  #include <fog_vertex>\n  #include <shadowmap_vertex>\n  #include <worldpos_vertex>\n\n  //-------- start vertex ------------\n  vUv = uv;\n\n  // vNormal = normal;\n\n  float t = uTime * uSpeed;\n  // Create a sine wave from top to bottom of the sphere\n  float distortion = 0.75 * cnoise(0.43 * position * uNoiseDensity + t);\n\n  vec3 pos = position + normal * distortion * uNoiseStrength * uLoadingTime;\n  vPos = pos;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.);\n}\n";
  }
});

// ../shadergradient-v2/dist/chunk-H2RSKIPT.mjs
var positionMix_exports;
var init_chunk_H2RSKIPT = __esm({
  "../shadergradient-v2/dist/chunk-H2RSKIPT.mjs"() {
    init_chunk_KR7RCWZK();
    init_chunk_Q2QAY7NM();
    init_chunk_NYQYF5HU();
    init_chunk_5BEQP2BQ();
    positionMix_exports = {};
    __export(positionMix_exports, {
      plane: () => plane_exports,
      sphere: () => sphere_exports,
      waterPlane: () => waterPlane_exports
    });
  }
});

// ../shadergradient-v2/dist/chunk-UDZCNACG.mjs
var plane_exports2, fragment_default4, vertex_default4;
var init_chunk_UDZCNACG = __esm({
  "../shadergradient-v2/dist/chunk-UDZCNACG.mjs"() {
    init_chunk_5BEQP2BQ();
    plane_exports2 = {};
    __export(plane_exports2, {
      fragment: () => fragment_default4,
      vertex: () => vertex_default4
    });
    fragment_default4 = "// Cosmic Plane Fragment Shader - Holographic Gradient\n\n#define STANDARD\n#ifdef PHYSICAL\n#define REFLECTIVITY\n#define CLEARCOAT\n#define TRANSMISSION\n#endif\n\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n\n#ifdef TRANSMISSION\nuniform float transmission;\n#endif\n#ifdef REFLECTIVITY\nuniform float reflectivity;\n#endif\n#ifdef CLEARCOAT\nuniform float clearcoat;\nuniform float clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\nuniform vec3 sheen;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n#ifdef USE_TANGENT\nvarying vec3 vTangent;\nvarying vec3 vBitangent;\n#endif\n#endif\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <color_pars_fragment>\n#include <common>\n#include <dithering_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <map_pars_fragment>\n#include <packing>\n#include <uv2_pars_fragment>\n#include <uv_pars_fragment>\n#include <bsdfs>\n#include <bumpmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <clipping_planes_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <lights_physical_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <shadowmap_pars_fragment>\n\nvarying vec3 vNormal;\nvarying float displacement;\nvarying vec3 vPos;\nvarying float vDistort;\nvarying vec2 vUv;\nvarying float vHolographicIntensity;\nvarying float vCosmicWave;\n\nuniform float uTime;\nuniform float uSpeed;\n\nuniform float uC1r;\nuniform float uC1g;\nuniform float uC1b;\nuniform float uC2r;\nuniform float uC2g;\nuniform float uC2b;\nuniform float uC3r;\nuniform float uC3g;\nuniform float uC3b;\n\n// Holographic helper functions\nfloat hash(vec2 p) {\n    return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453123);\n}\n\nfloat noise2D(vec2 p) {\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n    vec2 u = f * f * (3.0 - 2.0 * f);\n    \n    return mix(mix(hash(i + vec2(0.0, 0.0)), \n                   hash(i + vec2(1.0, 0.0)), u.x),\n               mix(hash(i + vec2(0.0, 1.0)), \n                   hash(i + vec2(1.0, 1.0)), u.x), u.y);\n}\n\n// for npm package, need to add this manually\nfloat linearToRelativeLuminance2( const in vec3 color ) {\n    vec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n    return dot( weights, color.rgb );\n}\n\nvoid main() {\n\n  //-------- Cosmic Holographic Gradient ------------\n  vec3 color1 = vec3(uC1r, uC1g, uC1b);\n  vec3 color2 = vec3(uC2r, uC2g, uC2b);\n  vec3 color3 = vec3(uC3r, uC3g, uC3b);\n  \n  float clearcoat = 1.0;\n  float clearcoatRoughness = 0.2; // More reflective for holographic effect\n\n  #include <clipping_planes_fragment>\n\n  float t = uTime * uSpeed;\n  \n  // Create holographic interference patterns\n  float interference1 = sin(vPos.x * 20.0 + t * 3.0) * cos(vPos.y * 15.0 + t * 2.0);\n  float interference2 = sin(vPos.x * 35.0 + t * 4.0) * sin(vPos.y * 30.0 + t * 3.5);\n  float interference3 = cos(vPos.x * 50.0 + t * 5.0) * cos(vPos.y * 45.0 + t * 4.5);\n  \n  // Combine interference patterns\n  float holographicPattern = (interference1 + interference2 * 0.5 + interference3 * 0.25) / 1.75;\n  \n  // Create cosmic shimmer effect\n  float shimmer = noise2D(vPos.xy * 40.0 + t * 2.0) * 0.3;\n  float cosmicGlow = noise2D(vPos.xy * 8.0 + t * 0.5) * 0.5;\n  \n  // Holographic color shifting\n  vec3 holographicShift = vec3(\n    sin(vPos.x * 10.0 + t * 2.0 + 0.0) * 0.1,\n    sin(vPos.x * 10.0 + t * 2.0 + 2.094) * 0.1,  // 120 degrees\n    sin(vPos.x * 10.0 + t * 2.0 + 4.188) * 0.1   // 240 degrees\n  );\n  \n  // Enhanced gradient mixing with cosmic effects\n  float gradientX = smoothstep(-4.0, 4.0, vPos.x + holographicPattern * 2.0);\n  float gradientY = smoothstep(-4.0, 4.0, vPos.y + vCosmicWave * 1.5);\n  float gradientZ = smoothstep(-2.0, 2.0, vPos.z + shimmer);\n  \n  // Multi-layer color mixing for depth\n  vec3 baseGradient = mix(\n    mix(color1, color2, gradientX), \n    color3, \n    gradientY * 0.7 + gradientZ * 0.3\n  );\n  \n  // Apply holographic color shifts\n  vec3 holographicColor = baseGradient + holographicShift;\n  \n  // Add cosmic glow and shimmer\n  vec3 cosmicEnhancement = vec3(\n    cosmicGlow * 0.2,\n    shimmer * 0.15,\n    (cosmicGlow + shimmer) * 0.1\n  );\n  \n  // Holographic intensity modulation\n  float intensityMod = 1.0 + vHolographicIntensity * 0.5 + abs(holographicPattern) * 0.3;\n  \n  // Final color with cosmic and holographic effects\n  vec3 finalColor = (holographicColor + cosmicEnhancement) * intensityMod;\n  \n  // Add subtle iridescence\n  float iridescence = sin(vPos.x * 25.0 + t * 3.0) * cos(vPos.y * 20.0 + t * 2.5) * 0.1;\n  finalColor += vec3(iridescence * 0.2, iridescence * 0.3, iridescence * 0.4);\n\n  vec4 diffuseColor = vec4(finalColor, 1.0);\n\n  //-------- Enhanced Materiality for Holographic Effect ------------\n  ReflectedLight reflectedLight = ReflectedLight(vec3(0.0), vec3(0.0), vec3(0.0), vec3(0.0));\n  vec3 totalEmissiveRadiance = emissive + finalColor * 0.1; // Add some emission for glow\n\n  #ifdef TRANSMISSION\n    float totalTransmission = transmission;\n  #endif\n  #include <logdepthbuf_fragment>\n  #include <map_fragment>\n  #include <color_fragment>\n  #include <alphamap_fragment>\n  #include <alphatest_fragment>\n  #include <roughnessmap_fragment>\n  #include <metalnessmap_fragment>\n  #include <normal_fragment_begin>\n  #include <normal_fragment_maps>\n  #include <clearcoat_normal_fragment_begin>\n  #include <clearcoat_normal_fragment_maps>\n  #include <emissivemap_fragment>\n  #include <lights_physical_fragment>\n  #include <lights_fragment_begin>\n  #include <lights_fragment_maps>\n  #include <lights_fragment_end>\n  #include <aomap_fragment>\n  \n  vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse +\n                      reflectedLight.directSpecular + reflectedLight.indirectSpecular +\n                      totalEmissiveRadiance;\n\n  #ifdef TRANSMISSION\n    diffuseColor.a *= mix(saturate(1. - totalTransmission +\n                        linearToRelativeLuminance2(reflectedLight.directSpecular +\n                                                  reflectedLight.indirectSpecular)),\n                1.0, metalness);\n  #endif\n\n  #include <tonemapping_fragment>\n  #include <encodings_fragment>\n  #include <fog_fragment>\n  #include <premultiplied_alpha_fragment>\n  #include <dithering_fragment>\n\n  gl_FragColor = vec4(outgoingLight, diffuseColor.a);\n}\n";
    vertex_default4 = "// Cosmic Plane Vertex Shader - Holographic Effect\n// #pragma glslify: cnoise3 = require(glsl-noise/classic/3d) \n\n// noise source from https://github.com/hughsk/glsl-noise/blob/master/periodic/3d.glsl\n\nvec3 mod289(vec3 x)\n{\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289(vec4 x)\n{\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x)\n{\n  return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nvec3 fade(vec3 t) {\n  return t*t*t*(t*(t*6.0-15.0)+10.0);\n}\n\nfloat cnoise(vec3 P)\n{\n  vec3 Pi0 = floor(P); // Integer part for indexing\n  vec3 Pi1 = Pi0 + vec3(1.0); // Integer part + 1\n  Pi0 = mod289(Pi0);\n  Pi1 = mod289(Pi1);\n  vec3 Pf0 = fract(P); // Fractional part for interpolation\n  vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\n  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n  vec4 iy = vec4(Pi0.yy, Pi1.yy);\n  vec4 iz0 = Pi0.zzzz;\n  vec4 iz1 = Pi1.zzzz;\n\n  vec4 ixy = permute(permute(ix) + iy);\n  vec4 ixy0 = permute(ixy + iz0);\n  vec4 ixy1 = permute(ixy + iz1);\n\n  vec4 gx0 = ixy0 * (1.0 / 7.0);\n  vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;\n  gx0 = fract(gx0);\n  vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\n  vec4 sz0 = step(gz0, vec4(0.0));\n  gx0 -= sz0 * (step(0.0, gx0) - 0.5);\n  gy0 -= sz0 * (step(0.0, gy0) - 0.5);\n\n  vec4 gx1 = ixy1 * (1.0 / 7.0);\n  vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;\n  gx1 = fract(gx1);\n  vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\n  vec4 sz1 = step(gz1, vec4(0.0));\n  gx1 -= sz1 * (step(0.0, gx1) - 0.5);\n  gy1 -= sz1 * (step(0.0, gy1) - 0.5);\n\n  vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);\n  vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);\n  vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);\n  vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);\n  vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);\n  vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);\n  vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);\n  vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);\n\n  vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n  g000 *= norm0.x;\n  g010 *= norm0.y;\n  g100 *= norm0.z;\n  g110 *= norm0.w;\n  vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n  g001 *= norm1.x;\n  g011 *= norm1.y;\n  g101 *= norm1.z;\n  g111 *= norm1.w;\n\n  float n000 = dot(g000, Pf0);\n  float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\n  float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\n  float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\n  float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\n  float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\n  float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\n  float n111 = dot(g111, Pf1);\n\n  vec3 fade_xyz = fade(Pf0);\n  vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\n  vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\n  float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x); \n  return 2.2 * n_xyz;\n}\n\n//-------- Holographic Effect Functions ------------\n\nmat3 rotation3dY(float angle) {\n  float s = sin(angle);\n  float c = cos(angle);\n  return mat3(c, 0.0, -s, 0.0, 1.0, 0.0, s, 0.0, c);\n}\n\nmat3 rotation3dX(float angle) {\n  float s = sin(angle);\n  float c = cos(angle);\n  return mat3(1.0, 0.0, 0.0, 0.0, c, s, 0.0, -s, c);\n}\n\nvec3 rotateY(vec3 v, float angle) { return rotation3dY(angle) * v; }\nvec3 rotateX(vec3 v, float angle) { return rotation3dX(angle) * v; }\n\nvarying vec3 vNormal;\nvarying float displacement;\nvarying vec3 vPos;\nvarying float vDistort;\nvarying vec2 vUv;\nvarying float vHolographicIntensity;\nvarying float vCosmicWave;\n\nuniform float uTime;\nuniform float uSpeed;\nuniform float uLoadingTime;\nuniform float uNoiseDensity;\nuniform float uNoiseStrength;\n\n#define STANDARD\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n#ifdef USE_TANGENT\nvarying vec3 vTangent;\nvarying vec3 vBitangent;\n#endif\n#endif\n#include <clipping_planes_pars_vertex>\n#include <color_pars_vertex>\n#include <common>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <skinning_pars_vertex>\n#include <uv2_pars_vertex>\n#include <uv_pars_vertex>\n\nvoid main() {\n\n  #include <beginnormal_vertex>\n  #include <color_vertex>\n  #include <defaultnormal_vertex>\n  #include <morphnormal_vertex>\n  #include <skinbase_vertex>\n  #include <skinnormal_vertex>\n  #include <uv2_vertex>\n  #include <uv_vertex>\n  #ifndef FLAT_SHADED\n    vNormal = normalize(transformedNormal);\n  #ifdef USE_TANGENT\n    vTangent = normalize(transformedTangent);\n    vBitangent = normalize(cross(vNormal, vTangent) * tangent.w);\n  #endif\n  #endif\n  #include <begin_vertex>\n\n  #include <clipping_planes_vertex>\n  #include <displacementmap_vertex>\n  #include <logdepthbuf_vertex>\n  #include <morphtarget_vertex>\n  #include <project_vertex>\n  #include <skinning_vertex>\n    vViewPosition = -mvPosition.xyz;\n  #include <fog_vertex>\n  #include <shadowmap_vertex>\n  #include <worldpos_vertex>\n\n  //-------- Cosmic Holographic Effect ------------\n  vUv = uv;\n  \n  float t = uTime * uSpeed;\n  \n  // Create holographic interference patterns\n  float holographicPattern = sin(position.x * 15.0 + t * 2.0) * \n                            sin(position.y * 12.0 + t * 1.5) * 0.1;\n  \n  // Cosmic wave distortion\n  float cosmicWave = cnoise(position * uNoiseDensity * 0.5 + vec3(t * 0.3, t * 0.2, t * 0.4));\n  vCosmicWave = cosmicWave;\n  \n  // Multi-layer noise for depth\n  float noise1 = cnoise(position * uNoiseDensity * 2.0 + t * 0.8);\n  float noise2 = cnoise(position * uNoiseDensity * 0.3 + t * 0.2) * 0.5;\n  float noise3 = cnoise(position * uNoiseDensity * 4.0 + t * 1.2) * 0.25;\n  \n  float combinedNoise = noise1 + noise2 + noise3;\n  \n  // Holographic shimmer effect\n  float shimmer = sin(position.x * 30.0 + t * 4.0) * \n                  cos(position.y * 25.0 + t * 3.0) * 0.05;\n  \n  // Calculate holographic intensity for fragment shader\n  vHolographicIntensity = abs(holographicPattern) + abs(shimmer) * 2.0;\n  \n  // Apply displacement with holographic and cosmic effects\n  float totalDisplacement = (combinedNoise + holographicPattern + shimmer) * uNoiseStrength * uLoadingTime;\n  \n  vec3 pos = position + normal * totalDisplacement;\n  vPos = pos;\n  \n  // Add subtle rotation effect for cosmic feel\n  pos = rotateY(pos, sin(t * 0.1) * 0.05);\n  pos = rotateX(pos, cos(t * 0.07) * 0.03);\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);\n}\n";
  }
});

// ../shadergradient-v2/dist/chunk-PBBG73XU.mjs
var sphere_exports2, fragment_default5, vertex_default5;
var init_chunk_PBBG73XU = __esm({
  "../shadergradient-v2/dist/chunk-PBBG73XU.mjs"() {
    init_chunk_5BEQP2BQ();
    sphere_exports2 = {};
    __export(sphere_exports2, {
      fragment: () => fragment_default5,
      vertex: () => vertex_default5
    });
    fragment_default5 = "// Cosmic Sphere Fragment Shader - Nebula Particle Effect\n\n#define STANDARD\n#ifdef PHYSICAL\n#define REFLECTIVITY\n#define CLEARCOAT\n#define TRANSMISSION\n#endif\n\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n\n#ifdef TRANSMISSION\nuniform float transmission;\n#endif\n#ifdef REFLECTIVITY\nuniform float reflectivity;\n#endif\n#ifdef CLEARCOAT\nuniform float clearcoat;\nuniform float clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\nuniform vec3 sheen;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n#ifdef USE_TANGENT\nvarying vec3 vTangent;\nvarying vec3 vBitangent;\n#endif\n#endif\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <color_pars_fragment>\n#include <common>\n#include <dithering_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <map_pars_fragment>\n#include <packing>\n#include <uv2_pars_fragment>\n#include <uv_pars_fragment>\n#include <bsdfs>\n#include <bumpmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <clipping_planes_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <lights_physical_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <shadowmap_pars_fragment>\n\nvarying vec3 vNormal;\nvarying float displacement;\nvarying vec3 vPos;\nvarying float vDistort;\nvarying vec2 vUv;\nvarying float vNebulaIntensity;\nvarying float vParticleDensity;\nvarying vec3 vCosmicSwirl;\n\nuniform float uTime;\nuniform float uSpeed;\n\nuniform float uC1r;\nuniform float uC1g;\nuniform float uC1b;\nuniform float uC2r;\nuniform float uC2g;\nuniform float uC2b;\nuniform float uC3r;\nuniform float uC3g;\nuniform float uC3b;\n\n// Nebula helper functions\nfloat hash(vec2 p) {\n    return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453123);\n}\n\nfloat noise2D(vec2 p) {\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n    vec2 u = f * f * (3.0 - 2.0 * f);\n    \n    return mix(mix(hash(i + vec2(0.0, 0.0)), \n                   hash(i + vec2(1.0, 0.0)), u.x),\n               mix(hash(i + vec2(0.0, 1.0)), \n                   hash(i + vec2(1.0, 1.0)), u.x), u.y);\n}\n\n// Fractal Brownian Motion for complex nebula patterns\nfloat fbm(vec2 p) {\n    float value = 0.0;\n    float amplitude = 0.5;\n    float frequency = 1.0;\n    \n    for(int i = 0; i < 5; i++) {\n        value += amplitude * noise2D(p * frequency);\n        amplitude *= 0.5;\n        frequency *= 2.0;\n    }\n    return value;\n}\n\n// Star field generation\nfloat stars(vec2 p, float density) {\n    vec2 n = floor(p * density);\n    vec2 f = fract(p * density);\n    \n    float d = 1.0;\n    for(int i = -1; i <= 1; i++) {\n        for(int j = -1; j <= 1; j++) {\n            vec2 g = vec2(float(i), float(j));\n            vec2 o = hash(n + g) * vec2(1.0);\n            vec2 r = g + o - f;\n            d = min(d, dot(r, r));\n        }\n    }\n    \n    return 1.0 - smoothstep(0.0, 0.02, sqrt(d));\n}\n\n// for npm package, need to add this manually\nfloat linearToRelativeLuminance2( const in vec3 color ) {\n    vec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n    return dot( weights, color.rgb );\n}\n\nvoid main() {\n\n  //-------- Cosmic Nebula Gradient ------------\n  vec3 color1 = vec3(uC1r, uC1g, uC1b);\n  vec3 color2 = vec3(uC2r, uC2g, uC2b);\n  vec3 color3 = vec3(uC3r, uC3g, uC3b);\n  \n  float clearcoat = 1.0;\n  float clearcoatRoughness = 0.1; // Very reflective for cosmic shine\n\n  #include <clipping_planes_fragment>\n\n  float t = uTime * uSpeed;\n  \n  // Calculate distance from center for radial effects\n  float distanceFromCenter = length(vPos);\n  float angle = atan(vPos.y, vPos.x);\n  \n  // Create complex nebula patterns using FBM\n  vec2 nebulaCoords = vPos.xy * 3.0 + vCosmicSwirl.xy;\n  float nebulaPattern1 = fbm(nebulaCoords + t * 0.1);\n  float nebulaPattern2 = fbm(nebulaCoords * 2.0 + t * 0.15);\n  float nebulaPattern3 = fbm(nebulaCoords * 4.0 + t * 0.2);\n  \n  // Combine nebula patterns\n  float combinedNebula = (nebulaPattern1 + nebulaPattern2 * 0.5 + nebulaPattern3 * 0.25) / 1.75;\n  \n  // Create particle-like bright spots\n  float particleField = stars(vPos.xy * 20.0 + t * 0.5, 50.0);\n  float microParticles = stars(vPos.xy * 80.0 + t * 1.0, 200.0) * 0.5;\n  \n  // Create cosmic dust clouds\n  float dustClouds = fbm(vPos.xy * 8.0 + t * 0.05) * 0.3;\n  \n  // Energy streams\n  float energyStream1 = sin(vPos.x * 15.0 + t * 3.0 + angle * 2.0) * 0.1;\n  float energyStream2 = cos(vPos.y * 20.0 + t * 2.5 + distanceFromCenter * 5.0) * 0.1;\n  \n  // Cosmic gradient mixing with nebula influence\n  float gradientX = smoothstep(-3.0, 3.0, vPos.x + combinedNebula * 2.0 + vCosmicSwirl.x * 3.0);\n  float gradientY = smoothstep(-3.0, 3.0, vPos.y + vNebulaIntensity * 1.5 + vCosmicSwirl.y * 2.0);\n  float gradientZ = smoothstep(-2.0, 2.0, vPos.z + dustClouds * 2.0);\n  \n  // Multi-layer color mixing\n  vec3 baseGradient = mix(\n    mix(color1, color2, gradientX), \n    color3, \n    gradientY * 0.6 + gradientZ * 0.4\n  );\n  \n  // Add nebula color variations\n  vec3 nebulaColor = baseGradient;\n  nebulaColor.r += combinedNebula * 0.3 + energyStream1;\n  nebulaColor.g += vNebulaIntensity * 0.2 + energyStream2;\n  nebulaColor.b += dustClouds * 0.4 + abs(vCosmicSwirl.z) * 0.5;\n  \n  // Add particle brightness\n  vec3 particleGlow = vec3(\n    particleField * 0.8 + microParticles * 0.4,\n    particleField * 0.6 + microParticles * 0.3,\n    particleField * 0.9 + microParticles * 0.5\n  );\n  \n  // Create pulsing cosmic energy\n  float cosmicPulse = sin(t * 1.5 + distanceFromCenter * 3.0) * 0.1 + 1.0;\n  \n  // Combine all effects\n  vec3 finalColor = (nebulaColor + particleGlow * 2.0) * cosmicPulse;\n  \n  // Add cosmic rim lighting effect\n  float rimLight = pow(1.0 - abs(dot(normalize(vNormal), normalize(vViewPosition))), 2.0);\n  finalColor += rimLight * 0.3 * (color1 + color2 + color3) / 3.0;\n  \n  // Enhance particle density areas\n  finalColor = mix(finalColor, finalColor * 1.5, vParticleDensity * 0.5);\n  \n  // Add subtle color temperature variation\n  float temperature = sin(angle * 3.0 + t * 0.8) * 0.1;\n  finalColor.r += temperature * 0.1;\n  finalColor.b -= temperature * 0.1;\n\n  vec4 diffuseColor = vec4(finalColor, 1.0);\n\n  //-------- Enhanced Materiality for Cosmic Effect ------------\n  ReflectedLight reflectedLight = ReflectedLight(vec3(0.0), vec3(0.0), vec3(0.0), vec3(0.0));\n  vec3 totalEmissiveRadiance = emissive + finalColor * 0.2; // Strong emission for nebula glow\n\n  #ifdef TRANSMISSION\n    float totalTransmission = transmission;\n  #endif\n  #include <logdepthbuf_fragment>\n  #include <map_fragment>\n  #include <color_fragment>\n  #include <alphamap_fragment>\n  #include <alphatest_fragment>\n  #include <roughnessmap_fragment>\n  #include <metalnessmap_fragment>\n  #include <normal_fragment_begin>\n  #include <normal_fragment_maps>\n  #include <clearcoat_normal_fragment_begin>\n  #include <clearcoat_normal_fragment_maps>\n  #include <emissivemap_fragment>\n  #include <lights_physical_fragment>\n  #include <lights_fragment_begin>\n  #include <lights_fragment_maps>\n  #include <lights_fragment_end>\n  #include <aomap_fragment>\n  \n  vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse +\n                      reflectedLight.directSpecular + reflectedLight.indirectSpecular +\n                      totalEmissiveRadiance;\n\n  #ifdef TRANSMISSION\n    diffuseColor.a *= mix(saturate(1. - totalTransmission +\n                        linearToRelativeLuminance2(reflectedLight.directSpecular +\n                                                  reflectedLight.indirectSpecular)),\n                1.0, metalness);\n  #endif\n\n  #include <tonemapping_fragment>\n  #include <encodings_fragment>\n  #include <fog_fragment>\n  #include <premultiplied_alpha_fragment>\n  #include <dithering_fragment>\n\n  gl_FragColor = vec4(outgoingLight, diffuseColor.a);\n}\n";
    vertex_default5 = "// Cosmic Sphere Vertex Shader - Nebula Effect\n// #pragma glslify: cnoise3 = require(glsl-noise/classic/3d) \n\n// noise source from https://github.com/hughsk/glsl-noise/blob/master/periodic/3d.glsl\n\nvec3 mod289(vec3 x)\n{\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289(vec4 x)\n{\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x)\n{\n  return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nvec3 fade(vec3 t) {\n  return t*t*t*(t*(t*6.0-15.0)+10.0);\n}\n\nfloat cnoise(vec3 P)\n{\n  vec3 Pi0 = floor(P); // Integer part for indexing\n  vec3 Pi1 = Pi0 + vec3(1.0); // Integer part + 1\n  Pi0 = mod289(Pi0);\n  Pi1 = mod289(Pi1);\n  vec3 Pf0 = fract(P); // Fractional part for interpolation\n  vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\n  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n  vec4 iy = vec4(Pi0.yy, Pi1.yy);\n  vec4 iz0 = Pi0.zzzz;\n  vec4 iz1 = Pi1.zzzz;\n\n  vec4 ixy = permute(permute(ix) + iy);\n  vec4 ixy0 = permute(ixy + iz0);\n  vec4 ixy1 = permute(ixy + iz1);\n\n  vec4 gx0 = ixy0 * (1.0 / 7.0);\n  vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;\n  gx0 = fract(gx0);\n  vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\n  vec4 sz0 = step(gz0, vec4(0.0));\n  gx0 -= sz0 * (step(0.0, gx0) - 0.5);\n  gy0 -= sz0 * (step(0.0, gy0) - 0.5);\n\n  vec4 gx1 = ixy1 * (1.0 / 7.0);\n  vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;\n  gx1 = fract(gx1);\n  vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\n  vec4 sz1 = step(gz1, vec4(0.0));\n  gx1 -= sz1 * (step(0.0, gx1) - 0.5);\n  gy1 -= sz1 * (step(0.0, gy1) - 0.5);\n\n  vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);\n  vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);\n  vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);\n  vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);\n  vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);\n  vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);\n  vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);\n  vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);\n\n  vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n  g000 *= norm0.x;\n  g010 *= norm0.y;\n  g100 *= norm0.z;\n  g110 *= norm0.w;\n  vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n  g001 *= norm1.x;\n  g011 *= norm1.y;\n  g101 *= norm1.z;\n  g111 *= norm1.w;\n\n  float n000 = dot(g000, Pf0);\n  float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\n  float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\n  float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\n  float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\n  float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\n  float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\n  float n111 = dot(g111, Pf1);\n\n  vec3 fade_xyz = fade(Pf0);\n  vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\n  vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\n  float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x); \n  return 2.2 * n_xyz;\n}\n\n//-------- Nebula Effect Functions ------------\n\nmat3 rotation3dY(float angle) {\n  float s = sin(angle);\n  float c = cos(angle);\n  return mat3(c, 0.0, -s, 0.0, 1.0, 0.0, s, 0.0, c);\n}\n\nmat3 rotation3dX(float angle) {\n  float s = sin(angle);\n  float c = cos(angle);\n  return mat3(1.0, 0.0, 0.0, 0.0, c, s, 0.0, -s, c);\n}\n\nmat3 rotation3dZ(float angle) {\n  float s = sin(angle);\n  float c = cos(angle);\n  return mat3(c, s, 0.0, -s, c, 0.0, 0.0, 0.0, 1.0);\n}\n\nvec3 rotateY(vec3 v, float angle) { return rotation3dY(angle) * v; }\nvec3 rotateX(vec3 v, float angle) { return rotation3dX(angle) * v; }\nvec3 rotateZ(vec3 v, float angle) { return rotation3dZ(angle) * v; }\n\nvarying vec3 vNormal;\nvarying float displacement;\nvarying vec3 vPos;\nvarying float vDistort;\nvarying vec2 vUv;\nvarying float vNebulaIntensity;\nvarying float vParticleDensity;\nvarying vec3 vCosmicSwirl;\n\nuniform float uTime;\nuniform float uSpeed;\nuniform float uLoadingTime;\nuniform float uNoiseDensity;\nuniform float uNoiseStrength;\n\n#define STANDARD\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n#ifdef USE_TANGENT\nvarying vec3 vTangent;\nvarying vec3 vBitangent;\n#endif\n#endif\n#include <clipping_planes_pars_vertex>\n#include <color_pars_vertex>\n#include <common>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <skinning_pars_vertex>\n#include <uv2_pars_vertex>\n#include <uv_pars_vertex>\n\nvoid main() {\n\n  #include <beginnormal_vertex>\n  #include <color_vertex>\n  #include <defaultnormal_vertex>\n  #include <morphnormal_vertex>\n  #include <skinbase_vertex>\n  #include <skinnormal_vertex>\n  #include <uv2_vertex>\n  #include <uv_vertex>\n  #ifndef FLAT_SHADED\n    vNormal = normalize(transformedNormal);\n  #ifdef USE_TANGENT\n    vTangent = normalize(transformedTangent);\n    vBitangent = normalize(cross(vNormal, vTangent) * tangent.w);\n  #endif\n  #endif\n  #include <begin_vertex>\n\n  #include <clipping_planes_vertex>\n  #include <displacementmap_vertex>\n  #include <logdepthbuf_vertex>\n  #include <morphtarget_vertex>\n  #include <project_vertex>\n  #include <skinning_vertex>\n    vViewPosition = -mvPosition.xyz;\n  #include <fog_vertex>\n  #include <shadowmap_vertex>\n  #include <worldpos_vertex>\n\n  //-------- Cosmic Nebula Effect ------------\n  vUv = uv;\n  \n  float t = uTime * uSpeed;\n  \n  // Create swirling nebula patterns\n  vec3 swirlCenter = vec3(0.0, 0.0, 0.0);\n  vec3 toCenter = position - swirlCenter;\n  float distanceFromCenter = length(toCenter);\n  \n  // Create spiral motion\n  float angle = atan(toCenter.y, toCenter.x);\n  float spiralAngle = angle + distanceFromCenter * 2.0 + t * 0.5;\n  \n  // Multi-octave noise for nebula density\n  float nebula1 = cnoise(position * uNoiseDensity * 0.8 + vec3(t * 0.2, t * 0.3, t * 0.1));\n  float nebula2 = cnoise(position * uNoiseDensity * 1.5 + vec3(t * 0.4, t * 0.2, t * 0.5)) * 0.7;\n  float nebula3 = cnoise(position * uNoiseDensity * 3.0 + vec3(t * 0.8, t * 0.6, t * 0.9)) * 0.4;\n  float nebula4 = cnoise(position * uNoiseDensity * 6.0 + vec3(t * 1.2, t * 1.0, t * 1.4)) * 0.2;\n  \n  // Combine nebula layers for complexity\n  float nebulaPattern = nebula1 + nebula2 + nebula3 + nebula4;\n  vNebulaIntensity = abs(nebulaPattern);\n  \n  // Create particle-like density variations\n  float particleDensity = cnoise(position * uNoiseDensity * 8.0 + vec3(t * 2.0, t * 1.5, t * 2.5));\n  vParticleDensity = smoothstep(-0.3, 0.8, particleDensity);\n  \n  // Create cosmic swirl effect\n  vec3 swirl = vec3(\n    sin(spiralAngle + t * 0.3) * distanceFromCenter * 0.1,\n    cos(spiralAngle + t * 0.2) * distanceFromCenter * 0.1,\n    sin(distanceFromCenter * 3.0 + t * 0.4) * 0.05\n  );\n  vCosmicSwirl = swirl;\n  \n  // Create pulsing effect for cosmic energy\n  float pulse = sin(t * 2.0 + distanceFromCenter * 5.0) * 0.1 + 1.0;\n  \n  // Apply complex displacement\n  float totalDisplacement = nebulaPattern * uNoiseStrength * uLoadingTime * pulse;\n  \n  // Add swirl displacement\n  vec3 pos = position + normal * totalDisplacement + swirl * 0.3;\n  vPos = pos;\n  \n  // Add cosmic rotation for dynamic feel\n  pos = rotateY(pos, sin(t * 0.1 + distanceFromCenter) * 0.1);\n  pos = rotateX(pos, cos(t * 0.08 + angle) * 0.08);\n  pos = rotateZ(pos, sin(t * 0.05 + spiralAngle) * 0.05);\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);\n}\n";
  }
});

// ../shadergradient-v2/dist/chunk-6ZGZBJSV.mjs
var waterPlane_exports2, fragment_default6, vertex_default6;
var init_chunk_6ZGZBJSV = __esm({
  "../shadergradient-v2/dist/chunk-6ZGZBJSV.mjs"() {
    init_chunk_5BEQP2BQ();
    waterPlane_exports2 = {};
    __export(waterPlane_exports2, {
      fragment: () => fragment_default6,
      vertex: () => vertex_default6
    });
    fragment_default6 = "// Cosmic WaterPlane Fragment Shader - Aurora Wave Effect\n\n#define STANDARD\n#ifdef PHYSICAL\n#define REFLECTIVITY\n#define CLEARCOAT\n#define TRANSMISSION\n#endif\n\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n\n#ifdef TRANSMISSION\nuniform float transmission;\n#endif\n#ifdef REFLECTIVITY\nuniform float reflectivity;\n#endif\n#ifdef CLEARCOAT\nuniform float clearcoat;\nuniform float clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\nuniform vec3 sheen;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n#ifdef USE_TANGENT\nvarying vec3 vTangent;\nvarying vec3 vBitangent;\n#endif\n#endif\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <color_pars_fragment>\n#include <common>\n#include <dithering_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <map_pars_fragment>\n#include <packing>\n#include <uv2_pars_fragment>\n#include <uv_pars_fragment>\n#include <bsdfs>\n#include <bumpmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <clipping_planes_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <lights_physical_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <shadowmap_pars_fragment>\n\nvarying vec3 vNormal;\nvarying float displacement;\nvarying vec3 vPos;\nvarying float vDistort;\nvarying vec2 vUv;\nvarying float vAuroraIntensity;\nvarying float vWaveHeight;\nvarying vec3 vFlowDirection;\n\nuniform float uTime;\nuniform float uSpeed;\n\nuniform float uC1r;\nuniform float uC1g;\nuniform float uC1b;\nuniform float uC2r;\nuniform float uC2g;\nuniform float uC2b;\nuniform float uC3r;\nuniform float uC3g;\nuniform float uC3b;\n\n// Aurora helper functions\nfloat hash(vec2 p) {\n    return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453123);\n}\n\nfloat noise2D(vec2 p) {\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n    vec2 u = f * f * (3.0 - 2.0 * f);\n    \n    return mix(mix(hash(i + vec2(0.0, 0.0)), \n                   hash(i + vec2(1.0, 0.0)), u.x),\n               mix(hash(i + vec2(0.0, 1.0)), \n                   hash(i + vec2(1.0, 1.0)), u.x), u.y);\n}\n\n// Fractal Brownian Motion for aurora patterns\nfloat fbm(vec2 p) {\n    float value = 0.0;\n    float amplitude = 0.5;\n    float frequency = 1.0;\n    \n    for(int i = 0; i < 4; i++) {\n        value += amplitude * noise2D(p * frequency);\n        amplitude *= 0.5;\n        frequency *= 2.0;\n    }\n    return value;\n}\n\n// Aurora curtain effect\nfloat aurora(vec2 p, float time) {\n    vec2 q = vec2(fbm(p + vec2(0.0, time * 0.1)),\n                  fbm(p + vec2(5.2, time * 0.15)));\n    \n    vec2 r = vec2(fbm(p + 4.0 * q + vec2(1.7, time * 0.2)),\n                  fbm(p + 4.0 * q + vec2(8.3, time * 0.18)));\n    \n    return fbm(p + 4.0 * r);\n}\n\n// Water caustics effect\nfloat caustics(vec2 p, float time) {\n    vec2 uv = p * 4.0;\n    vec2 p0 = uv + vec2(time * 0.3, time * 0.2);\n    vec2 p1 = uv + vec2(time * -0.4, time * 0.3);\n    \n    float c1 = sin(length(p0) * 8.0 - time * 2.0) * 0.5 + 0.5;\n    float c2 = sin(length(p1) * 6.0 - time * 1.5) * 0.5 + 0.5;\n    \n    return (c1 + c2) * 0.5;\n}\n\n// for npm package, need to add this manually\nfloat linearToRelativeLuminance2( const in vec3 color ) {\n    vec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n    return dot( weights, color.rgb );\n}\n\nvoid main() {\n\n  //-------- Cosmic Aurora Water Gradient ------------\n  vec3 color1 = vec3(uC1r, uC1g, uC1b);\n  vec3 color2 = vec3(uC2r, uC2g, uC2b);\n  vec3 color3 = vec3(uC3r, uC3g, uC3b);\n  \n  float clearcoat = 1.0;\n  float clearcoatRoughness = 0.05; // Very smooth for water-like reflection\n\n  #include <clipping_planes_fragment>\n\n  float t = uTime * uSpeed;\n  \n  // Create aurora patterns\n  vec2 auroraCoords = vPos.xy * 2.0 + vFlowDirection.xy * t * 0.5;\n  float auroraPattern1 = aurora(auroraCoords, t);\n  float auroraPattern2 = aurora(auroraCoords * 1.5 + vec2(3.0, 1.0), t * 1.2);\n  float auroraPattern3 = aurora(auroraCoords * 0.7 + vec2(-2.0, 4.0), t * 0.8);\n  \n  // Combine aurora layers\n  float combinedAurora = (auroraPattern1 + auroraPattern2 * 0.7 + auroraPattern3 * 0.5) / 2.2;\n  \n  // Create water caustics\n  float causticsPattern = caustics(vPos.xy, t);\n  \n  // Create flowing light streams\n  float lightStream1 = sin(vPos.x * 8.0 + t * 2.0 + combinedAurora * 3.0) * 0.2;\n  float lightStream2 = cos(vPos.y * 6.0 + t * 1.5 + vWaveHeight * 4.0) * 0.15;\n  float lightStream3 = sin((vPos.x + vPos.y) * 10.0 + t * 2.5) * 0.1;\n  \n  // Create cosmic energy waves\n  float distanceFromCenter = length(vPos.xy);\n  float energyWave = sin(distanceFromCenter * 5.0 - t * 3.0) * \n                     exp(-distanceFromCenter * 0.05) * 0.3;\n  \n  // Aurora color shifting effect\n  vec3 auroraShift = vec3(\n    sin(combinedAurora * 6.28 + t * 1.0) * 0.2,\n    sin(combinedAurora * 6.28 + t * 1.0 + 2.094) * 0.2,  // 120 degrees\n    sin(combinedAurora * 6.28 + t * 1.0 + 4.188) * 0.2   // 240 degrees\n  );\n  \n  // Enhanced gradient mixing with aurora and water effects\n  float gradientX = smoothstep(-4.0, 4.0, vPos.x + combinedAurora * 3.0 + vFlowDirection.x * 2.0);\n  float gradientY = smoothstep(-4.0, 4.0, vPos.y + vWaveHeight * 2.0 + lightStream1 * 3.0);\n  float gradientZ = smoothstep(-3.0, 3.0, vPos.z + causticsPattern * 2.0);\n  \n  // Multi-layer color mixing\n  vec3 baseGradient = mix(\n    mix(color1, color2, gradientX), \n    color3, \n    gradientY * 0.7 + gradientZ * 0.3\n  );\n  \n  // Apply aurora color shifts\n  vec3 auroraColor = baseGradient + auroraShift;\n  \n  // Add water caustics coloring\n  vec3 causticsColor = vec3(\n    causticsPattern * 0.3,\n    causticsPattern * 0.4,\n    causticsPattern * 0.5\n  );\n  \n  // Add light streams\n  vec3 lightStreams = vec3(\n    abs(lightStream1) * 0.4,\n    abs(lightStream2) * 0.3,\n    abs(lightStream3) * 0.5\n  );\n  \n  // Aurora intensity modulation\n  float auroraIntensityMod = 1.0 + vAuroraIntensity * 0.8 + abs(combinedAurora) * 0.6;\n  \n  // Combine all effects\n  vec3 finalColor = (auroraColor + causticsColor + lightStreams + vec3(energyWave * 0.2)) * auroraIntensityMod;\n  \n  // Add water-like shimmer\n  float shimmer = sin(vPos.x * 20.0 + t * 4.0) * \n                  cos(vPos.y * 18.0 + t * 3.5) * \n                  vWaveHeight * 0.1;\n  finalColor += vec3(shimmer * 0.3, shimmer * 0.4, shimmer * 0.6);\n  \n  // Add aurora dancing effect\n  float auroraMovement = sin(vPos.x * 3.0 + t * 1.2 + combinedAurora * 2.0) * \n                         cos(vPos.y * 2.5 + t * 0.9) * 0.15;\n  finalColor.g += abs(auroraMovement) * 0.4;\n  finalColor.b += abs(auroraMovement) * 0.2;\n  \n  // Add cosmic depth variation\n  float depthVariation = noise2D(vPos.xy * 5.0 + t * 0.3) * 0.1;\n  finalColor *= (1.0 + depthVariation);\n\n  vec4 diffuseColor = vec4(finalColor, 1.0);\n\n  //-------- Enhanced Materiality for Water Aurora Effect ------------\n  ReflectedLight reflectedLight = ReflectedLight(vec3(0.0), vec3(0.0), vec3(0.0), vec3(0.0));\n  vec3 totalEmissiveRadiance = emissive + finalColor * 0.15; // Moderate emission for aurora glow\n\n  #ifdef TRANSMISSION\n    float totalTransmission = transmission;\n  #endif\n  #include <logdepthbuf_fragment>\n  #include <map_fragment>\n  #include <color_fragment>\n  #include <alphamap_fragment>\n  #include <alphatest_fragment>\n  #include <roughnessmap_fragment>\n  #include <metalnessmap_fragment>\n  #include <normal_fragment_begin>\n  #include <normal_fragment_maps>\n  #include <clearcoat_normal_fragment_begin>\n  #include <clearcoat_normal_fragment_maps>\n  #include <emissivemap_fragment>\n  #include <lights_physical_fragment>\n  #include <lights_fragment_begin>\n  #include <lights_fragment_maps>\n  #include <lights_fragment_end>\n  #include <aomap_fragment>\n  \n  vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse +\n                      reflectedLight.directSpecular + reflectedLight.indirectSpecular +\n                      totalEmissiveRadiance;\n\n  #ifdef TRANSMISSION\n    diffuseColor.a *= mix(saturate(1. - totalTransmission +\n                        linearToRelativeLuminance2(reflectedLight.directSpecular +\n                                                  reflectedLight.indirectSpecular)),\n                1.0, metalness);\n  #endif\n\n  #include <tonemapping_fragment>\n  #include <encodings_fragment>\n  #include <fog_fragment>\n  #include <premultiplied_alpha_fragment>\n  #include <dithering_fragment>\n\n  gl_FragColor = vec4(outgoingLight, diffuseColor.a);\n}\n";
    vertex_default6 = "// Cosmic WaterPlane Vertex Shader - Aurora Wave Effect\n// #pragma glslify: cnoise3 = require(glsl-noise/classic/3d) \n\n// noise source from https://github.com/hughsk/glsl-noise/blob/master/periodic/3d.glsl\n\nvec3 mod289(vec3 x)\n{\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289(vec4 x)\n{\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x)\n{\n  return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nvec3 fade(vec3 t) {\n  return t*t*t*(t*(t*6.0-15.0)+10.0);\n}\n\nfloat cnoise(vec3 P)\n{\n  vec3 Pi0 = floor(P); // Integer part for indexing\n  vec3 Pi1 = Pi0 + vec3(1.0); // Integer part + 1\n  Pi0 = mod289(Pi0);\n  Pi1 = mod289(Pi1);\n  vec3 Pf0 = fract(P); // Fractional part for interpolation\n  vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\n  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n  vec4 iy = vec4(Pi0.yy, Pi1.yy);\n  vec4 iz0 = Pi0.zzzz;\n  vec4 iz1 = Pi1.zzzz;\n\n  vec4 ixy = permute(permute(ix) + iy);\n  vec4 ixy0 = permute(ixy + iz0);\n  vec4 ixy1 = permute(ixy + iz1);\n\n  vec4 gx0 = ixy0 * (1.0 / 7.0);\n  vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;\n  gx0 = fract(gx0);\n  vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\n  vec4 sz0 = step(gz0, vec4(0.0));\n  gx0 -= sz0 * (step(0.0, gx0) - 0.5);\n  gy0 -= sz0 * (step(0.0, gy0) - 0.5);\n\n  vec4 gx1 = ixy1 * (1.0 / 7.0);\n  vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;\n  gx1 = fract(gx1);\n  vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\n  vec4 sz1 = step(gz1, vec4(0.0));\n  gx1 -= sz1 * (step(0.0, gx1) - 0.5);\n  gy1 -= sz1 * (step(0.0, gy1) - 0.5);\n\n  vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);\n  vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);\n  vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);\n  vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);\n  vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);\n  vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);\n  vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);\n  vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);\n\n  vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n  g000 *= norm0.x;\n  g010 *= norm0.y;\n  g100 *= norm0.z;\n  g110 *= norm0.w;\n  vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n  g001 *= norm1.x;\n  g011 *= norm1.y;\n  g101 *= norm1.z;\n  g111 *= norm1.w;\n\n  float n000 = dot(g000, Pf0);\n  float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\n  float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\n  float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\n  float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\n  float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\n  float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\n  float n111 = dot(g111, Pf1);\n\n  vec3 fade_xyz = fade(Pf0);\n  vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\n  vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\n  float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x); \n  return 2.2 * n_xyz;\n}\n\n//-------- Aurora Wave Effect Functions ------------\n\nmat3 rotation3dY(float angle) {\n  float s = sin(angle);\n  float c = cos(angle);\n  return mat3(c, 0.0, -s, 0.0, 1.0, 0.0, s, 0.0, c);\n}\n\nvec3 rotateY(vec3 v, float angle) { return rotation3dY(angle) * v; }\n\nvarying vec3 vNormal;\nvarying float displacement;\nvarying vec3 vPos;\nvarying float vDistort;\nvarying vec2 vUv;\nvarying float vAuroraIntensity;\nvarying float vWaveHeight;\nvarying vec3 vFlowDirection;\n\nuniform float uTime;\nuniform float uSpeed;\nuniform float uLoadingTime;\nuniform float uNoiseDensity;\nuniform float uNoiseStrength;\n\n#define STANDARD\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n#ifdef USE_TANGENT\nvarying vec3 vTangent;\nvarying vec3 vBitangent;\n#endif\n#endif\n#include <clipping_planes_pars_vertex>\n#include <color_pars_vertex>\n#include <common>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <skinning_pars_vertex>\n#include <uv2_pars_vertex>\n#include <uv_pars_vertex>\n\nvoid main() {\n\n  #include <beginnormal_vertex>\n  #include <color_vertex>\n  #include <defaultnormal_vertex>\n  #include <morphnormal_vertex>\n  #include <skinbase_vertex>\n  #include <skinnormal_vertex>\n  #include <uv2_vertex>\n  #include <uv_vertex>\n  #ifndef FLAT_SHADED\n    vNormal = normalize(transformedNormal);\n  #ifdef USE_TANGENT\n    vTangent = normalize(transformedTangent);\n    vBitangent = normalize(cross(vNormal, vTangent) * tangent.w);\n  #endif\n  #endif\n  #include <begin_vertex>\n\n  #include <clipping_planes_vertex>\n  #include <displacementmap_vertex>\n  #include <logdepthbuf_vertex>\n  #include <morphtarget_vertex>\n  #include <project_vertex>\n  #include <skinning_vertex>\n    vViewPosition = -mvPosition.xyz;\n  #include <fog_vertex>\n  #include <shadowmap_vertex>\n  #include <worldpos_vertex>\n\n  //-------- Cosmic Aurora Wave Effect ------------\n  vUv = uv;\n  \n  float t = uTime * uSpeed;\n  \n  // Create flowing aurora patterns\n  float auroraFlow1 = sin(position.x * 5.0 + t * 1.5) * cos(position.y * 3.0 + t * 1.0);\n  float auroraFlow2 = sin(position.x * 8.0 + t * 2.0) * sin(position.y * 6.0 + t * 1.8);\n  float auroraFlow3 = cos(position.x * 12.0 + t * 2.5) * cos(position.y * 9.0 + t * 2.2);\n  \n  // Combine aurora flows\n  float auroraPattern = (auroraFlow1 + auroraFlow2 * 0.7 + auroraFlow3 * 0.4) / 2.1;\n  vAuroraIntensity = abs(auroraPattern);\n  \n  // Create multi-layered waves\n  float wave1 = cnoise(vec3(position.xy * uNoiseDensity * 0.5, t * 0.3));\n  float wave2 = cnoise(vec3(position.xy * uNoiseDensity * 1.2, t * 0.5)) * 0.6;\n  float wave3 = cnoise(vec3(position.xy * uNoiseDensity * 2.5, t * 0.8)) * 0.3;\n  float wave4 = cnoise(vec3(position.xy * uNoiseDensity * 5.0, t * 1.2)) * 0.15;\n  \n  // Combine waves for complex water surface\n  float combinedWaves = wave1 + wave2 + wave3 + wave4;\n  vWaveHeight = combinedWaves;\n  \n  // Create flowing current patterns\n  vec2 flowDirection = vec2(\n    sin(position.x * 2.0 + t * 0.8) + cos(position.y * 1.5 + t * 0.6),\n    cos(position.x * 1.8 + t * 0.7) + sin(position.y * 2.2 + t * 0.9)\n  );\n  vFlowDirection = vec3(normalize(flowDirection), 0.0);\n  \n  // Aurora-influenced wave distortion\n  float auroraWave = sin(position.x * 15.0 + t * 3.0 + auroraPattern * 5.0) * \n                     cos(position.y * 12.0 + t * 2.5 + auroraPattern * 4.0) * 0.2;\n  \n  // Create cosmic energy ripples\n  float distanceFromCenter = length(position.xy);\n  float cosmicRipple = sin(distanceFromCenter * 8.0 - t * 4.0) * \n                       exp(-distanceFromCenter * 0.1) * 0.3;\n  \n  // Pulsing effect for cosmic energy\n  float cosmicPulse = sin(t * 1.5 + distanceFromCenter * 2.0) * 0.1 + 1.0;\n  \n  // Apply complex displacement\n  float totalDisplacement = (combinedWaves + auroraWave + cosmicRipple) * \n                           uNoiseStrength * uLoadingTime * cosmicPulse;\n  \n  vec3 pos = position + normal * totalDisplacement;\n  vPos = pos;\n  \n  // Add subtle rotation for cosmic flow\n  pos = rotateY(pos, sin(t * 0.05 + distanceFromCenter * 0.1) * 0.02);\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);\n}\n";
  }
});

// ../shadergradient-v2/dist/chunk-GLLM6F27.mjs
var cosmic_exports;
var init_chunk_GLLM6F27 = __esm({
  "../shadergradient-v2/dist/chunk-GLLM6F27.mjs"() {
    init_chunk_UDZCNACG();
    init_chunk_PBBG73XU();
    init_chunk_6ZGZBJSV();
    init_chunk_5BEQP2BQ();
    cosmic_exports = {};
    __export(cosmic_exports, {
      plane: () => plane_exports2,
      sphere: () => sphere_exports2,
      waterPlane: () => waterPlane_exports2
    });
  }
});

// ../shadergradient-v2/dist/chunk-R2XBTOLG.mjs
var plane_exports3, fragment_default7, vertex_default7;
var init_chunk_R2XBTOLG = __esm({
  "../shadergradient-v2/dist/chunk-R2XBTOLG.mjs"() {
    init_chunk_5BEQP2BQ();
    plane_exports3 = {};
    __export(plane_exports3, {
      fragment: () => fragment_default7,
      vertex: () => vertex_default7
    });
    fragment_default7 = "\n#define STANDARD\n#ifdef PHYSICAL\n#define REFLECTIVITY\n#define CLEARCOAT\n#define TRANSMISSION\n#endif\n\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n\n#ifdef TRANSMISSION\nuniform float transmission;\n#endif\n#ifdef REFLECTIVITY\nuniform float reflectivity;\n#endif\n#ifdef CLEARCOAT\nuniform float clearcoat;\nuniform float clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\nuniform vec3 sheen;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n#ifdef USE_TANGENT\nvarying vec3 vTangent;\nvarying vec3 vBitangent;\n#endif\n#endif\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <color_pars_fragment>\n#include <common>\n#include <dithering_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <map_pars_fragment>\n#include <packing>\n#include <uv2_pars_fragment>\n#include <uv_pars_fragment>\n// #include <transmissionmap_pars_fragment>\n#include <bsdfs>\n#include <bumpmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <clipping_planes_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <lights_physical_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <shadowmap_pars_fragment>\n// include\uB97C \uD1B5\uD574 \uAC00\uC838\uC628 \uAC12\uC740 \uB300\uBD80\uBD84 \uD658\uACBD, \uBE5B \uB4F1\uC744 \uACC4\uC0B0\uD558\uAE30 \uC704\uD574\uC11C \uAE30\uBCF8 fragment\n// shader\uC758 \uAC12\uB4E4\uC744 \uBC1B\uC544\uC654\uC2B5\uB2C8\uB2E4. \uC77C\uB2E8\uC740 \uBB34\uC2DC\uD558\uC154\uB3C4 \uB429\uB2C8\uB2E4.\n\nvarying vec3 vNormal;\nvarying float displacement;\nvarying vec3 vPos;\nvarying float vDistort;\n\nuniform float uC1r;\nuniform float uC1g;\nuniform float uC1b;\nuniform float uC2r;\nuniform float uC2g;\nuniform float uC2b;\nuniform float uC3r;\nuniform float uC3g;\nuniform float uC3b;\n\nvarying vec3 color1;\nvarying vec3 color2;\nvarying vec3 color3;\n\n// for npm package, need to add this manually\nfloat linearToRelativeLuminance2( const in vec3 color ) {\n    vec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n    return dot( weights, color.rgb );\n}\n\nvoid main() {\n\n  //-------- basic gradient ------------\n  vec3 color1 = vec3(uC1r, uC1g, uC1b);\n  vec3 color2 = vec3(uC2r, uC2g, uC2b);\n  vec3 color3 = vec3(uC3r, uC3g, uC3b);\n  float clearcoat = 1.0;\n  float clearcoatRoughness = 0.5;\n\n  #include <clipping_planes_fragment>\n\n  vec4 diffuseColor = vec4(\n      mix(mix(color1, color2, smoothstep(-3.0, 3.0, vPos.x)), color3, vPos.z),\n      1);\n  // diffuseColor\uB294 \uC624\uBE0C\uC81D\uD2B8\uC758 \uBCA0\uC774\uC2A4 \uC0C9\uC0C1 (\uD658\uACBD\uC774\uB098 \uBE5B\uC774 \uACE0\uB824\uB418\uC9C0 \uC54A\uC740 \uBCF8\uC5F0\uC758\n  // \uC0C9)\n\n  // mix(x, y, a): a\uB97C \uCD95\uC73C\uB85C \uD588\uC744 \uB54C \uAC00\uC7A5 \uB0AE\uC740 \uAC12\uC5D0\uC11C x\uAC12\uC758 \uC601\uD5A5\uB825\uC744 100%, \uAC00\uC7A5\n  // \uB192\uC740 \uAC12\uC5D0\uC11C y\uAC12\uC758 \uC601\uD5A5\uB825\uC744 100%\uB85C \uB9CC\uB4E0\uB2E4. smoothstep(x, y, a): a\uCD95\uC744\n  // \uAE30\uC900\uC73C\uB85C x\uB97C \uCD5C\uC18C\uAC12, y\uB97C \uCD5C\uB300\uAC12\uC73C\uB85C \uADF8 \uC0AC\uC774\uC758 \uAC12\uC744 \uCABC\uAC20\uB2E4. x\uC640 y \uC0AC\uC774\uB97C\n  // 0-100 \uC0AC\uC774\uC758 \uADF8\uB77C\uB514\uC5B8\uD2B8\uCC98\uB7FC \uB2E8\uACC4\uBCC4\uB85C \uD45C\uD604\uD558\uACE0, x \uBBF8\uB9CC\uC758 \uAC12\uC740 0, y \uC774\uC0C1\uC758\n  // \uAC12\uC740 100\uC73C\uB85C \uCC98\uB9AC\n\n  // 1. smoothstep(-3.0, 3.0,vPos.x)\uB85C x\uCD95\uC758 \uADF8\uB77C\uB514\uC5B8\uD2B8\uAC00 \uD45C\uD604 \uB420 \uBC94\uC704\uB97C -3,\n  // 3\uC73C\uB85C \uC815\uD55C\uB2E4.\n  // 2. mix(color1, color3, smoothstep(-3.0, 3.0,vPos.x))\uB85C color1\uACFC color3\uC744\n  // \uC704\uC758 \uBC94\uC704 \uC548\uC5D0\uC11C \uADF8\uB77C\uB514\uC5B8\uD2B8\uB85C \uD45C\uD604\uD55C\uB2E4.\n  // \uC608\uB97C \uB4E4\uC5B4 color1\uC774 \uB178\uB791, color3\uC774 \uD30C\uB791\uC774\uB77C\uACE0 \uCE58\uBA74, x\uCD95 \uAE30\uC900 -3\uBD80\uD130 3\uAE4C\uC9C0\n  // \uB178\uB791\uACFC \uD30C\uB791 \uC0AC\uC774\uC758 \uADF8\uB77C\uB514\uC5B8\uD2B8\uAC00 \uB098\uD0C0\uB098\uACE0, -3\uBCF4\uB2E4 \uC791\uC740 \uAC12\uC5D0\uC11C\uB294 \uACC4\uC18D \uB178\uB791,\n  // 3\uBCF4\uB2E4 \uD070 \uAC12\uC5D0\uC11C\uB294 \uACC4\uC18D \uD30C\uB791\uC774 \uB098\uD0C0\uB09C\uB2E4.\n  // 3. mix()\uB97C \uD55C \uBC88 \uB354 \uC0AC\uC6A9\uD574\uC11C \uC704\uC758 \uADF8\uB77C\uB514\uC5B8\uD2B8\uC640 color2\uB97C z\uCD95 \uAE30\uC900\uC73C\uB85C\n  // \uBD84\uBC30\uD55C\uB2E4.\n\n  //-------- materiality ------------\n  ReflectedLight reflectedLight =\n      ReflectedLight(vec3(0.0), vec3(0.0), vec3(0.0), vec3(0.0));\n  vec3 totalEmissiveRadiance = emissive;\n\n  #ifdef TRANSMISSION\n    float totalTransmission = transmission;\n  #endif\n  #include <logdepthbuf_fragment>\n  #include <map_fragment>\n  #include <color_fragment>\n  #include <alphamap_fragment>\n  #include <alphatest_fragment>\n  #include <roughnessmap_fragment>\n  #include <metalnessmap_fragment>\n  #include <normal_fragment_begin>\n  #include <normal_fragment_maps>\n  #include <clearcoat_normal_fragment_begin>\n  #include <clearcoat_normal_fragment_maps>\n  #include <emissivemap_fragment>\n  // #include <transmissionmap_fragment>\n  #include <lights_physical_fragment>\n  #include <lights_fragment_begin>\n  #include <lights_fragment_maps>\n  #include <lights_fragment_end>\n  #include <aomap_fragment>\n    vec3 outgoingLight =\n        reflectedLight.directDiffuse + reflectedLight.indirectDiffuse +\n        reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n    //\uC704\uC5D0\uC11C \uC815\uC758\uD55C diffuseColor\uC5D0 \uD658\uACBD\uC774\uB098 \uBC18\uC0AC\uAC12\uB4E4\uC744 \uBC18\uC601\uD55C \uAC12.\n  #ifdef TRANSMISSION\n    diffuseColor.a *=\n        mix(saturate(1. - totalTransmission +\n                    linearToRelativeLuminance2(reflectedLight.directSpecular +\n                                              reflectedLight.indirectSpecular)),\n            1.0, metalness);\n  #endif\n\n\n  #include <tonemapping_fragment>\n  #include <encodings_fragment>\n  #include <fog_fragment>\n  #include <premultiplied_alpha_fragment>\n  #include <dithering_fragment>\n\n\n  gl_FragColor = vec4(outgoingLight, diffuseColor.a);\n  // gl_FragColor\uAC00 fragment shader\uB97C \uD1B5\uD574 \uB098\uD0C0\uB098\uB294 \uCD5C\uC885\uAC12\uC73C\uB85C, diffuseColor\uC5D0\uC11C\n  // \uC815\uC758\uD55C \uADF8\uB77C\uB514\uC5B8\uD2B8 \uC0C9\uC0C1 \uC704\uC5D0 \uBC18\uC0AC\uB098 \uBE5B\uC744 \uACC4\uC0B0\uD55C \uAC12\uC744 \uCD5C\uC885\uAC12\uC73C\uB85C \uC815\uC758.\n  // gl_FragColor = vec4(mix(mix(color1, color3, smoothstep(-3.0, 3.0,vPos.x)),\n  // color2, vNormal.z), 1.0); \uC704\uCC98\uB7FC \uCD5C\uC885\uAC12\uC744 \uADF8\uB77C\uB514\uC5B8\uD2B8 \uAC12 \uC790\uCCB4\uB97C \uB123\uC73C\uBA74 \uD658\uACBD\n  // \uC601\uD5A5\uC5C6\uB294 \uADF8\uB77C\uB514\uC5B8\uD2B8\uB9CC \uD45C\uD604\uB428.\n}\n";
    vertex_default7 = "// #pragma glslify: cnoise3 = require(glsl-noise/classic/3d) \n\n// noise source from https://github.com/hughsk/glsl-noise/blob/master/periodic/3d.glsl\n\nvec3 mod289(vec3 x)\n{\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289(vec4 x)\n{\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x)\n{\n  return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nvec3 fade(vec3 t) {\n  return t*t*t*(t*(t*6.0-15.0)+10.0);\n}\n\nfloat cnoise(vec3 P)\n{\n  vec3 Pi0 = floor(P); // Integer part for indexing\n  vec3 Pi1 = Pi0 + vec3(1.0); // Integer part + 1\n  Pi0 = mod289(Pi0);\n  Pi1 = mod289(Pi1);\n  vec3 Pf0 = fract(P); // Fractional part for interpolation\n  vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\n  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n  vec4 iy = vec4(Pi0.yy, Pi1.yy);\n  vec4 iz0 = Pi0.zzzz;\n  vec4 iz1 = Pi1.zzzz;\n\n  vec4 ixy = permute(permute(ix) + iy);\n  vec4 ixy0 = permute(ixy + iz0);\n  vec4 ixy1 = permute(ixy + iz1);\n\n  vec4 gx0 = ixy0 * (1.0 / 7.0);\n  vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;\n  gx0 = fract(gx0);\n  vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\n  vec4 sz0 = step(gz0, vec4(0.0));\n  gx0 -= sz0 * (step(0.0, gx0) - 0.5);\n  gy0 -= sz0 * (step(0.0, gy0) - 0.5);\n\n  vec4 gx1 = ixy1 * (1.0 / 7.0);\n  vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;\n  gx1 = fract(gx1);\n  vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\n  vec4 sz1 = step(gz1, vec4(0.0));\n  gx1 -= sz1 * (step(0.0, gx1) - 0.5);\n  gy1 -= sz1 * (step(0.0, gy1) - 0.5);\n\n  vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);\n  vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);\n  vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);\n  vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);\n  vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);\n  vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);\n  vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);\n  vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);\n\n  vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n  g000 *= norm0.x;\n  g010 *= norm0.y;\n  g100 *= norm0.z;\n  g110 *= norm0.w;\n  vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n  g001 *= norm1.x;\n  g011 *= norm1.y;\n  g101 *= norm1.z;\n  g111 *= norm1.w;\n\n  float n000 = dot(g000, Pf0);\n  float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\n  float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\n  float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\n  float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\n  float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\n  float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\n  float n111 = dot(g111, Pf1);\n\n  vec3 fade_xyz = fade(Pf0);\n  vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\n  vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\n  float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x); \n  return 2.2 * n_xyz;\n}\n\n//-------- start here ------------\n\nmat3 rotation3dY(float angle) {\n  float s = sin(angle);\n  float c = cos(angle);\n\n  return mat3(c, 0.0, -s, 0.0, 1.0, 0.0, s, 0.0, c);\n}\n\nvec3 rotateY(vec3 v, float angle) { return rotation3dY(angle) * v; }\n\nvarying vec3 vNormal;\nvarying float displacement;\nvarying vec3 vPos;\nvarying float vDistort;\n\nvarying vec2 vUv;\n\nuniform float uTime;\nuniform float uSpeed;\nuniform float uLoop;\nuniform float uLoopDuration;\n\nuniform float uLoadingTime;\n\nuniform float uNoiseDensity;\nuniform float uNoiseStrength;\n\n#define STANDARD\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n#ifdef USE_TANGENT\nvarying vec3 vTangent;\nvarying vec3 vBitangent;\n#endif\n#endif\n#include <clipping_planes_pars_vertex>\n#include <color_pars_vertex>\n#include <common>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <skinning_pars_vertex>\n#include <uv2_pars_vertex>\n#include <uv_pars_vertex>\n\nvoid main() {\n\n  #include <beginnormal_vertex>\n  #include <color_vertex>\n  #include <defaultnormal_vertex>\n  #include <morphnormal_vertex>\n  #include <skinbase_vertex>\n  #include <skinnormal_vertex>\n  #include <uv2_vertex>\n  #include <uv_vertex>\n  #ifndef FLAT_SHADED\n    vNormal = normalize(transformedNormal);\n  #ifdef USE_TANGENT\n    vTangent = normalize(transformedTangent);\n    vBitangent = normalize(cross(vNormal, vTangent) * tangent.w);\n  #endif\n  #endif\n  #include <begin_vertex>\n\n  #include <clipping_planes_vertex>\n  #include <displacementmap_vertex>\n  #include <logdepthbuf_vertex>\n  #include <morphtarget_vertex>\n  #include <project_vertex>\n  #include <skinning_vertex>\n    vViewPosition = -mvPosition.xyz;\n  #include <fog_vertex>\n  #include <shadowmap_vertex>\n  #include <worldpos_vertex>\n\n  //-------- start vertex ------------\n  vUv = uv;\n\n  float t = uTime * uSpeed;\n  \n  // For seamless loops, sample noise using 4D-like circular interpolation\n  vec3 noisePos = 0.43 * position * uNoiseDensity;\n  float distortion;\n  \n  if (uLoop > 0.5) {\n    // Create truly dynamic seamless loop using 4D noise simulation\n    // Loop progress only depends on time and duration, not speed\n    float loopProgress = uTime / uLoopDuration;\n    float angle = loopProgress * 6.28318530718; // 2*PI\n    \n    // Radius scales with speed to maintain consistent visual speed\n    // Larger radius = more distance traveled = faster perceived motion\n    float radius = 5.0 * uSpeed;\n    \n    // Sample 4 noise values at cardinal points around the circle\n    vec3 offset0 = vec3(cos(angle) * radius, sin(angle) * radius, 0.0);\n    vec3 offset1 = vec3(cos(angle + 1.57079632679) * radius, sin(angle + 1.57079632679) * radius, 0.0);\n    vec3 offset2 = vec3(cos(angle + 3.14159265359) * radius, sin(angle + 3.14159265359) * radius, 0.0);\n    vec3 offset3 = vec3(cos(angle + 4.71238898038) * radius, sin(angle + 4.71238898038) * radius, 0.0);\n    \n    // Get noise at all 4 points\n    float n0 = cnoise(noisePos + offset0);\n    float n1 = cnoise(noisePos + offset1);\n    float n2 = cnoise(noisePos + offset2);\n    float n3 = cnoise(noisePos + offset3);\n    \n    // Smooth interpolation weights using cosine\n    float w0 = (cos(angle) + 1.0) * 0.5;\n    float w1 = (cos(angle + 1.57079632679) + 1.0) * 0.5;\n    float w2 = (cos(angle + 3.14159265359) + 1.0) * 0.5;\n    float w3 = (cos(angle + 4.71238898038) + 1.0) * 0.5;\n    \n    // Normalize weights\n    float totalWeight = w0 + w1 + w2 + w3;\n    w0 /= totalWeight;\n    w1 /= totalWeight;\n    w2 /= totalWeight;\n    w3 /= totalWeight;\n    \n    // Blend all samples with amplitude boost to match single-sample strength\n    // Blending reduces amplitude by ~30%, so we compensate\n    float blendedNoise = n0 * w0 + n1 * w1 + n2 * w2 + n3 * w3;\n    distortion = 0.75 * blendedNoise * 1.5;\n  } else {\n    // Normal linear time progression\n    distortion = 0.75 * cnoise(noisePos + t);\n  }\n\n  vec3 pos = position + normal * distortion * uNoiseStrength * uLoadingTime;\n  vPos = pos;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.);\n}\n";
  }
});

// ../shadergradient-v2/dist/chunk-5BVQK6OK.mjs
var sphere_exports3, fragment_default8, vertex_default8;
var init_chunk_5BVQK6OK = __esm({
  "../shadergradient-v2/dist/chunk-5BVQK6OK.mjs"() {
    init_chunk_5BEQP2BQ();
    sphere_exports3 = {};
    __export(sphere_exports3, {
      fragment: () => fragment_default8,
      vertex: () => vertex_default8
    });
    fragment_default8 = "\n#define STANDARD\n#ifdef PHYSICAL\n#define REFLECTIVITY\n#define CLEARCOAT\n#define TRANSMISSION\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef TRANSMISSION\nuniform float transmission;\n#endif\n#ifdef REFLECTIVITY\nuniform float reflectivity;\n#endif\n#ifdef CLEARCOAT\nuniform float clearcoat;\nuniform float clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\nuniform vec3 sheen;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n#ifdef USE_TANGENT\nvarying vec3 vTangent;\nvarying vec3 vBitangent;\n#endif\n#endif\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <color_pars_fragment>\n#include <common>\n#include <dithering_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <map_pars_fragment>\n#include <packing>\n#include <uv2_pars_fragment>\n#include <uv_pars_fragment>\n// #include <transmissionmap_pars_fragment>\n#include <bsdfs>\n#include <bumpmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <clipping_planes_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <lights_physical_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <shadowmap_pars_fragment>\n// include\uB97C \uD1B5\uD574 \uAC00\uC838\uC628 \uAC12\uC740 \uB300\uBD80\uBD84 \uD658\uACBD, \uBE5B \uB4F1\uC744 \uACC4\uC0B0\uD558\uAE30 \uC704\uD574\uC11C \uAE30\uBCF8 fragment\n// shader\uC758 \uAC12\uB4E4\uC744 \uBC1B\uC544\uC654\uC2B5\uB2C8\uB2E4. \uC77C\uB2E8\uC740 \uBB34\uC2DC\uD558\uC154\uB3C4 \uB429\uB2C8\uB2E4.\nvarying vec3 vNormal;\nvarying float displacement;\nvarying vec3 vPos;\nvarying float vDistort;\nuniform float uC1r;\nuniform float uC1g;\nuniform float uC1b;\nuniform float uC2r;\nuniform float uC2g;\nuniform float uC2b;\nuniform float uC3r;\nuniform float uC3g;\nuniform float uC3b;\nvarying vec3 color1;\nvarying vec3 color2;\nvarying vec3 color3;\nvarying float distanceToCenter;\n\n\n// for npm package, need to add this manually\n// 'linearToRelativeLuminance' : function already has a body\nfloat linearToRelativeLuminance2( const in vec3 color ) {\n    vec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n    return dot( weights, color.rgb );\n}\n\nvoid main() {\n  //-------- basic gradient ------------\n  vec3 color1 = vec3(uC1r, uC1g, uC1b);\n  vec3 color2 = vec3(uC2r, uC2g, uC2b);\n  vec3 color3 = vec3(uC3r, uC3g, uC3b);\n  float clearcoat = 1.0;\n  float clearcoatRoughness = 0.5;\n#include <clipping_planes_fragment>\n\n  float distanceToCenter = distance(vPos, vec3(0, 0, 0));\n  // distanceToCenter\uB85C \uC911\uC2EC\uC810\uACFC\uC758 \uAC70\uB9AC\uB97C \uAD6C\uD568.\n\n  vec4 diffuseColor =\n      vec4(mix(color3, mix(color2, color1, smoothstep(-1.0, 1.0, vPos.y)),\n               distanceToCenter),\n           1);\n\n  //-------- materiality ------------\n  ReflectedLight reflectedLight =\n      ReflectedLight(vec3(0.0), vec3(0.0), vec3(0.0), vec3(0.0));\n  vec3 totalEmissiveRadiance = emissive;\n#ifdef TRANSMISSION\n  float totalTransmission = transmission;\n#endif\n#include <logdepthbuf_fragment>\n#include <map_fragment>\n#include <color_fragment>\n#include <alphamap_fragment>\n#include <alphatest_fragment>\n#include <roughnessmap_fragment>\n#include <metalnessmap_fragment>\n#include <normal_fragment_begin>\n#include <normal_fragment_maps>\n#include <clearcoat_normal_fragment_begin>\n#include <clearcoat_normal_fragment_maps>\n#include <emissivemap_fragment>\n// #include <transmissionmap_fragment>\n#include <lights_physical_fragment>\n#include <lights_fragment_begin>\n#include <lights_fragment_maps>\n#include <lights_fragment_end>\n#include <aomap_fragment>\n  vec3 outgoingLight =\n      reflectedLight.directDiffuse + reflectedLight.indirectDiffuse +\n      reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n//\uC704\uC5D0\uC11C \uC815\uC758\uD55C diffuseColor\uC5D0 \uD658\uACBD\uC774\uB098 \uBC18\uC0AC\uAC12\uB4E4\uC744 \uBC18\uC601\uD55C \uAC12.\n#ifdef TRANSMISSION\n  diffuseColor.a *=\n      mix(saturate(1. - totalTransmission +\n                   linearToRelativeLuminance2(reflectedLight.directSpecular +\n                                             reflectedLight.indirectSpecular)),\n          1.0, metalness);\n#endif\n  gl_FragColor = vec4(outgoingLight, diffuseColor.a);\n  // gl_FragColor\uAC00 fragment shader\uB97C \uD1B5\uD574 \uB098\uD0C0\uB098\uB294 \uCD5C\uC885\uAC12\uC73C\uB85C, diffuseColor\uC5D0\uC11C\n  // \uC815\uC758\uD55C \uADF8\uB77C\uB514\uC5B8\uD2B8 \uC0C9\uC0C1 \uC704\uC5D0 \uBC18\uC0AC\uB098 \uBE5B\uC744 \uACC4\uC0B0\uD55C \uAC12\uC744 \uCD5C\uC885\uAC12\uC73C\uB85C \uC815\uC758.\n  // gl_FragColor = vec4(mix(mix(color1, color3, smoothstep(-3.0, 3.0,vPos.x)),\n  // color2, vNormal.z), 1.0); \uC704\uCC98\uB7FC \uCD5C\uC885\uAC12\uC744 \uADF8\uB77C\uB514\uC5B8\uD2B8 \uAC12 \uC790\uCCB4\uB97C \uB123\uC73C\uBA74 \uD658\uACBD\n  // \uC601\uD5A5\uC5C6\uB294 \uADF8\uB77C\uB514\uC5B8\uD2B8\uB9CC \uD45C\uD604\uB428.\n\n#include <tonemapping_fragment>\n#include <encodings_fragment>\n#include <fog_fragment>\n#include <premultiplied_alpha_fragment>\n#include <dithering_fragment>\n}\n";
    vertex_default8 = "// #pragma glslify: pnoise = require(glsl-noise/periodic/3d)\n\nvec3 mod289(vec3 x)\n{\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289(vec4 x)\n{\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x)\n{\n  return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nvec3 fade(vec3 t) {\n  return t*t*t*(t*(t*6.0-15.0)+10.0);\n}\n\n// Classic Perlin noise, periodic variant\nfloat pnoise(vec3 P, vec3 rep)\n{\n  vec3 Pi0 = mod(floor(P), rep); // Integer part, modulo period\n  vec3 Pi1 = mod(Pi0 + vec3(1.0), rep); // Integer part + 1, mod period\n  Pi0 = mod289(Pi0);\n  Pi1 = mod289(Pi1);\n  vec3 Pf0 = fract(P); // Fractional part for interpolation\n  vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\n  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n  vec4 iy = vec4(Pi0.yy, Pi1.yy);\n  vec4 iz0 = Pi0.zzzz;\n  vec4 iz1 = Pi1.zzzz;\n\n  vec4 ixy = permute(permute(ix) + iy);\n  vec4 ixy0 = permute(ixy + iz0);\n  vec4 ixy1 = permute(ixy + iz1);\n\n  vec4 gx0 = ixy0 * (1.0 / 7.0);\n  vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;\n  gx0 = fract(gx0);\n  vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\n  vec4 sz0 = step(gz0, vec4(0.0));\n  gx0 -= sz0 * (step(0.0, gx0) - 0.5);\n  gy0 -= sz0 * (step(0.0, gy0) - 0.5);\n\n  vec4 gx1 = ixy1 * (1.0 / 7.0);\n  vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;\n  gx1 = fract(gx1);\n  vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\n  vec4 sz1 = step(gz1, vec4(0.0));\n  gx1 -= sz1 * (step(0.0, gx1) - 0.5);\n  gy1 -= sz1 * (step(0.0, gy1) - 0.5);\n\n  vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);\n  vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);\n  vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);\n  vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);\n  vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);\n  vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);\n  vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);\n  vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);\n\n  vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n  g000 *= norm0.x;\n  g010 *= norm0.y;\n  g100 *= norm0.z;\n  g110 *= norm0.w;\n  vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n  g001 *= norm1.x;\n  g011 *= norm1.y;\n  g101 *= norm1.z;\n  g111 *= norm1.w;\n\n  float n000 = dot(g000, Pf0);\n  float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\n  float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\n  float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\n  float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\n  float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\n  float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\n  float n111 = dot(g111, Pf1);\n\n  vec3 fade_xyz = fade(Pf0);\n  vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\n  vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\n  float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x);\n  return 2.2 * n_xyz;\n}\n\n\n//-------- start here ------------\n\nvarying vec3 vNormal;\nuniform float uTime;\nuniform float uSpeed;\nuniform float uLoop;\nuniform float uLoopDuration;\nuniform float uNoiseDensity;\nuniform float uNoiseStrength;\nuniform float uFrequency;\nuniform float uAmplitude;\nvarying vec3 vPos;\nvarying float vDistort;\nvarying vec2 vUv;\nvarying vec3 vViewPosition;\n\n#define STANDARD\n#ifndef FLAT_SHADED\n  #ifdef USE_TANGENT\n    varying vec3 vTangent;\n    varying vec3 vBitangent;\n  #endif\n#endif\n\n#include <clipping_planes_pars_vertex>\n#include <color_pars_vertex>\n#include <common>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <skinning_pars_vertex>\n#include <uv2_pars_vertex>\n#include <uv_pars_vertex>\n\n\n// rotation\nmat3 rotation3dY(float angle) {\n  float s = sin(angle);\n  float c = cos(angle);\n  return mat3(c, 0.0, -s, 0.0, 1.0, 0.0, s, 0.0, c);\n}\n\nvec3 rotateY(vec3 v, float angle) { return rotation3dY(angle) * v; }\n\nvoid main() {\n  #include <beginnormal_vertex>\n  #include <color_vertex>\n  #include <defaultnormal_vertex>\n  #include <morphnormal_vertex>\n  #include <skinbase_vertex>\n  #include <skinnormal_vertex>\n  #include <uv2_vertex>\n  #include <uv_vertex>\n  #ifndef FLAT_SHADED\n    vNormal = normalize(transformedNormal);\n  #ifdef USE_TANGENT\n    vTangent = normalize(transformedTangent);\n    vBitangent = normalize(cross(vNormal, vTangent) * tangent.w);\n  #endif\n  #endif\n  #include <begin_vertex>\n\n  #include <clipping_planes_vertex>\n  #include <displacementmap_vertex>\n  #include <logdepthbuf_vertex>\n  #include <morphtarget_vertex>\n  #include <project_vertex>\n  #include <skinning_vertex>\n    vViewPosition = -mvPosition.xyz;\n  #include <fog_vertex>\n  #include <shadowmap_vertex>\n  #include <worldpos_vertex>\n\n  //-------- start vertex ------------\n  float t = uTime * uSpeed;\n  \n  // For seamless loops, sample noise using 4D-like circular interpolation\n  float distortion;\n  float angle;\n  \n  if (uLoop > 0.5) {\n    // Create truly dynamic seamless loop using 4D noise simulation\n    float loopProgress = uTime / uLoopDuration;\n    float loopAngle = loopProgress * 6.28318530718; // 2*PI\n    \n    // Radius scales with speed to maintain consistent visual speed\n    float radius = 5.0 * uSpeed;\n    \n    // Sample 4 noise values at cardinal points\n    vec3 offset0 = vec3(cos(loopAngle) * radius, sin(loopAngle) * radius, 0.0);\n    vec3 offset1 = vec3(cos(loopAngle + 1.57079632679) * radius, sin(loopAngle + 1.57079632679) * radius, 0.0);\n    vec3 offset2 = vec3(cos(loopAngle + 3.14159265359) * radius, sin(loopAngle + 3.14159265359) * radius, 0.0);\n    vec3 offset3 = vec3(cos(loopAngle + 4.71238898038) * radius, sin(loopAngle + 4.71238898038) * radius, 0.0);\n    \n    // Get noise at all 4 points\n    float n0 = pnoise((normal + offset0) * uNoiseDensity, vec3(10.0));\n    float n1 = pnoise((normal + offset1) * uNoiseDensity, vec3(10.0));\n    float n2 = pnoise((normal + offset2) * uNoiseDensity, vec3(10.0));\n    float n3 = pnoise((normal + offset3) * uNoiseDensity, vec3(10.0));\n    \n    // Smooth interpolation weights\n    float w0 = (cos(loopAngle) + 1.0) * 0.5;\n    float w1 = (cos(loopAngle + 1.57079632679) + 1.0) * 0.5;\n    float w2 = (cos(loopAngle + 3.14159265359) + 1.0) * 0.5;\n    float w3 = (cos(loopAngle + 4.71238898038) + 1.0) * 0.5;\n    \n    float totalWeight = w0 + w1 + w2 + w3;\n    w0 /= totalWeight;\n    w1 /= totalWeight;\n    w2 /= totalWeight;\n    w3 /= totalWeight;\n    \n    // Blend samples with amplitude boost to match single-sample strength\n    float blendedNoise = n0 * w0 + n1 * w1 + n2 * w2 + n3 * w3;\n    distortion = blendedNoise * 1.5 * uNoiseStrength;\n    \n    // Apply loop to spiral effect with blended offset\n    float angleOffset = offset0.x * w0 + offset1.x * w1 + offset2.x * w2 + offset3.x * w3;\n    angle = sin(uv.y * uFrequency + angleOffset) * uAmplitude;\n  } else {\n    // Normal linear time progression\n    distortion = pnoise((normal + t) * uNoiseDensity, vec3(10.0)) * uNoiseStrength;\n    angle = sin(uv.y * uFrequency + t) * uAmplitude;\n  }\n  \n  vec3 pos = position + (normal * distortion);\n  pos = rotateY(pos, angle);\n\n  vPos = pos;\n  vDistort = distortion;\n  vNormal = normal;\n  vUv = uv;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.);\n}\n";
  }
});

// ../shadergradient-v2/dist/chunk-CMNL4XFD.mjs
var waterPlane_exports3, fragment_default9, vertex_default9;
var init_chunk_CMNL4XFD = __esm({
  "../shadergradient-v2/dist/chunk-CMNL4XFD.mjs"() {
    init_chunk_5BEQP2BQ();
    waterPlane_exports3 = {};
    __export(waterPlane_exports3, {
      fragment: () => fragment_default9,
      vertex: () => vertex_default9
    });
    fragment_default9 = "\n#define STANDARD\n#ifdef PHYSICAL\n#define REFLECTIVITY\n#define CLEARCOAT\n#define TRANSMISSION\n#endif\n\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n\n#ifdef TRANSMISSION\nuniform float transmission;\n#endif\n#ifdef REFLECTIVITY\nuniform float reflectivity;\n#endif\n#ifdef CLEARCOAT\nuniform float clearcoat;\nuniform float clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\nuniform vec3 sheen;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n#ifdef USE_TANGENT\nvarying vec3 vTangent;\nvarying vec3 vBitangent;\n#endif\n#endif\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <color_pars_fragment>\n#include <common>\n#include <dithering_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <map_pars_fragment>\n#include <packing>\n#include <uv2_pars_fragment>\n#include <uv_pars_fragment>\n// #include <transmissionmap_pars_fragment>\n#include <bsdfs>\n#include <bumpmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <clipping_planes_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <lights_physical_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <shadowmap_pars_fragment>\n// include\uB97C \uD1B5\uD574 \uAC00\uC838\uC628 \uAC12\uC740 \uB300\uBD80\uBD84 \uD658\uACBD, \uBE5B \uB4F1\uC744 \uACC4\uC0B0\uD558\uAE30 \uC704\uD574\uC11C \uAE30\uBCF8 fragment\n// shader\uC758 \uAC12\uB4E4\uC744 \uBC1B\uC544\uC654\uC2B5\uB2C8\uB2E4. \uC77C\uB2E8\uC740 \uBB34\uC2DC\uD558\uC154\uB3C4 \uB429\uB2C8\uB2E4.\n\nvarying vec3 vNormal;\nvarying float displacement;\nvarying vec3 vPos;\nvarying float vDistort;\n\nuniform float uC1r;\nuniform float uC1g;\nuniform float uC1b;\nuniform float uC2r;\nuniform float uC2g;\nuniform float uC2b;\nuniform float uC3r;\nuniform float uC3g;\nuniform float uC3b;\n\nvarying vec3 color1;\nvarying vec3 color2;\nvarying vec3 color3;\n\n// for npm package, need to add this manually\n// 'linearToRelativeLuminance' : function already has a body\nfloat linearToRelativeLuminance2( const in vec3 color ) {\n    vec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n    return dot( weights, color.rgb );\n}\n\nvoid main() {\n\n  //-------- basic gradient ------------\n  vec3 color1 = vec3(uC1r, uC1g, uC1b);\n  vec3 color2 = vec3(uC2r, uC2g, uC2b);\n  vec3 color3 = vec3(uC3r, uC3g, uC3b);\n  float clearcoat = 1.0;\n  float clearcoatRoughness = 0.5;\n\n  #include <clipping_planes_fragment>\n\n  vec4 diffuseColor = vec4(\n      mix(mix(color1, color2, smoothstep(-3.0, 3.0, vPos.x)), color3, vPos.z),\n      1);\n  // diffuseColor\uB294 \uC624\uBE0C\uC81D\uD2B8\uC758 \uBCA0\uC774\uC2A4 \uC0C9\uC0C1 (\uD658\uACBD\uC774\uB098 \uBE5B\uC774 \uACE0\uB824\uB418\uC9C0 \uC54A\uC740 \uBCF8\uC5F0\uC758\n  // \uC0C9)\n\n  // mix(x, y, a): a\uB97C \uCD95\uC73C\uB85C \uD588\uC744 \uB54C \uAC00\uC7A5 \uB0AE\uC740 \uAC12\uC5D0\uC11C x\uAC12\uC758 \uC601\uD5A5\uB825\uC744 100%, \uAC00\uC7A5\n  // \uB192\uC740 \uAC12\uC5D0\uC11C y\uAC12\uC758 \uC601\uD5A5\uB825\uC744 100%\uB85C \uB9CC\uB4E0\uB2E4. smoothstep(x, y, a): a\uCD95\uC744\n  // \uAE30\uC900\uC73C\uB85C x\uB97C \uCD5C\uC18C\uAC12, y\uB97C \uCD5C\uB300\uAC12\uC73C\uB85C \uADF8 \uC0AC\uC774\uC758 \uAC12\uC744 \uCABC\uAC20\uB2E4. x\uC640 y \uC0AC\uC774\uB97C\n  // 0-100 \uC0AC\uC774\uC758 \uADF8\uB77C\uB514\uC5B8\uD2B8\uCC98\uB7FC \uB2E8\uACC4\uBCC4\uB85C \uD45C\uD604\uD558\uACE0, x \uBBF8\uB9CC\uC758 \uAC12\uC740 0, y \uC774\uC0C1\uC758\n  // \uAC12\uC740 100\uC73C\uB85C \uCC98\uB9AC\n\n  // 1. smoothstep(-3.0, 3.0,vPos.x)\uB85C x\uCD95\uC758 \uADF8\uB77C\uB514\uC5B8\uD2B8\uAC00 \uD45C\uD604 \uB420 \uBC94\uC704\uB97C -3,\n  // 3\uC73C\uB85C \uC815\uD55C\uB2E4.\n  // 2. mix(color1, color3, smoothstep(-3.0, 3.0,vPos.x))\uB85C color1\uACFC color3\uC744\n  // \uC704\uC758 \uBC94\uC704 \uC548\uC5D0\uC11C \uADF8\uB77C\uB514\uC5B8\uD2B8\uB85C \uD45C\uD604\uD55C\uB2E4.\n  // \uC608\uB97C \uB4E4\uC5B4 color1\uC774 \uB178\uB791, color3\uC774 \uD30C\uB791\uC774\uB77C\uACE0 \uCE58\uBA74, x\uCD95 \uAE30\uC900 -3\uBD80\uD130 3\uAE4C\uC9C0\n  // \uB178\uB791\uACFC \uD30C\uB791 \uC0AC\uC774\uC758 \uADF8\uB77C\uB514\uC5B8\uD2B8\uAC00 \uB098\uD0C0\uB098\uACE0, -3\uBCF4\uB2E4 \uC791\uC740 \uAC12\uC5D0\uC11C\uB294 \uACC4\uC18D \uB178\uB791,\n  // 3\uBCF4\uB2E4 \uD070 \uAC12\uC5D0\uC11C\uB294 \uACC4\uC18D \uD30C\uB791\uC774 \uB098\uD0C0\uB09C\uB2E4.\n  // 3. mix()\uB97C \uD55C \uBC88 \uB354 \uC0AC\uC6A9\uD574\uC11C \uC704\uC758 \uADF8\uB77C\uB514\uC5B8\uD2B8\uC640 color2\uB97C z\uCD95 \uAE30\uC900\uC73C\uB85C\n  // \uBD84\uBC30\uD55C\uB2E4.\n\n  //-------- materiality ------------\n  ReflectedLight reflectedLight =\n      ReflectedLight(vec3(0.0), vec3(0.0), vec3(0.0), vec3(0.0));\n  vec3 totalEmissiveRadiance = emissive;\n\n  #ifdef TRANSMISSION\n    float totalTransmission = transmission;\n  #endif\n  #include <logdepthbuf_fragment>\n  #include <map_fragment>\n  #include <color_fragment>\n  #include <alphamap_fragment>\n  #include <alphatest_fragment>\n  #include <roughnessmap_fragment>\n  #include <metalnessmap_fragment>\n  #include <normal_fragment_begin>\n  #include <normal_fragment_maps>\n  #include <clearcoat_normal_fragment_begin>\n  #include <clearcoat_normal_fragment_maps>\n  #include <emissivemap_fragment>\n  // #include <transmissionmap_fragment>\n  #include <lights_physical_fragment>\n  #include <lights_fragment_begin>\n  #include <lights_fragment_maps>\n  #include <lights_fragment_end>\n  #include <aomap_fragment>\n    vec3 outgoingLight =\n        reflectedLight.directDiffuse + reflectedLight.indirectDiffuse +\n        reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n    //\uC704\uC5D0\uC11C \uC815\uC758\uD55C diffuseColor\uC5D0 \uD658\uACBD\uC774\uB098 \uBC18\uC0AC\uAC12\uB4E4\uC744 \uBC18\uC601\uD55C \uAC12.\n  #ifdef TRANSMISSION\n    diffuseColor.a *=\n        mix(saturate(1. - totalTransmission +\n                    linearToRelativeLuminance2(reflectedLight.directSpecular +\n                                              reflectedLight.indirectSpecular)),\n            1.0, metalness);\n  #endif\n\n\n  #include <tonemapping_fragment>\n  #include <encodings_fragment>\n  #include <fog_fragment>\n  #include <premultiplied_alpha_fragment>\n  #include <dithering_fragment>\n\n\n  gl_FragColor = vec4(outgoingLight, diffuseColor.a);\n  // gl_FragColor\uAC00 fragment shader\uB97C \uD1B5\uD574 \uB098\uD0C0\uB098\uB294 \uCD5C\uC885\uAC12\uC73C\uB85C, diffuseColor\uC5D0\uC11C\n  // \uC815\uC758\uD55C \uADF8\uB77C\uB514\uC5B8\uD2B8 \uC0C9\uC0C1 \uC704\uC5D0 \uBC18\uC0AC\uB098 \uBE5B\uC744 \uACC4\uC0B0\uD55C \uAC12\uC744 \uCD5C\uC885\uAC12\uC73C\uB85C \uC815\uC758.\n  // gl_FragColor = vec4(mix(mix(color1, color3, smoothstep(-3.0, 3.0,vPos.x)),\n  // color2, vNormal.z), 1.0); \uC704\uCC98\uB7FC \uCD5C\uC885\uAC12\uC744 \uADF8\uB77C\uB514\uC5B8\uD2B8 \uAC12 \uC790\uCCB4\uB97C \uB123\uC73C\uBA74 \uD658\uACBD\n  // \uC601\uD5A5\uC5C6\uB294 \uADF8\uB77C\uB514\uC5B8\uD2B8\uB9CC \uD45C\uD604\uB428.\n}\n";
    vertex_default9 = "// #pragma glslify: cnoise3 = require(glsl-noise/classic/3d) \nvec3 mod289(vec3 x)\n{\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289(vec4 x)\n{\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x)\n{\n  return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nvec3 fade(vec3 t) {\n  return t*t*t*(t*(t*6.0-15.0)+10.0);\n}\n\nfloat cnoise(vec3 P)\n{\n  vec3 Pi0 = floor(P); // Integer part for indexing\n  vec3 Pi1 = Pi0 + vec3(1.0); // Integer part + 1\n  Pi0 = mod289(Pi0);\n  Pi1 = mod289(Pi1);\n  vec3 Pf0 = fract(P); // Fractional part for interpolation\n  vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\n  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n  vec4 iy = vec4(Pi0.yy, Pi1.yy);\n  vec4 iz0 = Pi0.zzzz;\n  vec4 iz1 = Pi1.zzzz;\n\n  vec4 ixy = permute(permute(ix) + iy);\n  vec4 ixy0 = permute(ixy + iz0);\n  vec4 ixy1 = permute(ixy + iz1);\n\n  vec4 gx0 = ixy0 * (1.0 / 7.0);\n  vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;\n  gx0 = fract(gx0);\n  vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\n  vec4 sz0 = step(gz0, vec4(0.0));\n  gx0 -= sz0 * (step(0.0, gx0) - 0.5);\n  gy0 -= sz0 * (step(0.0, gy0) - 0.5);\n\n  vec4 gx1 = ixy1 * (1.0 / 7.0);\n  vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;\n  gx1 = fract(gx1);\n  vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\n  vec4 sz1 = step(gz1, vec4(0.0));\n  gx1 -= sz1 * (step(0.0, gx1) - 0.5);\n  gy1 -= sz1 * (step(0.0, gy1) - 0.5);\n\n  vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);\n  vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);\n  vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);\n  vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);\n  vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);\n  vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);\n  vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);\n  vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);\n\n  vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n  g000 *= norm0.x;\n  g010 *= norm0.y;\n  g100 *= norm0.z;\n  g110 *= norm0.w;\n  vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n  g001 *= norm1.x;\n  g011 *= norm1.y;\n  g101 *= norm1.z;\n  g111 *= norm1.w;\n\n  float n000 = dot(g000, Pf0);\n  float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\n  float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\n  float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\n  float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\n  float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\n  float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\n  float n111 = dot(g111, Pf1);\n\n  vec3 fade_xyz = fade(Pf0);\n  vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\n  vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\n  float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x); \n  return 2.2 * n_xyz;\n}\n\n//-------- start here ------------\n\nmat3 rotation3dY(float angle) {\n  float s = sin(angle);\n  float c = cos(angle);\n\n  return mat3(c, 0.0, -s, 0.0, 1.0, 0.0, s, 0.0, c);\n}\n\nvec3 rotateY(vec3 v, float angle) { return rotation3dY(angle) * v; }\n\nvarying vec3 vNormal;\nvarying float displacement;\nvarying vec3 vPos;\nvarying float vDistort;\n\nuniform float uTime;\nuniform float uSpeed;\nuniform float uLoop;\nuniform float uLoopDuration;\nuniform float uNoiseDensity;\nuniform float uNoiseStrength;\n\n#define STANDARD\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n#ifdef USE_TANGENT\nvarying vec3 vTangent;\nvarying vec3 vBitangent;\n#endif\n#endif\n#include <clipping_planes_pars_vertex>\n#include <color_pars_vertex>\n#include <common>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <skinning_pars_vertex>\n#include <uv2_pars_vertex>\n#include <uv_pars_vertex>\n\nvoid main() {\n\n  #include <beginnormal_vertex>\n  #include <color_vertex>\n  #include <defaultnormal_vertex>\n  #include <morphnormal_vertex>\n  #include <skinbase_vertex>\n  #include <skinnormal_vertex>\n  #include <uv2_vertex>\n  #include <uv_vertex>\n  #ifndef FLAT_SHADED\n    vNormal = normalize(transformedNormal);\n  #ifdef USE_TANGENT\n    vTangent = normalize(transformedTangent);\n    vBitangent = normalize(cross(vNormal, vTangent) * tangent.w);\n  #endif\n  #endif\n  #include <begin_vertex>\n\n  #include <clipping_planes_vertex>\n  #include <displacementmap_vertex>\n  #include <logdepthbuf_vertex>\n  #include <morphtarget_vertex>\n  #include <project_vertex>\n  #include <skinning_vertex>\n    vViewPosition = -mvPosition.xyz;\n  #include <fog_vertex>\n  #include <shadowmap_vertex>\n  #include <worldpos_vertex>\n\n  //-------- start vertex ------------\n  float t = uTime * uSpeed;\n  \n  // For seamless loops, sample noise using 4D-like circular interpolation\n  vec3 noisePos = 0.43 * position * uNoiseDensity;\n  float distortion;\n  \n  if (uLoop > 0.5) {\n    // Create truly dynamic seamless loop using 4D noise simulation\n    float loopProgress = uTime / uLoopDuration;\n    float angle = loopProgress * 6.28318530718; // 2*PI\n    \n    // Radius scales with speed to maintain consistent visual speed\n    float radius = 5.0 * uSpeed;\n    \n    // Sample 4 noise values at cardinal points\n    vec3 offset0 = vec3(cos(angle) * radius, sin(angle) * radius, 0.0);\n    vec3 offset1 = vec3(cos(angle + 1.57079632679) * radius, sin(angle + 1.57079632679) * radius, 0.0);\n    vec3 offset2 = vec3(cos(angle + 3.14159265359) * radius, sin(angle + 3.14159265359) * radius, 0.0);\n    vec3 offset3 = vec3(cos(angle + 4.71238898038) * radius, sin(angle + 4.71238898038) * radius, 0.0);\n    \n    // Get noise at all 4 points\n    float n0 = cnoise(noisePos + offset0);\n    float n1 = cnoise(noisePos + offset1);\n    float n2 = cnoise(noisePos + offset2);\n    float n3 = cnoise(noisePos + offset3);\n    \n    // Smooth interpolation weights\n    float w0 = (cos(angle) + 1.0) * 0.5;\n    float w1 = (cos(angle + 1.57079632679) + 1.0) * 0.5;\n    float w2 = (cos(angle + 3.14159265359) + 1.0) * 0.5;\n    float w3 = (cos(angle + 4.71238898038) + 1.0) * 0.5;\n    \n    float totalWeight = w0 + w1 + w2 + w3;\n    w0 /= totalWeight;\n    w1 /= totalWeight;\n    w2 /= totalWeight;\n    w3 /= totalWeight;\n    \n    // Blend samples with amplitude boost to match single-sample strength\n    float blendedNoise = n0 * w0 + n1 * w1 + n2 * w2 + n3 * w3;\n    distortion = 0.75 * blendedNoise * 1.5;\n  } else {\n    // Normal linear time progression\n    distortion = 0.75 * cnoise(noisePos + t);\n  }\n\n  vec3 pos = position + normal * distortion * uNoiseStrength;\n  vPos = pos;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.);\n}\n";
  }
});

// ../shadergradient-v2/dist/chunk-4GZNORIL.mjs
var defaults_exports;
var init_chunk_4GZNORIL = __esm({
  "../shadergradient-v2/dist/chunk-4GZNORIL.mjs"() {
    init_chunk_R2XBTOLG();
    init_chunk_5BVQK6OK();
    init_chunk_CMNL4XFD();
    init_chunk_5BEQP2BQ();
    defaults_exports = {};
    __export(defaults_exports, {
      plane: () => plane_exports3,
      sphere: () => sphere_exports3,
      waterPlane: () => waterPlane_exports3
    });
  }
});

// ../shadergradient-v2/dist/chunk-4DHS567T.mjs
var waterPlane_exports4, fragment_default10, vertex_default10;
var init_chunk_4DHS567T = __esm({
  "../shadergradient-v2/dist/chunk-4DHS567T.mjs"() {
    init_chunk_5BEQP2BQ();
    waterPlane_exports4 = {};
    __export(waterPlane_exports4, {
      fragment: () => fragment_default10,
      vertex: () => vertex_default10
    });
    fragment_default10 = "// Glass WaterPlane Fragment Shader - Liquid Glass Effect\n\n#define STANDARD\n#ifdef PHYSICAL\n#define REFLECTIVITY\n#define CLEARCOAT\n#define TRANSMISSION\n#endif\n\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n\n// transmission is already defined by Three.js when TRANSMISSION is enabled\n#ifdef REFLECTIVITY\nuniform float reflectivity;\n#endif\n#ifdef CLEARCOAT\nuniform float clearcoat;\nuniform float clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\nuniform vec3 sheen;\n#endif\n\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n#ifdef USE_TANGENT\nvarying vec3 vTangent;\nvarying vec3 vBitangent;\n#endif\n#endif\n\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <color_pars_fragment>\n#include <common>\n#include <dithering_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <map_pars_fragment>\n#include <packing>\n#include <uv2_pars_fragment>\n#include <uv_pars_fragment>\n#include <bsdfs>\n#include <bumpmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <clipping_planes_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <lights_physical_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <transmission_pars_fragment>\n\n// Custom uniforms for liquid glass effect\nuniform float uTime;\nuniform vec3 uColor1;\nuniform vec3 uColor2;\nuniform vec3 uColor3;\nuniform float uTransparency;\nuniform float uRefraction;\nuniform float uChromaticAberration;\nuniform float uFresnelPower;\nuniform float uReflectivity;\n// envMap and envMapIntensity are provided by Three.js\nuniform float uLiquidEffect;\nuniform float uFoamIntensity;\n\nvarying vec2 vUv;\nvarying vec3 vPosition;\nvarying vec3 vNormal;\nvarying vec3 vGlassWorldPos;\nvarying vec3 vReflect;\nvarying vec3 vRefract;\nvarying float vWaveHeight;\nvarying vec3 vWaveNormal;\n\n// Fresnel calculation\nfloat fresnel(vec3 viewDirection, vec3 normal, float power) {\n  return pow(1.0 - abs(dot(viewDirection, normal)), power);\n}\n\n// Chromatic aberration for refraction\nvec3 chromaticRefraction(vec3 viewDirection, vec3 normal, float ior, float chromaticStrength) {\n  vec3 refractedR = refract(viewDirection, normal, 1.0 / (ior - chromaticStrength));\n  vec3 refractedG = refract(viewDirection, normal, 1.0 / ior);\n  vec3 refractedB = refract(viewDirection, normal, 1.0 / (ior + chromaticStrength));\n  \n  #ifdef ENVMAP_TYPE_CUBE\n  vec3 result = vec3(\n    textureCube(envMap, refractedR).r,\n    textureCube(envMap, refractedG).g,\n    textureCube(envMap, refractedB).b\n  );\n  \n  // Add distortion based on wave height\n  float distortion = vWaveHeight * 0.1;\n  result = mix(result, textureCube(envMap, refractedG + vec3(distortion)).rgb, 0.3);\n  #else\n  vec3 result = vec3(0.5);\n  #endif\n  \n  return result;\n}\n\n// Foam effect for water surface\nfloat foam(vec2 uv, float waveHeight, float time) {\n  float foamThreshold = 0.3;\n  float foamAmount = smoothstep(foamThreshold - 0.1, foamThreshold + 0.1, abs(waveHeight));\n  \n  // Add foam texture pattern\n  float foamPattern = sin(uv.x * 40.0 + time) * cos(uv.y * 30.0 - time * 0.5);\n  foamPattern += sin(uv.x * 25.0 - time * 0.8) * sin(uv.y * 35.0 + time);\n  foamPattern = clamp(foamPattern * 0.5 + 0.5, 0.0, 1.0);\n  \n  return foamAmount * foamPattern;\n}\n\n// Caustics for underwater effect\nvec3 caustics(vec3 position, float time) {\n  float c1 = sin(position.x * 6.0 + time * 1.5) * sin(position.z * 6.0 + time);\n  float c2 = cos(position.x * 4.0 - time) * cos(position.z * 5.0 + time * 1.2);\n  float c3 = sin((position.x + position.z) * 3.0 + time * 0.8);\n  \n  float causticPattern = (c1 + c2 + c3) / 3.0;\n  causticPattern = pow(max(0.0, causticPattern), 2.0);\n  \n  return vec3(causticPattern) * vec3(0.3, 0.6, 1.0);\n}\n\nvoid main() {\n  #include <clipping_planes_fragment>\n  \n  vec4 diffuseColor = vec4(diffuse, opacity);\n  ReflectedLight reflectedLight = ReflectedLight(vec3(0.0), vec3(0.0), vec3(0.0), vec3(0.0));\n  vec3 totalEmissiveRadiance = emissive;\n  \n  #include <logdepthbuf_fragment>\n  #include <map_fragment>\n  #include <color_fragment>\n  #include <alphamap_fragment>\n  #include <alphatest_fragment>\n  #include <specularmap_fragment>\n  #include <roughnessmap_fragment>\n  #include <metalnessmap_fragment>\n  #include <normal_fragment_begin>\n  #include <normal_fragment_maps>\n  #include <clearcoat_normal_fragment_begin>\n  #include <clearcoat_normal_fragment_maps>\n  #include <emissivemap_fragment>\n  \n  // Use wave normal for more accurate water surface\n  vec3 viewDirection = normalize(vViewPosition);\n  vec3 worldNormal = normalize(vWaveNormal);\n  \n  // Calculate Fresnel effect\n  float fresnelFactor = fresnel(viewDirection, worldNormal, uFresnelPower);\n  \n  // Water color gradient with depth effect\n  float depth = 1.0 - abs(vWaveHeight) * 2.0;\n  vec3 shallowColor = mix(uColor1, uColor2, vUv.y);\n  vec3 deepColor = mix(uColor2, uColor3, depth);\n  vec3 gradientColor = mix(shallowColor, deepColor, fresnelFactor);\n  \n  // Add foam effect\n  float foamAmount = foam(vUv, vWaveHeight, uTime) * uFoamIntensity;\n  vec3 foamColor = vec3(1.0, 1.0, 1.0);\n  gradientColor = mix(gradientColor, foamColor, foamAmount);\n  \n  // Reflection\n  #ifdef ENVMAP_TYPE_CUBE\n  vec3 reflectionColor = textureCube(envMap, vReflect).rgb * envMapIntensity;\n  \n  // Add slight blur to reflection for water effect\n  vec3 blurredReflection = reflectionColor;\n  for (int i = 0; i < 4; i++) {\n    vec3 offset = vec3(\n      sin(float(i) * 2.0) * 0.01,\n      0.0,\n      cos(float(i) * 2.0) * 0.01\n    );\n    blurredReflection += textureCube(envMap, vReflect + offset).rgb * envMapIntensity;\n  }\n  blurredReflection /= 5.0;\n  reflectionColor = mix(reflectionColor, blurredReflection, uLiquidEffect);\n  #else\n  vec3 reflectionColor = vec3(0.5);\n  #endif\n  \n  // Refraction with chromatic aberration (stronger for water)\n  vec3 refractionColor;\n  #ifdef ENVMAP_TYPE_CUBE\n  if (uChromaticAberration > 0.0) {\n    float waterIOR = 1.33 + vWaveHeight * 0.1;\n    refractionColor = chromaticRefraction(-viewDirection, worldNormal, waterIOR, uChromaticAberration * 1.5);\n  } else {\n    refractionColor = textureCube(envMap, vRefract).rgb;\n  }\n  refractionColor *= envMapIntensity;\n  #else\n  refractionColor = vec3(0.3);\n  #endif\n  \n  // Add caustics to refraction\n  vec3 causticsColor = caustics(vGlassWorldPos, uTime);\n  refractionColor += causticsColor * 0.3 * uLiquidEffect;\n  \n  // Mix reflection and refraction based on Fresnel and wave\n  float reflectionMix = fresnelFactor * uReflectivity * (1.0 + abs(vWaveHeight));\n  vec3 envColor = mix(refractionColor, reflectionColor, clamp(reflectionMix, 0.0, 1.0));\n  \n  // Combine all effects\n  vec3 finalColor = mix(gradientColor, envColor, 0.85);\n  \n  // Apply transparency with wave variation\n  float waveAlpha = 1.0 - abs(vWaveHeight) * 0.3;\n  float finalAlpha = mix(uTransparency * waveAlpha, 1.0, fresnelFactor * 0.6 + foamAmount * 0.4);\n  \n  // Set diffuse color for standard lighting\n  diffuseColor.rgb = finalColor;\n  diffuseColor.a = finalAlpha;\n  \n  // Skip transmission_fragment to avoid conflicts\n  \n  vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + \n                       reflectedLight.directSpecular + reflectedLight.indirectSpecular + \n                       totalEmissiveRadiance;\n  \n  // Add our liquid glass color contribution\n  outgoingLight += finalColor * 0.95;\n  \n  gl_FragColor = vec4(outgoingLight, diffuseColor.a);\n  \n  #include <tonemapping_fragment>\n  #include <colorspace_fragment>\n  #include <fog_fragment>\n  #include <premultiplied_alpha_fragment>\n  #include <dithering_fragment>\n}\n";
    vertex_default10 = "// Glass WaterPlane Vertex Shader - Liquid Glass Effect\n\n#define STANDARD\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n#ifdef USE_TANGENT\nvarying vec3 vTangent;\nvarying vec3 vBitangent;\n#endif\n#endif\n#include <clipping_planes_pars_vertex>\n#include <color_pars_vertex>\n#include <common>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <skinning_pars_vertex>\n#include <uv2_pars_vertex>\n#include <uv_pars_vertex>\n\nvarying vec2 vUv;\nvarying vec3 vPosition;\nvarying vec3 vNormal;\nvarying vec3 vGlassWorldPos;\nvarying vec3 vReflect;\nvarying vec3 vRefract;\nvarying float vWaveHeight;\nvarying vec3 vWaveNormal;\n\nuniform float uTime;\nuniform float uSpeed;\nuniform float uWaveAmplitude;\nuniform float uWaveFrequency;\nuniform float uNoiseStrength;\nuniform float uDistortion;\nuniform float uFlowSpeed;\nuniform vec2 uFlowDirection;\n\n// Noise functions for water-like glass distortion\nvec3 mod289(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289(vec4 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x) {\n  return mod289(((x * 34.0) + 1.0) * x);\n}\n\nvec4 taylorInvSqrt(vec4 r) {\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat snoise(vec3 v) {\n  const vec2 C = vec2(1.0 / 6.0, 1.0 / 3.0);\n  const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n  vec3 i = floor(v + dot(v, C.yyy));\n  vec3 x0 = v - i + dot(i, C.xxx);\n\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min(g.xyz, l.zxy);\n  vec3 i2 = max(g.xyz, l.zxy);\n\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy;\n  vec3 x3 = x0 - D.yyy;\n\n  i = mod289(i);\n  vec4 p = permute(permute(permute(\n    i.z + vec4(0.0, i1.z, i2.z, 1.0))\n    + i.y + vec4(0.0, i1.y, i2.y, 1.0))\n    + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n  float n_ = 0.142857142857;\n  vec3 ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_);\n\n  vec4 x = x_ * ns.x + ns.yyyy;\n  vec4 y = y_ * ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4(x.xy, y.xy);\n  vec4 b1 = vec4(x.zw, y.zw);\n\n  vec4 s0 = floor(b0) * 2.0 + 1.0;\n  vec4 s1 = floor(b1) * 2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw * sh.xxyy;\n  vec4 a1 = b1.xzyw + s1.xzyw * sh.zzww;\n\n  vec3 p0 = vec3(a0.xy, h.x);\n  vec3 p1 = vec3(a0.zw, h.y);\n  vec3 p2 = vec3(a1.xy, h.z);\n  vec3 p3 = vec3(a1.zw, h.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(p0, p0), dot(p1, p1), dot(p2, p2), dot(p3, p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n  vec4 m = max(0.6 - vec4(dot(x0, x0), dot(x1, x1), dot(x2, x2), dot(x3, x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot(m * m, vec4(dot(p0, x0), dot(p1, x1),\n    dot(p2, x2), dot(p3, x3)));\n}\n\n// Water wave function\nvec3 waterWave(vec2 pos, float time) {\n  // Flow effect\n  vec2 flowPos = pos + uFlowDirection * time * uFlowSpeed;\n  \n  // Multiple wave layers for realistic water\n  float wave1 = sin(flowPos.x * uWaveFrequency + time) * cos(flowPos.y * uWaveFrequency * 0.8 + time * 0.7);\n  float wave2 = sin(flowPos.x * uWaveFrequency * 1.7 - time * 1.3) * sin(flowPos.y * uWaveFrequency * 1.3 + time);\n  float wave3 = cos(flowPos.x * uWaveFrequency * 0.5 + time * 0.5) * sin(flowPos.y * uWaveFrequency * 0.6 - time * 0.8);\n  \n  // Combine waves\n  float height = (wave1 * 0.5 + wave2 * 0.3 + wave3 * 0.2) * uWaveAmplitude;\n  \n  // Calculate wave normals\n  float dx = cos(flowPos.x * uWaveFrequency + time) * uWaveFrequency * 0.5 * uWaveAmplitude;\n  float dz = -sin(flowPos.y * uWaveFrequency * 0.8 + time * 0.7) * uWaveFrequency * 0.8 * 0.5 * uWaveAmplitude;\n  \n  return vec3(dx, height, dz);\n}\n\nvoid main() {\n  #include <uv_pars_vertex>\n  #include <uv_vertex>\n  #include <uv2_pars_vertex>\n  #include <uv2_vertex>\n  #include <color_pars_vertex>\n  #include <color_vertex>\n  #include <morphcolor_vertex>\n  #include <beginnormal_vertex>\n  #include <morphnormal_vertex>\n  #include <skinbase_vertex>\n  #include <skinnormal_vertex>\n  #include <defaultnormal_vertex>\n  #include <normal_vertex>\n  \n  // Pass UV coordinates\n  vUv = uv;\n\n  // Calculate time-based animation\n  float time = uTime * uSpeed;\n  \n  // Calculate water waves\n  vec3 waveData = waterWave(position.xz, time);\n  float waveHeight = waveData.y;\n  vec2 waveGradient = waveData.xz;\n  \n  // Add noise for organic water movement\n  vec3 noisePos = vec3(position.x, position.y, position.z) + vec3(time * 0.05);\n  float noise = snoise(noisePos * 1.2) * uNoiseStrength * 0.5;\n  \n  // Store wave height for fragment shader\n  vWaveHeight = waveHeight + noise;\n  \n  // Calculate perturbed normal for water surface\n  vec3 waveNormal = normalize(vec3(-waveGradient.x, 1.0, -waveGradient.y));\n  vWaveNormal = waveNormal;\n  \n  // Blend original normal with wave normal\n  vec3 blendedNormal = normalize(mix(normal, waveNormal, 0.7));\n  \n  #ifndef FLAT_SHADED\n  vNormal = normalize(mat3(modelViewMatrix) * blendedNormal);\n  #ifdef USE_TANGENT\n  vTangent = normalize(transformedTangent);\n  vBitangent = normalize(cross(vNormal, vTangent) * tangent.w);\n  #endif\n  #endif\n  \n  #include <begin_vertex>\n  #include <morphtarget_vertex>\n  #include <skinning_vertex>\n  #include <displacementmap_vertex>\n  \n  // Apply wave displacement and additional distortion\n  transformed.y += waveHeight + noise;\n  transformed += blendedNormal * uDistortion * noise;\n  \n  #include <project_vertex>\n  #include <logdepthbuf_vertex>\n  #include <clipping_planes_vertex>\n  \n  vViewPosition = -mvPosition.xyz;\n  vPosition = transformed;\n  \n  // Calculate world position for refraction\n  vec4 worldPosition = modelMatrix * vec4(transformed, 1.0);\n  vGlassWorldPos = worldPosition.xyz;\n  \n  // Calculate reflection and refraction vectors with wave normal\n  vec3 worldNormal = normalize(mat3(modelMatrix) * blendedNormal);\n  vec3 viewVector = normalize(cameraPosition - worldPosition.xyz);\n  \n  // Reflection vector\n  vReflect = reflect(-viewVector, worldNormal);\n  \n  // Refraction vector with varying IOR for water effect\n  float ior = 1.33 + sin(time + position.x * 2.0) * 0.1; // Water IOR ~1.33\n  vRefract = refract(-viewVector, worldNormal, 1.0 / ior);\n  \n  #include <fog_vertex>\n  #include <shadowmap_vertex>\n}\n";
  }
});

// ../shadergradient-v2/dist/chunk-73SSHDUK.mjs
var plane_exports4, fragment_default11, vertex_default11;
var init_chunk_73SSHDUK = __esm({
  "../shadergradient-v2/dist/chunk-73SSHDUK.mjs"() {
    init_chunk_5BEQP2BQ();
    plane_exports4 = {};
    __export(plane_exports4, {
      fragment: () => fragment_default11,
      vertex: () => vertex_default11
    });
    fragment_default11 = "// Glass Plane Fragment Shader - Transparency & Refraction\n\n#define STANDARD\n#ifdef PHYSICAL\n#define REFLECTIVITY\n#define CLEARCOAT\n#define TRANSMISSION\n#endif\n\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n\n// transmission is already defined by Three.js when TRANSMISSION is enabled\n#ifdef REFLECTIVITY\nuniform float reflectivity;\n#endif\n#ifdef CLEARCOAT\nuniform float clearcoat;\nuniform float clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\nuniform vec3 sheen;\n#endif\n\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n#ifdef USE_TANGENT\nvarying vec3 vTangent;\nvarying vec3 vBitangent;\n#endif\n#endif\n\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <color_pars_fragment>\n#include <common>\n#include <dithering_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <map_pars_fragment>\n#include <packing>\n#include <uv2_pars_fragment>\n#include <uv_pars_fragment>\n#include <bsdfs>\n#include <bumpmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <clipping_planes_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <lights_physical_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <transmission_pars_fragment>\n\n// Custom uniforms for glass effect\nuniform float uTime;\nuniform vec3 uColor1;\nuniform vec3 uColor2;\nuniform vec3 uColor3;\nuniform float uTransparency;\nuniform float uRefraction;\nuniform float uChromaticAberration;\nuniform float uFresnelPower;\nuniform float uReflectivity;\n// envMap and envMapIntensity are provided by Three.js\n\nvarying vec2 vUv;\nvarying vec3 vPosition;\nvarying vec3 vNormal;\nvarying vec3 vGlassWorldPos;\nvarying vec3 vReflect;\nvarying vec3 vRefract;\n\n// Fresnel calculation\nfloat fresnel(vec3 viewDirection, vec3 normal, float power) {\n  return pow(1.0 - dot(viewDirection, normal), power);\n}\n\n// Chromatic aberration for refraction\nvec3 chromaticRefraction(vec3 viewDirection, vec3 normal, float ior, float chromaticStrength) {\n  vec3 refractedR = refract(viewDirection, normal, 1.0 / (ior - chromaticStrength));\n  vec3 refractedG = refract(viewDirection, normal, 1.0 / ior);\n  vec3 refractedB = refract(viewDirection, normal, 1.0 / (ior + chromaticStrength));\n  \n  #ifdef ENVMAP_TYPE_CUBE\n  return vec3(\n    textureCube(envMap, refractedR).r,\n    textureCube(envMap, refractedG).g,\n    textureCube(envMap, refractedB).b\n  );\n  #else\n  return vec3(0.5);\n  #endif\n}\n\nvoid main() {\n  #include <clipping_planes_fragment>\n  \n  vec4 diffuseColor = vec4(diffuse, opacity);\n  ReflectedLight reflectedLight = ReflectedLight(vec3(0.0), vec3(0.0), vec3(0.0), vec3(0.0));\n  vec3 totalEmissiveRadiance = emissive;\n  \n  #include <logdepthbuf_fragment>\n  #include <map_fragment>\n  #include <color_fragment>\n  #include <alphamap_fragment>\n  #include <alphatest_fragment>\n  #include <specularmap_fragment>\n  #include <roughnessmap_fragment>\n  #include <metalnessmap_fragment>\n  #include <normal_fragment_begin>\n  #include <normal_fragment_maps>\n  #include <clearcoat_normal_fragment_begin>\n  #include <clearcoat_normal_fragment_maps>\n  #include <emissivemap_fragment>\n  \n  // Glass-specific calculations\n  vec3 viewDirection = normalize(vViewPosition);\n  vec3 worldNormal = normalize(vNormal);\n  \n  // Calculate Fresnel effect\n  float fresnelFactor = fresnel(viewDirection, worldNormal, uFresnelPower);\n  \n  // Base glass color gradient\n  vec3 gradientColor = mix(uColor1, uColor2, vUv.y);\n  gradientColor = mix(gradientColor, uColor3, fresnelFactor);\n  \n  // Reflection\n  #ifdef ENVMAP_TYPE_CUBE\n  vec3 reflectionColor = textureCube(envMap, vReflect).rgb * envMapIntensity;\n  #else\n  vec3 reflectionColor = vec3(0.5);\n  #endif\n  \n  // Refraction with chromatic aberration\n  vec3 refractionColor;\n  #ifdef ENVMAP_TYPE_CUBE\n  if (uChromaticAberration > 0.0) {\n    refractionColor = chromaticRefraction(-viewDirection, worldNormal, uRefraction, uChromaticAberration);\n  } else {\n    refractionColor = textureCube(envMap, vRefract).rgb;\n  }\n  refractionColor *= envMapIntensity;\n  #else\n  refractionColor = vec3(0.3);\n  #endif\n  \n  // Mix reflection and refraction based on Fresnel\n  vec3 envColor = mix(refractionColor, reflectionColor, fresnelFactor * uReflectivity);\n  \n  // Combine with gradient color\n  vec3 finalColor = mix(gradientColor, envColor, 0.7);\n  \n  // Apply transparency\n  float finalAlpha = mix(uTransparency, 1.0, fresnelFactor * 0.5);\n  \n  // Set diffuse color for standard lighting\n  diffuseColor.rgb = finalColor;\n  diffuseColor.a = finalAlpha;\n  \n  // Skip transmission_fragment to avoid conflicts\n  \n  vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + \n                       reflectedLight.directSpecular + reflectedLight.indirectSpecular + \n                       totalEmissiveRadiance;\n  \n  // Add our glass color contribution\n  outgoingLight += finalColor * 0.8;\n  \n  gl_FragColor = vec4(outgoingLight, diffuseColor.a);\n  \n  #include <tonemapping_fragment>\n  #include <colorspace_fragment>\n  #include <fog_fragment>\n  #include <premultiplied_alpha_fragment>\n  #include <dithering_fragment>\n}\n";
    vertex_default11 = "// Glass Plane Vertex Shader - Refraction & Transparency Effects\n\n#define STANDARD\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n#ifdef USE_TANGENT\nvarying vec3 vTangent;\nvarying vec3 vBitangent;\n#endif\n#endif\n#include <clipping_planes_pars_vertex>\n#include <color_pars_vertex>\n#include <common>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <skinning_pars_vertex>\n#include <uv2_pars_vertex>\n#include <uv_pars_vertex>\n\nvarying vec2 vUv;\nvarying vec3 vPosition;\nvarying vec3 vNormal;\nvarying vec3 vGlassWorldPos;\nvarying vec3 vReflect;\nvarying vec3 vRefract;\n\nuniform float uTime;\nuniform float uSpeed;\nuniform float uWaveAmplitude;\nuniform float uWaveFrequency;\nuniform float uNoiseStrength;\nuniform float uDistortion;\n\n// Noise functions for glass distortion\nvec3 mod289(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289(vec4 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x) {\n  return mod289(((x * 34.0) + 1.0) * x);\n}\n\nvec4 taylorInvSqrt(vec4 r) {\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat snoise(vec3 v) {\n  const vec2 C = vec2(1.0 / 6.0, 1.0 / 3.0);\n  const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n  vec3 i = floor(v + dot(v, C.yyy));\n  vec3 x0 = v - i + dot(i, C.xxx);\n\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min(g.xyz, l.zxy);\n  vec3 i2 = max(g.xyz, l.zxy);\n\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy;\n  vec3 x3 = x0 - D.yyy;\n\n  i = mod289(i);\n  vec4 p = permute(permute(permute(\n    i.z + vec4(0.0, i1.z, i2.z, 1.0))\n    + i.y + vec4(0.0, i1.y, i2.y, 1.0))\n    + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n  float n_ = 0.142857142857;\n  vec3 ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_);\n\n  vec4 x = x_ * ns.x + ns.yyyy;\n  vec4 y = y_ * ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4(x.xy, y.xy);\n  vec4 b1 = vec4(x.zw, y.zw);\n\n  vec4 s0 = floor(b0) * 2.0 + 1.0;\n  vec4 s1 = floor(b1) * 2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw * sh.xxyy;\n  vec4 a1 = b1.xzyw + s1.xzyw * sh.zzww;\n\n  vec3 p0 = vec3(a0.xy, h.x);\n  vec3 p1 = vec3(a0.zw, h.y);\n  vec3 p2 = vec3(a1.xy, h.z);\n  vec3 p3 = vec3(a1.zw, h.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(p0, p0), dot(p1, p1), dot(p2, p2), dot(p3, p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n  vec4 m = max(0.6 - vec4(dot(x0, x0), dot(x1, x1), dot(x2, x2), dot(x3, x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot(m * m, vec4(dot(p0, x0), dot(p1, x1),\n    dot(p2, x2), dot(p3, x3)));\n}\n\nvoid main() {\n  #include <uv_pars_vertex>\n  #include <uv_vertex>\n  #include <uv2_pars_vertex>\n  #include <uv2_vertex>\n  #include <color_pars_vertex>\n  #include <color_vertex>\n  #include <morphcolor_vertex>\n  #include <beginnormal_vertex>\n  #include <morphnormal_vertex>\n  #include <skinbase_vertex>\n  #include <skinnormal_vertex>\n  #include <defaultnormal_vertex>\n  #include <normal_vertex>\n  \n  #ifndef FLAT_SHADED\n  vNormal = normalize(transformedNormal);\n  #ifdef USE_TANGENT\n  vTangent = normalize(transformedTangent);\n  vBitangent = normalize(cross(vNormal, vTangent) * tangent.w);\n  #endif\n  #endif\n  \n  #include <begin_vertex>\n  #include <morphtarget_vertex>\n  #include <skinning_vertex>\n  #include <displacementmap_vertex>\n  \n  // Pass UV coordinates\n  vUv = uv;\n\n  // Calculate time-based animation\n  float time = uTime * uSpeed;\n  \n  // Create subtle wave distortion for glass effect\n  float waveX = sin(position.x * uWaveFrequency + time) * uWaveAmplitude;\n  float waveY = cos(position.y * uWaveFrequency + time) * uWaveAmplitude;\n  float waveZ = sin(position.z * uWaveFrequency + time * 0.5) * uWaveAmplitude * 0.5;\n  \n  // Add noise for organic glass distortion\n  vec3 noisePos = position + vec3(time * 0.1);\n  float noise = snoise(noisePos * 0.5) * uNoiseStrength;\n  \n  // Apply distortion to transformed position\n  transformed += vec3(waveX, waveY, waveZ) * uDistortion + normal * noise;\n  \n  #include <project_vertex>\n  #include <logdepthbuf_vertex>\n  #include <clipping_planes_vertex>\n  \n  vViewPosition = -mvPosition.xyz;\n  vPosition = transformed;\n  \n  // Calculate world position for refraction\n  vec4 worldPosition = modelMatrix * vec4(transformed, 1.0);\n  vGlassWorldPos = worldPosition.xyz;\n  \n  // Calculate reflection and refraction vectors\n  vec3 worldNormal = normalize(mat3(modelMatrix) * normal);\n  vec3 viewVector = normalize(cameraPosition - worldPosition.xyz);\n  \n  // Reflection vector\n  vReflect = reflect(-viewVector, worldNormal);\n  \n  // Refraction vector with index of refraction for glass (1.5)\n  float ior = 1.5;\n  vRefract = refract(-viewVector, worldNormal, 1.0 / ior);\n  \n  #include <fog_vertex>\n  #include <shadowmap_vertex>\n}\n";
  }
});

// ../shadergradient-v2/dist/chunk-IGOCR32Y.mjs
var sphere_exports4, fragment_default12, vertex_default12;
var init_chunk_IGOCR32Y = __esm({
  "../shadergradient-v2/dist/chunk-IGOCR32Y.mjs"() {
    init_chunk_5BEQP2BQ();
    sphere_exports4 = {};
    __export(sphere_exports4, {
      fragment: () => fragment_default12,
      vertex: () => vertex_default12
    });
    fragment_default12 = "// Glass Sphere Fragment Shader - Transparency & Refraction\n\n#define STANDARD\n#ifdef PHYSICAL\n#define REFLECTIVITY\n#define CLEARCOAT\n#define TRANSMISSION\n#endif\n\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n\n// transmission is already defined by Three.js when TRANSMISSION is enabled\n#ifdef REFLECTIVITY\nuniform float reflectivity;\n#endif\n#ifdef CLEARCOAT\nuniform float clearcoat;\nuniform float clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\nuniform vec3 sheen;\n#endif\n\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n#ifdef USE_TANGENT\nvarying vec3 vTangent;\nvarying vec3 vBitangent;\n#endif\n#endif\n\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <color_pars_fragment>\n#include <common>\n#include <dithering_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <map_pars_fragment>\n#include <packing>\n#include <uv2_pars_fragment>\n#include <uv_pars_fragment>\n#include <bsdfs>\n#include <bumpmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <clipping_planes_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <lights_physical_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <transmission_pars_fragment>\n\n// Custom uniforms for glass effect\nuniform float uTime;\nuniform vec3 uColor1;\nuniform vec3 uColor2;\nuniform vec3 uColor3;\nuniform float uTransparency;\nuniform float uRefraction;\nuniform float uChromaticAberration;\nuniform float uFresnelPower;\nuniform float uReflectivity;\n// envMap and envMapIntensity are provided by Three.js\n\nvarying vec2 vUv;\nvarying vec3 vPosition;\nvarying vec3 vNormal;\nvarying vec3 vGlassWorldPos;\nvarying vec3 vReflect;\nvarying vec3 vRefract;\nvarying float vDistortion;\n\n// Fresnel calculation\nfloat fresnel(vec3 viewDirection, vec3 normal, float power) {\n  return pow(1.0 - abs(dot(viewDirection, normal)), power);\n}\n\n// Chromatic aberration for refraction\nvec3 chromaticRefraction(vec3 viewDirection, vec3 normal, float ior, float chromaticStrength) {\n  vec3 refractedR = refract(viewDirection, normal, 1.0 / (ior - chromaticStrength));\n  vec3 refractedG = refract(viewDirection, normal, 1.0 / ior);\n  vec3 refractedB = refract(viewDirection, normal, 1.0 / (ior + chromaticStrength));\n  \n  #ifdef ENVMAP_TYPE_CUBE\n  return vec3(\n    textureCube(envMap, refractedR).r,\n    textureCube(envMap, refractedG).g,\n    textureCube(envMap, refractedB).b\n  );\n  #else\n  return vec3(0.5);\n  #endif\n}\n\n// Caustics simulation for sphere\nfloat caustics(vec3 position, float time) {\n  float c1 = sin(position.x * 4.0 + time) * sin(position.y * 4.0 + time * 0.8);\n  float c2 = sin(position.z * 3.0 - time * 1.2) * sin(position.x * 3.0 + time);\n  return (c1 + c2) * 0.5 + 0.5;\n}\n\nvoid main() {\n  #include <clipping_planes_fragment>\n  \n  vec4 diffuseColor = vec4(diffuse, opacity);\n  ReflectedLight reflectedLight = ReflectedLight(vec3(0.0), vec3(0.0), vec3(0.0), vec3(0.0));\n  vec3 totalEmissiveRadiance = emissive;\n  \n  #include <logdepthbuf_fragment>\n  #include <map_fragment>\n  #include <color_fragment>\n  #include <alphamap_fragment>\n  #include <alphatest_fragment>\n  #include <specularmap_fragment>\n  #include <roughnessmap_fragment>\n  #include <metalnessmap_fragment>\n  #include <normal_fragment_begin>\n  #include <normal_fragment_maps>\n  #include <clearcoat_normal_fragment_begin>\n  #include <clearcoat_normal_fragment_maps>\n  #include <emissivemap_fragment>\n  \n  // Glass-specific calculations\n  vec3 viewDirection = normalize(vViewPosition);\n  vec3 worldNormal = normalize(vNormal);\n  \n  // Calculate Fresnel effect\n  float fresnelFactor = fresnel(viewDirection, worldNormal, uFresnelPower);\n  \n  // For sphere, use spherical UV mapping for gradient\n  float sphericalU = atan(vPosition.z, vPosition.x) / (2.0 * PI) + 0.5;\n  float sphericalV = acos(vPosition.y / length(vPosition)) / PI;\n  vec2 sphericalUV = vec2(sphericalU, sphericalV);\n  \n  // Create color gradient based on spherical coordinates\n  vec3 gradientColor = mix(uColor1, uColor2, sphericalUV.y);\n  gradientColor = mix(gradientColor, uColor3, pow(fresnelFactor, 1.5));\n  \n  // Add caustics effect for sphere\n  float causticsValue = caustics(vGlassWorldPos, uTime);\n  gradientColor += vec3(causticsValue * 0.1);\n  \n  // Reflection\n  #ifdef ENVMAP_TYPE_CUBE\n  vec3 reflectionColor = textureCube(envMap, vReflect).rgb * envMapIntensity;\n  #else\n  vec3 reflectionColor = vec3(0.5);\n  #endif\n  \n  // Refraction with chromatic aberration (enhanced for sphere)\n  vec3 refractionColor;\n  #ifdef ENVMAP_TYPE_CUBE\n  if (uChromaticAberration > 0.0) {\n    float chromaticIntensity = uChromaticAberration * (1.0 + vDistortion * 0.5);\n    refractionColor = chromaticRefraction(-viewDirection, worldNormal, uRefraction, chromaticIntensity);\n  } else {\n    refractionColor = textureCube(envMap, vRefract).rgb;\n  }\n  refractionColor *= envMapIntensity;\n  #else\n  refractionColor = vec3(0.3);\n  #endif\n  \n  // Mix reflection and refraction based on Fresnel (stronger effect for sphere)\n  vec3 envColor = mix(refractionColor, reflectionColor, fresnelFactor * uReflectivity);\n  \n  // Add inner glow effect for sphere\n  float innerGlow = pow(1.0 - abs(dot(viewDirection, worldNormal)), 3.0);\n  vec3 glowColor = mix(uColor2, uColor3, innerGlow) * innerGlow * 0.5;\n  \n  // Combine all effects\n  vec3 finalColor = mix(gradientColor, envColor, 0.8) + glowColor;\n  \n  // Apply transparency with sphere thickness consideration\n  float thickness = 1.0 - pow(abs(dot(viewDirection, worldNormal)), 0.5);\n  float finalAlpha = mix(uTransparency * thickness, 1.0, fresnelFactor * 0.7);\n  \n  // Set diffuse color for standard lighting\n  diffuseColor.rgb = finalColor;\n  diffuseColor.a = finalAlpha;\n  \n  // Skip transmission_fragment to avoid conflicts\n  \n  vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + \n                       reflectedLight.directSpecular + reflectedLight.indirectSpecular + \n                       totalEmissiveRadiance;\n  \n  // Add our glass color contribution\n  outgoingLight += finalColor * 0.9;\n  \n  gl_FragColor = vec4(outgoingLight, diffuseColor.a);\n  \n  #include <tonemapping_fragment>\n  #include <colorspace_fragment>\n  #include <fog_fragment>\n  #include <premultiplied_alpha_fragment>\n  #include <dithering_fragment>\n}\n";
    vertex_default12 = "// Glass Sphere Vertex Shader - Refraction & Transparency Effects\n\n#define STANDARD\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n#ifdef USE_TANGENT\nvarying vec3 vTangent;\nvarying vec3 vBitangent;\n#endif\n#endif\n#include <clipping_planes_pars_vertex>\n#include <color_pars_vertex>\n#include <common>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <skinning_pars_vertex>\n#include <uv2_pars_vertex>\n#include <uv_pars_vertex>\n\nvarying vec2 vUv;\nvarying vec3 vPosition;\nvarying vec3 vNormal;\nvarying vec3 vGlassWorldPos;\nvarying vec3 vReflect;\nvarying vec3 vRefract;\nvarying float vDistortion;\n\nuniform float uTime;\nuniform float uSpeed;\nuniform float uWaveAmplitude;\nuniform float uWaveFrequency;\nuniform float uNoiseStrength;\nuniform float uDistortion;\n\n// Noise functions for glass distortion\nvec3 mod289(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289(vec4 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x) {\n  return mod289(((x * 34.0) + 1.0) * x);\n}\n\nvec4 taylorInvSqrt(vec4 r) {\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat snoise(vec3 v) {\n  const vec2 C = vec2(1.0 / 6.0, 1.0 / 3.0);\n  const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n  vec3 i = floor(v + dot(v, C.yyy));\n  vec3 x0 = v - i + dot(i, C.xxx);\n\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min(g.xyz, l.zxy);\n  vec3 i2 = max(g.xyz, l.zxy);\n\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy;\n  vec3 x3 = x0 - D.yyy;\n\n  i = mod289(i);\n  vec4 p = permute(permute(permute(\n    i.z + vec4(0.0, i1.z, i2.z, 1.0))\n    + i.y + vec4(0.0, i1.y, i2.y, 1.0))\n    + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n  float n_ = 0.142857142857;\n  vec3 ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_);\n\n  vec4 x = x_ * ns.x + ns.yyyy;\n  vec4 y = y_ * ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4(x.xy, y.xy);\n  vec4 b1 = vec4(x.zw, y.zw);\n\n  vec4 s0 = floor(b0) * 2.0 + 1.0;\n  vec4 s1 = floor(b1) * 2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw * sh.xxyy;\n  vec4 a1 = b1.xzyw + s1.xzyw * sh.zzww;\n\n  vec3 p0 = vec3(a0.xy, h.x);\n  vec3 p1 = vec3(a0.zw, h.y);\n  vec3 p2 = vec3(a1.xy, h.z);\n  vec3 p3 = vec3(a1.zw, h.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(p0, p0), dot(p1, p1), dot(p2, p2), dot(p3, p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n  vec4 m = max(0.6 - vec4(dot(x0, x0), dot(x1, x1), dot(x2, x2), dot(x3, x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot(m * m, vec4(dot(p0, x0), dot(p1, x1),\n    dot(p2, x2), dot(p3, x3)));\n}\n\nvoid main() {\n  #include <uv_pars_vertex>\n  #include <uv_vertex>\n  #include <uv2_pars_vertex>\n  #include <uv2_vertex>\n  #include <color_pars_vertex>\n  #include <color_vertex>\n  #include <morphcolor_vertex>\n  #include <beginnormal_vertex>\n  #include <morphnormal_vertex>\n  #include <skinbase_vertex>\n  #include <skinnormal_vertex>\n  #include <defaultnormal_vertex>\n  #include <normal_vertex>\n  \n  #ifndef FLAT_SHADED\n  vNormal = normalize(transformedNormal);\n  #ifdef USE_TANGENT\n  vTangent = normalize(transformedTangent);\n  vBitangent = normalize(cross(vNormal, vTangent) * tangent.w);\n  #endif\n  #endif\n  \n  #include <begin_vertex>\n  #include <morphtarget_vertex>\n  #include <skinning_vertex>\n  #include <displacementmap_vertex>\n  \n  // Pass UV coordinates\n  vUv = uv;\n\n  // Calculate time-based animation\n  float time = uTime * uSpeed;\n  \n  // For sphere, use spherical coordinates for better distortion\n  float theta = atan(position.z, position.x);\n  float phi = acos(position.y / length(position));\n  \n  // Create waves based on spherical coordinates\n  float waveTheta = sin(theta * uWaveFrequency * 2.0 + time) * uWaveAmplitude;\n  float wavePhi = cos(phi * uWaveFrequency + time * 1.5) * uWaveAmplitude;\n  \n  // Add noise for organic glass distortion\n  vec3 noisePos = position + vec3(time * 0.1);\n  float noise = snoise(noisePos * 0.8) * uNoiseStrength;\n  \n  // Calculate distortion based on position on sphere\n  float distortionAmount = (waveTheta + wavePhi) * uDistortion + noise;\n  vDistortion = distortionAmount;\n  \n  // Apply distortion along normal for sphere\n  transformed += normal * distortionAmount;\n  \n  #include <project_vertex>\n  #include <logdepthbuf_vertex>\n  #include <clipping_planes_vertex>\n  \n  vViewPosition = -mvPosition.xyz;\n  vPosition = transformed;\n  \n  // Calculate world position for refraction\n  vec4 worldPosition = modelMatrix * vec4(transformed, 1.0);\n  vGlassWorldPos = worldPosition.xyz;\n  \n  // Calculate reflection and refraction vectors\n  vec3 worldNormal = normalize(mat3(modelMatrix) * normal);\n  vec3 viewVector = normalize(cameraPosition - worldPosition.xyz);\n  \n  // Reflection vector\n  vReflect = reflect(-viewVector, worldNormal);\n  \n  // Refraction vector with index of refraction for glass (1.5)\n  // For sphere, adjust IOR based on curvature\n  float ior = 1.5 + sin(theta * 2.0 + time) * 0.1;\n  vRefract = refract(-viewVector, worldNormal, 1.0 / ior);\n  \n  #include <fog_vertex>\n  #include <shadowmap_vertex>\n}\n";
  }
});

// ../shadergradient-v2/dist/chunk-XILNFAQ3.mjs
var glass_exports;
var init_chunk_XILNFAQ3 = __esm({
  "../shadergradient-v2/dist/chunk-XILNFAQ3.mjs"() {
    init_chunk_4DHS567T();
    init_chunk_73SSHDUK();
    init_chunk_IGOCR32Y();
    init_chunk_5BEQP2BQ();
    glass_exports = {};
    __export(glass_exports, {
      plane: () => plane_exports4,
      sphere: () => sphere_exports4,
      waterPlane: () => waterPlane_exports4
    });
  }
});

// ../shadergradient-v2/dist/chunk-NXCPH64Q.mjs
var shaders_exports;
var init_chunk_NXCPH64Q = __esm({
  "../shadergradient-v2/dist/chunk-NXCPH64Q.mjs"() {
    init_chunk_H2RSKIPT();
    init_chunk_GLLM6F27();
    init_chunk_4GZNORIL();
    init_chunk_XILNFAQ3();
    init_chunk_5BEQP2BQ();
    shaders_exports = {};
    __export(shaders_exports, {
      cosmic: () => cosmic_exports,
      defaults: () => defaults_exports,
      glass: () => glass_exports,
      positionMix: () => positionMix_exports
    });
  }
});

// ../shadergradient-v2/dist/chunk-QRRZJ6IM.mjs
var debugState, debug;
var init_chunk_QRRZJ6IM = __esm({
  "../shadergradient-v2/dist/chunk-QRRZJ6IM.mjs"() {
    debugState = {
      performance: false,
      render: true
    };
    debug = {
      enable: (category) => {
        debugState[category] = true;
      },
      disable: (category) => {
        debugState[category] = false;
      },
      enableAll: () => {
        Object.keys(debugState).forEach((key) => {
          debugState[key] = true;
        });
      },
      disableAll: () => {
        Object.keys(debugState).forEach((key) => {
          debugState[key] = false;
        });
      },
      performance: (...args) => {
        if (debugState.performance) {
          console.log("[Performance]", ...args);
        }
      },
      render: (...args) => {
        if (debugState.render) {
          console.log("[Render]", ...args);
        }
      }
    };
    if (typeof window !== "undefined") {
      window.debug = debug;
    }
  }
});

// ../shadergradient-v2/dist/chunk-WNGYPXFW.mjs
function dToR(d) {
  return d / 180 * Math.PI;
}
function dToRArr(degrees) {
  return degrees.map((d) => dToR(d));
}
function formatUrlString(urlString) {
  return urlString.replace("http://localhost:3001/customize", "").replace("https://shadergradient.co/customize", "").replace("https://www.shadergradient.co/customize", "");
}
function formatFramerProps(_a3) {
  var _b2 = _a3, {
    position,
    rotation,
    cameraAngle,
    noise
  } = _b2, rest = __objRest(_b2, [
    "position",
    "rotation",
    "cameraAngle",
    "noise"
  ]);
  const { positionX, positionY, positionZ } = position;
  const { rotationX, rotationY, rotationZ } = rotation;
  const { cAzimuthAngle, cPolarAngle } = cameraAngle;
  const { uDensity, uStrength } = noise;
  return __spreadValues({
    positionX,
    positionY,
    positionZ,
    rotationX,
    rotationY,
    rotationZ,
    cAzimuthAngle,
    cPolarAngle,
    uDensity,
    uStrength
  }, rest);
}
var init_chunk_WNGYPXFW = __esm({
  "../shadergradient-v2/dist/chunk-WNGYPXFW.mjs"() {
    init_chunk_5BEQP2BQ();
  }
});

// ../shadergradient-v2/dist/chunk-R4OX5Y2X.mjs
import { jsx as jsx4, jsxs as jsxs2 } from "react/jsx-runtime";
function Mesh2({
  animate,
  range,
  rangeStart,
  rangeEnd,
  loop,
  loopDuration,
  positionX,
  positionY,
  positionZ,
  rotationX,
  rotationY,
  rotationZ,
  type,
  color1,
  color2,
  color3,
  reflection,
  uTime,
  uSpeed,
  uDensity,
  uStrength,
  uFrequency,
  uAmplitude,
  shader
}) {
  const { vertex: vertex2, fragment: fragment2 } = shaders_exports[shader][type];
  const baseUniforms = {
    colors: [color1, color2, color3],
    uTime,
    uSpeed,
    uLoadingTime: 1,
    // no loading animation
    uNoiseDensity: uDensity,
    uNoiseStrength: uStrength,
    uFrequency,
    uAmplitude,
    uIntensity: 0.5,
    uLoop: loop === "on" ? 1 : 0,
    uLoopDuration: loopDuration || 5
  };
  const glassUniforms = shader === "glass" ? {
    uColor1: colorToRgb(color1),
    uColor2: colorToRgb(color2),
    uColor3: colorToRgb(color3),
    uTransparency: 0.1,
    uRefraction: 1.5,
    uChromaticAberration: 0.1,
    uFresnelPower: 2,
    uReflectivity: 0.9,
    uWaveAmplitude: 0.02,
    uWaveFrequency: 5,
    uDistortion: 0.1,
    uFlowSpeed: 0.1,
    uFlowDirection: { x: 1, y: 0.5 },
    uLiquidEffect: 0.5,
    uFoamIntensity: 0.3,
    envMapIntensity: 1
  } : {};
  const uniforms = __spreadValues(__spreadValues({}, baseUniforms), glassUniforms);
  return /* @__PURE__ */ jsxs2(
    "mesh",
    {
      name: "shadergradient-mesh",
      position: [positionX, positionY, positionZ],
      rotation: dToRArr([rotationX, rotationY, rotationZ]),
      children: [
        /* @__PURE__ */ jsx4(Geometry, { type }),
        /* @__PURE__ */ jsx4(
          Materials,
          {
            animate,
            range,
            rangeStart,
            rangeEnd,
            loop,
            loopDuration,
            reflection,
            shader,
            uniforms,
            vertexShader: vertex2,
            fragmentShader: fragment2,
            onInit: (material) => {
              debug.performance("material (onInit)", material);
            }
          }
        )
      ]
    }
  );
}
var init_chunk_R4OX5Y2X = __esm({
  "../shadergradient-v2/dist/chunk-R4OX5Y2X.mjs"() {
    init_chunk_WBM42ICI();
    init_chunk_V62OMFTZ();
    init_chunk_NXCPH64Q();
    init_chunk_QRRZJ6IM();
    init_chunk_WNGYPXFW();
    init_chunk_BI5IV7LU();
    init_chunk_5BEQP2BQ();
  }
});

// ../shadergradient-v2/dist/chunk-USQFKVUW.mjs
var CopyShader;
var init_chunk_USQFKVUW = __esm({
  "../shadergradient-v2/dist/chunk-USQFKVUW.mjs"() {
    CopyShader = {
      uniforms: {
        tDiffuse: { value: null },
        opacity: { value: 1 }
      },
      vertexShader: (
        /* glsl */
        `

		varying vec2 vUv;

		void main() {

			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`
      ),
      fragmentShader: (
        /* glsl */
        `

		uniform float opacity;

		uniform sampler2D tDiffuse;

		varying vec2 vUv;

		void main() {

			vec4 texel = texture2D( tDiffuse, vUv );
			gl_FragColor = opacity * texel;

		}`
      )
    };
  }
});

// ../shadergradient-v2/dist/chunk-AU32OSCX.mjs
var Pass, _camera2, _geometry2, FullScreenQuad;
var init_chunk_AU32OSCX = __esm({
  "../shadergradient-v2/dist/chunk-AU32OSCX.mjs"() {
    init_chunk_BT6X4JN2();
    Pass = class {
      constructor() {
        this.enabled = true;
        this.needsSwap = true;
        this.clear = false;
        this.renderToScreen = false;
      }
      setSize() {
      }
      render() {
        console.error("THREE.Pass: .render() must be implemented in derived pass.");
      }
    };
    _camera2 = new OrthographicCamera(-1, 1, 1, -1, 0, 1);
    _geometry2 = new BufferGeometry();
    _geometry2.setAttribute(
      "position",
      new Float32BufferAttribute([-1, 3, 0, -1, -1, 0, 3, -1, 0], 3)
    );
    _geometry2.setAttribute("uv", new Float32BufferAttribute([0, 2, 0, 0, 2, 0], 2));
    FullScreenQuad = class {
      constructor(material) {
        this._mesh = new Mesh(_geometry2, material);
      }
      dispose() {
        this._mesh.geometry.dispose();
      }
      render(renderer) {
        renderer.render(this._mesh, _camera2);
      }
      get material() {
        return this._mesh.material;
      }
      set material(value) {
        this._mesh.material = value;
      }
    };
  }
});

// ../shadergradient-v2/dist/chunk-KXZH64OP.mjs
var MaskPass, ClearMaskPass;
var init_chunk_KXZH64OP = __esm({
  "../shadergradient-v2/dist/chunk-KXZH64OP.mjs"() {
    init_chunk_AU32OSCX();
    MaskPass = class extends Pass {
      constructor(scene, camera) {
        super();
        this.scene = scene;
        this.camera = camera;
        this.clear = true;
        this.needsSwap = false;
        this.inverse = false;
      }
      render(renderer, writeBuffer, readBuffer) {
        const context2 = renderer.getContext();
        const state = renderer.state;
        state.buffers.color.setMask(false);
        state.buffers.depth.setMask(false);
        state.buffers.color.setLocked(true);
        state.buffers.depth.setLocked(true);
        let writeValue, clearValue;
        if (this.inverse) {
          writeValue = 0;
          clearValue = 1;
        } else {
          writeValue = 1;
          clearValue = 0;
        }
        state.buffers.stencil.setTest(true);
        state.buffers.stencil.setOp(
          context2.REPLACE,
          context2.REPLACE,
          context2.REPLACE
        );
        state.buffers.stencil.setFunc(context2.ALWAYS, writeValue, 4294967295);
        state.buffers.stencil.setClear(clearValue);
        state.buffers.stencil.setLocked(true);
        renderer.setRenderTarget(readBuffer);
        if (this.clear) renderer.clear();
        renderer.render(this.scene, this.camera);
        renderer.setRenderTarget(writeBuffer);
        if (this.clear) renderer.clear();
        renderer.render(this.scene, this.camera);
        state.buffers.color.setLocked(false);
        state.buffers.depth.setLocked(false);
        state.buffers.stencil.setLocked(false);
        state.buffers.stencil.setFunc(context2.EQUAL, 1, 4294967295);
        state.buffers.stencil.setOp(context2.KEEP, context2.KEEP, context2.KEEP);
        state.buffers.stencil.setLocked(true);
      }
    };
    ClearMaskPass = class extends Pass {
      constructor() {
        super();
        this.needsSwap = false;
      }
      render(renderer) {
        renderer.state.buffers.stencil.setLocked(false);
        renderer.state.buffers.stencil.setTest(false);
      }
    };
  }
});

// ../shadergradient-v2/dist/chunk-EW3CJI4E.mjs
var ShaderPass;
var init_chunk_EW3CJI4E = __esm({
  "../shadergradient-v2/dist/chunk-EW3CJI4E.mjs"() {
    init_chunk_AU32OSCX();
    init_chunk_BT6X4JN2();
    ShaderPass = class extends Pass {
      constructor(shader, textureID) {
        super();
        this.textureID = textureID !== void 0 ? textureID : "tDiffuse";
        if (shader instanceof ShaderMaterial) {
          this.uniforms = shader.uniforms;
          this.material = shader;
        } else if (shader) {
          this.uniforms = UniformsUtils.clone(shader.uniforms);
          this.material = new ShaderMaterial({
            defines: Object.assign({}, shader.defines),
            uniforms: this.uniforms,
            vertexShader: shader.vertexShader,
            fragmentShader: shader.fragmentShader
          });
        }
        this.fsQuad = new FullScreenQuad(this.material);
      }
      render(renderer, writeBuffer, readBuffer) {
        if (this.uniforms[this.textureID]) {
          this.uniforms[this.textureID].value = readBuffer.texture;
        }
        this.fsQuad.material = this.material;
        if (this.renderToScreen) {
          renderer.setRenderTarget(null);
          this.fsQuad.render(renderer);
        } else {
          renderer.setRenderTarget(writeBuffer);
          if (this.clear)
            renderer.clear(
              renderer.autoClearColor,
              renderer.autoClearDepth,
              renderer.autoClearStencil
            );
          this.fsQuad.render(renderer);
        }
      }
    };
  }
});

// ../shadergradient-v2/dist/chunk-FVJI5A2G.mjs
var EffectComposer, _camera3, _geometry3;
var init_chunk_FVJI5A2G = __esm({
  "../shadergradient-v2/dist/chunk-FVJI5A2G.mjs"() {
    init_chunk_USQFKVUW();
    init_chunk_KXZH64OP();
    init_chunk_EW3CJI4E();
    init_chunk_BT6X4JN2();
    EffectComposer = class {
      constructor(renderer, renderTarget) {
        this.renderer = renderer;
        if (renderTarget === void 0) {
          const parameters = {
            minFilter: LinearFilter,
            magFilter: LinearFilter,
            format: RGBAFormat
          };
          const size = renderer.getSize(new Vector2());
          this._pixelRatio = renderer.getPixelRatio();
          this._width = size.width;
          this._height = size.height;
          renderTarget = new WebGLRenderTarget(
            this._width * this._pixelRatio,
            this._height * this._pixelRatio,
            parameters
          );
          renderTarget.texture.name = "EffectComposer.rt1";
        } else {
          this._pixelRatio = 1;
          this._width = renderTarget.width;
          this._height = renderTarget.height;
        }
        this.renderTarget1 = renderTarget;
        this.renderTarget2 = renderTarget.clone();
        this.renderTarget2.texture.name = "EffectComposer.rt2";
        this.writeBuffer = this.renderTarget1;
        this.readBuffer = this.renderTarget2;
        this.renderToScreen = true;
        this.passes = [];
        if (CopyShader === void 0) {
          console.error("THREE.EffectComposer relies on CopyShader");
        }
        if (ShaderPass === void 0) {
          console.error("THREE.EffectComposer relies on ShaderPass");
        }
        this.copyPass = new ShaderPass(CopyShader);
        this.clock = new Clock();
      }
      swapBuffers() {
        const tmp2 = this.readBuffer;
        this.readBuffer = this.writeBuffer;
        this.writeBuffer = tmp2;
      }
      addPass(pass) {
        this.passes.push(pass);
        pass.setSize(
          this._width * this._pixelRatio,
          this._height * this._pixelRatio
        );
      }
      insertPass(pass, index) {
        this.passes.splice(index, 0, pass);
        pass.setSize(
          this._width * this._pixelRatio,
          this._height * this._pixelRatio
        );
      }
      removePass(pass) {
        const index = this.passes.indexOf(pass);
        if (index !== -1) {
          this.passes.splice(index, 1);
        }
      }
      isLastEnabledPass(passIndex) {
        for (let i2 = passIndex + 1; i2 < this.passes.length; i2++) {
          if (this.passes[i2].enabled) {
            return false;
          }
        }
        return true;
      }
      render(deltaTime) {
        if (deltaTime === void 0) {
          deltaTime = this.clock.getDelta();
        }
        const currentRenderTarget = this.renderer.getRenderTarget();
        let maskActive = false;
        for (let i2 = 0, il = this.passes.length; i2 < il; i2++) {
          const pass = this.passes[i2];
          if (pass.enabled === false) continue;
          pass.renderToScreen = this.renderToScreen && this.isLastEnabledPass(i2);
          pass.render(
            this.renderer,
            this.writeBuffer,
            this.readBuffer,
            deltaTime,
            maskActive
          );
          if (pass.needsSwap) {
            if (maskActive) {
              const context2 = this.renderer.getContext();
              const stencil = this.renderer.state.buffers.stencil;
              stencil.setFunc(context2.NOTEQUAL, 1, 4294967295);
              this.copyPass.render(
                this.renderer,
                this.writeBuffer,
                this.readBuffer,
                deltaTime
              );
              stencil.setFunc(context2.EQUAL, 1, 4294967295);
            }
            this.swapBuffers();
          }
          if (MaskPass !== void 0) {
            if (pass instanceof MaskPass) {
              maskActive = true;
            } else if (pass instanceof ClearMaskPass) {
              maskActive = false;
            }
          }
        }
        this.renderer.setRenderTarget(currentRenderTarget);
      }
      reset(renderTarget) {
        if (renderTarget === void 0) {
          const size = this.renderer.getSize(new Vector2());
          this._pixelRatio = this.renderer.getPixelRatio();
          this._width = size.width;
          this._height = size.height;
          renderTarget = this.renderTarget1.clone();
          renderTarget.setSize(
            this._width * this._pixelRatio,
            this._height * this._pixelRatio
          );
        }
        this.renderTarget1.dispose();
        this.renderTarget2.dispose();
        this.renderTarget1 = renderTarget;
        this.renderTarget2 = renderTarget.clone();
        this.writeBuffer = this.renderTarget1;
        this.readBuffer = this.renderTarget2;
      }
      setSize(width, height) {
        this._width = width;
        this._height = height;
        const effectiveWidth = this._width * this._pixelRatio;
        const effectiveHeight = this._height * this._pixelRatio;
        this.renderTarget1.setSize(effectiveWidth, effectiveHeight);
        this.renderTarget2.setSize(effectiveWidth, effectiveHeight);
        for (let i2 = 0; i2 < this.passes.length; i2++) {
          this.passes[i2].setSize(effectiveWidth, effectiveHeight);
        }
      }
      setPixelRatio(pixelRatio) {
        this._pixelRatio = pixelRatio;
        this.setSize(this._width, this._height);
      }
    };
    _camera3 = new OrthographicCamera(-1, 1, 1, -1, 0, 1);
    _geometry3 = new BufferGeometry();
    _geometry3.setAttribute(
      "position",
      new Float32BufferAttribute([-1, 3, 0, -1, -1, 0, 3, -1, 0], 3)
    );
    _geometry3.setAttribute("uv", new Float32BufferAttribute([0, 2, 0, 0, 2, 0], 2));
  }
});

// ../shadergradient-v2/dist/chunk-OJ2FJ367.mjs
var RenderPass;
var init_chunk_OJ2FJ367 = __esm({
  "../shadergradient-v2/dist/chunk-OJ2FJ367.mjs"() {
    init_chunk_AU32OSCX();
    init_chunk_BT6X4JN2();
    RenderPass = class extends Pass {
      constructor(scene, camera, overrideMaterial, clearColor, clearAlpha) {
        super();
        this.scene = scene;
        this.camera = camera;
        this.overrideMaterial = overrideMaterial;
        this.clearColor = clearColor;
        this.clearAlpha = clearAlpha !== void 0 ? clearAlpha : 0;
        this.clear = true;
        this.clearDepth = false;
        this.needsSwap = false;
        this._oldClearColor = new Color();
      }
      render(renderer, writeBuffer, readBuffer) {
        const oldAutoClear = renderer.autoClear;
        renderer.autoClear = false;
        let oldClearAlpha, oldOverrideMaterial;
        if (this.overrideMaterial !== void 0) {
          oldOverrideMaterial = this.scene.overrideMaterial;
          this.scene.overrideMaterial = this.overrideMaterial;
        }
        if (this.clearColor) {
          renderer.getClearColor(this._oldClearColor);
          oldClearAlpha = renderer.getClearAlpha();
          renderer.setClearColor(this.clearColor, this.clearAlpha);
        }
        if (this.clearDepth) {
          renderer.clearDepth();
        }
        renderer.setRenderTarget(this.renderToScreen ? null : readBuffer);
        if (this.clear)
          renderer.clear(
            renderer.autoClearColor,
            renderer.autoClearDepth,
            renderer.autoClearStencil
          );
        renderer.render(this.scene, this.camera);
        if (this.clearColor) {
          renderer.setClearColor(this._oldClearColor, oldClearAlpha);
        }
        if (this.overrideMaterial !== void 0) {
          this.scene.overrideMaterial = oldOverrideMaterial;
        }
        renderer.autoClear = oldAutoClear;
      }
    };
  }
});

// ../shadergradient-v2/dist/chunk-4NRCS6EB.mjs
var BlendFunction;
var init_chunk_4NRCS6EB = __esm({
  "../shadergradient-v2/dist/chunk-4NRCS6EB.mjs"() {
    BlendFunction = {
      SKIP: 0,
      ADD: 1,
      ALPHA: 2,
      AVERAGE: 3,
      COLOR_BURN: 4,
      COLOR_DODGE: 5,
      DARKEN: 6,
      DIFFERENCE: 7,
      EXCLUSION: 8,
      LIGHTEN: 9,
      MULTIPLY: 10,
      DIVIDE: 11,
      NEGATION: 12,
      NORMAL: 13,
      OVERLAY: 14,
      REFLECT: 15,
      SCREEN: 16,
      SOFT_LIGHT: 17,
      SUBTRACT: 18
    };
  }
});

// ../shadergradient-v2/dist/chunk-OUMQVT4Y.mjs
var shader_default, shader_default2, shader_default3, shader_default4, shader_default5, shader_default6, shader_default7, shader_default8, shader_default9, shader_default10, shader_default11, shader_default12, shader_default13, shader_default14, shader_default15, shader_default16, shader_default17, shader_default18, blendFunctions, BlendMode;
var init_chunk_OUMQVT4Y = __esm({
  "../shadergradient-v2/dist/chunk-OUMQVT4Y.mjs"() {
    init_chunk_4NRCS6EB();
    init_chunk_BT6X4JN2();
    shader_default = "vec4 blend(const in vec4 x, const in vec4 y, const in float opacity) {\n\n	return min(x + y, 1.0) * opacity + x * (1.0 - opacity);\n\n}\n";
    shader_default2 = "vec3 blend(const in vec3 x, const in vec3 y, const in float opacity) {\n\n	return y * opacity + x * (1.0 - opacity);\n\n}\n\nvec4 blend(const in vec4 x, const in vec4 y, const in float opacity) {\n\n	float a = min(y.a, opacity);\n\n	return vec4(blend(x.rgb, y.rgb, a), max(x.a, a));\n\n}\n";
    shader_default3 = "vec4 blend(const in vec4 x, const in vec4 y, const in float opacity) {\n\n	return (x + y) * 0.5 * opacity + x * (1.0 - opacity);\n\n}\n";
    shader_default4 = "float blend(const in float x, const in float y) {\n\n	return (y == 0.0) ? y : max(1.0 - (1.0 - x) / y, 0.0);\n\n}\n\nvec4 blend(const in vec4 x, const in vec4 y, const in float opacity) {\n\n	vec4 z = vec4(\n		blend(x.r, y.r),\n		blend(x.g, y.g),\n		blend(x.b, y.b),\n		blend(x.a, y.a)\n	);\n\n	return z * opacity + x * (1.0 - opacity);\n\n}\n";
    shader_default5 = "float blend(const in float x, const in float y) {\n\n	return (y == 1.0) ? y : min(x / (1.0 - y), 1.0);\n\n}\n\nvec4 blend(const in vec4 x, const in vec4 y, const in float opacity) {\n\n	vec4 z = vec4(\n		blend(x.r, y.r),\n		blend(x.g, y.g),\n		blend(x.b, y.b),\n		blend(x.a, y.a)\n	);\n\n	return z * opacity + x * (1.0 - opacity);\n\n}\n";
    shader_default6 = "vec4 blend(const in vec4 x, const in vec4 y, const in float opacity) {\n\n	return min(x, y) * opacity + x * (1.0 - opacity);\n\n}\n";
    shader_default7 = "vec4 blend(const in vec4 x, const in vec4 y, const in float opacity) {\n\n	return abs(x - y) * opacity + x * (1.0 - opacity);\n\n}\n";
    shader_default8 = "float blend(const in float x, const in float y) {\n\n	return (y > 0.0) ? min(x / y, 1.0) : 1.0;\n\n}\n\nvec4 blend(const in vec4 x, const in vec4 y, const in float opacity) {\n\n	vec4 z = vec4(\n		blend(x.r, y.r),\n		blend(x.g, y.g),\n		blend(x.b, y.b),\n		blend(x.a, y.a)\n	);\n\n	return z * opacity + x * (1.0 - opacity);\n\n}\n";
    shader_default9 = "vec4 blend(const in vec4 x, const in vec4 y, const in float opacity) {\n\n	return (x + y - 2.0 * x * y) * opacity + x * (1.0 - opacity);\n\n}\n";
    shader_default10 = "vec4 blend(const in vec4 x, const in vec4 y, const in float opacity) {\n\n	return max(x, y) * opacity + x * (1.0 - opacity);\n\n}\n";
    shader_default11 = "vec4 blend(const in vec4 x, const in vec4 y, const in float opacity) {\n\n	return x * y * opacity + x * (1.0 - opacity);\n\n}\n";
    shader_default12 = "vec4 blend(const in vec4 x, const in vec4 y, const in float opacity) {\n\n	return (1.0 - abs(1.0 - x - y)) * opacity + x * (1.0 - opacity);\n\n}\n";
    shader_default13 = "vec4 blend(const in vec4 x, const in vec4 y, const in float opacity) {\n\n	return y * opacity + x * (1.0 - opacity);\n\n}\n";
    shader_default14 = "float blend(const in float x, const in float y) {\n\n	return (x < 0.5) ? (2.0 * x * y) : (1.0 - 2.0 * (1.0 - x) * (1.0 - y));\n\n}\n\nvec4 blend(const in vec4 x, const in vec4 y, const in float opacity) {\n\n	vec4 z = vec4(\n		blend(x.r, y.r),\n		blend(x.g, y.g),\n		blend(x.b, y.b),\n		blend(x.a, y.a)\n	);\n\n	return z * opacity + x * (1.0 - opacity);\n\n}\n";
    shader_default15 = "float blend(const in float x, const in float y) {\n\n	return (y == 1.0) ? y : min(x * x / (1.0 - y), 1.0);\n\n}\n\nvec4 blend(const in vec4 x, const in vec4 y, const in float opacity) {\n\n	vec4 z = vec4(\n		blend(x.r, y.r),\n		blend(x.g, y.g),\n		blend(x.b, y.b),\n		blend(x.a, y.a)\n	);\n\n	return z * opacity + x * (1.0 - opacity);\n\n}\n";
    shader_default16 = "vec4 blend(const in vec4 x, const in vec4 y, const in float opacity) {\n\n	return (1.0 - (1.0 - x) * (1.0 - y)) * opacity + x * (1.0 - opacity);\n\n}\n";
    shader_default17 = "float blend(const in float x, const in float y) {\n\n	return (y < 0.5) ?\n		(2.0 * x * y + x * x * (1.0 - 2.0 * y)) :\n		(sqrt(x) * (2.0 * y - 1.0) + 2.0 * x * (1.0 - y));\n\n}\n\nvec4 blend(const in vec4 x, const in vec4 y, const in float opacity) {\n\n	vec4 z = vec4(\n		blend(x.r, y.r),\n		blend(x.g, y.g),\n		blend(x.b, y.b),\n		blend(x.a, y.a)\n	);\n\n	return z * opacity + x * (1.0 - opacity);\n\n}\n";
    shader_default18 = "vec4 blend(const in vec4 x, const in vec4 y, const in float opacity) {\n\n	return max(x + y - 1.0, 0.0) * opacity + x * (1.0 - opacity);\n\n}\n";
    blendFunctions = /* @__PURE__ */ new Map([
      [BlendFunction.SKIP, null],
      [BlendFunction.ADD, shader_default],
      [BlendFunction.ALPHA, shader_default2],
      [BlendFunction.AVERAGE, shader_default3],
      [BlendFunction.COLOR_BURN, shader_default4],
      [BlendFunction.COLOR_DODGE, shader_default5],
      [BlendFunction.DARKEN, shader_default6],
      [BlendFunction.DIFFERENCE, shader_default7],
      [BlendFunction.EXCLUSION, shader_default9],
      [BlendFunction.LIGHTEN, shader_default10],
      [BlendFunction.MULTIPLY, shader_default11],
      [BlendFunction.DIVIDE, shader_default8],
      [BlendFunction.NEGATION, shader_default12],
      [BlendFunction.NORMAL, shader_default13],
      [BlendFunction.OVERLAY, shader_default14],
      [BlendFunction.REFLECT, shader_default15],
      [BlendFunction.SCREEN, shader_default16],
      [BlendFunction.SOFT_LIGHT, shader_default17],
      [BlendFunction.SUBTRACT, shader_default18]
    ]);
    BlendMode = class extends EventDispatcher {
      /**
       * Constructs a new blend mode.
       *
       * @param {BlendFunction} blendFunction - The blend function to use.
       * @param {Number} opacity - The opacity of the color that will be blended with the base color.
       */
      constructor(blendFunction, opacity = 1) {
        super();
        this.blendFunction = blendFunction;
        this.opacity = new Uniform(opacity);
      }
      /**
       * Returns the blend function.
       *
       * @return {BlendFunction} The blend function.
       */
      getBlendFunction() {
        return this.blendFunction;
      }
      /**
       * Sets the blend function.
       *
       * @param {BlendFunction} blendFunction - The blend function.
       */
      setBlendFunction(blendFunction) {
        this.blendFunction = blendFunction;
        this.dispatchEvent({ type: "change" });
      }
      /**
       * Returns the blend function shader code.
       *
       * @return {String} The blend function shader code.
       */
      getShaderCode() {
        return blendFunctions.get(this.blendFunction);
      }
    };
  }
});

// ../shadergradient-v2/dist/chunk-3U6A2N6D.mjs
var HalftoneShader;
var init_chunk_3U6A2N6D = __esm({
  "../shadergradient-v2/dist/chunk-3U6A2N6D.mjs"() {
    HalftoneShader = {
      uniforms: {
        tDiffuse: { value: null },
        shape: { value: 1 },
        radius: { value: 2 },
        rotateR: { value: Math.PI / 12 * 1 },
        rotateG: { value: Math.PI / 12 * 2 },
        rotateB: { value: Math.PI / 12 * 3 },
        scatter: { value: 1 },
        width: { value: 20 },
        height: { value: 20 },
        blending: { value: 1 },
        blendingMode: { value: 1 },
        greyscale: { value: false },
        disable: { value: false }
      },
      vertexShader: (
        /* glsl */
        `

		varying vec2 vUV;
		varying vec3 vPosition;

		void main() {

			vUV = uv;
			vPosition = position;

			gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);

		}`
      ),
      fragmentShader: (
        /* glsl */
        `

		#define SQRT2_MINUS_ONE 0.41421356
		#define SQRT2_HALF_MINUS_ONE 0.20710678
		#define PI2 6.28318531
		#define SHAPE_DOT 1
		#define SHAPE_ELLIPSE 2
		#define SHAPE_LINE 3
		#define SHAPE_SQUARE 4
		#define BLENDING_LINEAR 1
		#define BLENDING_MULTIPLY 2
		#define BLENDING_ADD 3
		#define BLENDING_LIGHTER 4
		#define BLENDING_DARKER 5
		uniform sampler2D tDiffuse;
		uniform float radius;
		uniform float rotateR;
		uniform float rotateG;
		uniform float rotateB;
		uniform float scatter;
		uniform float width;
		uniform float height;
		uniform int shape;
		uniform bool disable;
		uniform float blending;
		uniform int blendingMode;
		varying vec2 vUV;
		varying vec3 vPosition;
		uniform bool greyscale;
		const int samples = 8;

		float blend( float a, float b, float t ) {

		// linear blend
			return a * ( 1.0 - t ) + b * t;

		}

		float hypot( float x, float y ) {

		// vector magnitude
			return sqrt( x * x + y * y );

		}

		float rand( vec2 seed ){

		// get pseudo-random number
			return fract( sin( dot( seed.xy, vec2( 12.9898, 78.233 ) ) ) * 43758.5453 );

		}

		float distanceToDotRadius( float channel, vec2 coord, vec2 normal, vec2 p, float angle, float rad_max ) {

		// apply shape-specific transforms
			float dist = hypot( coord.x - p.x, coord.y - p.y );
			float rad = channel;

			if ( shape == SHAPE_DOT ) {

				rad = pow( abs( rad ), 1.125 ) * rad_max;

			} else if ( shape == SHAPE_ELLIPSE ) {

				rad = pow( abs( rad ), 1.125 ) * rad_max;

				if ( dist != 0.0 ) {
					float dot_p = abs( ( p.x - coord.x ) / dist * normal.x + ( p.y - coord.y ) / dist * normal.y );
					dist = ( dist * ( 1.0 - SQRT2_HALF_MINUS_ONE ) ) + dot_p * dist * SQRT2_MINUS_ONE;
				}

			} else if ( shape == SHAPE_LINE ) {

				rad = pow( abs( rad ), 1.5) * rad_max;
				float dot_p = ( p.x - coord.x ) * normal.x + ( p.y - coord.y ) * normal.y;
				dist = hypot( normal.x * dot_p, normal.y * dot_p );

			} else if ( shape == SHAPE_SQUARE ) {

				float theta = atan( p.y - coord.y, p.x - coord.x ) - angle;
				float sin_t = abs( sin( theta ) );
				float cos_t = abs( cos( theta ) );
				rad = pow( abs( rad ), 1.4 );
				rad = rad_max * ( rad + ( ( sin_t > cos_t ) ? rad - sin_t * rad : rad - cos_t * rad ) );

			}

			return rad - dist;

		}

		struct Cell {

		// grid sample positions
			vec2 normal;
			vec2 p1;
			vec2 p2;
			vec2 p3;
			vec2 p4;
			float samp2;
			float samp1;
			float samp3;
			float samp4;

		};

		vec4 getSample( vec2 point ) {

		// multi-sampled point
			vec4 tex = texture2D( tDiffuse, vec2( point.x / width, point.y / height ) );
			float base = rand( vec2( floor( point.x ), floor( point.y ) ) ) * PI2;
			float step = PI2 / float( samples );
			// float dist = radius * 0.66;
			float dist = radius * 0.0;

			for ( int i = 0; i < samples; ++i ) {

				float r = base + step * float( i );
				vec2 coord = point + vec2( cos( r ) * dist, sin( r ) * dist );
				tex += texture2D( tDiffuse, vec2( coord.x / width, coord.y / height ) );

			}

			tex /= float( samples ) + 1.0;
			return tex;

		}

		float getDotColour( Cell c, vec2 p, int channel, float angle, float aa ) {

		// get colour for given point
			float dist_c_1, dist_c_2, dist_c_3, dist_c_4, res;

			if ( channel == 0 ) {

				c.samp1 = getSample( c.p1 ).r;
				c.samp2 = getSample( c.p2 ).r;
				c.samp3 = getSample( c.p3 ).r;
				c.samp4 = getSample( c.p4 ).r;

			} else if (channel == 1) {

				c.samp1 = getSample( c.p1 ).g;
				c.samp2 = getSample( c.p2 ).g;
				c.samp3 = getSample( c.p3 ).g;
				c.samp4 = getSample( c.p4 ).g;

			} else {

				c.samp1 = getSample( c.p1 ).b;
				c.samp3 = getSample( c.p3 ).b;
				c.samp2 = getSample( c.p2 ).b;
				c.samp4 = getSample( c.p4 ).b;

			}

			dist_c_1 = distanceToDotRadius( c.samp1, c.p1, c.normal, p, angle, radius );
			dist_c_2 = distanceToDotRadius( c.samp2, c.p2, c.normal, p, angle, radius );
			dist_c_3 = distanceToDotRadius( c.samp3, c.p3, c.normal, p, angle, radius );
			dist_c_4 = distanceToDotRadius( c.samp4, c.p4, c.normal, p, angle, radius );
			res = ( dist_c_1 > 0.0 ) ? clamp( dist_c_1 / aa, 0.0, 1.0 ) : 0.0;
			// res = 0.0;
			res += ( dist_c_2 > 0.0 ) ? clamp( dist_c_2 / aa, 0.0, 1.0 ) : 0.0;
			res += ( dist_c_3 > 0.0 ) ? clamp( dist_c_3 / aa, 0.0, 1.0 ) : 0.0;
			res += ( dist_c_4 > 0.0 ) ? clamp( dist_c_4 / aa, 0.0, 1.0 ) : 0.0;
			res = clamp( res, 0.0, 1.0 );

			return res;
			// return 2

		}

		Cell getReferenceCell( vec2 p, vec2 origin, float grid_angle, float step ) {

		// get containing cell
			Cell c;

		// calc grid
			vec2 n = vec2( cos( grid_angle ), sin( grid_angle ) );
			float threshold = step * 0.5;
			float dot_normal = n.x * ( p.x - origin.x ) + n.y * ( p.y - origin.y );
			float dot_line = -n.y * ( p.x - origin.x ) + n.x * ( p.y - origin.y );
			vec2 offset = vec2( n.x * dot_normal, n.y * dot_normal );
			float offset_normal = mod( hypot( offset.x, offset.y ), step );
			float normal_dir = ( dot_normal < 0.0 ) ? 1.0 : -1.0;
			float normal_scale = ( ( offset_normal < threshold ) ? -offset_normal : step - offset_normal ) * normal_dir;
			float offset_line = mod( hypot( ( p.x - offset.x ) - origin.x, ( p.y - offset.y ) - origin.y ), step );
			float line_dir = ( dot_line < 0.0 ) ? 1.0 : -1.0;
			float line_scale = ( ( offset_line < threshold ) ? -offset_line : step - offset_line ) * line_dir;

		// get closest corner
			c.normal = n;
			c.p1.x = p.x - n.x * normal_scale + n.y * line_scale;
			c.p1.y = p.y - n.y * normal_scale - n.x * line_scale;

		// scatter
			if ( scatter != 0.0 ) {

				float off_mag = scatter * threshold * 0.5;
				float off_angle = rand( vec2( floor( c.p1.x ), floor( c.p1.y ) ) ) * PI2;
				c.p1.x += cos( off_angle ) * off_mag;
				c.p1.y += sin( off_angle ) * off_mag;

			}

		// find corners
			float normal_step = normal_dir * ( ( offset_normal < threshold ) ? step : -step );
			float line_step = line_dir * ( ( offset_line < threshold ) ? step : -step );
			c.p2.x = c.p1.x - n.x * normal_step;
			c.p2.y = c.p1.y - n.y * normal_step;
			c.p3.x = c.p1.x + n.y * line_step;
			c.p3.y = c.p1.y - n.x * line_step;
			c.p4.x = c.p1.x - n.x * normal_step + n.y * line_step;
			c.p4.y = c.p1.y - n.y * normal_step - n.x * line_step;

			return c;

		}

		float blendColour( float a, float b, float t ) {

		// blend colours
			if ( blendingMode == BLENDING_LINEAR ) {
				return blend( a, b, 1.0 - t );
			} else if ( blendingMode == BLENDING_ADD ) {
				return blend( a, min( 1.0, a + b ), t );
			} else if ( blendingMode == BLENDING_MULTIPLY ) {
				return blend( a, max( 0.0, a * b ), t );
			} else if ( blendingMode == BLENDING_LIGHTER ) {
				return blend( a, max( a, b ), t );
			} else if ( blendingMode == BLENDING_DARKER ) {
				return blend( a, min( a, b ), t );
			} else {
				return blend( a, b, 1.0 - t );
			}

		}

		void main() {

			if ( ! disable ) {

		// setup
				vec2 p = vec2( vUV.x * width, vUV.y * height ) - vec2(vPosition.x, vPosition.y) * 3.0; // - position values to remove black borders.
				vec2 origin = vec2( 0, 0 );
				float aa = ( radius < 2.5 ) ? radius * 0.5 : 1.25;
				// float aa = 0.0;

		// get channel samples
				Cell cell_r = getReferenceCell( p, origin, rotateR, radius );
				Cell cell_g = getReferenceCell( p, origin, rotateG, radius );
				Cell cell_b = getReferenceCell( p, origin, rotateB, radius );
				float r = getDotColour( cell_r, p, 0, rotateR, aa );
				float g = getDotColour( cell_g, p, 1, rotateG, aa );
				float b = getDotColour( cell_b, p, 2, rotateB, aa );

		// blend with original
				vec4 colour = texture2D( tDiffuse, vUV );
				
				// add masking before blendColour
				if (colour.r == 0.0) {
					r = 0.0;
				} else {
					r = blendColour( r, colour.r, blending );
				}

				if (colour.g == 0.0) {
					g = 0.0;
				} else {
					g = blendColour( g, colour.g, blending );
				}

				if (colour.b == 0.0) {
					b = 0.0;
				} else {
					b = blendColour( b, colour.b, blending );
				}
				
				
				

				if ( greyscale ) {
					r = g = b = (r + b + g) / 3.0;
				}

				// add alpha channel to each r, g, b colors
				vec4 vR;
				vec4 vG;
				vec4 vB;
	
				// apply transparent to outside of mesh
				if (r == 0.0 && colour.r == 0.0) {
					vR = vec4( 0, 0, 0, 0 );
				} else {
					vR = vec4( r, 0, 0, 1 );
				}
	
				if (g == 0.0 && colour.g == 0.0) {
					vG = vec4( 0, 0, 0, 0 );
				} else {
					vG = vec4( 0, g, 0, 1 );
				}
	
				if (b == 0.0 && colour.b == 0.0) {
					vB = vec4( 0, 0, 0, 0 );
				} else {
					vB = vec4( 0, 0, b, 1 );
				}

				// gl_FragColor = vec4( r, g, b, 1.0 );
				gl_FragColor = vR + vG + vB;

			} else {

				gl_FragColor = texture2D( tDiffuse, vUV );

			}

		}`
      )
    };
  }
});

// ../shadergradient-v2/dist/chunk-LZ3DDWYG.mjs
var Pass2, _camera4, _geometry4, FullScreenQuad2;
var init_chunk_LZ3DDWYG = __esm({
  "../shadergradient-v2/dist/chunk-LZ3DDWYG.mjs"() {
    init_chunk_BT6X4JN2();
    Pass2 = class {
      constructor() {
        this.enabled = true;
        this.needsSwap = true;
        this.clear = false;
        this.renderToScreen = false;
      }
      setSize() {
      }
      render() {
        console.error("THREE.Pass: .render() must be implemented in derived pass.");
      }
    };
    _camera4 = new OrthographicCamera(-1, 1, 1, -1, 0, 1);
    _geometry4 = new BufferGeometry();
    _geometry4.setAttribute(
      "position",
      new Float32BufferAttribute([-1, 3, 0, -1, -1, 0, 3, -1, 0], 3)
    );
    _geometry4.setAttribute("uv", new Float32BufferAttribute([0, 2, 0, 0, 2, 0], 2));
    FullScreenQuad2 = class {
      constructor(material) {
        this._mesh = new Mesh(_geometry4, material);
      }
      dispose() {
        this._mesh.geometry.dispose();
      }
      render(renderer) {
        renderer.render(this._mesh, _camera4);
      }
      get material() {
        return this._mesh.material;
      }
      set material(value) {
        this._mesh.material = value;
      }
    };
  }
});

// ../shadergradient-v2/dist/chunk-XPELZ53J.mjs
var usePassedMeshSize, HalftonePass;
var init_chunk_XPELZ53J = __esm({
  "../shadergradient-v2/dist/chunk-XPELZ53J.mjs"() {
    init_chunk_OUMQVT4Y();
    init_chunk_4NRCS6EB();
    init_chunk_3U6A2N6D();
    init_chunk_LZ3DDWYG();
    init_chunk_BT6X4JN2();
    usePassedMeshSize = true;
    HalftonePass = class extends Pass2 {
      constructor(width, height, params) {
        super();
        if (HalftoneShader === void 0) {
          console.error("THREE.HalftonePass requires HalftoneShader");
        }
        this.uniforms = UniformsUtils.clone(HalftoneShader.uniforms);
        this.material = new ShaderMaterial({
          uniforms: this.uniforms,
          fragmentShader: HalftoneShader.fragmentShader,
          vertexShader: HalftoneShader.vertexShader
        });
        if (usePassedMeshSize) {
          this.uniforms.width.value = width;
          this.uniforms.height.value = height;
        }
        this.uniforms.disable.value = params["disable"];
        this.fsQuad = new FullScreenQuad2(this.material);
        this.blendMode = new BlendMode(BlendFunction.SCREEN);
        this.extensions = null;
      }
      render(renderer, writeBuffer, readBuffer) {
        this.material.uniforms["tDiffuse"].value = readBuffer.texture;
        if (this.renderToScreen) {
          renderer.setRenderTarget(null);
          this.fsQuad.render(renderer);
        } else {
          renderer.setRenderTarget(writeBuffer);
          if (this.clear) renderer.clear();
          this.fsQuad.render(renderer);
        }
      }
      setSize(width, height) {
        if (usePassedMeshSize) {
          this.uniforms.width.value = width;
          this.uniforms.height.value = height;
        }
      }
      initialize(renderer, alpha, frameBufferType) {
      }
      addEventListener() {
      }
      getAttributes() {
        return this.attributes;
      }
      getFragmentShader() {
        return HalftoneShader.fragmentShader;
      }
      getVertexShader() {
        return HalftoneShader.vertexShader;
      }
      update(renderer, inputBuffer, deltaTime) {
      }
    };
  }
});

// ../shadergradient-v2/dist/chunk-HTJBLCUE.mjs
import { useEffect as useEffect6, useMemo as useMemo4 } from "react";
import { Fragment as Fragment3, jsx as jsx5 } from "react/jsx-runtime";
function PostProcessing({ disable = false }) {
  const { gl, scene, camera, size } = useThree();
  const composer = useMemo4(() => {
    const effectComposer = new EffectComposer(gl);
    effectComposer.addPass(new RenderPass(scene, camera));
    const halftoneParams = {
      shape: 1,
      radius: 2,
      rotateR: Math.PI / 12,
      rotateB: Math.PI / 12 * 2,
      rotateG: Math.PI / 12 * 3,
      scatter: 1,
      blending: 1,
      blendingMode: 1,
      greyscale: false,
      disable
    };
    const halftonePass = new HalftonePass(
      size.width,
      size.height,
      halftoneParams
    );
    effectComposer.addPass(halftonePass);
    return effectComposer;
  }, [gl, scene, camera, size, disable]);
  useEffect6(() => composer == null ? void 0 : composer.setSize(size.width, size.height), [composer, size]);
  useFrame(
    (_, delta) => void (gl.autoClear = true, composer.render(delta)),
    1
  );
  return /* @__PURE__ */ jsx5(Fragment3, {});
}
var init_chunk_HTJBLCUE = __esm({
  "../shadergradient-v2/dist/chunk-HTJBLCUE.mjs"() {
    init_chunk_FVJI5A2G();
    init_chunk_OJ2FJ367();
    init_chunk_XPELZ53J();
    init_chunk_73SH6GTX();
  }
});

// ../shadergradient-v2/dist/chunk-WPNBLVEI.mjs
var canvasProps, defaultPlanesZoom, defaultSphereDistance, zoomOutPlanes, zoomOutSphere, defaultEnvBasePath;
var init_chunk_WPNBLVEI = __esm({
  "../shadergradient-v2/dist/chunk-WPNBLVEI.mjs"() {
    canvasProps = (pixelDensity, fov2) => ({
      dpr: pixelDensity,
      //device pixel ratio - 1 default and fast, 2 detailed and slow
      // mode: 'concurrent' as 'legacy' | 'blocking' | 'concurrent',
      camera: { fov: fov2 },
      // could be replaced with zoom or distance?
      linear: true,
      //sRGBEncoding
      flat: true,
      //ACESFilmicToneMapping
      gl: { preserveDrawingBuffer: true }
      // to capture the canvas (Figma Plugin)
    });
    defaultPlanesZoom = 1;
    defaultSphereDistance = 14;
    zoomOutPlanes = { zoom: 1, distance: 14 };
    zoomOutSphere = { zoom: 5, distance: 14 };
    defaultEnvBasePath = "https://ruucm.github.io/shadergradient/ui@0.0.0/assets/hdr/";
  }
});

// ../shadergradient-v2/dist/chunk-AVV7TPJS.mjs
import { useEffect as useEffect7, useRef as useRef5 } from "react";
function useCameraAnimation({
  type,
  cAzimuthAngle,
  cPolarAngle,
  cDistance,
  cameraZoom,
  zoomOut,
  enableTransition = true
}) {
  const ref = useRef5();
  useFrame((state, delta) => ref.current.update(delta));
  useEffect7(() => {
    const control = ref.current;
    control == null ? void 0 : control.rotateTo(dToR(cAzimuthAngle), dToR(cPolarAngle), enableTransition);
  }, [ref, cAzimuthAngle, cPolarAngle]);
  useEffect7(() => {
    const control = ref.current;
    if (zoomOut) {
      if (type === "sphere") {
        control == null ? void 0 : control.dollyTo(zoomOutSphere.distance, enableTransition);
        control == null ? void 0 : control.zoomTo(zoomOutSphere.zoom, enableTransition);
      } else {
        control == null ? void 0 : control.dollyTo(zoomOutPlanes.distance, enableTransition);
        control == null ? void 0 : control.zoomTo(zoomOutPlanes.zoom, enableTransition);
      }
    } else {
      if (type === "sphere") {
        control == null ? void 0 : control.zoomTo(cameraZoom, enableTransition);
        control == null ? void 0 : control.dollyTo(defaultSphereDistance, enableTransition);
      } else {
        control == null ? void 0 : control.dollyTo(cDistance, enableTransition);
        control == null ? void 0 : control.zoomTo(defaultPlanesZoom, enableTransition);
      }
    }
  }, [ref, zoomOut, type, cameraZoom, cDistance]);
  return ref;
}
var init_chunk_AVV7TPJS = __esm({
  "../shadergradient-v2/dist/chunk-AVV7TPJS.mjs"() {
    init_chunk_WNGYPXFW();
    init_chunk_73SH6GTX();
    init_chunk_WPNBLVEI();
  }
});

// ../shadergradient-v2/dist/chunk-M2MFZVXL.mjs
import { useEffect as useEffect8 } from "react";
import { jsx as jsx6 } from "react/jsx-runtime";
function isPerspectiveCamera(camera) {
  return camera.isPerspectiveCamera;
}
function isOrthographicCamera2(camera) {
  return camera.isOrthographicCamera;
}
function clamp2(value, min, max) {
  return Math.max(min, Math.min(max, value));
}
function approxZero(number, error2 = EPSILON) {
  return Math.abs(number) < error2;
}
function approxEquals(a, b, error2 = EPSILON) {
  return approxZero(a - b, error2);
}
function roundToStep(value, step) {
  return Math.round(value / step) * step;
}
function infinityToMaxNumber(value) {
  if (isFinite(value))
    return value;
  if (value < 0)
    return -Number.MAX_VALUE;
  return Number.MAX_VALUE;
}
function maxNumberToInfinity(value) {
  if (Math.abs(value) < Number.MAX_VALUE)
    return value;
  return value * Infinity;
}
function smoothDamp(current, target2, currentVelocityRef, smoothTime, maxSpeed = Infinity, deltaTime) {
  smoothTime = Math.max(1e-4, smoothTime);
  const omega = 2 / smoothTime;
  const x = omega * deltaTime;
  const exp = 1 / (1 + x + 0.48 * x * x + 0.235 * x * x * x);
  let change = current - target2;
  const originalTo = target2;
  const maxChange = maxSpeed * smoothTime;
  change = clamp2(change, -maxChange, maxChange);
  target2 = current - change;
  const temp = (currentVelocityRef.value + omega * change) * deltaTime;
  currentVelocityRef.value = (currentVelocityRef.value - omega * temp) * exp;
  let output = target2 + (change + temp) * exp;
  if (originalTo - current > 0 === output > originalTo) {
    output = originalTo;
    currentVelocityRef.value = (output - originalTo) / deltaTime;
  }
  return output;
}
function smoothDampVec3(current, target2, currentVelocityRef, smoothTime, maxSpeed = Infinity, deltaTime, out) {
  smoothTime = Math.max(1e-4, smoothTime);
  const omega = 2 / smoothTime;
  const x = omega * deltaTime;
  const exp = 1 / (1 + x + 0.48 * x * x + 0.235 * x * x * x);
  let targetX = target2.x;
  let targetY = target2.y;
  let targetZ = target2.z;
  let changeX = current.x - targetX;
  let changeY = current.y - targetY;
  let changeZ = current.z - targetZ;
  const originalToX = targetX;
  const originalToY = targetY;
  const originalToZ = targetZ;
  const maxChange = maxSpeed * smoothTime;
  const maxChangeSq = maxChange * maxChange;
  const magnitudeSq = changeX * changeX + changeY * changeY + changeZ * changeZ;
  if (magnitudeSq > maxChangeSq) {
    const magnitude = Math.sqrt(magnitudeSq);
    changeX = changeX / magnitude * maxChange;
    changeY = changeY / magnitude * maxChange;
    changeZ = changeZ / magnitude * maxChange;
  }
  targetX = current.x - changeX;
  targetY = current.y - changeY;
  targetZ = current.z - changeZ;
  const tempX = (currentVelocityRef.x + omega * changeX) * deltaTime;
  const tempY = (currentVelocityRef.y + omega * changeY) * deltaTime;
  const tempZ = (currentVelocityRef.z + omega * changeZ) * deltaTime;
  currentVelocityRef.x = (currentVelocityRef.x - omega * tempX) * exp;
  currentVelocityRef.y = (currentVelocityRef.y - omega * tempY) * exp;
  currentVelocityRef.z = (currentVelocityRef.z - omega * tempZ) * exp;
  out.x = targetX + (changeX + tempX) * exp;
  out.y = targetY + (changeY + tempY) * exp;
  out.z = targetZ + (changeZ + tempZ) * exp;
  const origMinusCurrentX = originalToX - current.x;
  const origMinusCurrentY = originalToY - current.y;
  const origMinusCurrentZ = originalToZ - current.z;
  const outMinusOrigX = out.x - originalToX;
  const outMinusOrigY = out.y - originalToY;
  const outMinusOrigZ = out.z - originalToZ;
  if (origMinusCurrentX * outMinusOrigX + origMinusCurrentY * outMinusOrigY + origMinusCurrentZ * outMinusOrigZ > 0) {
    out.x = originalToX;
    out.y = originalToY;
    out.z = originalToZ;
    currentVelocityRef.x = (out.x - originalToX) / deltaTime;
    currentVelocityRef.y = (out.y - originalToY) / deltaTime;
    currentVelocityRef.z = (out.z - originalToZ) / deltaTime;
  }
  return out;
}
function extractClientCoordFromEvent(pointers, out) {
  out.set(0, 0);
  pointers.forEach((pointer) => {
    out.x += pointer.clientX;
    out.y += pointer.clientY;
  });
  out.x /= pointers.length;
  out.y /= pointers.length;
}
function notSupportedInOrthographicCamera(camera, message) {
  if (isOrthographicCamera2(camera)) {
    console.warn(`${message} is not supported in OrthographicCamera`);
    return true;
  }
  return false;
}
function CameraControl(_a22) {
  var _b2 = _a22, {
    smoothTime = 0.05
  } = _b2, props = __objRest(_b2, [
    "smoothTime"
  ]);
  CameraControls.install({ THREE: three_module_exports });
  extend({ CameraControls });
  const camera = useThree((state) => state.camera);
  const gl = useThree((state) => state.gl);
  const ref = useCameraAnimation(props);
  useEffect8(() => {
    const control = ref.current;
    if (!control) return;
    const { type, onCameraUpdate } = props || {};
    if (!onCameraUpdate) return;
    const toDegrees = (radians) => Math.round(radians * 180 / Math.PI);
    const getAngles = () => ({
      cAzimuthAngle: toDegrees(control.azimuthAngle),
      cPolarAngle: toDegrees(control.polarAngle)
    });
    const getZoomDistance = () => {
      var _a3;
      const result = {};
      if (type === "sphere") {
        const ctrlZoom = control == null ? void 0 : control.zoom;
        if (Number.isFinite(ctrlZoom)) {
          result.cameraZoom = Number(ctrlZoom.toFixed(2));
        } else {
          const camZoom = (_a3 = control == null ? void 0 : control.camera) == null ? void 0 : _a3.zoom;
          if (Number.isFinite(camZoom)) {
            result.cameraZoom = Number(camZoom.toFixed(2));
          }
        }
      } else {
        if (Number.isFinite(control.distance)) {
          result.cDistance = Number(control.distance.toFixed(2));
        }
      }
      return result;
    };
    const handleSleep = () => {
      onCameraUpdate(__spreadValues(__spreadValues({}, getAngles()), getZoomDistance()));
    };
    control.addEventListener("sleep", handleSleep);
    return () => {
      control.removeEventListener("sleep", handleSleep);
    };
  }, [ref, props]);
  return (
    // @ts-ignore
    /* @__PURE__ */ jsx6(
      "cameraControls",
      {
        ref,
        args: [camera, gl.domElement],
        enableDamping: true,
        smoothTime,
        zoomSpeed: 10,
        dollySpeed: 5,
        maxDistance: 1e3,
        restThreshold: 0,
        mouseButtons: {
          left: CameraControls.ACTION.ROTATE,
          middle: props.type === "sphere" ? CameraControls.ACTION.ZOOM : CameraControls.ACTION.DOLLY,
          right: CameraControls.ACTION.NONE,
          // disabling pan for now, as we don't support camera position value in props
          wheel: props.type === "sphere" ? CameraControls.ACTION.ZOOM : CameraControls.ACTION.DOLLY
        },
        touches: {
          one: CameraControls.ACTION.ROTATE,
          two: CameraControls.ACTION.NONE,
          // disable touch pan (TRUCK)
          three: CameraControls.ACTION.NONE
        }
      }
    )
  );
}
var MOUSE_BUTTON, ACTION, DOLLY_DIRECTION, PI_2, PI_HALF, EPSILON, DEG2RAD2, EventDispatcher2, _a2, VERSION, TOUCH_DOLLY_FACTOR, isMac, THREE, _ORIGIN, _AXIS_Y, _AXIS_Z, _v22, _v3A, _v3B, _v3C, _cameraDirection, _xColumn, _yColumn, _zColumn, _deltaTarget, _deltaOffset, _sphericalA, _sphericalB, _box3A, _box3B, _sphere2, _quaternionA, _quaternionB, _rotationMatrix, _raycaster, CameraControls;
var init_chunk_M2MFZVXL = __esm({
  "../shadergradient-v2/dist/chunk-M2MFZVXL.mjs"() {
    init_chunk_AVV7TPJS();
    init_chunk_73SH6GTX();
    init_chunk_BT6X4JN2();
    init_chunk_5BEQP2BQ();
    MOUSE_BUTTON = {
      LEFT: 1,
      RIGHT: 2,
      MIDDLE: 4
    };
    ACTION = Object.freeze({
      NONE: 0,
      ROTATE: 1,
      TRUCK: 2,
      OFFSET: 4,
      DOLLY: 8,
      ZOOM: 16,
      TOUCH_ROTATE: 32,
      TOUCH_TRUCK: 64,
      TOUCH_OFFSET: 128,
      TOUCH_DOLLY: 256,
      TOUCH_ZOOM: 512,
      TOUCH_DOLLY_TRUCK: 1024,
      TOUCH_DOLLY_OFFSET: 2048,
      TOUCH_DOLLY_ROTATE: 4096,
      TOUCH_ZOOM_TRUCK: 8192,
      TOUCH_ZOOM_OFFSET: 16384,
      TOUCH_ZOOM_ROTATE: 32768
    });
    DOLLY_DIRECTION = {
      NONE: 0,
      IN: 1,
      OUT: -1
    };
    PI_2 = Math.PI * 2;
    PI_HALF = Math.PI / 2;
    EPSILON = 1e-5;
    DEG2RAD2 = Math.PI / 180;
    EventDispatcher2 = class {
      constructor() {
        this._listeners = {};
      }
      /**
       * Adds the specified event listener.
       * @param type event name
       * @param listener handler function
       * @category Methods
       */
      addEventListener(type, listener) {
        const listeners = this._listeners;
        if (listeners[type] === void 0)
          listeners[type] = [];
        if (listeners[type].indexOf(listener) === -1)
          listeners[type].push(listener);
      }
      /**
       * Presence of the specified event listener.
       * @param type event name
       * @param listener handler function
       * @category Methods
       */
      hasEventListener(type, listener) {
        const listeners = this._listeners;
        return listeners[type] !== void 0 && listeners[type].indexOf(listener) !== -1;
      }
      /**
       * Removes the specified event listener
       * @param type event name
       * @param listener handler function
       * @category Methods
       */
      removeEventListener(type, listener) {
        const listeners = this._listeners;
        const listenerArray = listeners[type];
        if (listenerArray !== void 0) {
          const index = listenerArray.indexOf(listener);
          if (index !== -1)
            listenerArray.splice(index, 1);
        }
      }
      /**
       * Removes all event listeners
       * @param type event name
       * @category Methods
       */
      removeAllEventListeners(type) {
        if (!type) {
          this._listeners = {};
          return;
        }
        if (Array.isArray(this._listeners[type]))
          this._listeners[type].length = 0;
      }
      /**
       * Fire an event type.
       * @param event DispatcherEvent
       * @category Methods
       */
      dispatchEvent(event) {
        const listeners = this._listeners;
        const listenerArray = listeners[event.type];
        if (listenerArray !== void 0) {
          event.target = this;
          const array = listenerArray.slice(0);
          for (let i2 = 0, l2 = array.length; i2 < l2; i2++) {
            array[i2].call(this, event);
          }
        }
      }
    };
    VERSION = "2.9.0";
    TOUCH_DOLLY_FACTOR = 1 / 8;
    isMac = /Mac/.test((_a2 = globalThis === null || globalThis === void 0 ? void 0 : globalThis.navigator) === null || _a2 === void 0 ? void 0 : _a2.platform);
    CameraControls = class _CameraControls extends EventDispatcher2 {
      /**
           * Injects THREE as the dependency. You can then proceed to use CameraControls.
           *
           * e.g
           * ```javascript
           * CameraControls.install( { THREE: THREE } );
           * ```
           *
           * Note: If you do not wish to use enter three.js to reduce file size(tree-shaking for example), make a subset to install.
           *
           * ```js
           * import {
           * 	Vector2,
           * 	Vector3,
           * 	Vector4,
           * 	Quaternion,
           * 	Matrix4,
           * 	Spherical,
           * 	Box3,
           * 	Sphere,
           * 	Raycaster,
           * 	MathUtils,
           * } from 'three';
           *
           * const subsetOfTHREE = {
           * 	Vector2   : Vector2,
           * 	Vector3   : Vector3,
           * 	Vector4   : Vector4,
           * 	Quaternion: Quaternion,
           * 	Matrix4   : Matrix4,
           * 	Spherical : Spherical,
           * 	Box3      : Box3,
           * 	Sphere    : Sphere,
           * 	Raycaster : Raycaster,
           * };
      
           * CameraControls.install( { THREE: subsetOfTHREE } );
           * ```
           * @category Statics
           */
      static install(libs) {
        THREE = libs.THREE;
        _ORIGIN = Object.freeze(new THREE.Vector3(0, 0, 0));
        _AXIS_Y = Object.freeze(new THREE.Vector3(0, 1, 0));
        _AXIS_Z = Object.freeze(new THREE.Vector3(0, 0, 1));
        _v22 = new THREE.Vector2();
        _v3A = new THREE.Vector3();
        _v3B = new THREE.Vector3();
        _v3C = new THREE.Vector3();
        _cameraDirection = new THREE.Vector3();
        _xColumn = new THREE.Vector3();
        _yColumn = new THREE.Vector3();
        _zColumn = new THREE.Vector3();
        _deltaTarget = new THREE.Vector3();
        _deltaOffset = new THREE.Vector3();
        _sphericalA = new THREE.Spherical();
        _sphericalB = new THREE.Spherical();
        _box3A = new THREE.Box3();
        _box3B = new THREE.Box3();
        _sphere2 = new THREE.Sphere();
        _quaternionA = new THREE.Quaternion();
        _quaternionB = new THREE.Quaternion();
        _rotationMatrix = new THREE.Matrix4();
        _raycaster = new THREE.Raycaster();
      }
      /**
       * list all ACTIONs
       * @category Statics
       */
      static get ACTION() {
        return ACTION;
      }
      /**
       * Creates a `CameraControls` instance.
       *
       * Note:
       * You **must install** three.js before using camera-controls. see [#install](#install)
       * Not doing so will lead to runtime errors (`undefined` references to THREE).
       *
       * e.g.
       * ```
       * CameraControls.install( { THREE } );
       * const cameraControls = new CameraControls( camera, domElement );
       * ```
       *
       * @param camera A `THREE.PerspectiveCamera` or `THREE.OrthographicCamera` to be controlled.
       * @param domElement A `HTMLElement` for the draggable area, usually `renderer.domElement`.
       * @category Constructor
       */
      constructor(camera, domElement) {
        super();
        this.minPolarAngle = 0;
        this.maxPolarAngle = Math.PI;
        this.minAzimuthAngle = -Infinity;
        this.maxAzimuthAngle = Infinity;
        this.minDistance = Number.EPSILON;
        this.maxDistance = Infinity;
        this.infinityDolly = false;
        this.minZoom = 0.01;
        this.maxZoom = Infinity;
        this.smoothTime = 0.25;
        this.draggingSmoothTime = 0.125;
        this.maxSpeed = Infinity;
        this.azimuthRotateSpeed = 1;
        this.polarRotateSpeed = 1;
        this.dollySpeed = 1;
        this.dollyDragInverted = false;
        this.truckSpeed = 2;
        this.dollyToCursor = false;
        this.dragToOffset = false;
        this.verticalDragToForward = false;
        this.boundaryFriction = 0;
        this.restThreshold = 0.01;
        this.colliderMeshes = [];
        this.cancel = () => {
        };
        this._enabled = true;
        this._state = ACTION.NONE;
        this._viewport = null;
        this._changedDolly = 0;
        this._changedZoom = 0;
        this._hasRested = true;
        this._boundaryEnclosesCamera = false;
        this._needsUpdate = true;
        this._updatedLastTime = false;
        this._elementRect = new DOMRect();
        this._isDragging = false;
        this._dragNeedsUpdate = true;
        this._activePointers = [];
        this._lockedPointer = null;
        this._interactiveArea = new DOMRect(0, 0, 1, 1);
        this._isUserControllingRotate = false;
        this._isUserControllingDolly = false;
        this._isUserControllingTruck = false;
        this._isUserControllingOffset = false;
        this._isUserControllingZoom = false;
        this._lastDollyDirection = DOLLY_DIRECTION.NONE;
        this._thetaVelocity = { value: 0 };
        this._phiVelocity = { value: 0 };
        this._radiusVelocity = { value: 0 };
        this._targetVelocity = new THREE.Vector3();
        this._focalOffsetVelocity = new THREE.Vector3();
        this._zoomVelocity = { value: 0 };
        this._truckInternal = (deltaX, deltaY, dragToOffset) => {
          let truckX;
          let pedestalY;
          if (isPerspectiveCamera(this._camera)) {
            const offset = _v3A.copy(this._camera.position).sub(this._target);
            const fov2 = this._camera.getEffectiveFOV() * DEG2RAD2;
            const targetDistance = offset.length() * Math.tan(fov2 * 0.5);
            truckX = this.truckSpeed * deltaX * targetDistance / this._elementRect.height;
            pedestalY = this.truckSpeed * deltaY * targetDistance / this._elementRect.height;
          } else if (isOrthographicCamera2(this._camera)) {
            const camera2 = this._camera;
            truckX = deltaX * (camera2.right - camera2.left) / camera2.zoom / this._elementRect.width;
            pedestalY = deltaY * (camera2.top - camera2.bottom) / camera2.zoom / this._elementRect.height;
          } else {
            return;
          }
          if (this.verticalDragToForward) {
            dragToOffset ? this.setFocalOffset(this._focalOffsetEnd.x + truckX, this._focalOffsetEnd.y, this._focalOffsetEnd.z, true) : this.truck(truckX, 0, true);
            this.forward(-pedestalY, true);
          } else {
            dragToOffset ? this.setFocalOffset(this._focalOffsetEnd.x + truckX, this._focalOffsetEnd.y + pedestalY, this._focalOffsetEnd.z, true) : this.truck(truckX, pedestalY, true);
          }
        };
        this._rotateInternal = (deltaX, deltaY) => {
          const theta = PI_2 * this.azimuthRotateSpeed * deltaX / this._elementRect.height;
          const phi = PI_2 * this.polarRotateSpeed * deltaY / this._elementRect.height;
          this.rotate(theta, phi, true);
        };
        this._dollyInternal = (delta, x, y2) => {
          const dollyScale = Math.pow(0.95, -delta * this.dollySpeed);
          const lastDistance = this._sphericalEnd.radius;
          const distance = this._sphericalEnd.radius * dollyScale;
          const clampedDistance = clamp2(distance, this.minDistance, this.maxDistance);
          const overflowedDistance = clampedDistance - distance;
          if (this.infinityDolly && this.dollyToCursor) {
            this._dollyToNoClamp(distance, true);
          } else if (this.infinityDolly && !this.dollyToCursor) {
            this.dollyInFixed(overflowedDistance, true);
            this._dollyToNoClamp(clampedDistance, true);
          } else {
            this._dollyToNoClamp(clampedDistance, true);
          }
          if (this.dollyToCursor) {
            this._changedDolly += (this.infinityDolly ? distance : clampedDistance) - lastDistance;
            this._dollyControlCoord.set(x, y2);
          }
          this._lastDollyDirection = Math.sign(-delta);
        };
        this._zoomInternal = (delta, x, y2) => {
          const zoomScale = Math.pow(0.95, delta * this.dollySpeed);
          const lastZoom = this._zoom;
          const zoom = this._zoom * zoomScale;
          this.zoomTo(zoom, true);
          if (this.dollyToCursor) {
            this._changedZoom += zoom - lastZoom;
            this._dollyControlCoord.set(x, y2);
          }
        };
        if (typeof THREE === "undefined") {
          console.error("camera-controls: `THREE` is undefined. You must first run `CameraControls.install( { THREE: THREE } )`. Check the docs for further information.");
        }
        this._camera = camera;
        this._yAxisUpSpace = new THREE.Quaternion().setFromUnitVectors(this._camera.up, _AXIS_Y);
        this._yAxisUpSpaceInverse = this._yAxisUpSpace.clone().invert();
        this._state = ACTION.NONE;
        this._target = new THREE.Vector3();
        this._targetEnd = this._target.clone();
        this._focalOffset = new THREE.Vector3();
        this._focalOffsetEnd = this._focalOffset.clone();
        this._spherical = new THREE.Spherical().setFromVector3(_v3A.copy(this._camera.position).applyQuaternion(this._yAxisUpSpace));
        this._sphericalEnd = this._spherical.clone();
        this._lastDistance = this._spherical.radius;
        this._zoom = this._camera.zoom;
        this._zoomEnd = this._zoom;
        this._lastZoom = this._zoom;
        this._nearPlaneCorners = [
          new THREE.Vector3(),
          new THREE.Vector3(),
          new THREE.Vector3(),
          new THREE.Vector3()
        ];
        this._updateNearPlaneCorners();
        this._boundary = new THREE.Box3(new THREE.Vector3(-Infinity, -Infinity, -Infinity), new THREE.Vector3(Infinity, Infinity, Infinity));
        this._cameraUp0 = this._camera.up.clone();
        this._target0 = this._target.clone();
        this._position0 = this._camera.position.clone();
        this._zoom0 = this._zoom;
        this._focalOffset0 = this._focalOffset.clone();
        this._dollyControlCoord = new THREE.Vector2();
        this.mouseButtons = {
          left: ACTION.ROTATE,
          middle: ACTION.DOLLY,
          right: ACTION.TRUCK,
          wheel: isPerspectiveCamera(this._camera) ? ACTION.DOLLY : isOrthographicCamera2(this._camera) ? ACTION.ZOOM : ACTION.NONE
        };
        this.touches = {
          one: ACTION.TOUCH_ROTATE,
          two: isPerspectiveCamera(this._camera) ? ACTION.TOUCH_DOLLY_TRUCK : isOrthographicCamera2(this._camera) ? ACTION.TOUCH_ZOOM_TRUCK : ACTION.NONE,
          three: ACTION.TOUCH_TRUCK
        };
        const dragStartPosition = new THREE.Vector2();
        const lastDragPosition = new THREE.Vector2();
        const dollyStart = new THREE.Vector2();
        const onPointerDown = (event) => {
          if (!this._enabled || !this._domElement)
            return;
          if (this._interactiveArea.left !== 0 || this._interactiveArea.top !== 0 || this._interactiveArea.width !== 1 || this._interactiveArea.height !== 1) {
            const elRect = this._domElement.getBoundingClientRect();
            const left = event.clientX / elRect.width;
            const top = event.clientY / elRect.height;
            if (left < this._interactiveArea.left || left > this._interactiveArea.right || top < this._interactiveArea.top || top > this._interactiveArea.bottom)
              return;
          }
          const mouseButton = event.pointerType !== "mouse" ? null : (event.buttons & MOUSE_BUTTON.LEFT) === MOUSE_BUTTON.LEFT ? MOUSE_BUTTON.LEFT : (event.buttons & MOUSE_BUTTON.MIDDLE) === MOUSE_BUTTON.MIDDLE ? MOUSE_BUTTON.MIDDLE : (event.buttons & MOUSE_BUTTON.RIGHT) === MOUSE_BUTTON.RIGHT ? MOUSE_BUTTON.RIGHT : null;
          if (mouseButton !== null) {
            const zombiePointer = this._findPointerByMouseButton(mouseButton);
            zombiePointer && this._disposePointer(zombiePointer);
          }
          if ((event.buttons & MOUSE_BUTTON.LEFT) === MOUSE_BUTTON.LEFT && this._lockedPointer)
            return;
          const pointer = {
            pointerId: event.pointerId,
            clientX: event.clientX,
            clientY: event.clientY,
            deltaX: 0,
            deltaY: 0,
            mouseButton
          };
          this._activePointers.push(pointer);
          this._domElement.ownerDocument.removeEventListener("pointermove", onPointerMove, { passive: false });
          this._domElement.ownerDocument.removeEventListener("pointerup", onPointerUp);
          this._domElement.ownerDocument.addEventListener("pointermove", onPointerMove, { passive: false });
          this._domElement.ownerDocument.addEventListener("pointerup", onPointerUp);
          this._isDragging = true;
          startDragging(event);
        };
        const onPointerMove = (event) => {
          if (event.cancelable)
            event.preventDefault();
          const pointerId = event.pointerId;
          const pointer = this._lockedPointer || this._findPointerById(pointerId);
          if (!pointer)
            return;
          pointer.clientX = event.clientX;
          pointer.clientY = event.clientY;
          pointer.deltaX = event.movementX;
          pointer.deltaY = event.movementY;
          this._state = 0;
          if (event.pointerType === "touch") {
            switch (this._activePointers.length) {
              case 1:
                this._state = this.touches.one;
                break;
              case 2:
                this._state = this.touches.two;
                break;
              case 3:
                this._state = this.touches.three;
                break;
            }
          } else {
            if (!this._isDragging && this._lockedPointer || this._isDragging && (event.buttons & MOUSE_BUTTON.LEFT) === MOUSE_BUTTON.LEFT) {
              this._state = this._state | this.mouseButtons.left;
            }
            if (this._isDragging && (event.buttons & MOUSE_BUTTON.MIDDLE) === MOUSE_BUTTON.MIDDLE) {
              this._state = this._state | this.mouseButtons.middle;
            }
            if (this._isDragging && (event.buttons & MOUSE_BUTTON.RIGHT) === MOUSE_BUTTON.RIGHT) {
              this._state = this._state | this.mouseButtons.right;
            }
          }
          dragging();
        };
        const onPointerUp = (event) => {
          const pointer = this._findPointerById(event.pointerId);
          if (pointer && pointer === this._lockedPointer)
            return;
          pointer && this._disposePointer(pointer);
          if (event.pointerType === "touch") {
            switch (this._activePointers.length) {
              case 0:
                this._state = ACTION.NONE;
                break;
              case 1:
                this._state = this.touches.one;
                break;
              case 2:
                this._state = this.touches.two;
                break;
              case 3:
                this._state = this.touches.three;
                break;
            }
          } else {
            this._state = ACTION.NONE;
          }
          endDragging();
        };
        let lastScrollTimeStamp = -1;
        const onMouseWheel = (event) => {
          if (!this._domElement)
            return;
          if (!this._enabled || this.mouseButtons.wheel === ACTION.NONE)
            return;
          if (this._interactiveArea.left !== 0 || this._interactiveArea.top !== 0 || this._interactiveArea.width !== 1 || this._interactiveArea.height !== 1) {
            const elRect = this._domElement.getBoundingClientRect();
            const left = event.clientX / elRect.width;
            const top = event.clientY / elRect.height;
            if (left < this._interactiveArea.left || left > this._interactiveArea.right || top < this._interactiveArea.top || top > this._interactiveArea.bottom)
              return;
          }
          event.preventDefault();
          if (this.dollyToCursor || this.mouseButtons.wheel === ACTION.ROTATE || this.mouseButtons.wheel === ACTION.TRUCK) {
            const now2 = performance.now();
            if (lastScrollTimeStamp - now2 < 1e3)
              this._getClientRect(this._elementRect);
            lastScrollTimeStamp = now2;
          }
          const deltaYFactor = isMac ? -1 : -3;
          const delta = event.deltaMode === 1 ? event.deltaY / deltaYFactor : event.deltaY / (deltaYFactor * 10);
          const x = this.dollyToCursor ? (event.clientX - this._elementRect.x) / this._elementRect.width * 2 - 1 : 0;
          const y2 = this.dollyToCursor ? (event.clientY - this._elementRect.y) / this._elementRect.height * -2 + 1 : 0;
          switch (this.mouseButtons.wheel) {
            case ACTION.ROTATE: {
              this._rotateInternal(event.deltaX, event.deltaY);
              this._isUserControllingRotate = true;
              break;
            }
            case ACTION.TRUCK: {
              this._truckInternal(event.deltaX, event.deltaY, false);
              this._isUserControllingTruck = true;
              break;
            }
            case ACTION.OFFSET: {
              this._truckInternal(event.deltaX, event.deltaY, true);
              this._isUserControllingOffset = true;
              break;
            }
            case ACTION.DOLLY: {
              this._dollyInternal(-delta, x, y2);
              this._isUserControllingDolly = true;
              break;
            }
            case ACTION.ZOOM: {
              this._zoomInternal(-delta, x, y2);
              this._isUserControllingZoom = true;
              break;
            }
          }
          this.dispatchEvent({ type: "control" });
        };
        const onContextMenu = (event) => {
          if (!this._domElement || !this._enabled)
            return;
          if (this.mouseButtons.right === _CameraControls.ACTION.NONE) {
            const pointerId = event instanceof PointerEvent ? event.pointerId : 0;
            const pointer = this._findPointerById(pointerId);
            pointer && this._disposePointer(pointer);
            this._domElement.ownerDocument.removeEventListener("pointermove", onPointerMove, { passive: false });
            this._domElement.ownerDocument.removeEventListener("pointerup", onPointerUp);
            return;
          }
          event.preventDefault();
        };
        const startDragging = (event) => {
          if (!this._enabled)
            return;
          extractClientCoordFromEvent(this._activePointers, _v22);
          this._getClientRect(this._elementRect);
          dragStartPosition.copy(_v22);
          lastDragPosition.copy(_v22);
          const isMultiTouch = this._activePointers.length >= 2;
          if (isMultiTouch) {
            const dx = _v22.x - this._activePointers[1].clientX;
            const dy = _v22.y - this._activePointers[1].clientY;
            const distance = Math.sqrt(dx * dx + dy * dy);
            dollyStart.set(0, distance);
            const x = (this._activePointers[0].clientX + this._activePointers[1].clientX) * 0.5;
            const y2 = (this._activePointers[0].clientY + this._activePointers[1].clientY) * 0.5;
            lastDragPosition.set(x, y2);
          }
          this._state = 0;
          if (!event) {
            if (this._lockedPointer)
              this._state = this._state | this.mouseButtons.left;
          } else if ("pointerType" in event && event.pointerType === "touch") {
            switch (this._activePointers.length) {
              case 1:
                this._state = this.touches.one;
                break;
              case 2:
                this._state = this.touches.two;
                break;
              case 3:
                this._state = this.touches.three;
                break;
            }
          } else {
            if (!this._lockedPointer && (event.buttons & MOUSE_BUTTON.LEFT) === MOUSE_BUTTON.LEFT) {
              this._state = this._state | this.mouseButtons.left;
            }
            if ((event.buttons & MOUSE_BUTTON.MIDDLE) === MOUSE_BUTTON.MIDDLE) {
              this._state = this._state | this.mouseButtons.middle;
            }
            if ((event.buttons & MOUSE_BUTTON.RIGHT) === MOUSE_BUTTON.RIGHT) {
              this._state = this._state | this.mouseButtons.right;
            }
          }
          if ((this._state & ACTION.ROTATE) === ACTION.ROTATE || (this._state & ACTION.TOUCH_ROTATE) === ACTION.TOUCH_ROTATE || (this._state & ACTION.TOUCH_DOLLY_ROTATE) === ACTION.TOUCH_DOLLY_ROTATE || (this._state & ACTION.TOUCH_ZOOM_ROTATE) === ACTION.TOUCH_ZOOM_ROTATE) {
            this._sphericalEnd.theta = this._spherical.theta;
            this._sphericalEnd.phi = this._spherical.phi;
            this._thetaVelocity.value = 0;
            this._phiVelocity.value = 0;
          }
          if ((this._state & ACTION.TRUCK) === ACTION.TRUCK || (this._state & ACTION.TOUCH_TRUCK) === ACTION.TOUCH_TRUCK || (this._state & ACTION.TOUCH_DOLLY_TRUCK) === ACTION.TOUCH_DOLLY_TRUCK || (this._state & ACTION.TOUCH_ZOOM_TRUCK) === ACTION.TOUCH_ZOOM_TRUCK) {
            this._targetEnd.copy(this._target);
            this._targetVelocity.set(0, 0, 0);
          }
          if ((this._state & ACTION.DOLLY) === ACTION.DOLLY || (this._state & ACTION.TOUCH_DOLLY) === ACTION.TOUCH_DOLLY || (this._state & ACTION.TOUCH_DOLLY_TRUCK) === ACTION.TOUCH_DOLLY_TRUCK || (this._state & ACTION.TOUCH_DOLLY_OFFSET) === ACTION.TOUCH_DOLLY_OFFSET || (this._state & ACTION.TOUCH_DOLLY_ROTATE) === ACTION.TOUCH_DOLLY_ROTATE) {
            this._sphericalEnd.radius = this._spherical.radius;
            this._radiusVelocity.value = 0;
          }
          if ((this._state & ACTION.ZOOM) === ACTION.ZOOM || (this._state & ACTION.TOUCH_ZOOM) === ACTION.TOUCH_ZOOM || (this._state & ACTION.TOUCH_ZOOM_TRUCK) === ACTION.TOUCH_ZOOM_TRUCK || (this._state & ACTION.TOUCH_ZOOM_OFFSET) === ACTION.TOUCH_ZOOM_OFFSET || (this._state & ACTION.TOUCH_ZOOM_ROTATE) === ACTION.TOUCH_ZOOM_ROTATE) {
            this._zoomEnd = this._zoom;
            this._zoomVelocity.value = 0;
          }
          if ((this._state & ACTION.OFFSET) === ACTION.OFFSET || (this._state & ACTION.TOUCH_OFFSET) === ACTION.TOUCH_OFFSET || (this._state & ACTION.TOUCH_DOLLY_OFFSET) === ACTION.TOUCH_DOLLY_OFFSET || (this._state & ACTION.TOUCH_ZOOM_OFFSET) === ACTION.TOUCH_ZOOM_OFFSET) {
            this._focalOffsetEnd.copy(this._focalOffset);
            this._focalOffsetVelocity.set(0, 0, 0);
          }
          this.dispatchEvent({ type: "controlstart" });
        };
        const dragging = () => {
          if (!this._enabled || !this._dragNeedsUpdate)
            return;
          this._dragNeedsUpdate = false;
          extractClientCoordFromEvent(this._activePointers, _v22);
          const isPointerLockActive = this._domElement && this._domElement.ownerDocument.pointerLockElement === this._domElement;
          const lockedPointer = isPointerLockActive ? this._lockedPointer || this._activePointers[0] : null;
          const deltaX = lockedPointer ? -lockedPointer.deltaX : lastDragPosition.x - _v22.x;
          const deltaY = lockedPointer ? -lockedPointer.deltaY : lastDragPosition.y - _v22.y;
          lastDragPosition.copy(_v22);
          if ((this._state & ACTION.ROTATE) === ACTION.ROTATE || (this._state & ACTION.TOUCH_ROTATE) === ACTION.TOUCH_ROTATE || (this._state & ACTION.TOUCH_DOLLY_ROTATE) === ACTION.TOUCH_DOLLY_ROTATE || (this._state & ACTION.TOUCH_ZOOM_ROTATE) === ACTION.TOUCH_ZOOM_ROTATE) {
            this._rotateInternal(deltaX, deltaY);
            this._isUserControllingRotate = true;
          }
          if ((this._state & ACTION.DOLLY) === ACTION.DOLLY || (this._state & ACTION.ZOOM) === ACTION.ZOOM) {
            const dollyX = this.dollyToCursor ? (dragStartPosition.x - this._elementRect.x) / this._elementRect.width * 2 - 1 : 0;
            const dollyY = this.dollyToCursor ? (dragStartPosition.y - this._elementRect.y) / this._elementRect.height * -2 + 1 : 0;
            const dollyDirection = this.dollyDragInverted ? -1 : 1;
            if ((this._state & ACTION.DOLLY) === ACTION.DOLLY) {
              this._dollyInternal(dollyDirection * deltaY * TOUCH_DOLLY_FACTOR, dollyX, dollyY);
              this._isUserControllingDolly = true;
            } else {
              this._zoomInternal(dollyDirection * deltaY * TOUCH_DOLLY_FACTOR, dollyX, dollyY);
              this._isUserControllingZoom = true;
            }
          }
          if ((this._state & ACTION.TOUCH_DOLLY) === ACTION.TOUCH_DOLLY || (this._state & ACTION.TOUCH_ZOOM) === ACTION.TOUCH_ZOOM || (this._state & ACTION.TOUCH_DOLLY_TRUCK) === ACTION.TOUCH_DOLLY_TRUCK || (this._state & ACTION.TOUCH_ZOOM_TRUCK) === ACTION.TOUCH_ZOOM_TRUCK || (this._state & ACTION.TOUCH_DOLLY_OFFSET) === ACTION.TOUCH_DOLLY_OFFSET || (this._state & ACTION.TOUCH_ZOOM_OFFSET) === ACTION.TOUCH_ZOOM_OFFSET || (this._state & ACTION.TOUCH_DOLLY_ROTATE) === ACTION.TOUCH_DOLLY_ROTATE || (this._state & ACTION.TOUCH_ZOOM_ROTATE) === ACTION.TOUCH_ZOOM_ROTATE) {
            const dx = _v22.x - this._activePointers[1].clientX;
            const dy = _v22.y - this._activePointers[1].clientY;
            const distance = Math.sqrt(dx * dx + dy * dy);
            const dollyDelta = dollyStart.y - distance;
            dollyStart.set(0, distance);
            const dollyX = this.dollyToCursor ? (lastDragPosition.x - this._elementRect.x) / this._elementRect.width * 2 - 1 : 0;
            const dollyY = this.dollyToCursor ? (lastDragPosition.y - this._elementRect.y) / this._elementRect.height * -2 + 1 : 0;
            if ((this._state & ACTION.TOUCH_DOLLY) === ACTION.TOUCH_DOLLY || (this._state & ACTION.TOUCH_DOLLY_ROTATE) === ACTION.TOUCH_DOLLY_ROTATE || (this._state & ACTION.TOUCH_DOLLY_TRUCK) === ACTION.TOUCH_DOLLY_TRUCK || (this._state & ACTION.TOUCH_DOLLY_OFFSET) === ACTION.TOUCH_DOLLY_OFFSET) {
              this._dollyInternal(dollyDelta * TOUCH_DOLLY_FACTOR, dollyX, dollyY);
              this._isUserControllingDolly = true;
            } else {
              this._zoomInternal(dollyDelta * TOUCH_DOLLY_FACTOR, dollyX, dollyY);
              this._isUserControllingZoom = true;
            }
          }
          if ((this._state & ACTION.TRUCK) === ACTION.TRUCK || (this._state & ACTION.TOUCH_TRUCK) === ACTION.TOUCH_TRUCK || (this._state & ACTION.TOUCH_DOLLY_TRUCK) === ACTION.TOUCH_DOLLY_TRUCK || (this._state & ACTION.TOUCH_ZOOM_TRUCK) === ACTION.TOUCH_ZOOM_TRUCK) {
            this._truckInternal(deltaX, deltaY, false);
            this._isUserControllingTruck = true;
          }
          if ((this._state & ACTION.OFFSET) === ACTION.OFFSET || (this._state & ACTION.TOUCH_OFFSET) === ACTION.TOUCH_OFFSET || (this._state & ACTION.TOUCH_DOLLY_OFFSET) === ACTION.TOUCH_DOLLY_OFFSET || (this._state & ACTION.TOUCH_ZOOM_OFFSET) === ACTION.TOUCH_ZOOM_OFFSET) {
            this._truckInternal(deltaX, deltaY, true);
            this._isUserControllingOffset = true;
          }
          this.dispatchEvent({ type: "control" });
        };
        const endDragging = () => {
          extractClientCoordFromEvent(this._activePointers, _v22);
          lastDragPosition.copy(_v22);
          this._dragNeedsUpdate = false;
          if (this._activePointers.length === 0 || this._activePointers.length === 1 && this._activePointers[0] === this._lockedPointer) {
            this._isDragging = false;
          }
          if (this._activePointers.length === 0 && this._domElement) {
            this._domElement.ownerDocument.removeEventListener("pointermove", onPointerMove, { passive: false });
            this._domElement.ownerDocument.removeEventListener("pointerup", onPointerUp);
            this.dispatchEvent({ type: "controlend" });
          }
        };
        this.lockPointer = () => {
          if (!this._enabled || !this._domElement)
            return;
          this.cancel();
          this._lockedPointer = {
            pointerId: -1,
            clientX: 0,
            clientY: 0,
            deltaX: 0,
            deltaY: 0,
            mouseButton: null
          };
          this._activePointers.push(this._lockedPointer);
          this._domElement.ownerDocument.removeEventListener("pointermove", onPointerMove, { passive: false });
          this._domElement.ownerDocument.removeEventListener("pointerup", onPointerUp);
          this._domElement.requestPointerLock();
          this._domElement.ownerDocument.addEventListener("pointerlockchange", onPointerLockChange);
          this._domElement.ownerDocument.addEventListener("pointerlockerror", onPointerLockError);
          this._domElement.ownerDocument.addEventListener("pointermove", onPointerMove, { passive: false });
          this._domElement.ownerDocument.addEventListener("pointerup", onPointerUp);
          startDragging();
        };
        this.unlockPointer = () => {
          var _a22, _b2, _c;
          if (this._lockedPointer !== null) {
            this._disposePointer(this._lockedPointer);
            this._lockedPointer = null;
          }
          (_a22 = this._domElement) === null || _a22 === void 0 ? void 0 : _a22.ownerDocument.exitPointerLock();
          (_b2 = this._domElement) === null || _b2 === void 0 ? void 0 : _b2.ownerDocument.removeEventListener("pointerlockchange", onPointerLockChange);
          (_c = this._domElement) === null || _c === void 0 ? void 0 : _c.ownerDocument.removeEventListener("pointerlockerror", onPointerLockError);
          this.cancel();
        };
        const onPointerLockChange = () => {
          const isPointerLockActive = this._domElement && this._domElement.ownerDocument.pointerLockElement === this._domElement;
          if (!isPointerLockActive)
            this.unlockPointer();
        };
        const onPointerLockError = () => {
          this.unlockPointer();
        };
        this._addAllEventListeners = (domElement2) => {
          this._domElement = domElement2;
          this._domElement.style.touchAction = "none";
          this._domElement.style.userSelect = "none";
          this._domElement.style.webkitUserSelect = "none";
          this._domElement.addEventListener("pointerdown", onPointerDown);
          this._domElement.addEventListener("pointercancel", onPointerUp);
          this._domElement.addEventListener("wheel", onMouseWheel, { passive: false });
          this._domElement.addEventListener("contextmenu", onContextMenu);
        };
        this._removeAllEventListeners = () => {
          if (!this._domElement)
            return;
          this._domElement.style.touchAction = "";
          this._domElement.style.userSelect = "";
          this._domElement.style.webkitUserSelect = "";
          this._domElement.removeEventListener("pointerdown", onPointerDown);
          this._domElement.removeEventListener("pointercancel", onPointerUp);
          this._domElement.removeEventListener("wheel", onMouseWheel, { passive: false });
          this._domElement.removeEventListener("contextmenu", onContextMenu);
          this._domElement.ownerDocument.removeEventListener("pointermove", onPointerMove, { passive: false });
          this._domElement.ownerDocument.removeEventListener("pointerup", onPointerUp);
          this._domElement.ownerDocument.removeEventListener("pointerlockchange", onPointerLockChange);
          this._domElement.ownerDocument.removeEventListener("pointerlockerror", onPointerLockError);
        };
        this.cancel = () => {
          if (this._state === ACTION.NONE)
            return;
          this._state = ACTION.NONE;
          this._activePointers.length = 0;
          endDragging();
        };
        if (domElement)
          this.connect(domElement);
        this.update(0);
      }
      /**
       * The camera to be controlled
       * @category Properties
       */
      get camera() {
        return this._camera;
      }
      set camera(camera) {
        this._camera = camera;
        this.updateCameraUp();
        this._camera.updateProjectionMatrix();
        this._updateNearPlaneCorners();
        this._needsUpdate = true;
      }
      /**
       * Whether or not the controls are enabled.
       * `false` to disable user dragging/touch-move, but all methods works.
       * @category Properties
       */
      get enabled() {
        return this._enabled;
      }
      set enabled(enabled) {
        this._enabled = enabled;
        if (!this._domElement)
          return;
        if (enabled) {
          this._domElement.style.touchAction = "none";
          this._domElement.style.userSelect = "none";
          this._domElement.style.webkitUserSelect = "none";
        } else {
          this.cancel();
          this._domElement.style.touchAction = "";
          this._domElement.style.userSelect = "";
          this._domElement.style.webkitUserSelect = "";
        }
      }
      /**
       * Returns `true` if the controls are active updating.
       * readonly value.
       * @category Properties
       */
      get active() {
        return !this._hasRested;
      }
      /**
       * Getter for the current `ACTION`.
       * readonly value.
       * @category Properties
       */
      get currentAction() {
        return this._state;
      }
      /**
       * get/set Current distance.
       * @category Properties
       */
      get distance() {
        return this._spherical.radius;
      }
      set distance(distance) {
        if (this._spherical.radius === distance && this._sphericalEnd.radius === distance)
          return;
        this._spherical.radius = distance;
        this._sphericalEnd.radius = distance;
        this._needsUpdate = true;
      }
      // horizontal angle
      /**
       * get/set the azimuth angle (horizontal) in radians.
       * Every 360 degrees turn is added to `.azimuthAngle` value, which is accumulative.
       * @category Properties
       */
      get azimuthAngle() {
        return this._spherical.theta;
      }
      set azimuthAngle(azimuthAngle) {
        if (this._spherical.theta === azimuthAngle && this._sphericalEnd.theta === azimuthAngle)
          return;
        this._spherical.theta = azimuthAngle;
        this._sphericalEnd.theta = azimuthAngle;
        this._needsUpdate = true;
      }
      // vertical angle
      /**
       * get/set the polar angle (vertical) in radians.
       * @category Properties
       */
      get polarAngle() {
        return this._spherical.phi;
      }
      set polarAngle(polarAngle) {
        if (this._spherical.phi === polarAngle && this._sphericalEnd.phi === polarAngle)
          return;
        this._spherical.phi = polarAngle;
        this._sphericalEnd.phi = polarAngle;
        this._needsUpdate = true;
      }
      /**
       * Whether camera position should be enclosed in the boundary or not.
       * @category Properties
       */
      get boundaryEnclosesCamera() {
        return this._boundaryEnclosesCamera;
      }
      set boundaryEnclosesCamera(boundaryEnclosesCamera) {
        this._boundaryEnclosesCamera = boundaryEnclosesCamera;
        this._needsUpdate = true;
      }
      /**
       * Set drag-start, touches and wheel enable area in the domElement.
       * each values are between `0` and `1` inclusive, where `0` is left/top and `1` is right/bottom of the screen.
       * e.g. `{ x: 0, y: 0, width: 1, height: 1 }` for entire area.
       * @category Properties
       */
      set interactiveArea(interactiveArea) {
        this._interactiveArea.width = clamp2(interactiveArea.width, 0, 1);
        this._interactiveArea.height = clamp2(interactiveArea.height, 0, 1);
        this._interactiveArea.x = clamp2(interactiveArea.x, 0, 1 - this._interactiveArea.width);
        this._interactiveArea.y = clamp2(interactiveArea.y, 0, 1 - this._interactiveArea.height);
      }
      /**
       * Adds the specified event listener.
       * Applicable event types (which is `K`) are:
       * | Event name          | Timing |
       * | ------------------- | ------ |
       * | `'controlstart'`    | When the user starts to control the camera via mouse / touches. ¹ |
       * | `'control'`         | When the user controls the camera (dragging). |
       * | `'controlend'`      | When the user ends to control the camera. ¹ |
       * | `'transitionstart'` | When any kind of transition starts, either user control or using a method with `enableTransition = true` |
       * | `'update'`          | When the camera position is updated. |
       * | `'wake'`            | When the camera starts moving. |
       * | `'rest'`            | When the camera movement is below `.restThreshold` ². |
       * | `'sleep'`           | When the camera end moving. |
       *
       * 1. `mouseButtons.wheel` (Mouse wheel control) does not emit `'controlstart'` and `'controlend'`. `mouseButtons.wheel` uses scroll-event internally, and scroll-event happens intermittently. That means "start" and "end" cannot be detected.
       * 2. Due to damping, `sleep` will usually fire a few seconds after the camera _appears_ to have stopped moving. If you want to do something (e.g. enable UI, perform another transition) at the point when the camera has stopped, you probably want the `rest` event. This can be fine tuned using the `.restThreshold` parameter. See the [Rest and Sleep Example](https://yomotsu.github.io/camera-controls/examples/rest-and-sleep.html).
       *
       * e.g.
       * ```
       * cameraControl.addEventListener( 'controlstart', myCallbackFunction );
       * ```
       * @param type event name
       * @param listener handler function
       * @category Methods
       */
      addEventListener(type, listener) {
        super.addEventListener(type, listener);
      }
      /**
       * Removes the specified event listener
       * e.g.
       * ```
       * cameraControl.addEventListener( 'controlstart', myCallbackFunction );
       * ```
       * @param type event name
       * @param listener handler function
       * @category Methods
       */
      removeEventListener(type, listener) {
        super.removeEventListener(type, listener);
      }
      /**
       * Rotate azimuthal angle(horizontal) and polar angle(vertical).
       * Every value is added to the current value.
       * @param azimuthAngle Azimuth rotate angle. In radian.
       * @param polarAngle Polar rotate angle. In radian.
       * @param enableTransition Whether to move smoothly or immediately
       * @category Methods
       */
      rotate(azimuthAngle, polarAngle, enableTransition = false) {
        return this.rotateTo(this._sphericalEnd.theta + azimuthAngle, this._sphericalEnd.phi + polarAngle, enableTransition);
      }
      /**
       * Rotate azimuthal angle(horizontal) to the given angle and keep the same polar angle(vertical) target.
       *
       * e.g.
       * ```
       * cameraControls.rotateAzimuthTo( 30 * THREE.MathUtils.DEG2RAD, true );
       * ```
       * @param azimuthAngle Azimuth rotate angle. In radian.
       * @param enableTransition Whether to move smoothly or immediately
       * @category Methods
       */
      rotateAzimuthTo(azimuthAngle, enableTransition = false) {
        return this.rotateTo(azimuthAngle, this._sphericalEnd.phi, enableTransition);
      }
      /**
       * Rotate polar angle(vertical) to the given angle and keep the same azimuthal angle(horizontal) target.
       *
       * e.g.
       * ```
       * cameraControls.rotatePolarTo( 30 * THREE.MathUtils.DEG2RAD, true );
       * ```
       * @param polarAngle Polar rotate angle. In radian.
       * @param enableTransition Whether to move smoothly or immediately
       * @category Methods
       */
      rotatePolarTo(polarAngle, enableTransition = false) {
        return this.rotateTo(this._sphericalEnd.theta, polarAngle, enableTransition);
      }
      /**
       * Rotate azimuthal angle(horizontal) and polar angle(vertical) to the given angle.
       * Camera view will rotate over the orbit pivot absolutely:
       *
       * azimuthAngle
       * ```
       *       0º
       *         \
       * 90º -----+----- -90º
       *           \
       *           180º
       * ```
       * | direction | angle                  |
       * | --------- | ---------------------- |
       * | front     | 0º                     |
       * | left      | 90º (`Math.PI / 2`)    |
       * | right     | -90º (`- Math.PI / 2`) |
       * | back      | 180º (`Math.PI`)       |
       *
       * polarAngle
       * ```
       *     180º
       *      |
       *      90º
       *      |
       *      0º
       * ```
       * | direction            | angle                  |
       * | -------------------- | ---------------------- |
       * | top/sky              | 180º (`Math.PI`)       |
       * | horizontal from view | 90º (`Math.PI / 2`)    |
       * | bottom/floor         | 0º                     |
       *
       * @param azimuthAngle Azimuth rotate angle to. In radian.
       * @param polarAngle Polar rotate angle to. In radian.
       * @param enableTransition  Whether to move smoothly or immediately
       * @category Methods
       */
      rotateTo(azimuthAngle, polarAngle, enableTransition = false) {
        this._isUserControllingRotate = false;
        const theta = clamp2(azimuthAngle, this.minAzimuthAngle, this.maxAzimuthAngle);
        const phi = clamp2(polarAngle, this.minPolarAngle, this.maxPolarAngle);
        this._sphericalEnd.theta = theta;
        this._sphericalEnd.phi = phi;
        this._sphericalEnd.makeSafe();
        this._needsUpdate = true;
        if (!enableTransition) {
          this._spherical.theta = this._sphericalEnd.theta;
          this._spherical.phi = this._sphericalEnd.phi;
        }
        const resolveImmediately = !enableTransition || approxEquals(this._spherical.theta, this._sphericalEnd.theta, this.restThreshold) && approxEquals(this._spherical.phi, this._sphericalEnd.phi, this.restThreshold);
        return this._createOnRestPromise(resolveImmediately);
      }
      /**
       * Dolly in/out camera position.
       * @param distance Distance of dollyIn. Negative number for dollyOut.
       * @param enableTransition Whether to move smoothly or immediately.
       * @category Methods
       */
      dolly(distance, enableTransition = false) {
        return this.dollyTo(this._sphericalEnd.radius - distance, enableTransition);
      }
      /**
       * Dolly in/out camera position to given distance.
       * @param distance Distance of dolly.
       * @param enableTransition Whether to move smoothly or immediately.
       * @category Methods
       */
      dollyTo(distance, enableTransition = false) {
        this._isUserControllingDolly = false;
        this._lastDollyDirection = DOLLY_DIRECTION.NONE;
        this._changedDolly = 0;
        return this._dollyToNoClamp(clamp2(distance, this.minDistance, this.maxDistance), enableTransition);
      }
      _dollyToNoClamp(distance, enableTransition = false) {
        const lastRadius = this._sphericalEnd.radius;
        const hasCollider = this.colliderMeshes.length >= 1;
        if (hasCollider) {
          const maxDistanceByCollisionTest = this._collisionTest();
          const isCollided = approxEquals(maxDistanceByCollisionTest, this._spherical.radius);
          const isDollyIn = lastRadius > distance;
          if (!isDollyIn && isCollided)
            return Promise.resolve();
          this._sphericalEnd.radius = Math.min(distance, maxDistanceByCollisionTest);
        } else {
          this._sphericalEnd.radius = distance;
        }
        this._needsUpdate = true;
        if (!enableTransition) {
          this._spherical.radius = this._sphericalEnd.radius;
        }
        const resolveImmediately = !enableTransition || approxEquals(this._spherical.radius, this._sphericalEnd.radius, this.restThreshold);
        return this._createOnRestPromise(resolveImmediately);
      }
      /**
       * Dolly in, but does not change the distance between the target and the camera, and moves the target position instead.
       * Specify a negative value for dolly out.
       * @param distance Distance of dolly.
       * @param enableTransition Whether to move smoothly or immediately.
       * @category Methods
       */
      dollyInFixed(distance, enableTransition = false) {
        this._targetEnd.add(this._getCameraDirection(_cameraDirection).multiplyScalar(distance));
        if (!enableTransition) {
          this._target.copy(this._targetEnd);
        }
        const resolveImmediately = !enableTransition || approxEquals(this._target.x, this._targetEnd.x, this.restThreshold) && approxEquals(this._target.y, this._targetEnd.y, this.restThreshold) && approxEquals(this._target.z, this._targetEnd.z, this.restThreshold);
        return this._createOnRestPromise(resolveImmediately);
      }
      /**
       * Zoom in/out camera. The value is added to camera zoom.
       * Limits set with `.minZoom` and `.maxZoom`
       * @param zoomStep zoom scale
       * @param enableTransition Whether to move smoothly or immediately
       * @category Methods
       */
      zoom(zoomStep, enableTransition = false) {
        return this.zoomTo(this._zoomEnd + zoomStep, enableTransition);
      }
      /**
       * Zoom in/out camera to given scale. The value overwrites camera zoom.
       * Limits set with .minZoom and .maxZoom
       * @param zoom
       * @param enableTransition
       * @category Methods
       */
      zoomTo(zoom, enableTransition = false) {
        this._isUserControllingZoom = false;
        this._zoomEnd = clamp2(zoom, this.minZoom, this.maxZoom);
        this._needsUpdate = true;
        if (!enableTransition) {
          this._zoom = this._zoomEnd;
        }
        const resolveImmediately = !enableTransition || approxEquals(this._zoom, this._zoomEnd, this.restThreshold);
        this._changedZoom = 0;
        return this._createOnRestPromise(resolveImmediately);
      }
      /**
       * @deprecated `pan()` has been renamed to `truck()`
       * @category Methods
       */
      pan(x, y2, enableTransition = false) {
        console.warn("`pan` has been renamed to `truck`");
        return this.truck(x, y2, enableTransition);
      }
      /**
       * Truck and pedestal camera using current azimuthal angle
       * @param x Horizontal translate amount
       * @param y Vertical translate amount
       * @param enableTransition Whether to move smoothly or immediately
       * @category Methods
       */
      truck(x, y2, enableTransition = false) {
        this._camera.updateMatrix();
        _xColumn.setFromMatrixColumn(this._camera.matrix, 0);
        _yColumn.setFromMatrixColumn(this._camera.matrix, 1);
        _xColumn.multiplyScalar(x);
        _yColumn.multiplyScalar(-y2);
        const offset = _v3A.copy(_xColumn).add(_yColumn);
        const to = _v3B.copy(this._targetEnd).add(offset);
        return this.moveTo(to.x, to.y, to.z, enableTransition);
      }
      /**
       * Move forward / backward.
       * @param distance Amount to move forward / backward. Negative value to move backward
       * @param enableTransition Whether to move smoothly or immediately
       * @category Methods
       */
      forward(distance, enableTransition = false) {
        _v3A.setFromMatrixColumn(this._camera.matrix, 0);
        _v3A.crossVectors(this._camera.up, _v3A);
        _v3A.multiplyScalar(distance);
        const to = _v3B.copy(this._targetEnd).add(_v3A);
        return this.moveTo(to.x, to.y, to.z, enableTransition);
      }
      /**
       * Move up / down.
       * @param height Amount to move up / down. Negative value to move down
       * @param enableTransition Whether to move smoothly or immediately
       * @category Methods
       */
      elevate(height, enableTransition = false) {
        _v3A.copy(this._camera.up).multiplyScalar(height);
        return this.moveTo(this._targetEnd.x + _v3A.x, this._targetEnd.y + _v3A.y, this._targetEnd.z + _v3A.z, enableTransition);
      }
      /**
       * Move target position to given point.
       * @param x x coord to move center position
       * @param y y coord to move center position
       * @param z z coord to move center position
       * @param enableTransition Whether to move smoothly or immediately
       * @category Methods
       */
      moveTo(x, y2, z2, enableTransition = false) {
        this._isUserControllingTruck = false;
        const offset = _v3A.set(x, y2, z2).sub(this._targetEnd);
        this._encloseToBoundary(this._targetEnd, offset, this.boundaryFriction);
        this._needsUpdate = true;
        if (!enableTransition) {
          this._target.copy(this._targetEnd);
        }
        const resolveImmediately = !enableTransition || approxEquals(this._target.x, this._targetEnd.x, this.restThreshold) && approxEquals(this._target.y, this._targetEnd.y, this.restThreshold) && approxEquals(this._target.z, this._targetEnd.z, this.restThreshold);
        return this._createOnRestPromise(resolveImmediately);
      }
      /**
       * Look in the given point direction.
       * @param x point x.
       * @param y point y.
       * @param z point z.
       * @param enableTransition Whether to move smoothly or immediately.
       * @returns Transition end promise
       * @category Methods
       */
      lookInDirectionOf(x, y2, z2, enableTransition = false) {
        const point = _v3A.set(x, y2, z2);
        const direction = point.sub(this._targetEnd).normalize();
        const position = direction.multiplyScalar(-this._sphericalEnd.radius).add(this._targetEnd);
        return this.setPosition(position.x, position.y, position.z, enableTransition);
      }
      /**
       * Fit the viewport to the box or the bounding box of the object, using the nearest axis. paddings are in unit.
       * set `cover: true` to fill enter screen.
       * e.g.
       * ```
       * cameraControls.fitToBox( myMesh );
       * ```
       * @param box3OrObject Axis aligned bounding box to fit the view.
       * @param enableTransition Whether to move smoothly or immediately.
       * @param options | `<object>` { cover: boolean, paddingTop: number, paddingLeft: number, paddingBottom: number, paddingRight: number }
       * @returns Transition end promise
       * @category Methods
       */
      fitToBox(box3OrObject, enableTransition, { cover: cover2 = false, paddingLeft = 0, paddingRight = 0, paddingBottom = 0, paddingTop = 0 } = {}) {
        const promises = [];
        const aabb = box3OrObject.isBox3 ? _box3A.copy(box3OrObject) : _box3A.setFromObject(box3OrObject);
        if (aabb.isEmpty()) {
          console.warn("camera-controls: fitTo() cannot be used with an empty box. Aborting");
          Promise.resolve();
        }
        const theta = roundToStep(this._sphericalEnd.theta, PI_HALF);
        const phi = roundToStep(this._sphericalEnd.phi, PI_HALF);
        promises.push(this.rotateTo(theta, phi, enableTransition));
        const normal = _v3A.setFromSpherical(this._sphericalEnd).normalize();
        const rotation = _quaternionA.setFromUnitVectors(normal, _AXIS_Z);
        const viewFromPolar = approxEquals(Math.abs(normal.y), 1);
        if (viewFromPolar) {
          rotation.multiply(_quaternionB.setFromAxisAngle(_AXIS_Y, theta));
        }
        rotation.multiply(this._yAxisUpSpaceInverse);
        const bb = _box3B.makeEmpty();
        _v3B.copy(aabb.min).applyQuaternion(rotation);
        bb.expandByPoint(_v3B);
        _v3B.copy(aabb.min).setX(aabb.max.x).applyQuaternion(rotation);
        bb.expandByPoint(_v3B);
        _v3B.copy(aabb.min).setY(aabb.max.y).applyQuaternion(rotation);
        bb.expandByPoint(_v3B);
        _v3B.copy(aabb.max).setZ(aabb.min.z).applyQuaternion(rotation);
        bb.expandByPoint(_v3B);
        _v3B.copy(aabb.min).setZ(aabb.max.z).applyQuaternion(rotation);
        bb.expandByPoint(_v3B);
        _v3B.copy(aabb.max).setY(aabb.min.y).applyQuaternion(rotation);
        bb.expandByPoint(_v3B);
        _v3B.copy(aabb.max).setX(aabb.min.x).applyQuaternion(rotation);
        bb.expandByPoint(_v3B);
        _v3B.copy(aabb.max).applyQuaternion(rotation);
        bb.expandByPoint(_v3B);
        bb.min.x -= paddingLeft;
        bb.min.y -= paddingBottom;
        bb.max.x += paddingRight;
        bb.max.y += paddingTop;
        rotation.setFromUnitVectors(_AXIS_Z, normal);
        if (viewFromPolar) {
          rotation.premultiply(_quaternionB.invert());
        }
        rotation.premultiply(this._yAxisUpSpace);
        const bbSize = bb.getSize(_v3A);
        const center = bb.getCenter(_v3B).applyQuaternion(rotation);
        if (isPerspectiveCamera(this._camera)) {
          const distance = this.getDistanceToFitBox(bbSize.x, bbSize.y, bbSize.z, cover2);
          promises.push(this.moveTo(center.x, center.y, center.z, enableTransition));
          promises.push(this.dollyTo(distance, enableTransition));
          promises.push(this.setFocalOffset(0, 0, 0, enableTransition));
        } else if (isOrthographicCamera2(this._camera)) {
          const camera = this._camera;
          const width = camera.right - camera.left;
          const height = camera.top - camera.bottom;
          const zoom = cover2 ? Math.max(width / bbSize.x, height / bbSize.y) : Math.min(width / bbSize.x, height / bbSize.y);
          promises.push(this.moveTo(center.x, center.y, center.z, enableTransition));
          promises.push(this.zoomTo(zoom, enableTransition));
          promises.push(this.setFocalOffset(0, 0, 0, enableTransition));
        }
        return Promise.all(promises);
      }
      /**
       * Fit the viewport to the sphere or the bounding sphere of the object.
       * @param sphereOrMesh
       * @param enableTransition
       * @category Methods
       */
      fitToSphere(sphereOrMesh, enableTransition) {
        const promises = [];
        const isObject3D = "isObject3D" in sphereOrMesh;
        const boundingSphere = isObject3D ? _CameraControls.createBoundingSphere(sphereOrMesh, _sphere2) : _sphere2.copy(sphereOrMesh);
        promises.push(this.moveTo(boundingSphere.center.x, boundingSphere.center.y, boundingSphere.center.z, enableTransition));
        if (isPerspectiveCamera(this._camera)) {
          const distanceToFit = this.getDistanceToFitSphere(boundingSphere.radius);
          promises.push(this.dollyTo(distanceToFit, enableTransition));
        } else if (isOrthographicCamera2(this._camera)) {
          const width = this._camera.right - this._camera.left;
          const height = this._camera.top - this._camera.bottom;
          const diameter = 2 * boundingSphere.radius;
          const zoom = Math.min(width / diameter, height / diameter);
          promises.push(this.zoomTo(zoom, enableTransition));
        }
        promises.push(this.setFocalOffset(0, 0, 0, enableTransition));
        return Promise.all(promises);
      }
      /**
       * Look at the `target` from the `position`.
       * @param positionX
       * @param positionY
       * @param positionZ
       * @param targetX
       * @param targetY
       * @param targetZ
       * @param enableTransition
       * @category Methods
       */
      setLookAt(positionX, positionY, positionZ, targetX, targetY, targetZ, enableTransition = false) {
        this._isUserControllingRotate = false;
        this._isUserControllingDolly = false;
        this._isUserControllingTruck = false;
        this._lastDollyDirection = DOLLY_DIRECTION.NONE;
        this._changedDolly = 0;
        const target2 = _v3B.set(targetX, targetY, targetZ);
        const position = _v3A.set(positionX, positionY, positionZ);
        this._targetEnd.copy(target2);
        this._sphericalEnd.setFromVector3(position.sub(target2).applyQuaternion(this._yAxisUpSpace));
        this.normalizeRotations();
        this._needsUpdate = true;
        if (!enableTransition) {
          this._target.copy(this._targetEnd);
          this._spherical.copy(this._sphericalEnd);
        }
        const resolveImmediately = !enableTransition || approxEquals(this._target.x, this._targetEnd.x, this.restThreshold) && approxEquals(this._target.y, this._targetEnd.y, this.restThreshold) && approxEquals(this._target.z, this._targetEnd.z, this.restThreshold) && approxEquals(this._spherical.theta, this._sphericalEnd.theta, this.restThreshold) && approxEquals(this._spherical.phi, this._sphericalEnd.phi, this.restThreshold) && approxEquals(this._spherical.radius, this._sphericalEnd.radius, this.restThreshold);
        return this._createOnRestPromise(resolveImmediately);
      }
      /**
       * Similar to setLookAt, but it interpolates between two states.
       * @param positionAX
       * @param positionAY
       * @param positionAZ
       * @param targetAX
       * @param targetAY
       * @param targetAZ
       * @param positionBX
       * @param positionBY
       * @param positionBZ
       * @param targetBX
       * @param targetBY
       * @param targetBZ
       * @param t
       * @param enableTransition
       * @category Methods
       */
      lerpLookAt(positionAX, positionAY, positionAZ, targetAX, targetAY, targetAZ, positionBX, positionBY, positionBZ, targetBX, targetBY, targetBZ, t2, enableTransition = false) {
        this._isUserControllingRotate = false;
        this._isUserControllingDolly = false;
        this._isUserControllingTruck = false;
        this._lastDollyDirection = DOLLY_DIRECTION.NONE;
        this._changedDolly = 0;
        const targetA = _v3A.set(targetAX, targetAY, targetAZ);
        const positionA = _v3B.set(positionAX, positionAY, positionAZ);
        _sphericalA.setFromVector3(positionA.sub(targetA).applyQuaternion(this._yAxisUpSpace));
        const targetB = _v3C.set(targetBX, targetBY, targetBZ);
        const positionB = _v3B.set(positionBX, positionBY, positionBZ);
        _sphericalB.setFromVector3(positionB.sub(targetB).applyQuaternion(this._yAxisUpSpace));
        this._targetEnd.copy(targetA.lerp(targetB, t2));
        const deltaTheta = _sphericalB.theta - _sphericalA.theta;
        const deltaPhi = _sphericalB.phi - _sphericalA.phi;
        const deltaRadius = _sphericalB.radius - _sphericalA.radius;
        this._sphericalEnd.set(_sphericalA.radius + deltaRadius * t2, _sphericalA.phi + deltaPhi * t2, _sphericalA.theta + deltaTheta * t2);
        this.normalizeRotations();
        this._needsUpdate = true;
        if (!enableTransition) {
          this._target.copy(this._targetEnd);
          this._spherical.copy(this._sphericalEnd);
        }
        const resolveImmediately = !enableTransition || approxEquals(this._target.x, this._targetEnd.x, this.restThreshold) && approxEquals(this._target.y, this._targetEnd.y, this.restThreshold) && approxEquals(this._target.z, this._targetEnd.z, this.restThreshold) && approxEquals(this._spherical.theta, this._sphericalEnd.theta, this.restThreshold) && approxEquals(this._spherical.phi, this._sphericalEnd.phi, this.restThreshold) && approxEquals(this._spherical.radius, this._sphericalEnd.radius, this.restThreshold);
        return this._createOnRestPromise(resolveImmediately);
      }
      /**
       * Set angle and distance by given position.
       * An alias of `setLookAt()`, without target change. Thus keep gazing at the current target
       * @param positionX
       * @param positionY
       * @param positionZ
       * @param enableTransition
       * @category Methods
       */
      setPosition(positionX, positionY, positionZ, enableTransition = false) {
        return this.setLookAt(positionX, positionY, positionZ, this._targetEnd.x, this._targetEnd.y, this._targetEnd.z, enableTransition);
      }
      /**
       * Set the target position where gaze at.
       * An alias of `setLookAt()`, without position change. Thus keep the same position.
       * @param targetX
       * @param targetY
       * @param targetZ
       * @param enableTransition
       * @category Methods
       */
      setTarget(targetX, targetY, targetZ, enableTransition = false) {
        const pos = this.getPosition(_v3A);
        const promise = this.setLookAt(pos.x, pos.y, pos.z, targetX, targetY, targetZ, enableTransition);
        this._sphericalEnd.phi = clamp2(this._sphericalEnd.phi, this.minPolarAngle, this.maxPolarAngle);
        return promise;
      }
      /**
       * Set focal offset using the screen parallel coordinates. z doesn't affect in Orthographic as with Dolly.
       * @param x
       * @param y
       * @param z
       * @param enableTransition
       * @category Methods
       */
      setFocalOffset(x, y2, z2, enableTransition = false) {
        this._isUserControllingOffset = false;
        this._focalOffsetEnd.set(x, y2, z2);
        this._needsUpdate = true;
        if (!enableTransition)
          this._focalOffset.copy(this._focalOffsetEnd);
        const resolveImmediately = !enableTransition || approxEquals(this._focalOffset.x, this._focalOffsetEnd.x, this.restThreshold) && approxEquals(this._focalOffset.y, this._focalOffsetEnd.y, this.restThreshold) && approxEquals(this._focalOffset.z, this._focalOffsetEnd.z, this.restThreshold);
        return this._createOnRestPromise(resolveImmediately);
      }
      /**
       * Set orbit point without moving the camera.
       * SHOULD NOT RUN DURING ANIMATIONS. `setOrbitPoint()` will immediately fix the positions.
       * @param targetX
       * @param targetY
       * @param targetZ
       * @category Methods
       */
      setOrbitPoint(targetX, targetY, targetZ) {
        this._camera.updateMatrixWorld();
        _xColumn.setFromMatrixColumn(this._camera.matrixWorldInverse, 0);
        _yColumn.setFromMatrixColumn(this._camera.matrixWorldInverse, 1);
        _zColumn.setFromMatrixColumn(this._camera.matrixWorldInverse, 2);
        const position = _v3A.set(targetX, targetY, targetZ);
        const distance = position.distanceTo(this._camera.position);
        const cameraToPoint = position.sub(this._camera.position);
        _xColumn.multiplyScalar(cameraToPoint.x);
        _yColumn.multiplyScalar(cameraToPoint.y);
        _zColumn.multiplyScalar(cameraToPoint.z);
        _v3A.copy(_xColumn).add(_yColumn).add(_zColumn);
        _v3A.z = _v3A.z + distance;
        this.dollyTo(distance, false);
        this.setFocalOffset(-_v3A.x, _v3A.y, -_v3A.z, false);
        this.moveTo(targetX, targetY, targetZ, false);
      }
      /**
       * Set the boundary box that encloses the target of the camera. box3 is in THREE.Box3
       * @param box3
       * @category Methods
       */
      setBoundary(box3) {
        if (!box3) {
          this._boundary.min.set(-Infinity, -Infinity, -Infinity);
          this._boundary.max.set(Infinity, Infinity, Infinity);
          this._needsUpdate = true;
          return;
        }
        this._boundary.copy(box3);
        this._boundary.clampPoint(this._targetEnd, this._targetEnd);
        this._needsUpdate = true;
      }
      /**
       * Set (or unset) the current viewport.
       * Set this when you want to use renderer viewport and .dollyToCursor feature at the same time.
       * @param viewportOrX
       * @param y
       * @param width
       * @param height
       * @category Methods
       */
      setViewport(viewportOrX, y2, width, height) {
        if (viewportOrX === null) {
          this._viewport = null;
          return;
        }
        this._viewport = this._viewport || new THREE.Vector4();
        if (typeof viewportOrX === "number") {
          this._viewport.set(viewportOrX, y2, width, height);
        } else {
          this._viewport.copy(viewportOrX);
        }
      }
      /**
       * Calculate the distance to fit the box.
       * @param width box width
       * @param height box height
       * @param depth box depth
       * @returns distance
       * @category Methods
       */
      getDistanceToFitBox(width, height, depth, cover2 = false) {
        if (notSupportedInOrthographicCamera(this._camera, "getDistanceToFitBox"))
          return this._spherical.radius;
        const boundingRectAspect = width / height;
        const fov2 = this._camera.getEffectiveFOV() * DEG2RAD2;
        const aspect2 = this._camera.aspect;
        const heightToFit = (cover2 ? boundingRectAspect > aspect2 : boundingRectAspect < aspect2) ? height : width / aspect2;
        return heightToFit * 0.5 / Math.tan(fov2 * 0.5) + depth * 0.5;
      }
      /**
       * Calculate the distance to fit the sphere.
       * @param radius sphere radius
       * @returns distance
       * @category Methods
       */
      getDistanceToFitSphere(radius) {
        if (notSupportedInOrthographicCamera(this._camera, "getDistanceToFitSphere"))
          return this._spherical.radius;
        const vFOV = this._camera.getEffectiveFOV() * DEG2RAD2;
        const hFOV = Math.atan(Math.tan(vFOV * 0.5) * this._camera.aspect) * 2;
        const fov2 = 1 < this._camera.aspect ? vFOV : hFOV;
        return radius / Math.sin(fov2 * 0.5);
      }
      /**
       * Returns the orbit center position, where the camera looking at.
       * @param out The receiving Vector3 instance to copy the result
       * @param receiveEndValue Whether receive the transition end coords or current. default is `true`
       * @category Methods
       */
      getTarget(out, receiveEndValue = true) {
        const _out = !!out && out.isVector3 ? out : new THREE.Vector3();
        return _out.copy(receiveEndValue ? this._targetEnd : this._target);
      }
      /**
       * Returns the camera position.
       * @param out The receiving Vector3 instance to copy the result
       * @param receiveEndValue Whether receive the transition end coords or current. default is `true`
       * @category Methods
       */
      getPosition(out, receiveEndValue = true) {
        const _out = !!out && out.isVector3 ? out : new THREE.Vector3();
        return _out.setFromSpherical(receiveEndValue ? this._sphericalEnd : this._spherical).applyQuaternion(this._yAxisUpSpaceInverse).add(receiveEndValue ? this._targetEnd : this._target);
      }
      /**
       * Returns the spherical coordinates of the orbit.
       * @param out The receiving Spherical instance to copy the result
       * @param receiveEndValue Whether receive the transition end coords or current. default is `true`
       * @category Methods
       */
      getSpherical(out, receiveEndValue = true) {
        const _out = out || new THREE.Spherical();
        return _out.copy(receiveEndValue ? this._sphericalEnd : this._spherical);
      }
      /**
       * Returns the focal offset, which is how much the camera appears to be translated in screen parallel coordinates.
       * @param out The receiving Vector3 instance to copy the result
       * @param receiveEndValue Whether receive the transition end coords or current. default is `true`
       * @category Methods
       */
      getFocalOffset(out, receiveEndValue = true) {
        const _out = !!out && out.isVector3 ? out : new THREE.Vector3();
        return _out.copy(receiveEndValue ? this._focalOffsetEnd : this._focalOffset);
      }
      /**
       * Normalize camera azimuth angle rotation between 0 and 360 degrees.
       * @category Methods
       */
      normalizeRotations() {
        this._sphericalEnd.theta = this._sphericalEnd.theta % PI_2;
        if (this._sphericalEnd.theta < 0)
          this._sphericalEnd.theta += PI_2;
        this._spherical.theta += PI_2 * Math.round((this._sphericalEnd.theta - this._spherical.theta) / PI_2);
      }
      /**
       * stop all transitions.
       */
      stop() {
        this._focalOffset.copy(this._focalOffsetEnd);
        this._target.copy(this._targetEnd);
        this._spherical.copy(this._sphericalEnd);
        this._zoom = this._zoomEnd;
      }
      /**
       * Reset all rotation and position to defaults.
       * @param enableTransition
       * @category Methods
       */
      reset(enableTransition = false) {
        if (!approxEquals(this._camera.up.x, this._cameraUp0.x) || !approxEquals(this._camera.up.y, this._cameraUp0.y) || !approxEquals(this._camera.up.z, this._cameraUp0.z)) {
          this._camera.up.copy(this._cameraUp0);
          const position = this.getPosition(_v3A);
          this.updateCameraUp();
          this.setPosition(position.x, position.y, position.z);
        }
        const promises = [
          this.setLookAt(this._position0.x, this._position0.y, this._position0.z, this._target0.x, this._target0.y, this._target0.z, enableTransition),
          this.setFocalOffset(this._focalOffset0.x, this._focalOffset0.y, this._focalOffset0.z, enableTransition),
          this.zoomTo(this._zoom0, enableTransition)
        ];
        return Promise.all(promises);
      }
      /**
       * Set current camera position as the default position.
       * @category Methods
       */
      saveState() {
        this._cameraUp0.copy(this._camera.up);
        this.getTarget(this._target0);
        this.getPosition(this._position0);
        this._zoom0 = this._zoom;
        this._focalOffset0.copy(this._focalOffset);
      }
      /**
       * Sync camera-up direction.
       * When camera-up vector is changed, `.updateCameraUp()` must be called.
       * @category Methods
       */
      updateCameraUp() {
        this._yAxisUpSpace.setFromUnitVectors(this._camera.up, _AXIS_Y);
        this._yAxisUpSpaceInverse.copy(this._yAxisUpSpace).invert();
      }
      /**
       * Apply current camera-up direction to the camera.
       * The orbit system will be re-initialized with the current position.
       * @category Methods
       */
      applyCameraUp() {
        const cameraDirection = _v3A.subVectors(this._target, this._camera.position).normalize();
        const side = _v3B.crossVectors(cameraDirection, this._camera.up);
        this._camera.up.crossVectors(side, cameraDirection).normalize();
        this._camera.updateMatrixWorld();
        const position = this.getPosition(_v3A);
        this.updateCameraUp();
        this.setPosition(position.x, position.y, position.z);
      }
      /**
       * Update camera position and directions.
       * This should be called in your tick loop every time, and returns true if re-rendering is needed.
       * @param delta
       * @returns updated
       * @category Methods
       */
      update(delta) {
        const deltaTheta = this._sphericalEnd.theta - this._spherical.theta;
        const deltaPhi = this._sphericalEnd.phi - this._spherical.phi;
        const deltaRadius = this._sphericalEnd.radius - this._spherical.radius;
        const deltaTarget = _deltaTarget.subVectors(this._targetEnd, this._target);
        const deltaOffset = _deltaOffset.subVectors(this._focalOffsetEnd, this._focalOffset);
        const deltaZoom = this._zoomEnd - this._zoom;
        if (approxZero(deltaTheta)) {
          this._thetaVelocity.value = 0;
          this._spherical.theta = this._sphericalEnd.theta;
        } else {
          const smoothTime = this._isUserControllingRotate ? this.draggingSmoothTime : this.smoothTime;
          this._spherical.theta = smoothDamp(this._spherical.theta, this._sphericalEnd.theta, this._thetaVelocity, smoothTime, Infinity, delta);
          this._needsUpdate = true;
        }
        if (approxZero(deltaPhi)) {
          this._phiVelocity.value = 0;
          this._spherical.phi = this._sphericalEnd.phi;
        } else {
          const smoothTime = this._isUserControllingRotate ? this.draggingSmoothTime : this.smoothTime;
          this._spherical.phi = smoothDamp(this._spherical.phi, this._sphericalEnd.phi, this._phiVelocity, smoothTime, Infinity, delta);
          this._needsUpdate = true;
        }
        if (approxZero(deltaRadius)) {
          this._radiusVelocity.value = 0;
          this._spherical.radius = this._sphericalEnd.radius;
        } else {
          const smoothTime = this._isUserControllingDolly ? this.draggingSmoothTime : this.smoothTime;
          this._spherical.radius = smoothDamp(this._spherical.radius, this._sphericalEnd.radius, this._radiusVelocity, smoothTime, this.maxSpeed, delta);
          this._needsUpdate = true;
        }
        if (approxZero(deltaTarget.x) && approxZero(deltaTarget.y) && approxZero(deltaTarget.z)) {
          this._targetVelocity.set(0, 0, 0);
          this._target.copy(this._targetEnd);
        } else {
          const smoothTime = this._isUserControllingTruck ? this.draggingSmoothTime : this.smoothTime;
          smoothDampVec3(this._target, this._targetEnd, this._targetVelocity, smoothTime, this.maxSpeed, delta, this._target);
          this._needsUpdate = true;
        }
        if (approxZero(deltaOffset.x) && approxZero(deltaOffset.y) && approxZero(deltaOffset.z)) {
          this._focalOffsetVelocity.set(0, 0, 0);
          this._focalOffset.copy(this._focalOffsetEnd);
        } else {
          const smoothTime = this._isUserControllingOffset ? this.draggingSmoothTime : this.smoothTime;
          smoothDampVec3(this._focalOffset, this._focalOffsetEnd, this._focalOffsetVelocity, smoothTime, this.maxSpeed, delta, this._focalOffset);
          this._needsUpdate = true;
        }
        if (approxZero(deltaZoom)) {
          this._zoomVelocity.value = 0;
          this._zoom = this._zoomEnd;
        } else {
          const smoothTime = this._isUserControllingZoom ? this.draggingSmoothTime : this.smoothTime;
          this._zoom = smoothDamp(this._zoom, this._zoomEnd, this._zoomVelocity, smoothTime, Infinity, delta);
        }
        if (this.dollyToCursor) {
          if (isPerspectiveCamera(this._camera) && this._changedDolly !== 0) {
            const dollyControlAmount = this._spherical.radius - this._lastDistance;
            const camera = this._camera;
            const cameraDirection = this._getCameraDirection(_cameraDirection);
            const planeX = _v3A.copy(cameraDirection).cross(camera.up).normalize();
            if (planeX.lengthSq() === 0)
              planeX.x = 1;
            const planeY = _v3B.crossVectors(planeX, cameraDirection);
            const worldToScreen = this._sphericalEnd.radius * Math.tan(camera.getEffectiveFOV() * DEG2RAD2 * 0.5);
            const prevRadius = this._sphericalEnd.radius - dollyControlAmount;
            const lerpRatio = (prevRadius - this._sphericalEnd.radius) / this._sphericalEnd.radius;
            const cursor = _v3C.copy(this._targetEnd).add(planeX.multiplyScalar(this._dollyControlCoord.x * worldToScreen * camera.aspect)).add(planeY.multiplyScalar(this._dollyControlCoord.y * worldToScreen));
            const newTargetEnd = _v3A.copy(this._targetEnd).lerp(cursor, lerpRatio);
            const isMin = this._lastDollyDirection === DOLLY_DIRECTION.IN && this._spherical.radius <= this.minDistance;
            const isMax = this._lastDollyDirection === DOLLY_DIRECTION.OUT && this.maxDistance <= this._spherical.radius;
            if (this.infinityDolly && (isMin || isMax)) {
              this._sphericalEnd.radius -= dollyControlAmount;
              this._spherical.radius -= dollyControlAmount;
              const dollyAmount = _v3B.copy(cameraDirection).multiplyScalar(-dollyControlAmount);
              newTargetEnd.add(dollyAmount);
            }
            this._boundary.clampPoint(newTargetEnd, newTargetEnd);
            const targetEndDiff = _v3B.subVectors(newTargetEnd, this._targetEnd);
            this._targetEnd.copy(newTargetEnd);
            this._target.add(targetEndDiff);
            this._changedDolly -= dollyControlAmount;
            if (approxZero(this._changedDolly))
              this._changedDolly = 0;
          } else if (isOrthographicCamera2(this._camera) && this._changedZoom !== 0) {
            const dollyControlAmount = this._zoom - this._lastZoom;
            const camera = this._camera;
            const worldCursorPosition = _v3A.set(this._dollyControlCoord.x, this._dollyControlCoord.y, (camera.near + camera.far) / (camera.near - camera.far)).unproject(camera);
            const quaternion = _v3B.set(0, 0, -1).applyQuaternion(camera.quaternion);
            const cursor = _v3C.copy(worldCursorPosition).add(quaternion.multiplyScalar(-worldCursorPosition.dot(camera.up)));
            const prevZoom = this._zoom - dollyControlAmount;
            const lerpRatio = -(prevZoom - this._zoom) / this._zoom;
            const cameraDirection = this._getCameraDirection(_cameraDirection);
            const prevPlaneConstant = this._targetEnd.dot(cameraDirection);
            const newTargetEnd = _v3A.copy(this._targetEnd).lerp(cursor, lerpRatio);
            const newPlaneConstant = newTargetEnd.dot(cameraDirection);
            const pullBack = cameraDirection.multiplyScalar(newPlaneConstant - prevPlaneConstant);
            newTargetEnd.sub(pullBack);
            this._boundary.clampPoint(newTargetEnd, newTargetEnd);
            const targetEndDiff = _v3B.subVectors(newTargetEnd, this._targetEnd);
            this._targetEnd.copy(newTargetEnd);
            this._target.add(targetEndDiff);
            this._changedZoom -= dollyControlAmount;
            if (approxZero(this._changedZoom))
              this._changedZoom = 0;
          }
        }
        if (this._camera.zoom !== this._zoom) {
          this._camera.zoom = this._zoom;
          this._camera.updateProjectionMatrix();
          this._updateNearPlaneCorners();
          this._needsUpdate = true;
        }
        this._dragNeedsUpdate = true;
        const maxDistance = this._collisionTest();
        this._spherical.radius = Math.min(this._spherical.radius, maxDistance);
        this._spherical.makeSafe();
        this._camera.position.setFromSpherical(this._spherical).applyQuaternion(this._yAxisUpSpaceInverse).add(this._target);
        this._camera.lookAt(this._target);
        const affectOffset = !approxZero(this._focalOffset.x) || !approxZero(this._focalOffset.y) || !approxZero(this._focalOffset.z);
        if (affectOffset) {
          this._camera.updateMatrixWorld();
          _xColumn.setFromMatrixColumn(this._camera.matrix, 0);
          _yColumn.setFromMatrixColumn(this._camera.matrix, 1);
          _zColumn.setFromMatrixColumn(this._camera.matrix, 2);
          _xColumn.multiplyScalar(this._focalOffset.x);
          _yColumn.multiplyScalar(-this._focalOffset.y);
          _zColumn.multiplyScalar(this._focalOffset.z);
          _v3A.copy(_xColumn).add(_yColumn).add(_zColumn);
          this._camera.position.add(_v3A);
        }
        if (this._boundaryEnclosesCamera) {
          this._encloseToBoundary(this._camera.position.copy(this._target), _v3A.setFromSpherical(this._spherical).applyQuaternion(this._yAxisUpSpaceInverse), 1);
        }
        const updated = this._needsUpdate;
        if (updated && !this._updatedLastTime) {
          this._hasRested = false;
          this.dispatchEvent({ type: "wake" });
          this.dispatchEvent({ type: "update" });
        } else if (updated) {
          this.dispatchEvent({ type: "update" });
          if (approxZero(deltaTheta, this.restThreshold) && approxZero(deltaPhi, this.restThreshold) && approxZero(deltaRadius, this.restThreshold) && approxZero(deltaTarget.x, this.restThreshold) && approxZero(deltaTarget.y, this.restThreshold) && approxZero(deltaTarget.z, this.restThreshold) && approxZero(deltaOffset.x, this.restThreshold) && approxZero(deltaOffset.y, this.restThreshold) && approxZero(deltaOffset.z, this.restThreshold) && approxZero(deltaZoom, this.restThreshold) && !this._hasRested) {
            this._hasRested = true;
            this.dispatchEvent({ type: "rest" });
          }
        } else if (!updated && this._updatedLastTime) {
          this.dispatchEvent({ type: "sleep" });
        }
        this._lastDistance = this._spherical.radius;
        this._lastZoom = this._zoom;
        this._updatedLastTime = updated;
        this._needsUpdate = false;
        return updated;
      }
      /**
       * Get all state in JSON string
       * @category Methods
       */
      toJSON() {
        return JSON.stringify({
          enabled: this._enabled,
          minDistance: this.minDistance,
          maxDistance: infinityToMaxNumber(this.maxDistance),
          minZoom: this.minZoom,
          maxZoom: infinityToMaxNumber(this.maxZoom),
          minPolarAngle: this.minPolarAngle,
          maxPolarAngle: infinityToMaxNumber(this.maxPolarAngle),
          minAzimuthAngle: infinityToMaxNumber(this.minAzimuthAngle),
          maxAzimuthAngle: infinityToMaxNumber(this.maxAzimuthAngle),
          smoothTime: this.smoothTime,
          draggingSmoothTime: this.draggingSmoothTime,
          dollySpeed: this.dollySpeed,
          truckSpeed: this.truckSpeed,
          dollyToCursor: this.dollyToCursor,
          verticalDragToForward: this.verticalDragToForward,
          target: this._targetEnd.toArray(),
          position: _v3A.setFromSpherical(this._sphericalEnd).add(this._targetEnd).toArray(),
          zoom: this._zoomEnd,
          focalOffset: this._focalOffsetEnd.toArray(),
          target0: this._target0.toArray(),
          position0: this._position0.toArray(),
          zoom0: this._zoom0,
          focalOffset0: this._focalOffset0.toArray()
        });
      }
      /**
       * Reproduce the control state with JSON. enableTransition is where anim or not in a boolean.
       * @param json
       * @param enableTransition
       * @category Methods
       */
      fromJSON(json, enableTransition = false) {
        const obj = JSON.parse(json);
        this.enabled = obj.enabled;
        this.minDistance = obj.minDistance;
        this.maxDistance = maxNumberToInfinity(obj.maxDistance);
        this.minZoom = obj.minZoom;
        this.maxZoom = maxNumberToInfinity(obj.maxZoom);
        this.minPolarAngle = obj.minPolarAngle;
        this.maxPolarAngle = maxNumberToInfinity(obj.maxPolarAngle);
        this.minAzimuthAngle = maxNumberToInfinity(obj.minAzimuthAngle);
        this.maxAzimuthAngle = maxNumberToInfinity(obj.maxAzimuthAngle);
        this.smoothTime = obj.smoothTime;
        this.draggingSmoothTime = obj.draggingSmoothTime;
        this.dollySpeed = obj.dollySpeed;
        this.truckSpeed = obj.truckSpeed;
        this.dollyToCursor = obj.dollyToCursor;
        this.verticalDragToForward = obj.verticalDragToForward;
        this._target0.fromArray(obj.target0);
        this._position0.fromArray(obj.position0);
        this._zoom0 = obj.zoom0;
        this._focalOffset0.fromArray(obj.focalOffset0);
        this.moveTo(obj.target[0], obj.target[1], obj.target[2], enableTransition);
        _sphericalA.setFromVector3(_v3A.fromArray(obj.position).sub(this._targetEnd).applyQuaternion(this._yAxisUpSpace));
        this.rotateTo(_sphericalA.theta, _sphericalA.phi, enableTransition);
        this.dollyTo(_sphericalA.radius, enableTransition);
        this.zoomTo(obj.zoom, enableTransition);
        this.setFocalOffset(obj.focalOffset[0], obj.focalOffset[1], obj.focalOffset[2], enableTransition);
        this._needsUpdate = true;
      }
      /**
       * Attach all internal event handlers to enable drag control.
       * @category Methods
       */
      connect(domElement) {
        if (this._domElement) {
          console.warn("camera-controls is already connected.");
          return;
        }
        domElement.setAttribute("data-camera-controls-version", VERSION);
        this._addAllEventListeners(domElement);
        this._getClientRect(this._elementRect);
      }
      /**
       * Detach all internal event handlers to disable drag control.
       */
      disconnect() {
        this.cancel();
        this._removeAllEventListeners();
        if (this._domElement) {
          this._domElement.removeAttribute("data-camera-controls-version");
          this._domElement = void 0;
        }
      }
      /**
       * Dispose the cameraControls instance itself, remove all eventListeners.
       * @category Methods
       */
      dispose() {
        this.removeAllEventListeners();
        this.disconnect();
      }
      // it's okay to expose public though
      _getTargetDirection(out) {
        return out.setFromSpherical(this._spherical).divideScalar(this._spherical.radius).applyQuaternion(this._yAxisUpSpaceInverse);
      }
      // it's okay to expose public though
      _getCameraDirection(out) {
        return this._getTargetDirection(out).negate();
      }
      _findPointerById(pointerId) {
        return this._activePointers.find((activePointer) => activePointer.pointerId === pointerId);
      }
      _findPointerByMouseButton(mouseButton) {
        return this._activePointers.find((activePointer) => activePointer.mouseButton === mouseButton);
      }
      _disposePointer(pointer) {
        this._activePointers.splice(this._activePointers.indexOf(pointer), 1);
      }
      _encloseToBoundary(position, offset, friction) {
        const offsetLength2 = offset.lengthSq();
        if (offsetLength2 === 0) {
          return position;
        }
        const newTarget = _v3B.copy(offset).add(position);
        const clampedTarget = this._boundary.clampPoint(newTarget, _v3C);
        const deltaClampedTarget = clampedTarget.sub(newTarget);
        const deltaClampedTargetLength2 = deltaClampedTarget.lengthSq();
        if (deltaClampedTargetLength2 === 0) {
          return position.add(offset);
        } else if (deltaClampedTargetLength2 === offsetLength2) {
          return position;
        } else if (friction === 0) {
          return position.add(offset).add(deltaClampedTarget);
        } else {
          const offsetFactor = 1 + friction * deltaClampedTargetLength2 / offset.dot(deltaClampedTarget);
          return position.add(_v3B.copy(offset).multiplyScalar(offsetFactor)).add(deltaClampedTarget.multiplyScalar(1 - friction));
        }
      }
      _updateNearPlaneCorners() {
        if (isPerspectiveCamera(this._camera)) {
          const camera = this._camera;
          const near = camera.near;
          const fov2 = camera.getEffectiveFOV() * DEG2RAD2;
          const heightHalf = Math.tan(fov2 * 0.5) * near;
          const widthHalf = heightHalf * camera.aspect;
          this._nearPlaneCorners[0].set(-widthHalf, -heightHalf, 0);
          this._nearPlaneCorners[1].set(widthHalf, -heightHalf, 0);
          this._nearPlaneCorners[2].set(widthHalf, heightHalf, 0);
          this._nearPlaneCorners[3].set(-widthHalf, heightHalf, 0);
        } else if (isOrthographicCamera2(this._camera)) {
          const camera = this._camera;
          const zoomInv = 1 / camera.zoom;
          const left = camera.left * zoomInv;
          const right = camera.right * zoomInv;
          const top = camera.top * zoomInv;
          const bottom = camera.bottom * zoomInv;
          this._nearPlaneCorners[0].set(left, top, 0);
          this._nearPlaneCorners[1].set(right, top, 0);
          this._nearPlaneCorners[2].set(right, bottom, 0);
          this._nearPlaneCorners[3].set(left, bottom, 0);
        }
      }
      // lateUpdate
      _collisionTest() {
        let distance = Infinity;
        const hasCollider = this.colliderMeshes.length >= 1;
        if (!hasCollider)
          return distance;
        if (notSupportedInOrthographicCamera(this._camera, "_collisionTest"))
          return distance;
        const rayDirection = this._getTargetDirection(_cameraDirection);
        _rotationMatrix.lookAt(_ORIGIN, rayDirection, this._camera.up);
        for (let i2 = 0; i2 < 4; i2++) {
          const nearPlaneCorner = _v3B.copy(this._nearPlaneCorners[i2]);
          nearPlaneCorner.applyMatrix4(_rotationMatrix);
          const origin = _v3C.addVectors(this._target, nearPlaneCorner);
          _raycaster.set(origin, rayDirection);
          _raycaster.far = this._spherical.radius + 1;
          const intersects2 = _raycaster.intersectObjects(this.colliderMeshes);
          if (intersects2.length !== 0 && intersects2[0].distance < distance) {
            distance = intersects2[0].distance;
          }
        }
        return distance;
      }
      /**
       * Get its client rect and package into given `DOMRect` .
       */
      _getClientRect(target2) {
        if (!this._domElement)
          return;
        const rect = this._domElement.getBoundingClientRect();
        target2.x = rect.left;
        target2.y = rect.top;
        if (this._viewport) {
          target2.x += this._viewport.x;
          target2.y += rect.height - this._viewport.w - this._viewport.y;
          target2.width = this._viewport.z;
          target2.height = this._viewport.w;
        } else {
          target2.width = rect.width;
          target2.height = rect.height;
        }
        return target2;
      }
      _createOnRestPromise(resolveImmediately) {
        if (resolveImmediately)
          return Promise.resolve();
        this._hasRested = false;
        this.dispatchEvent({ type: "transitionstart" });
        return new Promise((resolve2) => {
          const onResolve = () => {
            this.removeEventListener("rest", onResolve);
            resolve2();
          };
          this.addEventListener("rest", onResolve);
        });
      }
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      _addAllEventListeners(_domElement) {
      }
      _removeAllEventListeners() {
      }
      /**
       * backward compatible
       * @deprecated use smoothTime (in seconds) instead
       * @category Properties
       */
      get dampingFactor() {
        console.warn(".dampingFactor has been deprecated. use smoothTime (in seconds) instead.");
        return 0;
      }
      /**
       * backward compatible
       * @deprecated use smoothTime (in seconds) instead
       * @category Properties
       */
      set dampingFactor(_) {
        console.warn(".dampingFactor has been deprecated. use smoothTime (in seconds) instead.");
      }
      /**
       * backward compatible
       * @deprecated use draggingSmoothTime (in seconds) instead
       * @category Properties
       */
      get draggingDampingFactor() {
        console.warn(".draggingDampingFactor has been deprecated. use draggingSmoothTime (in seconds) instead.");
        return 0;
      }
      /**
       * backward compatible
       * @deprecated use draggingSmoothTime (in seconds) instead
       * @category Properties
       */
      set draggingDampingFactor(_) {
        console.warn(".draggingDampingFactor has been deprecated. use draggingSmoothTime (in seconds) instead.");
      }
      static createBoundingSphere(object3d, out = new THREE.Sphere()) {
        const boundingSphere = out;
        const center = boundingSphere.center;
        _box3A.makeEmpty();
        object3d.traverseVisible((object) => {
          if (!object.isMesh)
            return;
          _box3A.expandByObject(object);
        });
        _box3A.getCenter(center);
        let maxRadiusSq = 0;
        object3d.traverseVisible((object) => {
          if (!object.isMesh)
            return;
          const mesh = object;
          const geometry = mesh.geometry.clone();
          geometry.applyMatrix4(mesh.matrixWorld);
          const bufferGeometry = geometry;
          const position = bufferGeometry.attributes.position;
          for (let i2 = 0, l2 = position.count; i2 < l2; i2++) {
            _v3A.fromBufferAttribute(position, i2);
            maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_v3A));
          }
        });
        boundingSphere.radius = Math.sqrt(maxRadiusSq);
        return boundingSphere;
      }
    };
  }
});

// ../shadergradient-v2/dist/chunk-3SCKP3WD.mjs
import { Fragment as Fragment4, jsx as jsx7 } from "react/jsx-runtime";
function Controls2(props) {
  return /* @__PURE__ */ jsx7(Fragment4, { children: /* @__PURE__ */ jsx7(CameraControl, __spreadValues({}, props)) });
}
var init_chunk_3SCKP3WD = __esm({
  "../shadergradient-v2/dist/chunk-3SCKP3WD.mjs"() {
    init_chunk_M2MFZVXL();
    init_chunk_5BEQP2BQ();
  }
});

// ../shadergradient-v2/dist/chunk-6A4LZ7FD.mjs
var RGBELoader, version2, UV1;
var init_chunk_6A4LZ7FD = __esm({
  "../shadergradient-v2/dist/chunk-6A4LZ7FD.mjs"() {
    init_chunk_BT6X4JN2();
    RGBELoader = class extends DataTextureLoader {
      constructor(manager) {
        super(manager);
        this.type = HalfFloatType;
      }
      // adapted from http://www.graphics.cornell.edu/~bjw/rgbe.html
      parse(buffer) {
        const rgbe_read_error = 1, rgbe_write_error = 2, rgbe_format_error = 3, rgbe_memory_error = 4, rgbe_error = function(rgbe_error_code, msg) {
          switch (rgbe_error_code) {
            case rgbe_read_error:
              throw new Error("THREE.RGBELoader: Read Error: " + (msg || ""));
            case rgbe_write_error:
              throw new Error("THREE.RGBELoader: Write Error: " + (msg || ""));
            case rgbe_format_error:
              throw new Error("THREE.RGBELoader: Bad File Format: " + (msg || ""));
            default:
            case rgbe_memory_error:
              throw new Error("THREE.RGBELoader: Memory Error: " + (msg || ""));
          }
        }, RGBE_VALID_PROGRAMTYPE = 1, RGBE_VALID_FORMAT = 2, RGBE_VALID_DIMENSIONS = 4, NEWLINE = "\n", fgets = function(buffer2, lineLimit, consume) {
          const chunkSize = 128;
          lineLimit = !lineLimit ? 1024 : lineLimit;
          let p3 = buffer2.pos, i2 = -1, len = 0, s = "", chunk = String.fromCharCode.apply(null, new Uint16Array(buffer2.subarray(p3, p3 + chunkSize)));
          while (0 > (i2 = chunk.indexOf(NEWLINE)) && len < lineLimit && p3 < buffer2.byteLength) {
            s += chunk;
            len += chunk.length;
            p3 += chunkSize;
            chunk += String.fromCharCode.apply(null, new Uint16Array(buffer2.subarray(p3, p3 + chunkSize)));
          }
          if (-1 < i2) {
            if (false !== consume)
              buffer2.pos += len + i2 + 1;
            return s + chunk.slice(0, i2);
          }
          return false;
        }, RGBE_ReadHeader = function(buffer2) {
          const magic_token_re = /^#\?(\S+)/, gamma_re = /^\s*GAMMA\s*=\s*(\d+(\.\d+)?)\s*$/, exposure_re = /^\s*EXPOSURE\s*=\s*(\d+(\.\d+)?)\s*$/, format_re = /^\s*FORMAT=(\S+)\s*$/, dimensions_re = /^\s*\-Y\s+(\d+)\s+\+X\s+(\d+)\s*$/, header = {
            valid: 0,
            string: "",
            comments: "",
            programtype: "RGBE",
            format: "",
            gamma: 1,
            exposure: 1,
            width: 0,
            height: 0
          };
          let line, match;
          if (buffer2.pos >= buffer2.byteLength || !(line = fgets(buffer2))) {
            rgbe_error(rgbe_read_error, "no header found");
          }
          if (!(match = line.match(magic_token_re))) {
            rgbe_error(rgbe_format_error, "bad initial token");
          }
          header.valid |= RGBE_VALID_PROGRAMTYPE;
          header.programtype = match[1];
          header.string += line + "\n";
          while (true) {
            line = fgets(buffer2);
            if (false === line)
              break;
            header.string += line + "\n";
            if ("#" === line.charAt(0)) {
              header.comments += line + "\n";
              continue;
            }
            if (match = line.match(gamma_re)) {
              header.gamma = parseFloat(match[1]);
            }
            if (match = line.match(exposure_re)) {
              header.exposure = parseFloat(match[1]);
            }
            if (match = line.match(format_re)) {
              header.valid |= RGBE_VALID_FORMAT;
              header.format = match[1];
            }
            if (match = line.match(dimensions_re)) {
              header.valid |= RGBE_VALID_DIMENSIONS;
              header.height = parseInt(match[1], 10);
              header.width = parseInt(match[2], 10);
            }
            if (header.valid & RGBE_VALID_FORMAT && header.valid & RGBE_VALID_DIMENSIONS)
              break;
          }
          if (!(header.valid & RGBE_VALID_FORMAT)) {
            rgbe_error(rgbe_format_error, "missing format specifier");
          }
          if (!(header.valid & RGBE_VALID_DIMENSIONS)) {
            rgbe_error(rgbe_format_error, "missing image size specifier");
          }
          return header;
        }, RGBE_ReadPixels_RLE = function(buffer2, w2, h22) {
          const scanline_width = w2;
          if (
            // run length encoding is not allowed so read flat
            scanline_width < 8 || scanline_width > 32767 || // this file is not run length encoded
            2 !== buffer2[0] || 2 !== buffer2[1] || buffer2[2] & 128
          ) {
            return new Uint8Array(buffer2);
          }
          if (scanline_width !== (buffer2[2] << 8 | buffer2[3])) {
            rgbe_error(rgbe_format_error, "wrong scanline width");
          }
          const data_rgba = new Uint8Array(4 * w2 * h22);
          if (!data_rgba.length) {
            rgbe_error(rgbe_memory_error, "unable to allocate buffer space");
          }
          let offset = 0, pos = 0;
          const ptr_end = 4 * scanline_width;
          const rgbeStart = new Uint8Array(4);
          const scanline_buffer = new Uint8Array(ptr_end);
          let num_scanlines = h22;
          while (num_scanlines > 0 && pos < buffer2.byteLength) {
            if (pos + 4 > buffer2.byteLength) {
              rgbe_error(rgbe_read_error);
            }
            rgbeStart[0] = buffer2[pos++];
            rgbeStart[1] = buffer2[pos++];
            rgbeStart[2] = buffer2[pos++];
            rgbeStart[3] = buffer2[pos++];
            if (2 != rgbeStart[0] || 2 != rgbeStart[1] || (rgbeStart[2] << 8 | rgbeStart[3]) != scanline_width) {
              rgbe_error(rgbe_format_error, "bad rgbe scanline format");
            }
            let ptr = 0, count;
            while (ptr < ptr_end && pos < buffer2.byteLength) {
              count = buffer2[pos++];
              const isEncodedRun = count > 128;
              if (isEncodedRun)
                count -= 128;
              if (0 === count || ptr + count > ptr_end) {
                rgbe_error(rgbe_format_error, "bad scanline data");
              }
              if (isEncodedRun) {
                const byteValue = buffer2[pos++];
                for (let i2 = 0; i2 < count; i2++) {
                  scanline_buffer[ptr++] = byteValue;
                }
              } else {
                scanline_buffer.set(buffer2.subarray(pos, pos + count), ptr);
                ptr += count;
                pos += count;
              }
            }
            const l2 = scanline_width;
            for (let i2 = 0; i2 < l2; i2++) {
              let off = 0;
              data_rgba[offset] = scanline_buffer[i2 + off];
              off += scanline_width;
              data_rgba[offset + 1] = scanline_buffer[i2 + off];
              off += scanline_width;
              data_rgba[offset + 2] = scanline_buffer[i2 + off];
              off += scanline_width;
              data_rgba[offset + 3] = scanline_buffer[i2 + off];
              offset += 4;
            }
            num_scanlines--;
          }
          return data_rgba;
        };
        const RGBEByteToRGBFloat = function(sourceArray, sourceOffset, destArray, destOffset) {
          const e = sourceArray[sourceOffset + 3];
          const scale = Math.pow(2, e - 128) / 255;
          destArray[destOffset + 0] = sourceArray[sourceOffset + 0] * scale;
          destArray[destOffset + 1] = sourceArray[sourceOffset + 1] * scale;
          destArray[destOffset + 2] = sourceArray[sourceOffset + 2] * scale;
          destArray[destOffset + 3] = 1;
        };
        const RGBEByteToRGBHalf = function(sourceArray, sourceOffset, destArray, destOffset) {
          const e = sourceArray[sourceOffset + 3];
          const scale = Math.pow(2, e - 128) / 255;
          destArray[destOffset + 0] = DataUtils.toHalfFloat(Math.min(sourceArray[sourceOffset + 0] * scale, 65504));
          destArray[destOffset + 1] = DataUtils.toHalfFloat(Math.min(sourceArray[sourceOffset + 1] * scale, 65504));
          destArray[destOffset + 2] = DataUtils.toHalfFloat(Math.min(sourceArray[sourceOffset + 2] * scale, 65504));
          destArray[destOffset + 3] = DataUtils.toHalfFloat(1);
        };
        const byteArray = new Uint8Array(buffer);
        byteArray.pos = 0;
        const rgbe_header_info = RGBE_ReadHeader(byteArray);
        const w = rgbe_header_info.width, h2 = rgbe_header_info.height, image_rgba_data = RGBE_ReadPixels_RLE(byteArray.subarray(byteArray.pos), w, h2);
        let data, type;
        let numElements;
        switch (this.type) {
          case FloatType:
            numElements = image_rgba_data.length / 4;
            const floatArray = new Float32Array(numElements * 4);
            for (let j2 = 0; j2 < numElements; j2++) {
              RGBEByteToRGBFloat(image_rgba_data, j2 * 4, floatArray, j2 * 4);
            }
            data = floatArray;
            type = FloatType;
            break;
          case HalfFloatType:
            numElements = image_rgba_data.length / 4;
            const halfArray = new Uint16Array(numElements * 4);
            for (let j2 = 0; j2 < numElements; j2++) {
              RGBEByteToRGBHalf(image_rgba_data, j2 * 4, halfArray, j2 * 4);
            }
            data = halfArray;
            type = HalfFloatType;
            break;
          default:
            throw new Error("THREE.RGBELoader: Unsupported type: " + this.type);
        }
        return {
          width: w,
          height: h2,
          data,
          header: rgbe_header_info.string,
          gamma: rgbe_header_info.gamma,
          exposure: rgbe_header_info.exposure,
          type
        };
      }
      setDataType(value) {
        this.type = value;
        return this;
      }
      load(url, onLoad, onProgress, onError) {
        function onLoadCallback(texture, texData) {
          switch (texture.type) {
            case FloatType:
            case HalfFloatType:
              if ("colorSpace" in texture)
                texture.colorSpace = "srgb-linear";
              else
                texture.encoding = 3e3;
              texture.minFilter = LinearFilter;
              texture.magFilter = LinearFilter;
              texture.generateMipmaps = false;
              texture.flipY = true;
              break;
          }
          if (onLoad)
            onLoad(texture, texData);
        }
        return super.load(url, onLoadCallback, onProgress, onError);
      }
    };
    version2 = /* @__PURE__ */ (() => parseInt(REVISION.replace(/\D+/g, "")))();
    UV1 = version2 >= 125 ? "uv1" : "uv2";
  }
});

// ../shadergradient-v2/dist/chunk-MSKNCSEN.mjs
function useRGBELoader(file, { path }) {
  const cubeTexture = useLoader(
    // @ts-ignore
    RGBELoader,
    file,
    (loader) => loader.setPath(path)
  );
  return cubeTexture;
}
var init_chunk_MSKNCSEN = __esm({
  "../shadergradient-v2/dist/chunk-MSKNCSEN.mjs"() {
    init_chunk_6A4LZ7FD();
    init_chunk_73SH6GTX();
  }
});

// ../shadergradient-v2/dist/chunk-5HVKDCHP.mjs
import { useEffect as useEffect9, useState as useState4, useRef as useRef6 } from "react";
function useInView(enabled = true, threshold = 0.1) {
  const [isInView, setIsInView] = useState4(true);
  const containerRef = useRef6(null);
  useEffect9(() => {
    if (!enabled) return;
    const observer = new IntersectionObserver(
      ([entry]) => {
        setIsInView(entry.isIntersecting);
      },
      {
        threshold
      }
    );
    if (containerRef.current) {
      observer.observe(containerRef.current);
    }
    return () => observer.disconnect();
  }, [enabled, threshold]);
  return { isInView, containerRef };
}
var init_chunk_5HVKDCHP = __esm({
  "../shadergradient-v2/dist/chunk-5HVKDCHP.mjs"() {
  }
});

// ../shadergradient-v2/dist/chunk-UJ5V3DPG.mjs
import { useEffect as useEffect10, createContext as createContext3, useMemo as useMemo5, useContext as useContext3 } from "react";
import { jsx as jsx8 } from "react/jsx-runtime";
function ShaderGradientCanvas({
  children,
  style = {},
  pixelDensity = 1,
  fov: fov2 = 45,
  pointerEvents,
  className,
  envBasePath,
  lazyLoad = true,
  threshold = 0.1
}) {
  const { isInView, containerRef } = useInView(lazyLoad, threshold);
  const contextValue = useMemo5(
    () => ({ envBasePath }),
    [envBasePath]
  );
  useShaderChunkFix();
  return /* @__PURE__ */ jsx8("div", { ref: containerRef, style: __spreadValues({ width: "100%", height: "100%" }, style), children: (!lazyLoad || isInView) && /* @__PURE__ */ jsx8(Context.Provider, { value: contextValue, children: /* @__PURE__ */ jsx8(
    Canvas2,
    __spreadProps(__spreadValues({
      id: "gradientCanvas",
      style: { pointerEvents },
      resize: { offsetSize: true },
      className
    }, canvasProps(pixelDensity, fov2)), {
      children
    }),
    pixelDensity + fov2
  ) }) });
}
function useShaderChunkFix() {
  useEffect10(() => {
    ShaderChunk["uv2_pars_vertex"] = ``;
    ShaderChunk["uv2_vertex"] = ``;
    ShaderChunk["uv2_pars_fragment"] = ``;
    ShaderChunk["encodings_fragment"] = ``;
  }, []);
}
var Context, useShaderGradientCanvasContext;
var init_chunk_UJ5V3DPG = __esm({
  "../shadergradient-v2/dist/chunk-UJ5V3DPG.mjs"() {
    init_chunk_5HVKDCHP();
    init_chunk_73SH6GTX();
    init_chunk_BT6X4JN2();
    init_chunk_WPNBLVEI();
    init_chunk_5BEQP2BQ();
    Context = createContext3(
      {}
    );
    useShaderGradientCanvasContext = () => {
      return useContext3(Context);
    };
  }
});

// ../shadergradient-v2/dist/chunk-ZLTLOVKT.mjs
import React4 from "react";
function EnvironmentMap({ background = false, envPreset }) {
  const { envBasePath } = useShaderGradientCanvasContext();
  const path = envBasePath || defaultEnvBasePath;
  const city = useRGBELoader("city.hdr", { path });
  const dawn = useRGBELoader("dawn.hdr", { path });
  const lobby = useRGBELoader("lobby.hdr", { path });
  const textures = { city, dawn, lobby };
  const map = textures[envPreset];
  const defaultScene = useThree((state) => state.scene);
  React4.useLayoutEffect(() => {
    if (map) {
      const target2 = resolveScene(defaultScene);
      const oldbg = target2.background;
      const oldenv = target2.environment;
      if (background !== "only") target2.environment = map;
      if (background) target2.background = map;
      return () => {
        if (background !== "only") target2.environment = oldenv;
        if (background) target2.background = "black";
      };
    }
  }, [defaultScene, map, background]);
  const texture = map;
  texture.mapping = EquirectangularReflectionMapping;
  return null;
}
var isRef2, resolveScene;
var init_chunk_ZLTLOVKT = __esm({
  "../shadergradient-v2/dist/chunk-ZLTLOVKT.mjs"() {
    init_chunk_MSKNCSEN();
    init_chunk_UJ5V3DPG();
    init_chunk_73SH6GTX();
    init_chunk_BT6X4JN2();
    init_chunk_WPNBLVEI();
    isRef2 = (obj) => obj.current && obj.current.isScene;
    resolveScene = (scene) => isRef2(scene) ? scene.current : scene;
  }
});

// ../shadergradient-v2/dist/chunk-AX2D4CR5.mjs
import { Suspense as Suspense2 } from "react";
import { Fragment as Fragment5, jsx as jsx9, jsxs as jsxs3 } from "react/jsx-runtime";
function Lights({ lightType, brightness, envPreset }) {
  return /* @__PURE__ */ jsxs3(Fragment5, { children: [
    lightType === "3d" && /* @__PURE__ */ jsx9("ambientLight", { intensity: (brightness || 1) * Math.PI }),
    lightType === "env" && /* @__PURE__ */ jsx9(Suspense2, { fallback: /* @__PURE__ */ jsx9(Loader2, {}), children: /* @__PURE__ */ jsx9(
      EnvironmentMap,
      {
        envPreset,
        background: false,
        loadingCallback: () => void 0
      }
    ) })
  ] });
}
function Loader2() {
  return /* @__PURE__ */ jsx9("ambientLight", { intensity: 0.4 });
}
var init_chunk_AX2D4CR5 = __esm({
  "../shadergradient-v2/dist/chunk-AX2D4CR5.mjs"() {
    init_chunk_ZLTLOVKT();
  }
});

// ../shadergradient-v2/dist/chunk-LGYLXRYF.mjs
function assignRef(ref, value) {
  if (typeof ref === "function") {
    return ref(value);
  } else if (ref) {
    ref.current = value;
  }
}
function mergeRefs(refs) {
  return (value) => {
    for (const ref of refs) assignRef(ref, value);
  };
}
var init_chunk_LGYLXRYF = __esm({
  "../shadergradient-v2/dist/chunk-LGYLXRYF.mjs"() {
  }
});

// ../shadergradient-v2/dist/chunk-RANVICU2.mjs
import * as React5 from "react";
function useFBO(width, height, settings) {
  const { gl, size, viewport } = useThree();
  const _width = typeof width === "number" ? width : size.width * viewport.dpr;
  const _height = typeof height === "number" ? height : size.height * viewport.dpr;
  const _settings = (typeof width === "number" ? settings : width) || {};
  const _a3 = _settings, { samples } = _a3, targetSettings = __objRest(_a3, ["samples"]);
  const target2 = React5.useMemo(() => {
    let target22;
    target22 = new WebGLRenderTarget(_width, _height, __spreadValues({
      minFilter: LinearFilter,
      magFilter: LinearFilter,
      encoding: gl.outputEncoding,
      type: HalfFloatType
    }, targetSettings));
    target22.samples = samples;
    return target22;
  }, []);
  React5.useLayoutEffect(() => {
    target2.setSize(_width, _height);
    if (samples) target2.samples = samples;
  }, [samples, target2, _width, _height]);
  React5.useEffect(() => {
    return () => target2.dispose();
  }, []);
  return target2;
}
var init_chunk_RANVICU2 = __esm({
  "../shadergradient-v2/dist/chunk-RANVICU2.mjs"() {
    init_chunk_73SH6GTX();
    init_chunk_BT6X4JN2();
    init_chunk_5BEQP2BQ();
  }
});

// ../shadergradient-v2/dist/chunk-EDAOQMIG.mjs
import * as React6 from "react";
import { Fragment as Fragment6, jsx as jsx10, jsxs as jsxs4 } from "react/jsx-runtime";
var isFunction, OrthographicCamera2;
var init_chunk_EDAOQMIG = __esm({
  "../shadergradient-v2/dist/chunk-EDAOQMIG.mjs"() {
    init_chunk_LGYLXRYF();
    init_chunk_RANVICU2();
    init_chunk_73SH6GTX();
    init_chunk_5BEQP2BQ();
    isFunction = (node) => typeof node === "function";
    OrthographicCamera2 = React6.forwardRef(
      (_a3, ref) => {
        var _b2 = _a3, {
          envMap,
          resolution = 256,
          frames = Infinity,
          children,
          makeDefault
        } = _b2, props = __objRest(_b2, [
          "envMap",
          "resolution",
          "frames",
          "children",
          "makeDefault"
        ]);
        const set = useThree(({ set: set2 }) => set2);
        const camera = useThree(({ camera: camera2 }) => camera2);
        const size = useThree(({ size: size2 }) => size2);
        const cameraRef = React6.useRef(null);
        const groupRef = React6.useRef(null);
        const fbo = useFBO(resolution);
        React6.useLayoutEffect(() => {
          if (!props.manual) {
            cameraRef.current.updateProjectionMatrix();
          }
        }, [size, props]);
        React6.useLayoutEffect(() => {
          cameraRef.current.updateProjectionMatrix();
        });
        React6.useLayoutEffect(() => {
          if (makeDefault) {
            const oldCam = camera;
            set(() => ({ camera: cameraRef.current }));
            return () => set(() => ({ camera: oldCam }));
          }
        }, [cameraRef, makeDefault, set]);
        let count = 0;
        let oldEnvMap = null;
        const functional = isFunction(children);
        useFrame((state) => {
          if (functional && (frames === Infinity || count < frames)) {
            groupRef.current.visible = false;
            state.gl.setRenderTarget(fbo);
            oldEnvMap = state.scene.background;
            if (envMap) state.scene.background = envMap;
            state.gl.render(state.scene, cameraRef.current);
            state.scene.background = oldEnvMap;
            state.gl.setRenderTarget(null);
            groupRef.current.visible = true;
            count++;
          }
        });
        return /* @__PURE__ */ jsxs4(Fragment6, { children: [
          /* @__PURE__ */ jsx10(
            "orthographicCamera",
            __spreadProps(__spreadValues({
              left: size.width / -2,
              right: size.width / 2,
              top: size.height / 2,
              bottom: size.height / -2,
              ref: mergeRefs([cameraRef, ref])
            }, props), {
              children: !functional && children
            })
          ),
          /* @__PURE__ */ jsx10("group", { ref: groupRef, children: functional && children(fbo.texture) })
        ] });
      }
    );
  }
});

// ../shadergradient-v2/dist/chunk-B5OTQHNJ.mjs
import * as React7 from "react";
function useCamera(camera, props) {
  const pointer = useThree((state) => state.pointer);
  const [raycast] = React7.useState(() => {
    const raycaster = new Raycaster();
    if (props) applyProps(raycaster, props, {});
    return function(_, intersects2) {
      raycaster.setFromCamera(
        pointer,
        camera instanceof Camera ? camera : camera.current
      );
      const rc = this.constructor.prototype.raycast.bind(this);
      if (rc) rc(raycaster, intersects2);
    };
  });
  return raycast;
}
var init_chunk_B5OTQHNJ = __esm({
  "../shadergradient-v2/dist/chunk-B5OTQHNJ.mjs"() {
    init_chunk_73SH6GTX();
    init_chunk_BT6X4JN2();
  }
});

// ../shadergradient-v2/dist/chunk-YXAOGFVW.mjs
import * as React8 from "react";
import { jsx as jsx11, jsxs as jsxs5 } from "react/jsx-runtime";
var Context2, useGizmoContext, turnRate, dummy, matrix, q1, q2, target, targetPosition, isOrbitControls, GizmoHelper;
var init_chunk_YXAOGFVW = __esm({
  "../shadergradient-v2/dist/chunk-YXAOGFVW.mjs"() {
    init_chunk_EDAOQMIG();
    init_chunk_B5OTQHNJ();
    init_chunk_73SH6GTX();
    init_chunk_BT6X4JN2();
    Context2 = React8.createContext(
      {}
    );
    useGizmoContext = () => {
      return React8.useContext(Context2);
    };
    turnRate = 2 * Math.PI;
    dummy = new Object3D();
    matrix = new Matrix4();
    [q1, q2] = [new Quaternion(), new Quaternion()];
    target = new Vector3();
    targetPosition = new Vector3();
    isOrbitControls = (controls) => {
      return "minPolarAngle" in controls;
    };
    GizmoHelper = ({
      alignment = "bottom-right",
      margin = [80, 80],
      renderPriority = 0,
      autoClear = true,
      onUpdate,
      onTarget,
      children: GizmoHelperComponent
    }) => {
      const size = useThree(({ size: size2 }) => size2);
      const mainCamera = useThree(({ camera }) => camera);
      const defaultControls = useThree(
        ({ controls }) => controls
      );
      const gl = useThree(({ gl: gl2 }) => gl2);
      const scene = useThree(({ scene: scene2 }) => scene2);
      const invalidate2 = useThree(({ invalidate: invalidate22 }) => invalidate22);
      const backgroundRef = React8.useRef();
      const gizmoRef = React8.useRef();
      const virtualCam = React8.useRef(null);
      const [virtualScene] = React8.useState(() => new Scene());
      const animating = React8.useRef(false);
      const radius = React8.useRef(0);
      const focusPoint = React8.useRef(new Vector3(0, 0, 0));
      const defaultUp = React8.useRef(new Vector3(0, 0, 0));
      React8.useEffect(() => {
        defaultUp.current.copy(mainCamera.up);
      }, [mainCamera]);
      const tweenCamera = React8.useCallback(
        (direction) => {
          animating.current = true;
          if (defaultControls || onTarget)
            focusPoint.current = (defaultControls == null ? void 0 : defaultControls.target) || (onTarget == null ? void 0 : onTarget());
          radius.current = mainCamera.position.distanceTo(target);
          q1.copy(mainCamera.quaternion);
          targetPosition.copy(direction).multiplyScalar(radius.current).add(target);
          dummy.lookAt(targetPosition);
          q2.copy(dummy.quaternion);
          invalidate2();
        },
        [defaultControls, mainCamera, onTarget, invalidate2]
      );
      React8.useEffect(() => {
        if (scene.background) {
          backgroundRef.current = scene.background;
          scene.background = null;
          virtualScene.background = backgroundRef.current;
        }
        return () => {
          if (backgroundRef.current) scene.background = backgroundRef.current;
        };
      }, []);
      useFrame((_, delta) => {
        var _a3;
        if (virtualCam.current && gizmoRef.current) {
          if (animating.current) {
            if (q1.angleTo(q2) < 0.01) {
              animating.current = false;
              if (isOrbitControls(defaultControls)) {
                mainCamera.up.copy(defaultUp.current);
              }
            } else {
              const step = delta * turnRate;
              q1.rotateTowards(q2, step);
              mainCamera.position.set(0, 0, 1).applyQuaternion(q1).multiplyScalar(radius.current).add(focusPoint.current);
              mainCamera.up.set(0, 1, 0).applyQuaternion(q1).normalize();
              mainCamera.quaternion.copy(q1);
              if (onUpdate) onUpdate();
              else if (defaultControls) defaultControls.update();
              invalidate2();
            }
          }
          matrix.copy(mainCamera.matrix).invert();
          (_a3 = gizmoRef.current) == null ? void 0 : _a3.quaternion.setFromRotationMatrix(matrix);
          if (autoClear) gl.autoClear = false;
          gl.clearDepth();
          gl.render(virtualScene, virtualCam.current);
        }
      }, renderPriority);
      const raycast = useCamera(virtualCam);
      const gizmoHelperContext = React8.useMemo(
        () => ({ tweenCamera, raycast }),
        [tweenCamera]
      );
      const [marginX, marginY] = margin;
      const x = alignment.endsWith("-center") ? 0 : alignment.endsWith("-left") ? -size.width / 2 + marginX : size.width / 2 - marginX;
      const y2 = alignment.startsWith("center-") ? 0 : alignment.startsWith("top-") ? size.height / 2 - marginY : -size.height / 2 + marginY;
      return createPortal(
        /* @__PURE__ */ jsxs5(Context2.Provider, { value: gizmoHelperContext, children: [
          /* @__PURE__ */ jsx11(OrthographicCamera2, { ref: virtualCam, position: [0, 0, 200] }),
          /* @__PURE__ */ jsx11("group", { ref: gizmoRef, position: [x, y2, 0], children: GizmoHelperComponent })
        ] }),
        virtualScene
      );
    };
  }
});

// ../shadergradient-v2/dist/chunk-UFEBSNTT.mjs
import * as React9 from "react";
import { Fragment as Fragment7, jsx as jsx12, jsxs as jsxs6 } from "react/jsx-runtime";
function Axis({ scale = [0.8, 0.05, 0.05], color, rotation }) {
  return /* @__PURE__ */ jsx12("group", { rotation, children: /* @__PURE__ */ jsxs6("mesh", { position: [0.4, 0, 0], children: [
    /* @__PURE__ */ jsx12("boxGeometry", { args: scale }),
    /* @__PURE__ */ jsx12("meshBasicMaterial", { color, toneMapped: false })
  ] }) });
}
function AxisHead(_a3) {
  var _b2 = _a3, {
    onClick,
    font,
    disabled,
    arcStyle,
    label,
    labelColor,
    axisHeadScale = 1
  } = _b2, props = __objRest(_b2, [
    "onClick",
    "font",
    "disabled",
    "arcStyle",
    "label",
    "labelColor",
    "axisHeadScale"
  ]);
  const gl = useThree((state) => state.gl);
  const texture = React9.useMemo(() => {
    const canvas = document.createElement("canvas");
    canvas.width = 64;
    canvas.height = 64;
    const context2 = canvas.getContext("2d");
    context2.beginPath();
    context2.arc(32, 32, 16, 0, 2 * Math.PI);
    context2.closePath();
    context2.fillStyle = arcStyle;
    context2.fill();
    if (label) {
      context2.font = font;
      context2.textAlign = "center";
      context2.fillStyle = labelColor;
      context2.fillText(label, 32, 41);
    }
    return new CanvasTexture(canvas);
  }, [arcStyle, label, labelColor, font]);
  const [active, setActive] = React9.useState(false);
  const scale = (label ? 1 : 0.75) * (active ? 1.2 : 1) * axisHeadScale;
  const handlePointerOver = (e) => {
    e.stopPropagation();
    setActive(true);
  };
  const handlePointerOut = (e) => {
    e.stopPropagation();
    setActive(false);
  };
  return /* @__PURE__ */ jsx12(
    "sprite",
    __spreadProps(__spreadValues({
      scale,
      onPointerOver: !disabled ? handlePointerOver : void 0,
      onPointerOut: !disabled ? onClick || handlePointerOut : void 0
    }, props), {
      children: /* @__PURE__ */ jsx12(
        "spriteMaterial",
        {
          map: texture,
          "map-encoding": gl.outputEncoding,
          "map-anisotropy": gl.capabilities.getMaxAnisotropy() || 1,
          alphaTest: 0.3,
          opacity: label ? 1 : 0.75,
          toneMapped: false
        }
      )
    })
  );
}
var GizmoViewport;
var init_chunk_UFEBSNTT = __esm({
  "../shadergradient-v2/dist/chunk-UFEBSNTT.mjs"() {
    init_chunk_YXAOGFVW();
    init_chunk_73SH6GTX();
    init_chunk_BT6X4JN2();
    init_chunk_5BEQP2BQ();
    GizmoViewport = (_a3) => {
      var _b2 = _a3, {
        hideNegativeAxes,
        hideAxisHeads,
        disabled,
        font = "18px Inter var, Arial, sans-serif",
        axisColors = ["#ff2060", "#20df80", "#2080ff"],
        axisHeadScale = 1,
        axisScale,
        labels = ["X", "Y", "Z"],
        labelColor = "#000",
        onClick
      } = _b2, props = __objRest(_b2, [
        "hideNegativeAxes",
        "hideAxisHeads",
        "disabled",
        "font",
        "axisColors",
        "axisHeadScale",
        "axisScale",
        "labels",
        "labelColor",
        "onClick"
      ]);
      const [colorX, colorY, colorZ] = axisColors;
      const { tweenCamera, raycast } = useGizmoContext();
      const axisHeadProps = {
        font,
        disabled,
        labelColor,
        raycast,
        onClick,
        axisHeadScale,
        onPointerDown: !disabled ? (e) => {
          tweenCamera(e.object.position);
          e.stopPropagation();
        } : void 0
      };
      return /* @__PURE__ */ jsxs6("group", __spreadProps(__spreadValues({ scale: 40 }, props), { children: [
        /* @__PURE__ */ jsx12(Axis, { color: colorX, rotation: [0, 0, 0], scale: axisScale }),
        /* @__PURE__ */ jsx12(Axis, { color: colorY, rotation: [0, 0, Math.PI / 2], scale: axisScale }),
        /* @__PURE__ */ jsx12(Axis, { color: colorZ, rotation: [0, -Math.PI / 2, 0], scale: axisScale }),
        !hideAxisHeads && /* @__PURE__ */ jsxs6(Fragment7, { children: [
          /* @__PURE__ */ jsx12(
            AxisHead,
            __spreadValues({
              arcStyle: colorX,
              position: [1, 0, 0],
              label: labels[0]
            }, axisHeadProps)
          ),
          /* @__PURE__ */ jsx12(
            AxisHead,
            __spreadValues({
              arcStyle: colorY,
              position: [0, 1, 0],
              label: labels[1]
            }, axisHeadProps)
          ),
          /* @__PURE__ */ jsx12(
            AxisHead,
            __spreadValues({
              arcStyle: colorZ,
              position: [0, 0, 1],
              label: labels[2]
            }, axisHeadProps)
          ),
          !hideNegativeAxes && /* @__PURE__ */ jsxs6(Fragment7, { children: [
            /* @__PURE__ */ jsx12(
              AxisHead,
              __spreadValues({
                arcStyle: colorX,
                position: [-1, 0, 0]
              }, axisHeadProps)
            ),
            /* @__PURE__ */ jsx12(
              AxisHead,
              __spreadValues({
                arcStyle: colorY,
                position: [0, -1, 0]
              }, axisHeadProps)
            ),
            /* @__PURE__ */ jsx12(
              AxisHead,
              __spreadValues({
                arcStyle: colorZ,
                position: [0, 0, -1]
              }, axisHeadProps)
            )
          ] })
        ] }),
        /* @__PURE__ */ jsx12("ambientLight", { intensity: 0.5 }),
        /* @__PURE__ */ jsx12("pointLight", { position: [10, 10, 10], intensity: 0.5 })
      ] }));
    };
  }
});

// ../shadergradient-v2/dist/chunk-X2DICZQA.mjs
import { Fragment as Fragment8, jsx as jsx13 } from "react/jsx-runtime";
function Axis2({ margin = [65, 110] }) {
  return /* @__PURE__ */ jsx13(Fragment8, { children: /* @__PURE__ */ jsx13(
    GizmoHelper,
    {
      alignment: "bottom-right",
      margin,
      renderPriority: 2,
      children: /* @__PURE__ */ jsx13(
        GizmoViewport,
        {
          axisColors: ["#FF430A", "#FF430A", "#FF430A"],
          labelColor: "white",
          hideNegativeAxes: true,
          axisHeadScale: 0.8
        }
      )
    }
  ) });
}
var init_chunk_X2DICZQA = __esm({
  "../shadergradient-v2/dist/chunk-X2DICZQA.mjs"() {
    init_chunk_UFEBSNTT();
    init_chunk_YXAOGFVW();
  }
});

// ../shadergradient-v2/dist/chunk-3ONLEHDB.mjs
var presets, presetsArray, propertyControls;
var init_chunk_3ONLEHDB = __esm({
  "../shadergradient-v2/dist/chunk-3ONLEHDB.mjs"() {
    presets = {
      halo: {
        title: "Halo",
        color: "white",
        props: {
          type: "plane",
          uAmplitude: 1,
          uDensity: 1.3,
          uSpeed: 0.4,
          uStrength: 4,
          uTime: 0,
          uFrequency: 5.5,
          range: "enabled",
          rangeStart: 0,
          rangeEnd: 40,
          frameRate: 10,
          destination: "onCanvas",
          format: "gif",
          axesHelper: "off",
          brightness: 1.2,
          cAzimuthAngle: 180,
          cDistance: 3.6,
          cPolarAngle: 90,
          cameraZoom: 1,
          color1: "#ff5005",
          color2: "#dbba95",
          color3: "#d0bce1",
          embedMode: "off",
          envPreset: "city",
          gizmoHelper: "hide",
          grain: "on",
          lightType: "3d",
          pixelDensity: 1,
          fov: 45,
          positionX: -1.4,
          positionY: 0,
          positionZ: 0,
          reflection: 0.1,
          rotationX: 0,
          rotationY: 10,
          rotationZ: 50,
          shader: "defaults",
          animate: "on",
          wireframe: false
        }
      },
      pensive: {
        title: "Pensive",
        color: "white",
        props: {
          range: "enabled",
          rangeStart: 0,
          rangeEnd: 40,
          frameRate: 10,
          destination: "onCanvas",
          format: "gif",
          animate: "on",
          axesHelper: "off",
          brightness: 1.5,
          cAzimuthAngle: 250,
          cDistance: 1.5,
          cPolarAngle: 140,
          cameraZoom: 12.5,
          color1: "#809bd6",
          color2: "#910aff",
          color3: "#af38ff",
          embedMode: "off",
          envPreset: "city",
          gizmoHelper: "hide",
          grain: "on",
          lightType: "3d",
          pixelDensity: 1,
          fov: 45,
          positionX: 0,
          positionY: 0,
          positionZ: 0,
          reflection: 0.5,
          rotationX: 0,
          rotationY: 0,
          rotationZ: 140,
          shader: "defaults",
          type: "sphere",
          uAmplitude: 7,
          uDensity: 0.8,
          uFrequency: 5.5,
          uSpeed: 0.3,
          uStrength: 0.4,
          uTime: 0,
          wireframe: false
        }
      },
      mint: {
        title: "Mint",
        color: "white",
        props: {
          range: "enabled",
          rangeStart: 0,
          rangeEnd: 40,
          frameRate: 10,
          destination: "onCanvas",
          format: "gif",
          animate: "on",
          axesHelper: "off",
          brightness: 1.2,
          cAzimuthAngle: 170,
          cDistance: 4.4,
          cPolarAngle: 70,
          cameraZoom: 1,
          color1: "#94ffd1",
          color2: "#6bf5ff",
          color3: "#ffffff",
          embedMode: "off",
          envPreset: "city",
          gizmoHelper: "hide",
          grain: "off",
          lightType: "3d",
          pixelDensity: 1,
          fov: 45,
          positionX: 0,
          positionY: 0.9,
          positionZ: -0.3,
          reflection: 0.1,
          rotationX: 45,
          rotationY: 0,
          rotationZ: 0,
          shader: "defaults",
          type: "waterPlane",
          uAmplitude: 0,
          uDensity: 1.2,
          uFrequency: 0,
          uSpeed: 0.2,
          uStrength: 3.4,
          uTime: 0,
          wireframe: false
        }
      },
      interstella: {
        title: "Interstella",
        color: "white",
        props: {
          range: "enabled",
          rangeStart: 0,
          rangeEnd: 40,
          frameRate: 10,
          destination: "onCanvas",
          format: "gif",
          animate: "on",
          axesHelper: "off",
          brightness: 0.8,
          cAzimuthAngle: 270,
          cDistance: 0.5,
          cPolarAngle: 180,
          cameraZoom: 15.1,
          color1: "#73bfc4",
          color2: "#ff810a",
          color3: "#8da0ce",
          embedMode: "off",
          envPreset: "city",
          gizmoHelper: "hide",
          grain: "on",
          lightType: "env",
          pixelDensity: 1,
          fov: 45,
          positionX: -0.1,
          positionY: 0,
          positionZ: 0,
          reflection: 0.4,
          rotationX: 0,
          rotationY: 130,
          rotationZ: 70,
          shader: "defaults",
          type: "sphere",
          uAmplitude: 3.2,
          uDensity: 0.8,
          uFrequency: 5.5,
          uSpeed: 0.3,
          uStrength: 0.3,
          uTime: 0,
          wireframe: false
        }
      },
      nightyNight: {
        title: "Nighty night",
        color: "white",
        props: {
          range: "enabled",
          rangeStart: 0,
          rangeEnd: 40,
          frameRate: 10,
          destination: "onCanvas",
          format: "gif",
          animate: "on",
          axesHelper: "off",
          brightness: 1,
          cAzimuthAngle: 180,
          cDistance: 2.8,
          cPolarAngle: 80,
          cameraZoom: 9.1,
          color1: "#606080",
          color2: "#8d7dca",
          color3: "#212121",
          embedMode: "off",
          envPreset: "city",
          gizmoHelper: "hide",
          grain: "on",
          lightType: "3d",
          pixelDensity: 1,
          fov: 45,
          positionX: 0,
          positionY: 0,
          positionZ: 0,
          reflection: 0.1,
          rotationX: 50,
          rotationY: 0,
          rotationZ: -60,
          shader: "defaults",
          type: "waterPlane",
          uAmplitude: 0,
          uDensity: 1.5,
          uFrequency: 0,
          uSpeed: 0.3,
          uStrength: 1.5,
          uTime: 8,
          wireframe: false
        }
      },
      violaOrientalis: {
        title: "Viola orientalis",
        color: "white",
        props: {
          range: "enabled",
          rangeStart: 0,
          rangeEnd: 40,
          frameRate: 10,
          destination: "onCanvas",
          format: "gif",
          animate: "on",
          axesHelper: "on",
          brightness: 1.1,
          cAzimuthAngle: 0,
          cDistance: 7.1,
          cPolarAngle: 140,
          cameraZoom: 17.3,
          color1: "#ffffff",
          color2: "#ffbb00",
          color3: "#0700ff",
          embedMode: "off",
          envPreset: "city",
          grain: "off",
          lightType: "3d",
          pixelDensity: 1,
          fov: 45,
          positionX: 0,
          positionY: 0,
          positionZ: 0,
          reflection: 0.1,
          rotationX: 0,
          rotationY: 0,
          rotationZ: 0,
          shader: "defaults",
          type: "sphere",
          uAmplitude: 1.4,
          uDensity: 1.1,
          uSpeed: 0.1,
          uStrength: 1,
          uTime: 0,
          uFrequency: 5.5,
          wireframe: false
        }
      },
      universe: {
        title: "Universe",
        color: "white",
        props: {
          range: "enabled",
          rangeStart: 0,
          rangeEnd: 40,
          frameRate: 10,
          destination: "onCanvas",
          format: "gif",
          animate: "on",
          axesHelper: "on",
          brightness: 1.1,
          cAzimuthAngle: 180,
          cDistance: 3.9,
          cPolarAngle: 115,
          cameraZoom: 1,
          color1: "#5606ff",
          color2: "#fe8989",
          color3: "#000000",
          embedMode: "off",
          envPreset: "city",
          grain: "off",
          lightType: "3d",
          pixelDensity: 1,
          fov: 45,
          positionX: -0.5,
          positionY: 0.1,
          positionZ: 0,
          reflection: 0.1,
          rotationX: 0,
          rotationY: 0,
          rotationZ: 235,
          shader: "defaults",
          type: "waterPlane",
          uAmplitude: 0,
          uDensity: 1.1,
          uSpeed: 0.1,
          uStrength: 2.4,
          uTime: 0.2,
          uFrequency: 5.5,
          wireframe: false
        }
      },
      sunset: {
        title: "Sunset",
        color: "white",
        props: {
          range: "enabled",
          rangeStart: 0,
          rangeEnd: 40,
          frameRate: 10,
          destination: "onCanvas",
          format: "gif",
          animate: "on",
          axesHelper: "on",
          bgColor1: "#000000",
          bgColor2: "#000000",
          brightness: 1.5,
          cAzimuthAngle: 60,
          cDistance: 7.1,
          cPolarAngle: 90,
          cameraZoom: 15.3,
          color1: "#ff7a33",
          color2: "#33a0ff",
          color3: "#ffc53d",
          embedMode: "off",
          envPreset: "dawn",
          grain: "off",
          lightType: "3d",
          pixelDensity: 1,
          fov: 45,
          positionX: 0,
          positionY: -0.15,
          positionZ: 0,
          reflection: 0.1,
          rotationX: 0,
          rotationY: 0,
          rotationZ: 0,
          shader: "defaults",
          type: "sphere",
          uAmplitude: 1.4,
          uDensity: 1.1,
          uSpeed: 0.1,
          uStrength: 0.4,
          uTime: 0,
          uFrequency: 5.5,
          wireframe: false
        }
      },
      mandarin: {
        title: "Mandarin",
        color: "white",
        props: {
          range: "enabled",
          rangeStart: 0,
          rangeEnd: 40,
          frameRate: 10,
          destination: "onCanvas",
          format: "gif",
          animate: "on",
          axesHelper: "on",
          bgColor1: "#000000",
          bgColor2: "#000000",
          brightness: 1.2,
          cAzimuthAngle: 180,
          cDistance: 2.4,
          cPolarAngle: 95,
          cameraZoom: 1,
          color1: "#ff6a1a",
          color2: "#c73c00",
          color3: "#FD4912",
          embedMode: "off",
          envPreset: "city",
          grain: "off",
          lightType: "3d",
          pixelDensity: 1,
          fov: 45,
          positionX: 0,
          positionY: -2.1,
          positionZ: 0,
          reflection: 0.1,
          rotationX: 0,
          rotationY: 0,
          rotationZ: 225,
          shader: "defaults",
          type: "waterPlane",
          uAmplitude: 0,
          uDensity: 1.8,
          uSpeed: 0.2,
          uStrength: 3,
          uTime: 0.2,
          uFrequency: 5.5,
          wireframe: false
        }
      },
      cottonCandy: {
        title: "Cotton Candy",
        color: "white",
        props: {
          range: "enabled",
          rangeStart: 0,
          rangeEnd: 40,
          frameRate: 10,
          destination: "onCanvas",
          format: "gif",
          animate: "on",
          axesHelper: "off",
          brightness: 1.2,
          cAzimuthAngle: 180,
          cDistance: 2.9,
          cPolarAngle: 120,
          cameraZoom: 1,
          color1: "#ebedff",
          color2: "#f3f2f8",
          color3: "#dbf8ff",
          embedMode: "off",
          envPreset: "city",
          grain: "off",
          lightType: "3d",
          pixelDensity: 1,
          fov: 45,
          positionX: 0,
          positionY: 1.8,
          positionZ: 0,
          reflection: 0.1,
          rotationX: 0,
          rotationY: 0,
          rotationZ: -90,
          shader: "defaults",
          type: "waterPlane",
          uAmplitude: 0,
          uDensity: 1,
          uSpeed: 0.3,
          uStrength: 3,
          uTime: 0.2,
          uFrequency: 5.5,
          wireframe: false
        }
      }
    };
    presetsArray = Object.values(presets);
    propertyControls = (ControlType, type = "") => ({
      control: {
        type: ControlType.Enum,
        options: ["props", "query"],
        optionTitles: ["Props", "Query"],
        displaySegmentedControl: true,
        defaultValue: type === "stateless" ? "query" : "props"
      },
      activeTab: {
        title: "Settings Group",
        type: ControlType.Enum,
        options: ["Shape", "Colors", "Effects", "View"],
        hidden: (props) => props.control === "query"
      },
      // Shape
      type: {
        type: ControlType.Enum,
        options: ["plane", "sphere", "waterPlane"],
        optionTitles: ["Plane", "Sphere", "Water"],
        displaySegmentedControl: true,
        hidden: (props) => props.control === "query" || props.activeTab !== "Shape"
      },
      shader: {
        type: ControlType.Enum,
        options: ["defaults", "positionMix", "glass"],
        optionTitles: ["Type A", "Type B", "Type C"],
        displaySegmentedControl: true,
        hidden: (props) => props.control === "query" || props.activeTab !== "Shape"
      },
      animate: {
        type: ControlType.Enum,
        options: ["on", "off"],
        optionTitles: ["On", "Off"],
        displaySegmentedControl: true,
        hidden: (props) => props.control === "query" || props.activeTab !== "Shape" && props.activeTab !== "URL"
      },
      uTime: {
        title: "Movements",
        type: ControlType.Number,
        step: 0.1,
        displayStepper: true,
        hidden: (props) => props.animate === "on" || props.control === "query" || props.activeTab !== "Shape"
      },
      uSpeed: {
        title: "Speed",
        type: ControlType.Number,
        step: 0.1,
        min: 0.1,
        displayStepper: true,
        defaultValue: 0.4,
        hidden: (props) => props.animate === "off" || props.control === "query" || props.activeTab !== "Shape"
      },
      noise: {
        type: ControlType.Object,
        controls: {
          uStrength: {
            type: ControlType.Number,
            title: "Strength",
            step: 0.1,
            min: 0.1,
            displayStepper: true,
            defaultValue: 4
          },
          uDensity: {
            type: ControlType.Number,
            title: "Density",
            step: 0.1,
            min: 0.1,
            displayStepper: true,
            defaultValue: 1.3
          }
          // uFrequency: {
          //     type: ControlType.Number,
          //     step: 0.1,
          //     min: 0.1,
          //     displayStepper: true,
          //     hidden: (props) =>
          //         props.type !== "sphere" ||
          //         props.control === "query" ||
          //         props.activeTab !== "Shape",
          // },
        },
        hidden: (props) => props.control === "query" || props.activeTab !== "Shape"
      },
      uAmplitude: {
        type: ControlType.Number,
        title: "Spiral",
        step: 0.1,
        min: 0.1,
        displayStepper: true,
        defaultValue: 1,
        hidden: (props) => props.type !== "sphere" || props.control === "query" || props.activeTab !== "Shape"
      },
      pixelDensity: {
        type: ControlType.Number,
        step: 0.1,
        min: 0,
        max: 3,
        displayStepper: true,
        defaultValue: 1,
        hidden: (props) => props.control === "query" || props.activeTab !== "Shape"
      },
      fov: {
        type: ControlType.Number,
        step: 1,
        min: 10,
        max: 180,
        displayStepper: true,
        defaultValue: 45,
        hidden: (props) => props.control === "query" || props.activeTab !== "Shape"
      },
      // Effects
      grain: {
        type: ControlType.Enum,
        options: ["on", "off"],
        optionTitles: ["On", "Off"],
        displaySegmentedControl: true,
        hidden: (props) => props.control === "query" || props.activeTab !== "Effects"
      },
      lightType: {
        type: ControlType.Enum,
        options: ["env", "3d"],
        optionTitles: ["Env", "Light"],
        displaySegmentedControl: true,
        defaultValue: "3d",
        hidden: (props) => props.control === "query" || props.activeTab !== "Effects"
      },
      envPreset: {
        type: ControlType.Enum,
        options: ["city", "dawn", "lobby"],
        optionTitles: ["City", "Dawn", "Lobby"],
        displaySegmentedControl: true,
        hidden: (props) => props.lightType === "3d" || props.control === "query" || props.activeTab !== "Effects"
      },
      brightness: {
        type: ControlType.Number,
        step: 0.1,
        min: 0.1,
        max: 3,
        defaultValue: 1.2,
        hidden: (props) => props.lightType === "env" || props.control === "query" || props.activeTab !== "Effects" || props.url
      },
      reflection: {
        type: ControlType.Number,
        step: 0.1,
        min: 0,
        max: 1,
        defaultValue: 0.1,
        hidden: (props) => props.lightType === "3d" || props.control === "query" || props.activeTab !== "Effects" || props.url
      },
      // Colors
      color1: {
        type: ControlType.Color,
        defaultValue: "#ff5005",
        hidden: (props) => props.control === "query" || props.activeTab !== "Colors"
      },
      color2: {
        type: ControlType.Color,
        defaultValue: "#dbba95",
        hidden: (props) => props.control === "query" || props.activeTab !== "Colors"
      },
      color3: {
        type: ControlType.Color,
        defaultValue: "#d0bce1",
        hidden: (props) => props.control === "query" || props.activeTab !== "Colors"
      },
      // View
      cDistance: {
        title: "Distance",
        type: ControlType.Number,
        displayStepper: true,
        min: 0,
        max: 20,
        defaultValue: 3.6,
        hidden: (props) => props.type === "sphere" || props.control === "query" || props.activeTab !== "View"
      },
      cameraZoom: {
        type: ControlType.Number,
        displayStepper: true,
        step: 0.1,
        min: 0.1,
        max: 30,
        defaultValue: 1,
        hidden: (props) => props.type !== "sphere" || props.control === "query" || props.activeTab !== "View"
      },
      cameraAngle: {
        type: ControlType.Object,
        controls: {
          cAzimuthAngle: {
            title: "Azimuth",
            type: ControlType.Number,
            displayStepper: true,
            step: 10,
            min: 0,
            max: 360,
            defaultValue: 180
          },
          cPolarAngle: {
            title: "Polar",
            type: ControlType.Number,
            displayStepper: true,
            step: 10,
            min: 0,
            max: 180,
            defaultValue: 90
          }
        },
        hidden: (props) => props.control === "query" || props.activeTab !== "View"
      },
      position: {
        type: ControlType.Object,
        controls: {
          positionX: {
            type: ControlType.Number,
            step: 0.1,
            displayStepper: true,
            defaultValue: -1.4
          },
          positionY: {
            type: ControlType.Number,
            step: 0.1,
            displayStepper: true,
            defaultValue: 0
          },
          positionZ: {
            type: ControlType.Number,
            step: 0.1,
            displayStepper: true,
            defaultValue: 0
          }
        },
        hidden: (props) => props.control === "query" || props.activeTab !== "View"
      },
      rotation: {
        type: ControlType.Object,
        controls: {
          rotationX: {
            type: ControlType.Number,
            step: 10,
            min: -360,
            max: 360,
            displayStepper: true,
            defaultValue: 0
          },
          rotationY: {
            type: ControlType.Number,
            step: 10,
            min: -360,
            max: 360,
            displayStepper: true,
            defaultValue: 10
          },
          rotationZ: {
            type: ControlType.Number,
            step: 10,
            min: -360,
            max: 360,
            displayStepper: true,
            defaultValue: 50
          }
        },
        hidden: (props) => props.control === "query" || props.activeTab !== "View"
      },
      // urlString
      urlString: {
        type: ControlType.String,
        placeholder: "URL from shadergradient.co",
        defaultValue: type === "stateless" ? "" : "https://www.shadergradient.co/customize?animate=on&axesHelper=off&bgColor1=%23000000&bgColor2=%23000000&brightness=1.2&cAzimuthAngle=180&cDistance=3.6&cPolarAngle=90&cameraZoom=1&color1=%23ff5005&color2=%23dbba95&color3=%23d0bce1&destination=onCanvas&embedMode=off&envPreset=city&format=gif&fov=45&frameRate=10&gizmoHelper=hide&grain=on&lightType=3d&pixelDensity=1&positionX=-1.4&positionY=0&positionZ=0&range=enabled&rangeEnd=40&rangeStart=0&reflection=0.1&rotationX=0&rotationY=10&rotationZ=50&shader=defaults&type=plane&uDensity=1.3&uFrequency=5.5&uSpeed=0.4&uStrength=4&uTime=0&wireframe=false",
        hidden: (props) => props.control === "props"
      },
      // Tools (🧰)
      zoomOut: {
        type: ControlType.Boolean,
        title: "View",
        enabledTitle: "Wide",
        disabledTitle: "-",
        hidden: (props) => props.control === "query"
      },
      toggleAxis: {
        type: ControlType.Boolean,
        title: "Axis",
        enabledTitle: "Guide",
        disabledTitle: "-",
        defaultValue: false,
        hidden: (props) => props.control === "query"
      },
      pointerEvents: {
        type: ControlType.Enum,
        title: "Touch Control",
        options: ["none", "auto"],
        optionTitles: ["Disable", "Enable"],
        displaySegmentedControl: true,
        hidden: (props) => props.control === "query"
      },
      performantOnCanvas: {
        type: ControlType.Boolean,
        defaultValue: false
      },
      lazyLoad: {
        type: ControlType.Boolean,
        defaultValue: true
      },
      threshold: {
        type: ControlType.Number,
        min: 0,
        max: 1,
        step: 0.1,
        defaultValue: 0.1,
        displayStepper: true,
        title: "\u21B3 Threshold",
        hidden: (props) => !props.lazyLoad
      }
    });
  }
});

// ../shadergradient-v2/dist/chunk-JQUAV2GN.mjs
import { Fragment as Fragment9, jsx as jsx14, jsxs as jsxs7 } from "react/jsx-runtime";
function decodeComponents(components, split) {
  try {
    return [decodeURIComponent(components.join(""))];
  } catch (err) {
  }
  if (components.length === 1) {
    return components;
  }
  split = split || 1;
  var left = components.slice(0, split);
  var right = components.slice(split);
  return Array.prototype.concat.call([], decodeComponents(left), decodeComponents(right));
}
function decode(input) {
  try {
    return decodeURIComponent(input);
  } catch (err) {
    var tokens = input.match(singleMatcher) || [];
    for (var i2 = 1; i2 < tokens.length; i2++) {
      input = decodeComponents(tokens, i2).join("");
      tokens = input.match(singleMatcher) || [];
    }
    return input;
  }
}
function customDecodeURIComponent(input) {
  var replaceMap = {
    "%FE%FF": "\uFFFD\uFFFD",
    "%FF%FE": "\uFFFD\uFFFD"
  };
  var match = multiMatcher.exec(input);
  while (match) {
    try {
      replaceMap[match[0]] = decodeURIComponent(match[0]);
    } catch (err) {
      var result = decode(match[0]);
      if (result !== match[0]) {
        replaceMap[match[0]] = result;
      }
    }
    match = multiMatcher.exec(input);
  }
  replaceMap["%C2"] = "\uFFFD";
  var entries = Object.keys(replaceMap);
  for (var i2 = 0; i2 < entries.length; i2++) {
    var key = entries[i2];
    input = input.replace(new RegExp(key, "g"), replaceMap[key]);
  }
  return input;
}
function __cjs_default__2(requiredModule) {
  var Object2 = (typeof window !== "undefined" && window || typeof self !== "undefined" && self || typeof global2 !== "undefined" && global2 || typeof globalThis !== "undefined" && globalThis || {}).Object;
  var isEsModule = false;
  var specifiers = Object2.create(null);
  var hasNamedExports = false;
  var hasDefaultExport = false;
  Object2.defineProperty(specifiers, "__esModule", {
    value: true,
    enumerable: false,
    configurable: true
  });
  if (requiredModule) {
    var names = Object2.getOwnPropertyNames(requiredModule);
    ;
    names.forEach(function(k3) {
      if (k3 === "default") {
        hasDefaultExport = true;
      } else if (!hasNamedExports && k3 != "__esModule") {
        try {
          hasNamedExports = requiredModule[k3] != null;
        } catch (err) {
        }
      }
      Object2.defineProperty(specifiers, k3, {
        get: function() {
          return requiredModule[k3];
        },
        enumerable: true,
        configurable: false
      });
    });
    if (Object2.getOwnPropertySymbols) {
      var symbols = Object2.getOwnPropertySymbols(requiredModule);
      symbols.forEach(function(k3) {
        Object2.defineProperty(specifiers, k3, {
          get: function() {
            return requiredModule[k3];
          },
          enumerable: false,
          configurable: false
        });
      });
    }
    Object2.preventExtensions(specifiers);
    Object2.seal(specifiers);
    if (Object2.freeze) {
      Object2.freeze(specifiers);
    }
  }
  if (hasNamedExports) {
    return specifiers;
  }
  if (hasDefaultExport) {
    if (Object2.isExtensible(specifiers.default) && !("default" in specifiers.default)) {
      Object2.defineProperty(specifiers.default, "default", {
        value: specifiers.default,
        configurable: false,
        enumerable: false
      });
    }
    return specifiers.default;
  }
  return specifiers;
}
function encoderForArrayFormat(options) {
  switch (options.arrayFormat) {
    case "index":
      return (key) => (result, value) => {
        const index = result.length;
        if (value === void 0 || options.skipNull && value === null || options.skipEmptyString && value === "") {
          return result;
        }
        if (value === null) {
          return [...result, [encode(key, options), "[", index, "]"].join("")];
        }
        return [
          ...result,
          [encode(key, options), "[", encode(index, options), "]=", encode(value, options)].join("")
        ];
      };
    case "bracket":
      return (key) => (result, value) => {
        if (value === void 0 || options.skipNull && value === null || options.skipEmptyString && value === "") {
          return result;
        }
        if (value === null) {
          return [...result, [encode(key, options), "[]"].join("")];
        }
        return [...result, [encode(key, options), "[]=", encode(value, options)].join("")];
      };
    case "colon-list-separator":
      return (key) => (result, value) => {
        if (value === void 0 || options.skipNull && value === null || options.skipEmptyString && value === "") {
          return result;
        }
        if (value === null) {
          return [...result, [encode(key, options), ":list="].join("")];
        }
        return [...result, [encode(key, options), ":list=", encode(value, options)].join("")];
      };
    case "comma":
    case "separator":
    case "bracket-separator": {
      const keyValueSep = options.arrayFormat === "bracket-separator" ? "[]=" : "=";
      return (key) => (result, value) => {
        if (value === void 0 || options.skipNull && value === null || options.skipEmptyString && value === "") {
          return result;
        }
        value = value === null ? "" : value;
        if (result.length === 0) {
          return [[encode(key, options), keyValueSep, encode(value, options)].join("")];
        }
        return [[result, encode(value, options)].join(options.arrayFormatSeparator)];
      };
    }
    default:
      return (key) => (result, value) => {
        if (value === void 0 || options.skipNull && value === null || options.skipEmptyString && value === "") {
          return result;
        }
        if (value === null) {
          return [...result, encode(key, options)];
        }
        return [...result, [encode(key, options), "=", encode(value, options)].join("")];
      };
  }
}
function parserForArrayFormat(options) {
  let result;
  switch (options.arrayFormat) {
    case "index":
      return (key, value, accumulator) => {
        result = /\[(\d*)\]$/.exec(key);
        key = key.replace(/\[\d*\]$/, "");
        if (!result) {
          accumulator[key] = value;
          return;
        }
        if (accumulator[key] === void 0) {
          accumulator[key] = {};
        }
        accumulator[key][result[1]] = value;
      };
    case "bracket":
      return (key, value, accumulator) => {
        result = /(\[\])$/.exec(key);
        key = key.replace(/\[\]$/, "");
        if (!result) {
          accumulator[key] = value;
          return;
        }
        if (accumulator[key] === void 0) {
          accumulator[key] = [value];
          return;
        }
        accumulator[key] = [].concat(accumulator[key], value);
      };
    case "colon-list-separator":
      return (key, value, accumulator) => {
        result = /(:list)$/.exec(key);
        key = key.replace(/:list$/, "");
        if (!result) {
          accumulator[key] = value;
          return;
        }
        if (accumulator[key] === void 0) {
          accumulator[key] = [value];
          return;
        }
        accumulator[key] = [].concat(accumulator[key], value);
      };
    case "comma":
    case "separator":
      return (key, value, accumulator) => {
        const isArray = typeof value === "string" && value.includes(options.arrayFormatSeparator);
        const isEncodedArray = typeof value === "string" && !isArray && decode2(value, options).includes(options.arrayFormatSeparator);
        value = isEncodedArray ? decode2(value, options) : value;
        const newValue = isArray || isEncodedArray ? value.split(options.arrayFormatSeparator).map((item) => decode2(item, options)) : value === null ? value : decode2(value, options);
        accumulator[key] = newValue;
      };
    case "bracket-separator":
      return (key, value, accumulator) => {
        const isArray = /(\[\])$/.test(key);
        key = key.replace(/\[\]$/, "");
        if (!isArray) {
          accumulator[key] = value ? decode2(value, options) : value;
          return;
        }
        const arrayValue = value === null ? [] : value.split(options.arrayFormatSeparator).map((item) => decode2(item, options));
        if (accumulator[key] === void 0) {
          accumulator[key] = arrayValue;
          return;
        }
        accumulator[key] = [].concat(accumulator[key], arrayValue);
      };
    default:
      return (key, value, accumulator) => {
        if (accumulator[key] === void 0) {
          accumulator[key] = value;
          return;
        }
        accumulator[key] = [].concat(accumulator[key], value);
      };
  }
}
function validateArrayFormatSeparator(value) {
  if (typeof value !== "string" || value.length !== 1) {
    throw new TypeError("arrayFormatSeparator must be single character string");
  }
}
function encode(value, options) {
  if (options.encode) {
    return options.strict ? strictUriEncode(value) : encodeURIComponent(value);
  }
  return value;
}
function decode2(value, options) {
  if (options.decode) {
    return decodeComponent(value);
  }
  return value;
}
function keysSorter(input) {
  if (Array.isArray(input)) {
    return input.sort();
  }
  if (typeof input === "object") {
    return keysSorter(Object.keys(input)).sort((a, b) => Number(a) - Number(b)).map((key) => input[key]);
  }
  return input;
}
function removeHash(input) {
  const hashStart = input.indexOf("#");
  if (hashStart !== -1) {
    input = input.slice(0, hashStart);
  }
  return input;
}
function getHash(url) {
  let hash = "";
  const hashStart = url.indexOf("#");
  if (hashStart !== -1) {
    hash = url.slice(hashStart);
  }
  return hash;
}
function extract(input) {
  input = removeHash(input);
  const queryStart = input.indexOf("?");
  if (queryStart === -1) {
    return "";
  }
  return input.slice(queryStart + 1);
}
function parseValue(value, options) {
  if (options.parseNumbers && !Number.isNaN(Number(value)) && (typeof value === "string" && value.trim() !== "")) {
    value = Number(value);
  } else if (options.parseBooleans && value !== null && (value.toLowerCase() === "true" || value.toLowerCase() === "false")) {
    value = value.toLowerCase() === "true";
  }
  return value;
}
function parse(query2, options) {
  options = Object.assign({
    decode: true,
    sort: true,
    arrayFormat: "none",
    arrayFormatSeparator: ",",
    parseNumbers: false,
    parseBooleans: false
  }, options);
  validateArrayFormatSeparator(options.arrayFormatSeparator);
  const formatter = parserForArrayFormat(options);
  const ret = /* @__PURE__ */ Object.create(null);
  if (typeof query2 !== "string") {
    return ret;
  }
  query2 = query2.trim().replace(/^[?#&]/, "");
  if (!query2) {
    return ret;
  }
  for (const param of query2.split("&")) {
    if (param === "") {
      continue;
    }
    let [key, value] = splitOnFirst(options.decode ? param.replace(/\+/g, " ") : param, "=");
    value = value === void 0 ? null : ["comma", "separator", "bracket-separator"].includes(options.arrayFormat) ? value : decode2(value, options);
    formatter(decode2(key, options), value, ret);
  }
  for (const key of Object.keys(ret)) {
    const value = ret[key];
    if (typeof value === "object" && value !== null) {
      for (const k3 of Object.keys(value)) {
        value[k3] = parseValue(value[k3], options);
      }
    } else {
      ret[key] = parseValue(value, options);
    }
  }
  if (options.sort === false) {
    return ret;
  }
  return (options.sort === true ? Object.keys(ret).sort() : Object.keys(ret).sort(options.sort)).reduce((result, key) => {
    const value = ret[key];
    if (Boolean(value) && typeof value === "object" && !Array.isArray(value)) {
      result[key] = keysSorter(value);
    } else {
      result[key] = value;
    }
    return result;
  }, /* @__PURE__ */ Object.create(null));
}
function ShaderGradient(passedProps) {
  const _a3 = __spreadValues(__spreadValues({}, presets.halo.props), passedProps), { control, urlString, onCameraUpdate } = _a3, rest = __objRest(_a3, ["control", "urlString", "onCameraUpdate"]);
  let props = rest;
  if (control === "query")
    props = __export110(formatUrlString(urlString), {
      parseNumbers: true,
      parseBooleans: true,
      arrayFormat: "index"
    });
  const _b2 = props, { lightType, envPreset, brightness, grain, toggleAxis } = _b2, others = __objRest(_b2, ["lightType", "envPreset", "brightness", "grain", "toggleAxis"]);
  return /* @__PURE__ */ jsxs7(Fragment9, { children: [
    /* @__PURE__ */ jsx14(Mesh2, __spreadValues({}, props)),
    /* @__PURE__ */ jsx14(
      Lights,
      {
        lightType,
        brightness,
        envPreset
      }
    ),
    grain !== "off" && /* @__PURE__ */ jsx14(PostProcessing, {}),
    toggleAxis && /* @__PURE__ */ jsx14(Axis2, {}),
    /* @__PURE__ */ jsx14(Controls2, __spreadProps(__spreadValues({}, props), { onCameraUpdate }))
  ] });
}
var filter_obj_exports, exports4, module4, filter_obj_default, split_on_first_exports, exports22, module22, split_on_first_default, decode_uri_component_exports, exports32, module32, token, singleMatcher, multiMatcher, decode_uri_component_default, strict_uri_encode_exports, exports42, module42, strict_uri_encode_default, global2, exports5, module5, strictUriEncode, decodeComponent, splitOnFirst, filterObject, isNullOrUndefined, encodeFragmentIdentifier, __export03, __export110, __export23, __export33, __export43, __export53, __export63, query_string_default;
var init_chunk_JQUAV2GN = __esm({
  "../shadergradient-v2/dist/chunk-JQUAV2GN.mjs"() {
    init_chunk_R4OX5Y2X();
    init_chunk_HTJBLCUE();
    init_chunk_3SCKP3WD();
    init_chunk_AX2D4CR5();
    init_chunk_WNGYPXFW();
    init_chunk_X2DICZQA();
    init_chunk_3ONLEHDB();
    init_chunk_5BEQP2BQ();
    filter_obj_exports = {};
    __export(filter_obj_exports, {
      default: () => filter_obj_default
    });
    exports4 = {};
    module4 = {
      get exports() {
        return exports4;
      },
      set exports(value) {
        exports4 = value;
      }
    };
    module4.exports = function(obj, predicate) {
      var ret = {};
      var keys = Object.keys(obj);
      var isArr = Array.isArray(predicate);
      for (var i2 = 0; i2 < keys.length; i2++) {
        var key = keys[i2];
        var val = obj[key];
        if (isArr ? predicate.indexOf(key) !== -1 : predicate(key, val, obj)) {
          ret[key] = val;
        }
      }
      return ret;
    };
    filter_obj_default = module4.exports;
    split_on_first_exports = {};
    __export(split_on_first_exports, {
      default: () => split_on_first_default
    });
    exports22 = {};
    module22 = {
      get exports() {
        return exports22;
      },
      set exports(value) {
        exports22 = value;
      }
    };
    module22.exports = (string, separator) => {
      if (!(typeof string === "string" && typeof separator === "string")) {
        throw new TypeError("Expected the arguments to be of type `string`");
      }
      if (separator === "") {
        return [string];
      }
      const separatorIndex = string.indexOf(separator);
      if (separatorIndex === -1) {
        return [string];
      }
      return [
        string.slice(0, separatorIndex),
        string.slice(separatorIndex + separator.length)
      ];
    };
    split_on_first_default = module22.exports;
    decode_uri_component_exports = {};
    __export(decode_uri_component_exports, {
      default: () => decode_uri_component_default
    });
    exports32 = {};
    module32 = {
      get exports() {
        return exports32;
      },
      set exports(value) {
        exports32 = value;
      }
    };
    token = "%[a-f0-9]{2}";
    singleMatcher = new RegExp("(" + token + ")|([^%]+?)", "gi");
    multiMatcher = new RegExp("(" + token + ")+", "gi");
    module32.exports = function(encodedURI) {
      if (typeof encodedURI !== "string") {
        throw new TypeError("Expected `encodedURI` to be of type `string`, got `" + typeof encodedURI + "`");
      }
      try {
        encodedURI = encodedURI.replace(/\+/g, " ");
        return decodeURIComponent(encodedURI);
      } catch (err) {
        return customDecodeURIComponent(encodedURI);
      }
    };
    decode_uri_component_default = module32.exports;
    strict_uri_encode_exports = {};
    __export(strict_uri_encode_exports, {
      default: () => strict_uri_encode_default
    });
    exports42 = {};
    module42 = {
      get exports() {
        return exports42;
      },
      set exports(value) {
        exports42 = value;
      }
    };
    module42.exports = (str) => encodeURIComponent(str).replace(/[!'()*]/g, (x) => `%${x.charCodeAt(0).toString(16).toUpperCase()}`);
    strict_uri_encode_default = module42.exports;
    global2 = typeof window !== "undefined" && window || typeof self !== "undefined" && self || typeof global2 !== "undefined" && global2 || typeof globalThis !== "undefined" && globalThis || {};
    exports5 = {};
    module5 = {
      get exports() {
        return exports5;
      },
      set exports(value) {
        exports5 = value;
      }
    };
    strictUriEncode = __cjs_default__2(typeof strict_uri_encode_exports !== "undefined" ? strict_uri_encode_exports : {});
    decodeComponent = __cjs_default__2(typeof decode_uri_component_exports !== "undefined" ? decode_uri_component_exports : {});
    splitOnFirst = __cjs_default__2(typeof split_on_first_exports !== "undefined" ? split_on_first_exports : {});
    filterObject = __cjs_default__2(typeof filter_obj_exports !== "undefined" ? filter_obj_exports : {});
    isNullOrUndefined = (value) => value === null || value === void 0;
    encodeFragmentIdentifier = Symbol("encodeFragmentIdentifier");
    exports5.extract = extract;
    exports5.parse = parse;
    exports5.stringify = (object, options) => {
      if (!object) {
        return "";
      }
      options = Object.assign({
        encode: true,
        strict: true,
        arrayFormat: "none",
        arrayFormatSeparator: ","
      }, options);
      validateArrayFormatSeparator(options.arrayFormatSeparator);
      const shouldFilter = (key) => options.skipNull && isNullOrUndefined(object[key]) || options.skipEmptyString && object[key] === "";
      const formatter = encoderForArrayFormat(options);
      const objectCopy = {};
      for (const key of Object.keys(object)) {
        if (!shouldFilter(key)) {
          objectCopy[key] = object[key];
        }
      }
      const keys = Object.keys(objectCopy);
      if (options.sort !== false) {
        keys.sort(options.sort);
      }
      return keys.map((key) => {
        const value = object[key];
        if (value === void 0) {
          return "";
        }
        if (value === null) {
          return encode(key, options);
        }
        if (Array.isArray(value)) {
          if (value.length === 0 && options.arrayFormat === "bracket-separator") {
            return encode(key, options) + "[]";
          }
          return value.reduce(formatter(key), []).join("&");
        }
        return encode(key, options) + "=" + encode(value, options);
      }).filter((x) => x.length > 0).join("&");
    };
    exports5.parseUrl = (url, options) => {
      options = Object.assign({
        decode: true
      }, options);
      const [url_, hash] = splitOnFirst(url, "#");
      return Object.assign(
        {
          url: url_.split("?")[0] || "",
          query: parse(extract(url), options)
        },
        options && options.parseFragmentIdentifier && hash ? { fragmentIdentifier: decode2(hash, options) } : {}
      );
    };
    exports5.stringifyUrl = (object, options) => {
      options = Object.assign({
        encode: true,
        strict: true,
        [encodeFragmentIdentifier]: true
      }, options);
      const url = removeHash(object.url).split("?")[0] || "";
      const queryFromUrl = exports5.extract(object.url);
      const parsedQueryFromUrl = exports5.parse(queryFromUrl, { sort: false });
      const query2 = Object.assign(parsedQueryFromUrl, object.query);
      let queryString = exports5.stringify(query2, options);
      if (queryString) {
        queryString = `?${queryString}`;
      }
      let hash = getHash(object.url);
      if (object.fragmentIdentifier) {
        hash = `#${options[encodeFragmentIdentifier] ? encode(object.fragmentIdentifier, options) : object.fragmentIdentifier}`;
      }
      return `${url}${queryString}${hash}`;
    };
    exports5.pick = (input, filter, options) => {
      options = Object.assign({
        parseFragmentIdentifier: true,
        [encodeFragmentIdentifier]: false
      }, options);
      const { url, query: query2, fragmentIdentifier } = exports5.parseUrl(input, options);
      return exports5.stringifyUrl({
        url,
        query: filterObject(query2, filter),
        fragmentIdentifier
      }, options);
    };
    exports5.exclude = (input, filter, options) => {
      const exclusionFilter = Array.isArray(filter) ? (key) => !filter.includes(key) : (key, value) => !filter(key, value);
      return exports5.pick(input, exclusionFilter, options);
    };
    if (Object.isExtensible(module5.exports) && Object.keys(module5.exports).length === 7) {
      __export03 = module5.exports["extract"];
      __export110 = module5.exports["parse"];
      __export23 = module5.exports["stringify"];
      __export33 = module5.exports["parseUrl"];
      __export43 = module5.exports["stringifyUrl"];
      __export53 = module5.exports["pick"];
      __export63 = module5.exports["exclude"];
    }
    query_string_default = module5.exports;
  }
});

// ../shadergradient-v2/dist/index.mjs
var init_dist = __esm({
  "../shadergradient-v2/dist/index.mjs"() {
    init_chunk_JQUAV2GN();
    init_chunk_WNGYPXFW();
    init_chunk_UJ5V3DPG();
    init_chunk_3ONLEHDB();
  }
});

// src/components/Shared/ShaderGradientStateless/store/presetURLs.ts
function convertPresets(presets2) {
  const PRESETS2 = Object.entries(presets2).map(([key, value]) => {
    const { title, color, props } = value;
    const urlParams = new URLSearchParams(
      Object.entries(props).reduce((acc, [propKey, propValue]) => {
        acc[propKey] = typeof propValue === "boolean" ? String(propValue) : String(propValue);
        return acc;
      }, {})
    ).toString();
    return {
      title,
      color,
      url: `?${urlParams}`
    };
  });
  return PRESETS2;
}
var initialActivePreset2, PRESETS, DEFAUlT_PRESET;
var init_presetURLs = __esm({
  "src/components/Shared/ShaderGradientStateless/store/presetURLs.ts"() {
    init_dist();
    initialActivePreset2 = 0;
    PRESETS = convertPresets(presets);
    DEFAUlT_PRESET = PRESETS[0].url;
  }
});

export {
  formatUrlString,
  formatFramerProps,
  ShaderGradientCanvas,
  propertyControls,
  ShaderGradient,
  init_dist,
  initialActivePreset2 as initialActivePreset,
  PRESETS,
  DEFAUlT_PRESET,
  init_presetURLs
};
/*! Bundled license information:

three/build/three.module.js:
  (**
   * @license
   * Copyright 2010-2024 Three.js Authors
   * SPDX-License-Identifier: MIT
   *)
*/
/*! Bundled license information:

scheduler/cjs/scheduler.development.js:
  (**
   * @license React
   * scheduler.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

scheduler/cjs/scheduler.production.min.js:
  (**
   * @license React
   * scheduler.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)
*/
/*! Bundled license information:

camera-controls/dist/camera-controls.module.js:
  (*!
   * camera-controls
   * https://github.com/yomotsu/camera-controls
   * (c) 2017 @yomotsu
   * Released under the MIT License.
   *)
*/
